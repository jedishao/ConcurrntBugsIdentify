

https://github.com/grpc/grpc-java
https://github.com/grpc/grpc-java/issues/1
Update to OkHttp 2.1 final.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One less SNAPSHOT to deal with...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2
Update to latest OkHttp master.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We'll probably wait on it a bit, unless I'm missing something. Since there weren't any functional changes, we can still advertise h2-16 with the existing code. There is a non-zero cost to upgrading our okhttp version internally so I figure just wait until we get something for it. (Especially since okhttp doesn't provide SNAPSHOT binaries to Maven Central)
Do note that the change would also need to update the git submodule that we now have in lib/.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3
Update OkHttp to h2-16.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/4
Resolve drift in Netty http/2 apis.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If you could also update the lib/netty submodule to the commit you are basing this work, that would be helpful (either HEAD or Nathan's commit).
We are definitely interested in inbound flow control, but it also seems like you ported over our usage of it. Did you mean outbound flow control? If so, then the answer is "yes, but not yet."
We haven't yet figured out the method name/API for exposing outbound flow control to applications in the Call/ServerCall class. We actually had an idea of how we wanted it to look, but couldn't quite decide on a name. There is now a conversation of changing flow control to look more like reactive-streams, which would also impact the interface.
We will certainly want to provide outbound flow control feedback to the application, but we don't yet know concretely what that will look like.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/5
Adopt token-based flow control from reactive-streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/6
Implement outbound flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should be token-based a la reactive streams. Although it also seems that maybe we will only ever have at most 1 token passed to the application.
Currently we provide no method of pushback to the application and buffer infinitely as the application sends.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/7
Investigate excessive flushing in Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Determine ways to reduce number of flushes we perform. For example, if the header frame is being sent, flushing afterward is generally a waste since a DATA frame typically follows. We want methods that allow smart semi-automatic flushing or using knowledge from application layer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/8
Optimize buffer usage in MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We currently allocate a large non-direct buffer per stream due to MessageFramer, only to copy immediately out of it. We should instead write directly to the transport-native buffer, which will cause us to have a WriteableBuffer or some such like our current Buffer class that is ready-only.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/9
Choose benchmark framework: JMH vs Caliper
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/10
Unary requests always send an empty DATA frame with EOS=true to close stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a performance issue. We should be able to set EOS=true on the DATA frame with the request payload rather than having to always write N+1 DATA frames. Likely fix is in frame interfaces.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/11
Update .gitignore for Gradle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/12
Improve test client for real cert
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM ... feel free to cherrypick.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/13
Align server flags with other languages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 it looks like this is based on work in #12 ... can you rebase after #12 is cherrypicked?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/14
Changing gRPC Java inbound flow control symantics
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look at this?  This is a rather large PR, so you can start by just reviewing the changes to MessageDeframer ... once we're happy with that we can move on to the rest of the PR.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/15
Move to a non-snapshot version of OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #2 and #3. Although now maybe we it's the right time to do this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/16
Do we need both gradle and maven?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Keeping dependencies and other details in pom.xml and build.gradle will become a tedious overhead.  Any reason to support two build systems?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/17
Race for Netty between cancel and stream creation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
AbstractClientStream.cancel won't cancel the stream on the wire if it appears the stream has not yet been allocated, as is described by the comment:
// Only send a cancellation to remote side if we have actually been allocated
// a stream id and we are not already closed. i.e. the server side is aware of the stream.
However, what happens if this is the case, is that the transport is not notified of the stream destruction, and the stream will still eventually be created by the transport and not be cancelled. This issue does not seem a problem with the OkHttp transport, since it allocates the stream id before returning any newly created stream. However, Netty delays id allocation until just before the stream headers are sent, which 1) is always done asynchronously and 2) may be strongly delayed due to MAX_CONCURRENT_STREAMS.
It appears that the optimization in AbstractClientStream should be removed outright and sendCancel's doc be updated to specify the expectation to handle such cases (as opposed to directly cause RST_STREAM). Both OkHttp and Netty seem to be handling such cases already. More importantly, the optimization seems highly prone for races given that id allocation is occurring in the transport thread whereas AbstractClientStream.cancel is happening on some application thread; using the normal synchronization between application and transport threads seems more than efficient enough and simpler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/18
Decompression occurring in Transport thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Apparently we are decompressing in the transport thread just so that we are able to provide the correct byte length to messageRead(). It seems we should remove the length argument to messageRead(), use Buffers.openStream(nextFrame, true), pass that stream to messageRead() (instead of calling toByteArray), and then set nextFrame = null.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/19
Change base package name to io.grpc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Lots of renames, but not really hard.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/20
Fix IntelliJ dependency on generated protobufs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/21
Remove Guava's Service from our immediate API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Service doesn't gain us anything and is just painful for our users. We should remove it and just make our own API (start and stop, plus health-checking API).
This has already been done for Channel. It still needs to be done for Server, but I'm already working on that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/22
TLS support for OkHttp when not running on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OkHttp transport current accepts a SSLSocketFactory which when on Android is provided by the OS. For testing when not running on Android we don't have a way to do TLS/ALPN. We need one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/23
Figure out what names we want for Client Foos vs Server Foos
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have Call on both Client and Server. When adding the server, we chose ServerCall as the name of the server-side Call, and discussed renaming the client-side to ClientCall. ClientInterceptor was named based on this idea. However, the rename hasn't happened yet and now some have suggested having the Client names simply lack "Client" (so it would remain "Call"). It seems it has simply been too long since the original discussion for us to remember what was decided.
We need to decide to either prefix Client with Client and Server with Server or only prefix Server with Server. After the decision, whatever needs fixing needs to be fixed.
Note that in the transport we must have ClientStream prefixed with Client, since Stream is a shared interface between Client and Server.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/24
Add unit tests to AbstractServerStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some unit tests from NettyServerStream are probably appropriate to move.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/25
Add unit tests for AbstractClientStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some unit tests from NettyClientStream are probably appropriate to move.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/26
Add tests for convert non-200 HTTP status codes to GRPC codes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The GRPC runtime should handle receiving HTTP2 responses with :status set to something other than 200. The runtime will need to map this to a GRPC status
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/27
Add unit tests for ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/28
Channel-state API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
At this moment, creating TCP connections are created lazily on first call of a Channel, and if the TCP connection goes down it isn't reconnected until a subsequent call. However, some users will want the TCP connection to be created and maintained during the lifetime of the Channel.
This "constant connection" behavior does not make as much sense when accessing a third party service, as the service may purposefully be disconnecting idle clients, but is very reasonable in low-latency, intra-datacenter communication.
We need an API to choose between those behaviors and to export failure information about the Channel. All of this is bundled together for the moment under the name "health-checking API," but we can split it apart as it makes sense.
They are tied together for the moment because certain operations like "wait until Channel is healthy" assume that the channel will actively try to connect.
Some notes from @louiscryan:

Do we want to canonicalize transport failure modes into an enum or are we
happy with a boolean indicating transient vs. durable. What failure modes
will we have

wire incompatability which can occur at any time and while is in theory
transient you may not want your application to continue working
unreachable
internal implementation error
redirection. the addressed service has moved elsewhere
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/29
Adding .gitignore for eclipse files.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 this should be an easy one :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/30
Netty HTTP/2 negotiation fails silently if ALPN/NPN in classpath, but jetty_alpn not in bootclasspath
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If you properly have ALPN/NPN in your classpath, but lack jetty_alpn in your bootclasspath, then we just hang after sending a SETTINGS frame. ALPN never happens, but "unsupported" isn't even called because that is normally called by jetty_alpn.
This makes it hard for users to determine what is wrong with their setup.
The only idea I have for a fix is to set a boolean when our ClientProvider is called and detect if it isn't set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/31
Fixing @GuardedBy annotation to use the correct lock name.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/32
Add test target for codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/33
Remove Service API from ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/34
Optimize number of DATA frames for unary requests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM ... feel free to cherry-pick!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/35
Remove Guava's Service from transport API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For similar reasons as #21, but more for ourselves instead of our users.
This will allow us to be much more precise and have nuances explicitly like how a connection can GOAWAY for new streams but keep the old streams processing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/36
Idea config breaks clean gradle build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
$ gradle clean
$ gradle build
FAILURE: Build failed with an exception.

* Where:
Build file '/home/ejona/clients/grpc-java/integration-testing/build.gradle' line: 31

* What went wrong:
A problem occurred evaluating project ':stubby-integration-testing'.
> java.lang.NullPointerException (no error message)

Commenting out line 31 works around the problem, but obviously doesn't solve it:
excludeDirs = [file('.gradle')]
//excludeDirs += files(file("$buildDir/").listFiles())
excludeDirs -= file("$buildDir/generated-sources")
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/37
Improve imports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/38
Add README.md to the compiler directory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/39
Migrating run scripts to gradle.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/40
Reorder the fields of LogHelper to be consistent with initialization order
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/41
Removing Maven build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 looks like pretty much everything is now handled by gradle.  Removing all the pom.xml files.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/42
Removing all references to "stubby"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @zhangkun83 take a look and make sure everything is in order.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/43
Add compiler and examples to the build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is already a build.gradle file, but we need to be using protoc built from HEAD.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/44
Add examples module into the build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's already there, we just need to add a build.gradle file for it and add it to settings.gradle.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/45
Moving decompression to the channel thread.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 a little light reading :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/46
Add Gradle wrapper for building.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh, that is a thing, would you look at that. 68K, not too bad.
Do we want to configure the version in the build.gradle, or is it just redundant?
task wrapper(type: Wrapper) {
    gradleVersion = '2.2.1'
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/47
Remove OkHttp submodule as we now depend on a release version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/48
Remove explicit Okio dependency.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Rebased and pushed as 6a93de9
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/49
Updating examples based on recent changes.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/50
Have Gradle observe LDFLAGS/CXXFLAGS/CPPFLAGS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/51
Improve Gradle build of protoc grpc plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/52
Fixing integration tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/53
Have test server print info about test client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/54
Fixing compiler build on OS X (Clang)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 easy fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/55
Properly cleaning and ignoring bin directories.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan and @ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/56
Protoc build instructions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Don't change the lib/netty subproject.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/57
Implement timeout/deadline in Channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/58
Implement timeout/deadline in Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/59
netty: Cancel stream if interrupted during create
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/60
OkHttp transport has high latency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For some unknown reason, OkHttp transport regressed in performance dramatically, considering it used to be beating Netty. Unfortunately we don't know when. We need to do some profiling and figure out where the latency is coming from.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/61
"No cached instance found" exception in integration test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The exception does not cause any problem other than noise, but we should still figure out what is going wrong.
java.lang.IllegalArgumentException: No cached instance found for grpc-default-executor
    at io.grpc.SharedResourceHolder.releaseInternal(SharedResourceHolder.java:144)
    at io.grpc.SharedResourceHolder.release(SharedResourceHolder.java:115)
    at io.grpc.AbstractChannelBuilder$2.run(AbstractChannelBuilder.java:109)
    at io.grpc.ChannelImpl.shutdown(ChannelImpl.java:113)
    at io.grpc.testing.integration.AbstractTransportTest.teardown(AbstractTransportTest.java:128)
    at io.grpc.testing.integration.TestServiceClient.teardown(TestServiceClient.java:160)
    at io.grpc.testing.integration.TestServiceClient.access$000(TestServiceClient.java:51)
    at io.grpc.testing.integration.TestServiceClient$1.run(TestServiceClient.java:65)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/62
Simplify connection callback handling in Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/63
Improve thread safety of newStream()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/64
Channel interface needs shutdown/close
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With the elimination of Service the Channel interface is now insufficient for normal use.
While ChannelImpl has a shutdown Channel does not and intercepting a ChannelImpl immediately converts it into Channel.
Closeable/AutoCloseable would be fine too
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/65
Consider making Channel/Server abstract classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
They were interfaces previously because of the bane of Service and the need to extend Abstract*Service in ChannelImpl/ServerImpl. Now that Service is gone from those APIs, we could swap to using abstract classes to give us greater ability to add to the APIs in the future.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/66
Fix shutdown race with negotiation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/67
Perform hostname checking on :authority before issuing call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We allow users to override the authority per-call, but we currently don't do any verification that that authority would be permitted for the current server. We should verify the provided authority against the TLS cert of the connection and fail in some way if the cert is not good for the requested authority. We would cache these verifications for the connection in a simple hash map.
It is the Java equivalent of grpc/grpc#471
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/68
QPS Client to perform throughput and latency tests.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/69
QPS Client to perform throughput and latency tests.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/70
Create CONTRIBUTING file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/71
Figure out how our users will use the protoc plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Whether it should be installed to /usr/local or similar for protoc to find, or we do some gradle dependency magic (which seems like it is likely difficult).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/72
Add getPort() or similar to ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I noticed that there doesn't seem to be a way to programatically retrieve a way to get the port a ServerImpl is listening on. Could we add a method that provides this information?
I would argue it's useful for when one wants to bind to port 0 i.e.
ServerImpl server = NettyServerBuilder.build();
server.start()

System.out.println("Server listening on port " + server.getPort());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/73
Naming inconsistency in NettyServerBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I noticed that NettyServerBuilder has the methods userBossEventLoopGroup and workerEventLoopGroup.
Why the user prefix in userBossEventLoopGroup, why not simply bossEventLoopGroup?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/74
Remove Guava Service from ClientTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/75
Only run terminationRunnable once
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/76
Move TLS certificates.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I updated the loadCerts method to work with jars. should be good for merge.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/77
Add missing dependency to benchmarks project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ðŸ˜œ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/78
Fix race in OkHttp test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/79
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/80
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/81
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/82
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/83
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/84
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/85
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/86
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/87
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/88
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/89
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/90
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/91
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/92
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/93
Fix inbound flow control for Calls.blockingServerStreamingCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need to explicitly call request(). Ideally, buffer would be removed and we only request a single message at a time; when returning a message with next(), we also call request(1). We would need a request(1) during init.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/94
Add ServerImpl#awaitTerminated() method. Fixes #80
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/95
Fix inbound flow control for Calls.blockingServerStreamingCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/96
Add link to documentation repo.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to NACK this change, because grpc-common is not up-to-date enough or complete enough at this point.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/97
Inform users they need Maven 3.2 to build our deps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/98
Add duration paramter to QPS Client and remove "server_threads" parameter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/99
Replace use of InputStream in transport APIs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current use of InputStream has a few problems:

it is non-idiomatic to split the responsibility for opening and closing a stream; it also prevents features such as try-with-resources
it essentially forces extra byte copying in order to consume the data

I haven't looked at the implementation, but since the comments say that the InputStream is non-blocking, I assume that it is used instead of byte[] simply to prevent modifications of the data when it is passed to multiple listeners (a reasonable concern).
Since there already appears to be a Guava dependency, the obvious alternative would be to pass a (inherently read-only) ByteSource instead.
(ByteString from protobuf would be another option, but for various reasons ByteSource is probably a better choice)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/100
Fix race for stream id in OkHttpClientTransport.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
wohooo PR #100 ðŸ˜ƒ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/101
Add scary JavaDoc to Metadata.setAuthority()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... sufficiently scary :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/102
Make sure to close InputStream even if cancelled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/103
Add nano support to Java codegen. Now the user can specify a flag nano=t...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/104
Plugin is not building following current instructions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Final gradle install is giving me:
Could not resolve all dependencies for configuration ':grpc-netty:compile'.

Could not find io.netty:netty-codec-http2:5.0.0.Alpha2-SNAPSHOT.
Searched in the following locations:
https://repo1.maven.org/maven2/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/maven-metadata.xml
https://repo1.maven.org/maven2/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/netty-codec-http2-5.0.0.Alpha2-SNAPSHOT.pom
https://repo1.maven.org/maven2/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/netty-codec-http2-5.0.0.Alpha2-SNAPSHOT.jar
file:/usr/local/google/home/lcarey/.m2/repository/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/maven-metadata.xml
file:/usr/local/google/home/lcarey/.m2/repository/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/netty-codec-http2-5.0.0.Alpha2-SNAPSHOT.pom
file:/usr/local/google/home/lcarey/.m2/repository/io/netty/netty-codec-http2/5.0.0.Alpha2-SNAPSHOT/netty-codec-http2-5.0.0.Alpha2-SNAPSHOT.jar
Required by:
io.grpc:grpc-netty:0.1.0-SNAPSHOT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/105
Update TODOs to use Github user names
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/106
Add java_package proto option for portability
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM although we'll be deleting these soon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/107
Remove target from .gitignore
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/108
Adding RouteGuide example and deleting others.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/109
Tidy up Javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Need to ensure that Javadoc in the major interfaces and exposed types is of high quality and properly makes of referencing annotations.
Suggest we divide and conquer as follows...

Channel / Call / Interceptors  @louiscryan
Transport    @ejona86
Stub & Helpers @zhangkun83
Builders  @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/110
Create architectural doc with diagram
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/111
Enforce coding conventions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have a checkstyle.xml here: https://github.com/grpc/grpc-java/blob/master/checkstyle.xml
This was borrowed from the googleapis java client library (I believe).  We should expand this as needed and enforce the conventions when building.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/112
Some comment cleanup in the Netty builders.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/113
Create CONTRIBUTING.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/114
Cleanup Javadoc for Channel, ServerCall and their related classes.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/115
Remove dead GrpcFramingUtil class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/116
Buffer Messages until TLS Handshake and HTTP2 Negotiation complete
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When grpc uses Netty as the client transport all RPC calls (aka HTTP2 Streams) block until the TLS Handshake and the HTTP2 negotiation is complete.
This blocking implementation (in grpc) is currently required as Netty's SslHandler doesn't buffer messages until the Handshake is complete ("You must make sure not to write a message while the handshake is in progress unless you are renegotiating."), and there is nothing to stop the user from starting to make RPC calls immediately.
This behavior comes with two problems:

With RPC calls blocking until the TLS Handshake is complete, every call launched before the TLS Handshake and HTTP2 Negotiation are done will block its thread from which one would expect async behavior though.
In cases when a DirectExecutor is being used it might lead to the EventLoop blocking forever (deadlock effectively). There is several scenarios how a deadlock could happen. One such scenario is when you are writing a server in Netty and within that server you want to connect to a grpc service to fetch some data. If you now use a DirectExecutor and reuse the EventLoop of the server with the grpc client, the TLS handshake would block the server's EventLoop, which is also the very EventLoop responsible for completing the TLS HandShake. That way neither the server nor the client would ever make progress again.

@nmittler , @ejona86 and I talked about this problem earlier today and we agreed to get rid of the blocking behavior by adding an additional ChannelHandler to the end of the pipeline (tail) that will buffer any data until TLS & HTTP2 are working. After that it will send the buffered messages through the pipeline and remove itself from the pipeline.
@nmittler @ejona86 @louiscryan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/117
Fixing memory leak in stream removal policy
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/118
Buffer RPC Calls for when the MAX_CONCURRENT_STREAMS limit is hit.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The number of concurrent RPC calls we can do is limited by HTTP2's MAX_CONCURRENT_STREAMS setting. Currently when using Netty as the client transport, each call made after this limit is reached blocks its calling thread until the number of active streams goes below the maximum again. The blocking is necessary as otherwise Netty would simply reject the stream with a PROTOCOL_ERROR, thus we want to buffer those calls and only pass them to Netty once there is room for new streams again.
Similar to #116 a user would again expect asynchronous behavior here.
The proposed solution to this problem is to remove the before mentioned buffering / blocking from grpc-java and let Netty handle it instead. To do this we will add a new Http2ConnectionEncoder implementation to Netty that acts as a decorator to the DefaultHttp2ConnectionEncoder. It will intercept calls to writeHeaders, writeData and writeRstStream and buffer all frames of streams that have been created after the maximum streams limit was reached and pass through the others. The encoder will also add a listener to the connection so that when an active stream is closed the next stream from the buffer can be created. A call to writeRstStream will cause the buffered stream to be deleted from the buffer. Frames other than HEADERS, DATA and RST_STREAM will be passed directly to the DefaultHttp2ConnectionEncoder.
We propose to contribute this change back to Netty as it will likely also be useful for other people using Netty's HTTP2 codec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/119
Set encoding for Java source to UTF-8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/120
Remove blocking parts from NettyClientTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
NettyClientTransport#newStream is currently a blocking operation. It blocks until the HEADERS frame has been written on the wire. This is behavior is not what people who use our asynchronous API would come to expect.
The blocking also is the cause for severe performance issues in the QPS Client as it results in more or less in as many threads being created as there are concurrent calls going on (We have seen ~850 Threads for 1000 concurrent calls, resulting in OOM).
The blocking may also lead to deadlocking the EventLoop in cases where a DirectExecutor is used. One scenario where a deadlock might happen is when the EventLoop is not able to completely flush the HEADERS frame on the wire because then Netty would internally create a task to flush the remaining bytes and put this task in its task queue. This task can never be completed though as the EventLoop Thread is blocked by our very own newStream method waiting for the task to be completed ...
This issue depends on #116 and #118 to be resolved first.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/121
Have SendGrpcFrameCommand constructor take an AbstractStream object instead of a stream id.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/122
Cleanup and Nitpicking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/123
Polish javadoc for stub/*
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/124
Update route guide gradle file with task that just generates gRPC code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently there are two tasks in the gradle file, one of which builds and runs the server, one of which builds and runs the client.
In the tutorial, I'd like the users to just generate the gRPC code with protoc without running anything, it'd be useful if the gradle file offered an option to do this
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/125
Update route guide gradle file with task that just generates gRPC code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently there are two tasks in the gradle file, one of which builds and runs the server, one of which builds and runs the client.
In the tutorial, I'd like the users to just generate the gRPC code with protoc without running anything, it'd be useful if the gradle file offered an option to do this
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/126
Can't build grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Following the installation instructions on a new Ubiquity instance. Installed Maven 3.2, using Java 8 (Google's JDK).
All works fine until I try the final build, then get:

What went wrong:
Could not resolve all dependencies for configuration ':grpc-core:compile'.

Could not find com.google.protobuf:protobuf-java:3.0.0-pre.
Searched in the following locations:
https://repo1.maven.org/maven2/com/google/protobuf/protobuf-java/3.0.0-pre/protobuf-java-3.0.0-pre.pom
https://repo1.maven.org/maven2/com/google/protobuf/protobuf-java/3.0.0-pre/protobuf-java-3.0.0-pre.jar
file:/usr/local/google/home/lcarey/.m2/repository/com/google/protobuf/protobuf-java/3.0.0-pre/protobuf-java-3.0.0-pre.pom
file:/usr/local/google/home/lcarey/.m2/repository/com/google/protobuf/protobuf-java/3.0.0-pre/protobuf-java-3.0.0-pre.jar
Required by:
io.grpc:grpc-core:0.1.0-SNAPSHOT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/127
Adding HelloWorld example to grpc-java repo.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @tbetbetbe can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/128
Upgrade com.twitter.hpack to v0.10.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/129
Polish javadoc for transport/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/130
Add new readme for Auth related issues
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
@jayantkolhe
@LisaFC
FYI. Will add follow up to link to this from common
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/131
Create temporary directory for javanano test if it does not exist.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Thanks for the fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/132
Remove nano codegen test temporarily. Currently I haven't figuired
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/133
Revert "Remove nano codegen test temporarily. Currently I haven't figuir...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/134
Swap to proto3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/135
Messages.proto has reference to stubby.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/integration-testing/src/main/proto/io/grpc/testing/integration/messages.proto contains the line:
package stubby.testing;
Should this be removed?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/136
Update README.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@LisaFC @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/137
Updating integ test protos to be consistent with C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/138
Depend on proto 3.0.0-alpha-2 instead of snapshot
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/139
Bug fix. frameWriter and frameReader are not initialized when an Excepti...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/140
Adding SimpleContext back into messages.proto.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/141
New auth readme
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
@LisaFC
continuing PR here as switching to public repo borked previous PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/142
Code for auth readme pending maven artifact for google auth library
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The maven artifact for https://github.com/google/google-auth-library-java
hasn't shown up in maven central yet. Pull request with supporting code is pending that
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/143
Update compiler/README.md with nano codegen commandline
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/144
Add MAX_CONCURRENT_STREAMS option to NettyServerBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/145
Integration tests failing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Occasionally the integration tests AbstractTransportTest#largeUnary and AbstractTransportTest#serverStreaming are failing on the server side with lots of  Exceptions of the like.
Feb 25, 2015 2:58:40 PM io.grpc.transport.netty.NettyServerHandler onStreamError
WARNING: Stream Error
io.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before write could take place
    at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:90)
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.clear(DefaultHttp2RemoteFlowController.java:431)
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$2.streamInactive(DefaultHttp2RemoteFlowController.java:78)
    at io.netty.handler.codec.http2.DefaultHttp2Connection.deactivateInternal(DefaultHttp2Connection.java:222)

We have traced it down to a bug in the HTTP2 Flow Control in Netty, where frames that are pending due to a not yet received WINDOW_UPDATE frame get canceled. For this bug to trigger the server endpoint has to be in the state HALF_CLOSE_REMOTE with no Flow Control Window left.
I have discussed the problem with @nmittler and @ejona86 and I am currently working on a PR for Netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/146
Support Unix Domain Socket
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should be straightforward enough now that Netty supports it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/147
Create PATENTS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/148
Polish javadoc for transport/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/149
Updating examples to be consistent with proto3 styleguide.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/150
Add CallOptions parameter to newCall()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need robust per-call configuration. For example, if we were to add configuration for specifying whether to retry, where would it go? Such configuration would need to be per-call, so it must go in Channel.newCall() somewhere. MethodDescriptor is where timeout is now, but putting more in MethodDescriptor seems like a long-term disaster. Metadata.Headers is where authority and path are now, but putting retry configuration there would be very odd.
A CallOptions class would be a natural place for per-call configuration, and would actually be a good home for timeout, authority, and path. Removal of timeout from MethodDescriptor would make it so that nobody ever needs to modify the object, which would allow us to greatly simplify the generated code. Authority and path don't really relate to Metadata; they relate to HTTP headers but not GRPC Metadata. Removal of them from Headers means we would remove the Headers/Trailers distinction and just have Metadata. That would also fix the issue where Headers doesn't make sense to send from ServerCall since authority and path are meaningless for response headers.
The main breakage would be with Interceptors, as it would be adding a new parameter.
I'm also uncertain as to whether CallOptions should be final or not. I think we want final, since we don't want that part of the API to be transport-specific, but it could be useful to have transport-specific options such as inbound flow control window.
@louiscryan and @zhangkun83, what do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/151
More example changes to match style guide.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I think this is the last of the changes.  After this is in, I'll create a bug for the C guys to update theirs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/152
The Future interface doesn't implement cancellation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently Future returned by the future interface is a SettableFuture and it doesn't implement the RPC cancellation. It should be as easy as implementing AbstractFuture.interruptTask().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/153
Implement cancellation for the Future interface.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/154
Tests fail with latest Netty version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running gradle clean build on master, I get the following unit test failures.
:grpc-netty:processTestResources UP-TO-DATE
:grpc-netty:testClasses
:grpc-netty:test

io.grpc.transport.netty.NettyServerHandlerTest > sendFrameShouldSucceed FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > inboundDataWithEndStreamShouldForwardToStreamListener FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > closeShouldCloseChannel FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:246

io.grpc.transport.netty.NettyServerHandlerTest > clientCancelShouldForwardToStreamListener FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > connectionErrorShouldCloseChannel FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > streamErrorShouldNotCloseChannel FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > clientHalfCloseShouldForwardToStreamListener FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyServerHandlerTest > inboundDataShouldForwardToStreamListener FAILED
    java.lang.NullPointerException at NettyServerHandlerTest.java:263

io.grpc.transport.netty.NettyClientHandlerTest > sendFrameShouldSucceed FAILED
    org.mockito.exceptions.verification.NeverWantedButInvoked at NettyClientHandlerTest.java:213

io.grpc.transport.netty.NettyClientHandlerTest > receivedGoAwayShouldFailQueuedStreams FAILED
    java.lang.NullPointerException at NettyClientHandlerTest.java:273

io.grpc.transport.netty.NettyClientHandlerTest > inboundHeadersShouldForwardToStream FAILED
    java.lang.NullPointerException at NettyClientHandlerTest.java:232

io.grpc.transport.netty.NettyClientHandlerTest > inboundDataShouldForwardToStream FAILED
    java.lang.NullPointerException at NettyClientHandlerTest.java:326

io.grpc.transport.netty.NettyClientHandlerTest > createStreamShouldSucceed FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at NettyClientHandlerTest.java:137

io.grpc.transport.netty.NettyClientHandlerTest > channelShutdownShouldFailInFlightStreams FAILED
    java.lang.NullPointerException at NettyClientHandlerTest.java:307

io.grpc.transport.netty.NettyClientHandlerTest > receivedGoAwayShouldFailUnknownStreams FAILED
    java.lang.NullPointerException at NettyClientHandlerTest.java:284

Example Stacktrace
channelShutdownShouldFailInFlightStreams

java.lang.NullPointerException
    at io.grpc.transport.netty.NettyClientHandler.onStreamError(NettyClientHandler.java:223)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:284)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:501)
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState$Frame.writeError(DefaultHttp2RemoteFlowController.java:543)
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.clear(DefaultHttp2RemoteFlowController.java:453)
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$2.streamInactive(DefaultHttp2RemoteFlowController.java:79)
    at io.netty.handler.codec.http2.DefaultHttp2Connection.deactivateInternal(DefaultHttp2Connection.java:222)
    at io.netty.handler.codec.http2.DefaultHttp2Connection.access$700(DefaultHttp2Connection.java:52)
    at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:402)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.closeStream(Http2ConnectionHandler.java:260)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:193)
    at io.grpc.transport.netty.NettyClientHandler.channelInactive(NettyClientHandler.java:204)
    at io.grpc.transport.netty.NettyClientHandlerTest.channelShutdownShouldFailInFlightStreams(NettyClientHandlerTest.java:307)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/155
Note in README that things don't build on Windows
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/156
Support building on Windows
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/157
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/158
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/159
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/160
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/161
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/162
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/163
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/164
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/165
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/166
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/167
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/168
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/169
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/170
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/171
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/172
Push Java libraries to Maven central
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As the majority of Java Developer, I am using Maven and not Gradle...
After compiling my self the protoc tool for Mac, and creating the Route sample Maven project, I am still block with the fact that the
import io.grpc.ServerImpl;
import io.grpc.stub.StreamObserver;
import io.grpc.transport.netty.NettyServerBuilder;
are nowhere in Maven...
My Current pom is like this, and the protoc generates correct code:


  4.0.0
  com.google.apphosting.grpc
  grpctest
  1.0
  jar
  
    
      dtrott
      http://maven.davidtrott.com/repository
    
    
  
    
      com.google.guava
      guava
      18.0
      jar
    
    
      javax.json
      javax.json-api
      1.0
      jar
    
    
      com.google.protobuf
      protobuf-java
      3.0.0-alpha-2
    
  
  
    UTF-8
    1.7
    1.7
  
  
    
      
        org.apache.maven.plugins
        maven-compiler-plugin
        3.2
        
          1.5
          1.5
        
      
      
        com.google.protobuf.tools
        maven-protoc-plugin
        0.1.10
        
          /usr/local/bin/protoc
        
        
          
            
              compile
              testCompile
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/173
Please test with broken stream IDs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
We recently got hit in C with a crash that happened when HTTP/2 stream IDs went unexpected (violating the invariant of increase on a connection) and also aren't prepared for the situation where we approach or cross max stream id (0x7fffffffu). Please check that this case works in Java. If you need some client code to test that, I can let you use the client code that was sent to me.
This is related to C issues: grpc/grpc#946 and grpc/grpc#957
Thanks!
Vijay
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/174
Access to controller (for connection metadata)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I would like to get the remote client's IP and TLS client-certificate from within a GRPC service. And I guess cancellation information as well.
Protobuf services had the controller argument.  Is there an equivalent in GRPC?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/175
could grpc-java generate jars by modifying gradle files? how?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to package these java files generated by grpc. How could I modify gradle files?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/176
IllegalReferenceCountException for DATA frame with EOS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a DATA frame is received with EOS set, an attempt is made to read the Netty ByteBuf after it has been closed.
The problem is this line: 
  
    
      grpc-java/core/src/main/java/io/grpc/transport/Http2ClientStream.java
    
    
         Line 139
      in
      ef87818
    
  
  
    

        
          
           frame.close(); 
        
    
  


Since the buffer was already added to the deframer and the user callback notified, they will then attempt to read from the buffer which has already been closed.  This causes the IllegalReferenceCountException to mask the actual problem with is that a DATA frame was received with EOS set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/177
Proper buffer closure when receiving DATA with EOS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/178
Test receiving invalid stream IDs in okhttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan can you take a look ... should be trivial.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/179
Updating to the latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/180
Swap to Netty's NPN/ALPN handling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This should simplify our code and would allow us to support tcnative for OpenSSL support. Other than being faster, tcnative does not depend on the JRE version and does not need bootclasspath specified, which would help new users trying to use gRPC for the first time.
This is API breaking as it will change how we use SslContexts provided by the user. We will require them to be properly configured with ALPN protocols. Since SslContext does not allow any form of partial configuration or reconfiguration (no way that two parties can work together to configure one), we will probably need a helper class that duplicates almost all the factory methods but without the parameters we want to specify (like ALPN protocols).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/181
Observe MAX_CONCURRENT_STREAMS in OkHttp client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We ignore it. We shouldn't.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/182
Vendorize our usages of OkHttp internal classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using the normal OkHttp API didn't quite seem to work for us. The blocking style made it seem like we would need a thread per stream, flow control wasn't exposed enough (although this may no longer be an issue due to how we are now using flow control, other than blocking), RST_STREAM, and other similar advanced HTTP/2 features didn't have quite as much support as we needed. Oh, and trailers...
So that led us to use internals of OkHttp that we shouldn't be, because it will be brittle. Instead, we should propose/upstream an API that supports advanced usage and can be stable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/183
Migrating to Netty 4.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 let's do this! :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/184
Update README.md to Netty 4.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/185
Use DEFAULT_WORKER_EVENT_LOOP_GROUP for both client and server. Fixes #82
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/186
Tweak Http2Error and add tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/187
Don't read with frameReader after it is closed, otherwise an Illegalstateexception would be thrown and will not be caught.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What was the backtrace that you got (just the grpc+okhttp portion)? The return of nextFrame seems like it is supposed to say when reading is complete.
I'm not convinced that this fix isn't racy. It seems like between checking for stopped and calling nextFrame() shutdown() could be called. It may not be possible to fix the race, but all the more reason for me to want to understand what is going on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/188
Better error description onGoAwayRead
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/189
Force JavaDoc to intepret code as UTF-8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/190
Stream fairness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Investigate how we stand on stream fairness.
Last I checked, Netty is splitting the available window between all the streams with data queued. That seems like it would waste bandwidth as it degrades into sending many 1-byte frames, but each frame has a 9 byte overhead.
Ideally we would decrease latency on "small" streams by preferring them over "large" streams.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/191
Stall MessageDeframer pro-actively
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler, does this look more appropriate?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/192
Enable Travis-CI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Most annoying part is likely building protobuf.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/193
Add support to Netty builders for specifying other channel types
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/194
Fix IntelliJ project generation by including generated protobuf srcs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/195
Cleanup warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/196
Add name and developers to pom
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/197
Add WritableBuffer interface for zero copy data writes. Fixes #8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/198
Support netty4 and5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ick! .... LGTM :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/199
Fix compile error introduced by previous commit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/200
Handle spaces in shell script
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/201
Provide Code Style definition file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would it be possible to provide the code style definition file you're using with Intellij?
Along these lines: https://www.jetbrains.com/idea/webhelp10.5/exporting-project-code-style-settings.html
This would make it easier to contribute to grpc!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/202
Add GrpcCallContext & GrpcSession, so transports can expose data (client IP, certificate)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So this is a WIP.  Most problematically, it doesn't seem that the integeration test servers are actually using encryption; it looks like they set everything up but when I test the session info (see tls_info test) it is NONE:SSL_NULL_WITH_NULL_NULL.  I think maybe the handshake just isn't happening.
I did change a fair bit of how TLS is actually set up, so I don't know if this is happening on master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/203
The -f flag for readlink is not available on OSX
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
readlink -f, as used in run-test-client.sh and run-test-server.sh is not available on OSX.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/204
Need docs on how to run integration test suite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems that this is the way:
Tab/window/screen 1:
./run-test-server.sh 

Tab/window/screen 2:
./run-test-client.sh --use_test_ca=true --server_host_override=foo.test.google.fr --test_case=empty_unary
./run-test-client.sh --use_test_ca=true --server_host_override=foo.test.google.fr --test_case=large_unary
./run-test-client.sh --use_test_ca=true --server_host_override=foo.test.google.fr --test_case=client_streaming
...

Is that correct?
And is there a way to avoid paying the Groovy/Gradle tax for every test?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/205
Use CreateStartScripts for integration-tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This would make the binaries more portable and wouldn't require running Gradle before every execution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/206
Is there any way to handle cookie in headersï¼Ÿ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We usually auth user by cookie/token.Should I use ClientInterceptor to set cookie or store cookie?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/207
Add simple HelloWord example handling custom header
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the information on your CLA or see this help article on setting the email on your git commits.
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/208
Add checkstyle checking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... thanks for doing this!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/209
HttpUtilTest missing package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/210
Add package statement to HttpUtilTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/211
Fix checkstyle warnings for examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Making example methods private would be easiest, but them being public seemed to be useful in http://www.useopen.net/blog/2015/rpc-performance.html .
getFeature() is also overloaded, and doesn't look like it should be, given that the two methods have different semantics.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/212
Adding outbound flow control API for Call/ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/213
Adding outbound flow control API for the transport API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/214
Add missing copyright headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/215
OkHttpClientStream.window is only written never read
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
Should be removed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/216
Improve CONTRIBUTING.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/217
Add missing @RunWith.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/218
Travis simple
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/219
method not found for method name automatically changed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use grpc ruby client and java server, the ruby client prompts that method not found, so I choose to debug the grpc java proto code, I got very confused.
the following code which generated by grpc java defines the SearchForum method:
private static final io.grpc.stub.Method<com.search.protoc.SearchRequest, com.search.protoc.SearchResponse> METHOD_SEARCH_FORUM = io.grpc.stub.Method.create( io.grpc.MethodType.UNARY, "SearchForum", io.grpc.proto.ProtoUtils.marshaller(com.search.protoc.SearchRequest.PARSER), io.grpc.proto.ProtoUtils.marshaller(com.search.protoc.SearchResponse.PARSER));
and the following code register the SearchForum method:
public static io.grpc.ServerServiceDefinition bindService( final SearchService serviceImpl) { return io.grpc.ServerServiceDefinition.builder("SearchService") .addMethod(createMethodDefinition( METHOD_SEARCH_FORUM, asyncUnaryRequestCall( new io.grpc.stub.ServerCalls.UnaryRequestMethod< com.search.protoc.SearchRequest, com.search.protoc.SearchResponse>() { @java.lang.Override public void invoke( com.search.protoc.SearchRequest request, io.grpc.stub.StreamObserver<com.search.protoc.SearchResponse> responseObserver) { serviceImpl.searchForum(request, responseObserver); } }))).build();
bug when I debug into the createMethodDefinition method:
public static <ReqT, RespT> ServerMethodDefinition<ReqT, RespT> createMethodDefinition( Method<ReqT, RespT> method, ServerCallHandler<ReqT, RespT> handler) { return ServerMethodDefinition.create(method.getName(), method.getRequestMarshaller(), method.getResponseMarshaller(), handler); }
it shows that the method.getName returns "searchForum".
that is the reason why ruby client cannot find the method SearchForum. but I totally don't understand why method name SearchForum has been renamed to searchForum, the data flow shows that nothing has done to the METHOD_SEARCH_FORUM method name.
I think this is a bug.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/220
Protobuf java/nano are now on Maven Central
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Want to update the readme to point to the new make_dependencies script
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/221
Improve Status exception message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/222
Move Status.toString next to other methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/223
OkHttp tests flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Change to shutdown of okhttp has caused tests to become flaky.
This is the location of the most common failure for me:
java.lang.AssertionError at OkHttpClientTransportTest.java:134
Full examples of such failures:
:grpc-okhttp:test

io.grpc.transport.okhttp.OkHttpClientTransportTest > cancelStream FAILED
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > receiveReset FAILED
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > receivedDataForInvalidStreamShouldResetStream FAILED
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > readStatus FAILED
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > streamIdExhausted FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at OkHttpClientTransportTest.java:450

io.grpc.transport.okhttp.OkHttpClientTransportTest > receivedHeadersForInvalidStreamShouldResetStream FAILED
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > stopNormally FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at OkHttpClientTransportTest.java:365
    java.lang.AssertionError at OkHttpClientTransportTest.java:134

io.grpc.transport.okhttp.OkHttpClientTransportTest > receiveGoAway FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at OkHttpClientTransportTest.java:423
    java.lang.AssertionError at OkHttpClientTransportTest.java:134
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/224
Working Travis build, with caching of deps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/225
Remove blocking on netty client stream creation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/226
Cache Gradle and not really Maven
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ping?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/227
Enable parallel Gradle builds for Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/228
okhttp: code style fixes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly, this fixes checkstyle warnings displayed during the build.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/229
Fix a race condition in the test, we may notify MockFrameReader to return before it starts waiting.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Without this change, the test failed 2~3 times out of 10 runs, with this change, it passed 30 runs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/230
Make checkstyle failures fatal, and fix last issues
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How do we feel about checkstyles being fatal? I think some may find it annoying, but I also wonder how well people will notice warnings.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/231
Data corruption when receiving payloads larger than 2048 bytes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here, OkHttpReadableBuffer is calling Buffer#read only once, even though the contract for Buffer#read is that it reads up to byteCount bytes and returns the number of bytes actually read.
Because Buffer uses a linked list of segments where each segment is at most 2048 bytes, Buffer#read will read only up to 2048 bytes at a time. This will result in corruption of any received payload larger than 2048 bytes (and on some smaller payloads as well, depending on the position in the buffer). In my case, it manifested as a series of '\0' bytes where data should have been.
Instead, we should call read in a loop until we have read all the bytes we need to. And we should also have some unit tests for OkHttpReadableBuffer...
I'm working on a pull request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/232
Fix data corruption issue receiving payloads > 2kB
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Thank you very much. The Arrays.equals() wasn't very useful, was it...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/233
Use TLS for Netty integration tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/234
Remove readlink -f in run-test*.sh scripts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/235
Gradle's testing should show more info on Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A flaky build on Travis doesn't provide enough information to diagnose what went wrong, because Gradle generally expects you to view the reports in the build directiory.
https://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.testing.logging.TestLoggingContainer.html
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/236
Use tls for netty tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/237
Making connection and stream windows configurable for Netty.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/238
Race in Server handler initialization
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When initializing an incoming client connection, we call startAsync() on the transport, which registers the handler on a separate thread. This is obviously a race, and it would have probably been fixed if I had finished Service removal in #35.
Symptom:
DEBUG i.n.channel.DefaultChannelPipeline - Discarded inbound message SimpleLeakAwareByteBuf(PooledUnsafeDirectByteBuf(ridx: 0, widx: 259, cap: 1024)) that reached at the tail of the pipeline. Please check your pipeline configuration.

The quickest fix would be to call awaitRunning() from initChannel(). That reduces the rate new connections can connect, but is probably the most expedient solution, until #35 is finished.
@nmittler, thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/239
Lacking preconditions for start() in ChannelImpl.CallImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For instance, calling request() before start() has been called results in a NullPointerException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/240
ClientAuthInterceptor.start() skips super.start() when there is an error, causing subsequent use of the top-level Call to throw IllegalStateException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
onClose does not log any exception or status, as it is commonly used in cases where there wasn't a server error but instead a client issue. Thus, in the IOException handling of ClientAuthInterceptior, if an exception is thrown it is thrown away, the caller doesn't notice, and will get some odd exception on whatever the next call is (NullPointerException in request() was what led me to this discovery). We discussed that the "proper" exception handling isn't very obvious, but certainly swallowing the exception is worse than the alternatives.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/241
Disable Travis parallel building to reduce memory usage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/242
Default client connection window to 1MiB.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The documentation in the builder says that it defaults to Http2CodecUtil#DEFAULT_WINDOW_SIZE. That should be updated.
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/243
Make connection/stream windows configurable for Netty server 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This has already been done for the client. Default connection window should be 1MiB.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/244
netty: Status should be based on GOAWAY code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I think we should also change createPendingStreams so that it calls goAwayStatus() inside the loop, only when it's setting the status on the stream.  The go away check should be moved above the stream ID check. And then in the stream ID check, we should augment the description to indicate that it's exhausted the stream IDs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/245
AbstractTransportTest.streamingOutputShouldBeFlowControlled doesn't test flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It is actually very difficult to test inbound flow control using our API without long sleeps. streamingOutputShouldBeFlowControlled does long sleeps, but doesn't actually assert the number of requests that should have been requested. That makes it the slowest test (4s, x3 transports) without actually verifying anything additional to the other tests.
We should either fix the test or remove it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/246
ClientAuthInterceptor synchronizes on wrong object
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The "this" in synchronized (this), is not the correct object to synchronize on:
https://github.com/grpc/grpc-java/blob/master/auth/src/main/java/io/grpc/auth/ClientAuthInterceptor.java#L77
It should be ClientAuthInterceptor.this instead. As the code stands, there is no synchronization between threads so you can see NullPointerExceptions as lastMetadata is set but not cached.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/247
Fix synchronization in client auth
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/248
Test whether inbound flow control functions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/249
Add precondition to throw more informative exception when calling request() before start() has been called.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM.
Oh, I had thought the other methods might have been missing Preconditions, but would you look at that, they are there (I think maybe because @louiscryan made me during review :-) ).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/250
Wait for handler registration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/251
Fix an issue caused by the intercepting call failing in start() and skip super.start()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I thought we were going to execute getRequestMetadata() immediately when interceptCall and then return either the ForwardingCall on success or a NoopCall on failure. I'm not convinced we should add more API to ForwardingCall (other than having a delegate() method instead of delegate field).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/252
TLS support for okhttp transport.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/253
Add clearer message when receiving GOAWAY from the server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/254
Document transport layers (netty vs okhttp)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, am I right that there are currently two implementations of the transport layer? Netty and okhttp? I was curious if there are any situations in which one might be preferable to the other as I'm not quite sure why there are two implementations.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/255
Implement GrpcCallContext & GrpcSession
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a more minimal version of #202, which just takes the step of implementing GrpcCallContext/GrpcSession, with just enough functionality to test it (the remote address, which I hope is less controversial than SSL).
I don't think putting the session into the Metadata.Headers is ideal, but alternatives seem more invasive.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/256
Disable Nagle's algorithm.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please take a look.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/257
OkHttp may be missing flush after sending headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It looks like we aren't flushing after headers. This works okay because we don't have any tests that don't send data. We should add such a test to AbstractTransportTests and add the flush as appropriate.

  
    
      grpc-java/okhttp/src/main/java/io/grpc/transport/okhttp/OkHttpClientTransport.java
    
    
         Line 192
      in
      7865b03
    
  
  
    

        
          
           frameWriter.synStream(false, false, clientStream.id(), 0, requestHeaders); 
        
    
  


On Friday I was playing with a change that allows removing the flush() on headers for unary and server streaming RPCs. We may be more interested in it now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/258
Upgrading to the latest Netty 4.1 branch.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/259
Use codegen for integration testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/260
"An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier MUST ignore that setting."
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I happened to send an invalid setting id (0x0) to a java server and saw the connection shutdown. The expected behavior as in http2 spec is
An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier MUST ignore that setting.
instead of connection error.
Here is the stack trace:
Mar 31, 2015 5:58:51 PM io.grpc.transport.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.handler.codec.http2.Http2Exception: key
at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:72)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:496)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:235)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:130)
at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:99)
at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:276)
at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:183)
at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:317)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:316)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:84)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
at io.netty.channel.PausableChannelEventExecutor.invokeChannelRead(PausableChannelEventExecutor.java:86)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:389)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:956)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:127)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:514)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:471)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:385)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:351)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/261
Change the package option of example protos to be the same as grpc-common's
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/262
Context API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ideally it would not be grpc-specific. It would help with things like #174, but could also maybe provide cancellation support to the async stub and deadline propagation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/263
ServerCalls delays handler calling for unary streams for outdated reason
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc-java/blob/master/stub/src/main/java/io/grpc/stub/ServerCalls.java#L76
// We delay calling method.invoke() until onHalfClose(), because application may call
// close(OK) inside invoke(), while close(OK) is not allowed before onHalfClose().
The restriction of halfClose before OK is no longer present, having been removed before open sourcing. We should update the comment at the very least. We may choose to change how it works.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/264
Fix the issue where the intecepting call fails in start(), does not call super.start(), and makes the subsequent use of other methods on the call throw IllegalStateException.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/265
Add "unsed imports" check.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/266
Remove "Operation" from Status exceptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Changed based on feedback offline from @louiscryan, PTAL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/267
Fix JavaDoc references to non-imported class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/268
Improve JavaDoc for Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/269
Respect MAX_CONCURRENT_STREAMS in OkHttp client.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/270
checkstyle change:
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/271
Hold lock while reading isThreadScheduled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/272
Fix memory leak by adding the Http2StreamRemovalPolicy to the channel pipeline.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/273
how to generate Grpc class with gradle?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc example use gradle-plugin-protobuf to generate Grpc class with the following config:

protobufCodeGenPlugins = ["java_plugin:$javaPluginPath"]
generateProto.dependsOn ':grpc-compiler:java_pluginExecutable'

but this doesn't succeed when I build with gradle, it prompts:

Could not determine the dependencies of task ':generateProto'.

how to reference grpc complier if I create a stand alone java project with gradle?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/274
OkHttp: Flushes headers out immediately for client streaming and bidi streaming 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am curious why this is the way to do. This actually doubles the number of
syscall on client writing path because otherwise header and data can be
fused into a single write syscall (unless the header has some
user-specified metadata). This has some performance impact given the proper
designed benchmarks.
On Tue, Apr 7, 2015 at 12:03 AM, Xudong Ma notifications@github.com wrote:

Flushes headers out immediately for OkHttp transport, so that the server
can be aware of the stream before receiving real data (or half close).
Adds corresponding test to AbstractTransportTest.
You can view, comment on, or merge this pull request online at:
#274
Commit Summary

Fix for #257.

File Changes

M
integration-testing/src/main/java/io/grpc/testing/integration/AbstractTransportTest.java
https://github.com/grpc/grpc-java/pull/274/files#diff-0 (46)
M
integration-testing/src/main/java/io/grpc/testing/integration/TestServiceImpl.java
https://github.com/grpc/grpc-java/pull/274/files#diff-1 (33)
M
integration-testing/src/main/proto/io/grpc/testing/integration/test.proto
https://github.com/grpc/grpc-java/pull/274/files#diff-2 (5)
M
okhttp/src/main/java/io/grpc/transport/okhttp/OkHttpClientTransport.java
https://github.com/grpc/grpc-java/pull/274/files#diff-3 (2)

Patch Links:

https://github.com/grpc/grpc-java/pull/274.patch
https://github.com/grpc/grpc-java/pull/274.diff

â€”
Reply to this email directly or view it on GitHub
#274.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/275
okhttp: Reset stream when receiving window is negative  Resolves #215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/276
Rename java_plugin to protoc-gen-grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This follows a naming convention that allows just placing it in PATH and having protoc discover it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/277
Fixes Travis breakage caused by wrong order of imports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly, LGTM.
@buchgr, using times() from internal doesn't look right. I think you just wanted Mockito.times
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/278
Temporally support Http protocol name "h2-16" for OkHttp client.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/279
Clean up stream after AbstractClientStream.inboundTransportError()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Otherwise the stream object will still be held in the stream map of OkHttpClientTransport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/280
okhttp:Clean up stream after AbstractClientStream.inboundTransportError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This looks like a larger change than is necessary. Let's discuss approaches on #279.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/281
Calls.asyncServerStreamingCall requests only one response
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The method Calls.asyncServerStreamingCall requests only 1 response from the underlying call. The documentation for request(N) states that a call will not deliver more than N responses, so if Call implementations would implement this contract, the resulting server stream would never contain more than one element.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/282
Replace 'internal' import with correct one.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/283
netty: Use the bootstrap ClassLoader for ALPN/NPN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... great work!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/284
Fix the issue where the intercepting call fails in start(), does not call super.start(), and makes the subsequent use of other methods on the call throw IllegalStateException.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/285
Fix bug where the stream id would not get incremented for buffered streams.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/286
Rename the codegen binary from java_plugin to protoc-gen-grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/287
Remove unused local variable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/288
Fix warnings (JavaDoc and [deprecated])
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/289
AbstractTransportTest is flaky.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've seen several failures of Http2OkHttpTest.pingPong() on Travis, like this one: https://s3.amazonaws.com/archive.travis-ci.org/jobs/57879240/log.txt.
But I couldn't reproduce the same failure in ~30 runs in my local repository.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/290
Improve documentation of contract of io.grpc.Call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This class seems to be underspecified. A couple of issues which can't be easily derived:

Can request(N) be called multiple times before the next payload is received, and is it accumulating.
If not accumulating, what does it mean if request(0) is called after request(N) but before payload is received. Does it suppress the already scheduled output? How strong is the contract that there are never more than N responses?
Can there be race conditions for request() calls and onPayload() calls on the listener.
Is request() always be called before sendPayload() or can it be also called afterwards.
What happens if any of the Call methods is called after halfClose, cancel, or onClose.
if cancel is called, should it eventually report onClose(Status.CANCELLED) on the listener.

There might be more. Ideally we would specify the allowed sequences and interferences between call and listener.
I may follow up with a suggestion for the spec later.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/291
Split protobuf into its own project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/292
Use more precise names for protobuf and nano
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/293
OkHttp only connects to "h2" ALPN protocol
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Values "h2-14", "h2-15", and "h2-16" result in Protocol throwing an error from OkHttpTlsUpgrader.
We should support all those options, as we still are seeing them being used since the final HTTP/2 spec hasn't been published.
java.lang.RuntimeException: java.io.IOException: Unexpected protocol: h2-14
            at io.grpc.transport.okhttp.OkHttpClientTransport.start(OkHttpClientTransport.java:300)
            at io.grpc.ChannelImpl.obtainActiveTransport(ChannelImpl.java:188)
            at io.grpc.ChannelImpl.access$600(ChannelImpl.java:55)
            at io.grpc.ChannelImpl$CallImpl.start(ChannelImpl.java:248)
            at io.grpc.ForwardingCall.start(ForwardingCall.java:45)
...
     Caused by: java.io.IOException: Unexpected protocol: h2-14
            at com.squareup.okhttp.Protocol.get(Protocol.java:94)
            at com.squareup.okhttp.OkHttpTlsUpgrader.upgrade(OkHttpTlsUpgrader.java:80)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/294
OkHttp: Temporally support multiple h2-xx protocol on client side.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/295
Split protobuf into its own project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#291 is a pull request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/296
Gradle build points to https with self signed certificate
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In installation step for grpc-java
./gradlew install
exec /usr/lib/jvm/jdk1.7.0_51/bin/java -Dorg.gradle.appname=gradlew -classpath /grpc-java/gradle/wrapper/gradle-wrapper.jar org.gradle.wrapper.GradleWrapperMain install
Downloading https://services.gradle.org/distributions/gradle-2.2.1-all.zip
Exception in thread "main" javax.net.ssl.SSLHandshakeException: java.security.cert.CertificateException: No subject alternative DNS name matching services.gradle.org found.
Work around is to modify gradle/wrapper/gradle-wrapper.properties to change to http.
Should change it permanently?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/297
Add missing projects to grpc-all
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/298
netty: Add option to set MAX_CONCURRENT_STREAMS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/299
platform issue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I run a grpc java server on Mac OS, it is ok to test it with java client, but error happened on a linux server,and the error is as follows:

com.google.common.util.concurrent.UncheckedExecutionException: io.grpc.Status$OperationRuntimeException: INTERNAL
at io.grpc.stub.Calls.getUnchecked(Calls.java:117)
at io.grpc.stub.Calls.blockingUnaryCall(Calls.java:129)
at com.engzo.search.protoc.SearchGrpc$SearchBlockingStub.searchForum(SearchGrpc.java:245)
at com.engzo.search.api.SearchClient.searchForum(SearchClient.java:35)
at com.engzo.search.api.SearchClient.main(SearchClient.java:76)
Caused by: io.grpc.Status$OperationRuntimeException: INTERNAL
at io.grpc.Status.asRuntimeException(Status.java:428)
at io.grpc.stub.Calls$UnaryStreamToFuture.onClose(Calls.java:324)
at io.grpc.ChannelImpl$CallImpl$ClientStreamListenerImpl$3.run(ChannelImpl.java:373)
at io.grpc.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:152)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/300
Reset stream if receive server's halfClose before client sends halfClose.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This was exposed by the discussion on #279.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/301
okhttp: Clean up stream when error happens.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/302
De-flake transport test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I feel like we shouldn't be seeing any flakes with 1s, as things should take single-digit milliseconds at most (even with a GC). But I also don't have any other clues as to why we would be getting the timeout for both Netty and OkHttp.
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/303
Remove Guava's Service from server transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/304
Solution for GRPC codegen deployment
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/305
Reduce number of flushes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Each flush causes its own TCP frame to be written because we Nagle is disabled. Reducing the number of flushes would greatly reduce the number of TCP frames and number of syscalls. Even if performance benchmarks don't show a benefit by reduced flushing, if we are able to see improvements to goodput that would be enough for such an optimization.
Reduce number of flushes, in gRPC and maybe Netty.
May need a batch write API. We have the ability internally already, it is deciding a way to expose it.
Allow hint to delay headers until first data write (could maybe be part of batch API).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/306
Upgrading to the latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/307
Revisit Lifecycle API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current shutdown/shutdownNow/isShutdown/awaitShutdown/isTerminated/awaitTerminated API of ChannelImpl and ServerImpl was chosen when we had time constraints in removing Service from our API. During its addition in #33, @adriancole and @nmittler expressed concern for the API, but the API was left in-place and the decision delayed as part of #28. The Health-checking API is coming, but the current Lifecycle API continues to be contentious in the mean time as it is part of both channel layer and transport layer.
We need to agree on an API.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/308
Fix netty closure check
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
oof ... LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/309
Build seems broken on OS/X
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Commit da3c3f8 (Solution for GRPC codegen deployment) seems to have broken the compiler build for me on OS/X. The previous commit builds fine.
$ java -version
java version "1.8.0_40"
Java(TM) SE Runtime Environment (build 1.8.0_40-b25)
Java HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)
$ uname -a
Darwin eno.local 14.3.0 Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64 x86_64
$ ../gradlew local_archJava_pluginExecutable
:grpc-compiler:compileLocal_archJava_pluginExecutableJava_pluginCpp UP-TO-DATE
:grpc-compiler:linkLocal_archJava_pluginExecutable
Undefined symbols for architecture x86_64:
  "google::protobuf::io::Printer::Print(char const*)", referenced from:
      java_grpc_generator::PrintImports(google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintService(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintMethodFields(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintServiceDescriptor(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
      java_grpc_generator::PrintStub(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, java_grpc_generator::StubType) in java_generator.o
      java_grpc_generator::PrintBindServiceMethod(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
  "google::protobuf::io::Printer::Print(char const*, char const*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)", referenced from:
      java_grpc_generator::GenerateService(google::protobuf::ServiceDescriptor const*, google::protobuf::io::ZeroCopyOutputStream*, bool) in java_generator.o
  "google::protobuf::io::Printer::Print(std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator                                            <char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > > const&, char const*)", referenced from:
      java_grpc_generator::PrintService(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintMethodFields(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintServiceDescriptor(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::a                                                                    llocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
      java_grpc_generator::PrintStub(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, java_grpc_generator::StubType) in java_generator.o
      java_grpc_generator::PrintBindServiceMethod(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
  "google::protobuf::io::Printer::Indent()", referenced from:
      java_grpc_generator::PrintService(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1:                                                                                :allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintServiceDescriptor(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
      java_grpc_generator::PrintStub(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, java_grpc_generator::StubType) in java_generator.o
      java_grpc_generator::PrintBindServiceMethod(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf:                          :io::Printer*) in java_generator.o
  "google::protobuf::io::Printer::Outdent()", referenced from:
      java_grpc_generator::PrintService(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, bool) in java_generator.o
      java_grpc_generator::PrintServiceDescriptor(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
      java_grpc_generator::PrintStub(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*, java_gr                 pc_generator::StubType) in java_generator.o
      java_grpc_generator::PrintBindServiceMethod(google::protobuf::ServiceDescriptor const*, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > >*, google::protobuf::io::Printer*) in java_generator.o
  "google::protobuf::io::Printer::Printer(google::protobuf::io::ZeroCopyOutputStream*, char)", referenced from:
      java_grpc_generator::GenerateService(google::protobuf::ServiceDescriptor const*, google::protobuf::io::ZeroCopyOutputStream*, bool) in java_generator.o
  "google::protobuf::io::Printer::~Printer()", referenced from:
      java_grpc_generator::GenerateService(google::protobuf::ServiceDescriptor const*, google::protobuf::io::ZeroCopyOutputStream*, bool) in java_generator.o
  "google::protobuf::compiler::PluginMain(int, char**, google::protobuf::compiler::CodeGenerator const*)", referenced from:
      _main in java_plugin.o
  "google::protobuf::compiler::CodeGenerator::~CodeGenerator()", referenced from:
      JavaGrpcGenerator::~JavaGrpcGenerator() in java_plugin.o
  "google::protobuf::compiler::ParseGeneratorParameter(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::vector<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocat                                                                                                 or<char> > > > >*)", referenced from:
      JavaGrpcGenerator::Generate(google::protobuf::FileDescriptor const*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, google::protobuf::compiler::GeneratorContext*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >*) const in java_plugin.o
  "google::protobuf::compiler::java::ClassName(google::protobuf::Descriptor const*)", referenced from:
      java_grpc_generator::MessageFullJavaName(google::protobuf::Descriptor const*) in java_generator.o
  "google::protobuf::compiler::java::ClassName(google::protobuf::FileDescriptor const*)", referenced from:
      java_grpc_generator::ServiceJavaPackage(google::protobuf::FileDescriptor const*) in java_generator.o
  "typeinfo for google::protobuf::compiler::CodeGenerator", referenced from:
      typeinfo for JavaGrpcGenerator in java_plugin.o
  "vtable for google::protobuf::compiler::CodeGenerator", referenced from:
      google::protobuf::compiler::CodeGenerator::CodeGenerator() in java_plugin.o
  NOTE: a missing vtable usually means the first non-inline virtual member function has no definition.
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
:grpc-compiler:linkLocal_archJava_pluginExecutable FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/310
Remove call sites of Os.isFamily(). Use osdetector instead
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/311
Fix Mac build failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/312
MessageFramer produces too small message chunks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MessageFramer uses
bufferAllocator.allocate(maxFrameSize)
to produce chunks that the transport can write. Currently these chunks are always 4096 bytes regardless of transport or payload size.
Transports cannot coalesce these chunks and typically end up writing each one in a syscall. For large payloads this really hurts performance. Instead we should delegate to the buffer allocator and ask it to produce a chunk up to the payload size. E.g.
bufferAllocator.allocate(len)
Experimentation with HBase has shown that for a 51k payload this reduces syscalls on write by 3x.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/313
Allow the message frame to create chunks as large as transport will allow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI  - This PR is work in progress, initially just demonstrates idea.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/314
On Server side, use Status "UNKNOWN" instead of "INTERNAL" for errors ca...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Those messages give way too much information. Simply UNKNOWN is probably more appropriate.
But really, we should change Status.fromThrowable to use UNKNOWN instead of INTERNAL as users will be using that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/315
Fix protobuf-nano build broken by 3666de4427460a307bfb86a7f93b3a04cb28f8...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks! I don't know why we weren't seeing build failures, but yeah, it was messed up.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/316
Upgrade to com.google.protobuf:protobuf-gradle-plugin:0.1.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/317
Integration test largeUnary failing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We recently ran into an issue with one of our services where sending large responses results in transport errors being logged as well as eventual transport failure. I managed to reproduce this behavior in integration test largeUnary as well. When running a single iteration of largeUnary the test passes although connection errors are logged:
Apr 20, 2015 10:43:45 AM io.grpc.transport.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.handler.codec.http2.Http2Exception: Stream does not exist 3
    at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:58)
    at io.netty.handler.codec.http2.DefaultHttp2Connection.requireStream(DefaultHttp2Connection.java:110)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onWindowUpdateRead(DefaultHttp2ConnectionDecoder.java:486)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onWindowUpdateRead(Http2InboundFrameLogger.java:124)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readWindowUpdateFrame(DefaultHttp2FrameReader.java:560)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:247)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:130)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:99)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:291)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:332)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
    at io.netty.channel.local.LocalChannel.finishPeerRead(LocalChannel.java:329)
    at io.netty.channel.local.LocalChannel.access$400(LocalChannel.java:45)
    at io.netty.channel.local.LocalChannel$5.run(LocalChannel.java:315)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

However, running largeUnary in a simple loop causes transport failure after a few iterations. This happens with both netty and okhttp client variants, as well as with netty local channel.
Other details:
$ uname -a
Darwin eno.local 14.3.0 Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64 x86_64
$ java -version
java version "1.8.0_40"
Java(TM) SE Runtime Environment (build 1.8.0_40-b25)
Java HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)


David
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/318
Remove String allocation in MutableHandlerRegistryImpl.lookupMethod(String).
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In QPS benchmarks we spend roughly 1% of the total allocations on allocating String objects when doing a substring on the method name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/319
CodedInputStream and CodedOutputStream always allocate a fixed 4KB byte array.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Protobuf's CodedInputStream and CodedOutputStream always allocate 4KB sized byte arrays in their constructor. For small messages this is overkill and we should investigate if we can reduce this. On QPS benchmarks our heap consists for roughly 30% of those byte arrays. So this can have a big impact for memory usage.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/320
CompositeReadableBuffer and SerializingExecutor allocate a 16 entry ArrayDeque.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The CompositeReadableBuffer and the SerializingExecutor always allocate a 16 entry ArrayDeque. We should investigate if we can get away with a smaller default size in order to save memory. In benchmarks just over 2% of total allocations are the Object[] that back the ArrayDeque.
A 16 element Object[] uses roughly 80 byte of memory (12 byte obj header + 4 byte length + 4 byte per entry with compressed oops). Initializing it to a more reasonable default value like 4, could save ~50%, but we should figure out how many entries we are likely to actually need.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/321
Set initial size for ArrayList in TransportFrameUtil.toHttp2Headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In QPS benchmarks roughly 0.5% of the total heap is spend on growing the ArrayList in TransportFrameUtil.toHttp2Headers(). It seems like we roughly know the size in advance and so we should initialize it to this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/322
Improve synchronization of SerializingExecutor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are seeing some contention in ChannelImpl.obtainActiveTransport() and SerializingExecutor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/323
Propagate explicit flushes through MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/324
okhttp: Don't allow server half-closes before client's half-close.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/325
Determine upper-bound for Netty buffer sizes used in frame
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As a follow on to
#312
we need benchmarks to determine whether we should be placing an upper-bound on the buffers allocated to the MessageFramer from Netty. We are already setting a lower-bound to page-size (default is 8k) to facilitate buffer object caching within Netty as well as allowing for follow-on writes.
Setting an upper-bound should probably be done by benchmark (unless one already exists)
Above the Netty arena size (currently 16MB) Netty will allocate an Unpooled buffer. Above 32k Netty takes an arena lock to allocate a buffer out of the arena (i.e. it will not cache the buffer itself)
See https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919
for the scheme Netty follows
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/326
Upgrading to latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/327
Log stack traces of test failures to the console.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/328
Create DEPLOYING.md to document deployment instructions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should this go in a different file since most people shouldn't need to look at it and it could scare new users?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/329
Support setting the HTTP/2 flow control window in grpc.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if we could set the HTTP/2 flow control window from grpc in order to be able to do meaningful throughput tests in different environments e.g. two of my cloud VMs have a bandwidth delay product of 485KByte/s (high latency and high bandwidth). So with the default flow control window of 64KB we can theoretically only ever reach 13% of the possible throughput on that network.
Would be nice to also add this as a command line flag to the QPS benchmarks.
@ejona86 @louiscryan @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/330
OkHttpClientTransport.onGoAway() races with startPendingStreams()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
onGoAway has two phases: do things necessary under lock and final cleanup. In the first phase it collects the streams to terminate in the second and sets goAway.
startPendingStreams() does not observe goAway and also creates new streams that should be failed due to the goAway. From an initial look, it seems it would be best to remove failPendingStreams() and simply integrate its two phases into onGoAway()'s two phases; that is, when holding the lock in onGoAway, replace pendingStreams with an empty list, and then when not holding the lock call transportReportStatus
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/331
Throughput: AbstractServerStream does unnecessary flushes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @nmittler

AbstractServerStream.writeMessage if no headers have been sent will immediately flush an empty header to the transport, by triggering internalSendFrame(flush = true)
In the case of a unary response we don't delay the flush of the framed message to allow the trailers to be flushed at the same time.

Will work on a PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/332
Throughput: NettyClientTransport does unnecessary flush
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the case of Unary & Server-streaming calls the immediate flush of request headers is unnecessary as a single payload must immediately follow for a valid call
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/333
Changing the protobuf branch name in the README.md.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/334
Update QPS Client and Server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/335
Add support for setting the connection and stream flow control window to NettyServerBuilder.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan @nmittler @ejona86 Please take a look.
I basically just copied the code from Nathan's commit for the client handler.
@louiscryan I will add a flag to QPS once this stuff is merged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/336
Memoryleak in Netty Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When pushing the server hard I am getting
SEVERE: LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 0
Created at:
    io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:250)
    io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
    io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:91)
    io.grpc.transport.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:65)
    io.grpc.transport.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:48)
    io.grpc.transport.MessageFramer.commitToSink(MessageFramer.java:240)
    io.grpc.transport.MessageFramer.close(MessageFramer.java:221)
    io.grpc.transport.AbstractStream.closeFramer(AbstractStream.java:136)
    io.grpc.transport.AbstractServerStream.close(AbstractServerStream.java:107)
    io.grpc.ServerImpl$ServerCallImpl.close(ServerImpl.java:434)
    io.grpc.stub.ServerCalls$ResponseObserver.onCompleted(ServerCalls.java:195)
    io.grpc.benchmarks.qps.QpsAsyncServer$TestServiceImpl.unaryCall(QpsAsyncServer.java:177)
    grpc.testing.TestServiceGrpc$2.invoke(TestServiceGrpc.java:193)
    grpc.testing.TestServiceGrpc$2.invoke(TestServiceGrpc.java:188)
    io.grpc.stub.ServerCalls$1$1.onHalfClose(ServerCalls.java:93)
    io.grpc.ServerImpl$ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerImpl.java:480)
    io.grpc.ServerImpl$JumpToApplicationThreadServerStreamListener$2.run(ServerImpl.java:370)
    io.grpc.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:152)
    com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:299)
    io.grpc.SerializingExecutor.execute(SerializingExecutor.java:110)
    io.grpc.ServerImpl$JumpToApplicationThreadServerStreamListener.halfClosed(ServerImpl.java:366)
    io.grpc.transport.AbstractServerStream.halfCloseListener(AbstractServerStream.java:243)
    io.grpc.transport.AbstractServerStream.remoteEndClosed(AbstractServerStream.java:200)
    io.grpc.transport.AbstractStream$1.endOfStream(AbstractStream.java:85)
    io.grpc.transport.MessageDeframer.deliver(MessageDeframer.java:245)
    io.grpc.transport.MessageDeframer.request(MessageDeframer.java:142)
    io.grpc.transport.AbstractStream.requestMessagesFromDeframer(AbstractStream.java:226)
    io.grpc.transport.netty.NettyServerStream.access$000(NettyServerStream.java:47)
    io.grpc.transport.netty.NettyServerStream$1.run(NettyServerStream.java:74)
    io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
    io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    java.lang.Thread.run(Thread.java:745)

and OOM with a 30GB heap after a few minutes. I guess we have a memory leak :-). Working on it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/337
Fix memeory leak in MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr @ejona86
We've actually always had a leak, it was just very slow.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/338
Client stream flush reduction
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/339
Add code generation for the advanced server interface
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I asked on the mailing list (https://groups.google.com/forum/#!topic/grpc-io/1RiPC8XYP_U) whether a callback existed to notify the server that a client had disconnected so it could perform some cleanup actions. Here's the answer I received from Eric Anderson:
Because it is a unary request, there isn't a callback that notifies you of client cancellation (any error is considered a cancellation to the server). The next time you call onValue though, an exception will be thrown notifying you of the cancellation. That is enough in some scenarios.
The "advanced" interface provides such notification though. It has onHalfClose (which is when onComplete is normally called), onComplete (when the RPC gracefully completed), and onCancel (if there was an error or if the client cancelled). We don't have code generation for the advanced interface though, so you would need to implement ServerCallHandler for each method in the service, create ServerMethodDefinitions and add them to a ServerServiceDefinition, which is what you pass to the ServerBuilder's addService. That would be verbose and annoying, but simple code. It would probably make sense for you to create an issue for us to add codegen for the advanced interface.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/340
Buffer writes until flush, before sending to transport thread/lock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This design could benefit both okhttp, as it reduces synchronization overhead. It also would also improve flush behavior and make flushes predictable when MAX_CONCURRENT_STREAMS is exceeded.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/341
OkHttp does not observe SETTINGS_INITIAL_WINDOW_SIZE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It only observes MAX_CONCURRENT_STREAMS.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/342
Add Openloop Client to benchmarks.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @nmittler @louiscryan @vjpai
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/343
Update to protobuf-gradle-plugin:0.2.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/344
Fix buffer leak from 0-length buffer optimization
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/345
Fix the race between failing and starting pending streams.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/346
Cannot compile C++ code on WIndows (VisualCpp)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm trying to build project under Windows. To do this I added tool chain with visualCpp(VisualCpp) (compiler/build.gradle):
toolChains {
    visualCpp(VisualCpp) {
      installDir "c:/path/Microsoft Visual Studio 12.0"
    }
    gcc(Gcc) {
      target("x86_64") {
    cppCompiler.withArguments { args ->
      args << "-m64"
    }
    linker.withArguments { args ->
      args << "-m64"
    }
      }
      target("x86_32") {
    cppCompiler.withArguments { args ->
      args << "-m32"
    }
    linker.withArguments { args ->
      args << "-m32"
    }
      }
      target('local_arch') { }
    }
    [...]

Sadly VisualCpp plugin does not support target and I get error:
* Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':grpc-compiler:compileLocal_archJava_pluginExecutableJava_pluginCpp'.
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:69)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:306)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:23)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:88)
    at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62)
    at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
    at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:68)
    at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:55)
    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:149)
    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:106)
    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:86)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:80)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:36)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26)
       at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:51)
    at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:169)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:237)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:210)
    at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35)
    at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:206)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
    at org.gradle.launcher.Main.doAction(Main.java:33)
    at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:54)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:35)
    at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
    at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30)
    at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:127)
    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:56)
Caused by: org.gradle.api.GradleException: No tool chain is available to build for platform 'local_arch':
  - Tool chain 'visualCpp' (Visual Studio): Don't know how to build for platform 'local_arch'.
  - Tool chain 'gcc' (GNU GCC): Could not find C compiler 'gcc' in system path.
  - Tool chain 'clang' (Clang): Could not find C compiler 'clang' in system path.
    at org.gradle.nativeplatform.toolchain.internal.UnavailablePlatformToolProvider.failure(UnavailablePlatformToolProvider.java:47)
    at org.gradle.nativeplatform.toolchain.internal.UnavailablePlatformToolProvider.newCompiler(UnavailablePlatformToolProvider.java:71)
    at org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask.compile(AbstractNativeCompileTask.java:83)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute(AnnotationProcessingTaskFactory.java:235)

    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:211)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute(AnnotationProcessingTaskFactory.java:222)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:200)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    ... 47 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/347
Upgrading to the latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/348
Adding outbound flow control for Netty.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan @ejona86 can you take a look?  I still have to add tests for outbound flow control, but I wanted to get thoughts on the implementation first.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/349
okhttp: respect SETTINGS_INITIAL_WINDOW_SIZE in outbound flow control.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86, please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/350
MessageFramer close on error can recurse
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MessageFramer.close is not safe for re-entrancy.
A stream write error, triggers an error reported to the stream, which triggers framer.close, which triggers a write, which ....
at io.grpc.transport.netty.NettyServerHandler.onStreamError(NettyServerHandler.java:215)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:470)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData.error(DefaultHttp2ConnectionEncoder.java:342)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultFlowState.writeError(DefaultHttp2RemoteFlowController.java:697)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultFlowState.cancel(DefaultHttp2RemoteFlowController.java:566)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultFlowState.write(DefaultHttp2RemoteFlowController.java:638)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultFlowState.writeBytes(DefaultHttp2RemoteFlowController.java:580)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.sendFlowControlled(DefaultHttp2RemoteFlowController.java:180)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeData(DefaultHttp2ConnectionEncoder.java:133)
at io.grpc.transport.netty.NettyServerHandler.sendGrpcFrame(NettyServerHandler.java:287)
at io.grpc.transport.netty.NettyServerHandler.write(NettyServerHandler.java:245)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeWriteNow(ChannelHandlerInvokerUtil.java:157)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeWrite(DefaultChannelHandlerInvoker.java:337)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:265)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:258)
at io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:1039)
at io.netty.channel.AbstractChannel.write(AbstractChannel.java:252)
at io.grpc.transport.netty.NettyServerStream.sendFrame(NettyServerStream.java:93)
at io.grpc.transport.AbstractServerStream.internalSendFrame(AbstractServerStream.java:146)
at io.grpc.transport.AbstractStream$2.deliverFrame(AbstractStream.java:91)
at io.grpc.transport.MessageFramer.commitToSink(MessageFramer.java:246)
at io.grpc.transport.MessageFramer.close(MessageFramer.java:228)
at io.grpc.transport.AbstractStream.closeFramer(AbstractStream.java:136)
at io.grpc.transport.AbstractServerStream.abortStream(AbstractServerStream.java:226)
at io.grpc.transport.netty.NettyServerHandler.onStreamError(NettyServerHandler.java:215)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/351
Fix issue where MessageFramer.close can be called in a reentrant fashion
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/352
Recursion in NettyClientHandler during shutdown caused by channelInactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler @ejona86
Connection termination can trigger recursion in active stream shutdown
channelnactive -> close active streams -> send pending frames -> write headers (fail) -> connection error -> send go_away -> close active streams -> ...
Apr 28, 2015 1:34:55 PM io.netty.handler.codec.http2.DefaultHttp2Connection notifyClosed
SEVERE: Caught RuntimeException from listener onStreamClosed.
java.lang.NullPointerException
at io.grpc.transport.netty.NettyClientHandler.onStreamError(NettyClientHandler.java:237)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:470)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData.error(DefaultHttp2ConnectionEncoder.java:341)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.writeError(DefaultHttp2RemoteFlowController.java:691)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.cancel(DefaultHttp2RemoteFlowController.java:578)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.cancel(DefaultHttp2RemoteFlowController.java:560)
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$2.onStreamClosed(DefaultHttp2RemoteFlowController.java:87)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.grpc.transport.netty.NettyClientHandler.goingAway(NettyClientHandler.java:310)
at io.grpc.transport.netty.NettyClientHandler.access$300(NettyClientHandler.java:65)
at io.grpc.transport.netty.NettyClientHandler$1.onGoAwaySent(NettyClientHandler.java:99)
at io.netty.handler.codec.http2.DefaultHttp2Connection.goAwaySent(DefaultHttp2Connection.java:189)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:555)
at io.netty.handler.codec.http2.Http2ConnectionHandler.goAway(Http2ConnectionHandler.java:586)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onConnectionError(Http2ConnectionHandler.java:494)
at io.grpc.transport.netty.NettyClientHandler.onConnectionError(NettyClientHandler.java:228)
at io.netty.handler.codec.http2.Http2ConnectionHandler.onException(Http2ConnectionHandler.java:477)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.error(DefaultHttp2ConnectionEncoder.java:425)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:472)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.operationComplete(DefaultHttp2ConnectionEncoder.java:440)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyLateListener(DefaultPromise.java:621)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:138)
at io.netty.channel.DefaultChannelPromise.addListener(DefaultChannelPromise.java:93)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledBase.(DefaultHttp2ConnectionEncoder.java:459)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:411)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledHeaders.(DefaultHttp2ConnectionEncoder.java:401)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:169)
at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeHeaders(DecoratingHttp2FrameWriter.java:50)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.writeHeaders(BufferingHttp2ConnectionEncoder.java:118)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$HeadersFrame.send(BufferingHttp2ConnectionEncoder.java:288)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$PendingStream.sendFrames(BufferingHttp2ConnectionEncoder.java:235)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.createNextPendingStream(BufferingHttp2ConnectionEncoder.java:196)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder.access$100(BufferingHttp2ConnectionEncoder.java:68)
at io.grpc.transport.netty.BufferingHttp2ConnectionEncoder$1.onStreamClosed(BufferingHttp2ConnectionEncoder.java:95)
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:263)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1150)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams$2.process(DefaultHttp2Connection.java:1097)
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1121)
at io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
at io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder.channelInactive(Http2ConnectionHandler.java:151)
at io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:325)
at io.grpc.transport.netty.NettyClientHandler.channelInactive(NettyClientHandler.java:217)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelInactiveNow(ChannelHandlerInvokerUtil.java:56)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelInactive(DefaultChannelHandlerInvoker.java:92)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:135)
at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:928)
at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:647)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)
at java.lang.Thread.run(Thread.java:724)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/353
Upgrade to protobuf plugin 0.3.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/354
Fix style violations added in 986d221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java:406: Line is longer than 100 characters
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/355
Include gradle 2.3 in Travis-CI cache
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/356
OkHttpClientTransportTest.pendingStreamFailedByIdExhausted is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in the Travis logs:
io.grpc.transport.okhttp.OkHttpClientTransportTest > pendingStreamFailedByIdExhausted FAILED
    java.lang.AssertionError: Failed waiting stream to be closed.
        at org.junit.Assert.fail(Assert.java:88)
        at io.grpc.transport.okhttp.OkHttpClientTransportTest$MockStreamListener.waitUntilStreamClosed(OkHttpClientTransportTest.java:912)
        at io.grpc.transport.okhttp.OkHttpClientTransportTest.pendingStreamFailedByIdExhausted(OkHttpClientTransportTest.java:650)

    java.lang.AssertionError: expected:<0> but was:<1>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:118)
        at org.junit.Assert.assertEquals(Assert.java:555)
        at org.junit.Assert.assertEquals(Assert.java:542)
        at io.grpc.transport.okhttp.OkHttpClientTransportTest.tearDown(OkHttpClientTransportTest.java:142)

The commit was restarted, and succeeded.
Another example of apparent flakiness: https://travis-ci.org/grpc/grpc-java/builds/59916295 . The commit before and after were green. The tested commit only changed Netty code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/357
Try to allow building java without having to build codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It may be possible to use the last released codegen binary.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/358
De-flake OkHttpClientTransportTest.pendingStreamFailedByIdExhausted.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/359
Http2ClientStream overwrites error message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Http2ClientStream.transportHeadersReceived() is calling withDescription instead of augmentDescription. This hinders debugging what went wrong.
@yang-g, since he is interested in when this is resolved.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/360
Check response content type on client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems we aren't checking the content type of responses on the client. The flag was originally put in place because some implementations were sending the wrong content type, but it seems we should enable it again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/361
Remove all blocking from the NettyClientTransport. Fixes #116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler @ejona86
Ready for review. Before this can be merged Netty has to be updated to commit netty/netty@31a6ab9
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/362
Fix build on Windows/VC++
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/363
c++ server and java client communications issue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello.
I try write gRPC communication with java client and c++ server on linux.
But i have exception (below) in client when it runs RPC procedure.
Logs shows that server processed request, sended answer and continues its work.
For test i wrote same client on c++ and same server on java. All communication versions works. And only client(java) with server(c++) failed.
I hope you can help me. Thanks.
Exception in thread "main" com.google.common.util.concurrent.UncheckedExecutionException: io.grpc.Status$OperationRuntimeException: INTERNAL:
Headers(path=null,authority=null,metadata={grpc-status=[0]})
DATA-----------------------------
 at io.grpc.stub.Calls.getUnchecked(Calls.java:117)
 at io.grpc.stub.Calls.blockingUnaryCall(Calls.java:129)
 at rpc_test.ManagerServiceGrpc$ManagerServiceBlockingStub.doGet(ManagerServiceGrpc.java:274)
 at rpc_test.Client.testRPC(Client.java:53)
 at rpc_test.Client.main(Client.java:64)

Caused by: io.grpc.Status$OperationRuntimeException: INTERNAL:
Headers(path=null,authority=null,metadata={grpc-status=[0]})
DATA-----------------------------
 at io.grpc.Status.asRuntimeException(Status.java:428)
 at io.grpc.stub.Calls$UnaryStreamToFuture.onClose(Calls.java:324)
 at io.grpc.ChannelImpl$CallImpl$ClientStreamListenerImpl$3.run(ChannelImpl.java:373)
 at io.grpc.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:152)
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
 at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/364
Don't overwrite error message if bad headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/365
Cleaning up some warnings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/366
Swap to Netty's SslContextBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/367
More flush reduction for Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/368
Don't use SerializingExecutor when running with a direct executor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I wanted to know what the impact of the SerializingExecutor is when running with a direct executor.
So I did 3 benchmarks, choosing the best out of 3 runs.
Direct Executor + Serializing (current master)
buchgr@buchgr0:~/Code/grpc-java/benchmarks/build/install/grpc-benchmarks/bin$ ./qps_client --port=33333 --host=localhost --channels=8 --outstanding_rpcs_per_channel=10 --warmup_duration=10s --duration=30s --server_payload=1 --client_payload=1 --directexecutor
Channels:                       8
Outstanding RPCs per Channel:   10
Server Payload Size:            1
Client Payload Size:            1
50%ile Latency (in micros):     669
90%ile Latency (in micros):     1817
95%ile Latency (in micros):     3231
99%ile Latency (in micros):     5727
99.9%ile Latency (in micros):   9255
QPS:                            78642

Direct Executor + Serializing Executor without synchronized blocks.
buchgr@buchgr0:~/Code/grpc-java/benchmarks/build/install/grpc-benchmarks/bin$ ./qps_client --port=33333 --host=localhost --channels=8 --outstanding_rpcs_per_channel=10 --warmup_duration=10s --duration=30s --server_payload=1 --client_payload=1 --directexecutor
Channels:                       8
Outstanding RPCs per Channel:   10
Server Payload Size:            1
Client Payload Size:            1
50%ile Latency (in micros):     655
90%ile Latency (in micros):     1647
95%ile Latency (in micros):     3083
99%ile Latency (in micros):     5679
99.9%ile Latency (in micros):   9607
QPS:                            81500

Direct Executor only, no Serializing Executor
buchgr@buchgr0:~/Code/grpc-java/benchmarks/build/install/grpc-benchmarks/bin$ ./qps_client --port=33333 --host=localhost --channels=8 --outstanding_rpcs_per_channel=10 --warmup_duration=10s --duration=30s --server_payload=1 --client_payload=1 --directexecutor
Channels:                       8
Outstanding RPCs per Channel:   10
Server Payload Size:            1
Client Payload Size:            1
50%ile Latency (in micros):     619
90%ile Latency (in micros):     1096
95%ile Latency (in micros):     1132
99%ile Latency (in micros):     3999
99.9%ile Latency (in micros):   11407
QPS:                            99904

So it seems to me that the potential improvement is significant enough to make some changes and not use a SerializingExecutor when using direct i.e. by adding an option to the Server / Channel Builders.
WDYT @nmittler @louiscryan @ejona86 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/369
Update Netty to 9d70cf3 to pick up flush elimination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler @ejona86
This is just the changes necessary to work with the flush elimination change in Netty
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/370
Don't close streams when sending GOAWAY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/371
okhttp: Implement outbound flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#6 implemented the outbound flow control API for client and server, as well as support for it in Netty, but it did not implement support for it in OkHttp. We need outbound support in OkHttp, or at least dummy support (that implements the API, but doesn't provide push-back) for the near future.
Dummy support could be implemented on the client-side by calling notifyIfReady on stream creation (similar to in Netty). It seems server-side may work as-is. In either case, this would rely on AbstractStream.isReady() always returning true.
But we should really implement the full feature on OkHttp.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/372
Do not fail pending streams when sending GOAWAY.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @buchgr can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/373
Adding bin to .gitignore for OSX
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look? I still get these directories popping up on OSX ... it's annoying :/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/374
netty: Remove goAwayStatus when client closing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/375
OkHttp: "Platform.getSelectedProtocol() == null" check is problematic
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
May 04, 2015 9:48:24 PM com.squareup.okhttp.internal.Platform$JdkWithJettyBootPlatform getSelectedProtocol
INFO: ALPN callback dropped: SPDY and HTTP/2 are disabled. Is alpn-boot on the boot class path?
I used "Platform.getSelectedProtocol() == null" prior to our TLS hand shake to check whether user has already done the handshake, if they haven't, this log would show up while we are about to do the handshake.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/376
Add comment to satisfy checkstyle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/377
Make checkstyle fail build by default
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/378
Use CreateStartScripts for integration-testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/379
Produce combined JavaDoc, add links, exclude internals
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/380
Updating to the latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/381
Add Jacoco code coverage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/382
Unsupported TLS version exception on server side is not handled.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
May 05, 2015 11:01:26 AM io.netty.channel.DefaultChannelPipeline$TailContext exceptionCaught
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: Client requested protocol TLSv1 not enabled or not supported
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:358)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:127)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Caused by: javax.net.ssl.SSLHandshakeException: Client requested protocol TLSv1 not enabled or not supported
at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1421)
at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535)
at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:813)
security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1139)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1003)
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:943)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
... 14 more
Caused by: javax.net.ssl.SSLHandshakeException: Client requested protocol TLSv1 not enabled or not supported
at sun.security.ssl.Alerts.getSSLException(Alerts.java:203)
at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1666)
at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:304)
at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:292)
at sun.security.ssl.ServerHandshaker.clientHello(ServerHandshaker.java:504)
at sun.security.ssl.ServerHandshaker.processMessage(ServerHandshaker.java:217)
at sun.security.ssl.Handshaker.processLoop(Handshaker.java:969)
at sun.security.ssl.Handshaker$1.run(Handshaker.java:909)
at sun.security.ssl.Handshaker$1.run(Handshaker.java:906)
at java.security.AccessController.doPrivileged(Native Method)
at sun.security.ssl.Handshaker$DelegatedTask.run(Handshaker.java:1359)
at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1173)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1025)
... 16 more

The corresponding client exception is:
java.lang.RuntimeException: javax.net.ssl.SSLException: Connection closed by peer
It's hard to understand what was wrong from such limited info.
We should let the client knows its TLS version is problematic.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/383
Cleaning up closing for Netty client/server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 this is a follow up to c8c478e  that addresses both the client and server side.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/384
Updating to the latest Netty version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/385
No ciphers available.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With using Http2SecurityUtil.CIPHERS, we are encountering this cipher suites issue, the previous workaround is running with JDK8.
But now this issue is biting Android integration test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/386
Always checking MAX_CONCURRENT_STREAMS in
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @buchgr can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/387
Allow skip codegen build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems like project properties are exposed as settings in settings.gradle: https://gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/388
Re-adding goAwayStatus when client application closes.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/389
Integration test fails on HEAD
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am on HEAD (commit 111f6dd)
./gradlew :grpc-integration-testing:test keeps failing on both Mac and Linux with:
io.grpc.testing.integration.Http2NettyTest > veryLargeRequest FAILED
    java.lang.Exception: test timed out after 30000 milliseconds

io.grpc.testing.integration.Http2NettyTest > veryLargeResponse FAILED
    java.lang.Exception: test timed out after 30000 milliseconds

io.grpc.testing.integration.Http2NettyTest > exchangeContextUnaryCall FAILED
    com.google.common.util.concurrent.UncheckedExecutionException: io.grpc.StatusRuntimeException: UNKNOWN

        Caused by:
        io.grpc.StatusRuntimeException: UNKNOWN

            Caused by:
            javax.net.ssl.SSLException: SSLEngine closed already

io.grpc.testing.integration.Http2NettyTest > emptyUnary FAILED
    java.lang.Exception: test timed out after 10000 milliseconds

io.grpc.testing.integration.Http2NettyTest > pingPong FAILED
    Wanted but not invoked:
    streamObserver.onValue(
        payload {
...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/390
Fix the filesets to be checked by checkstyle.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/391
Unify build properties
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/392
Properly removing buffered streams after receiving goAway
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/393
Adding logging to NettyClientHandler.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/394
Examples should use CreateStartScripts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using CreateStartScripts in benchmark and integration-testing, and it seems nice. We should do the same for the examples (so similar changes to 00a7192).
Documentation will need to be updated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/395
Only complete graceful shutdown after buffered streams complete.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What does this gain us? I thought 77d0042 would be identical behavior unless we overrode the appropriate method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/396
Improve Contributing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/397
Add build status icon and rephrase title
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/398
Use protoc artifact from Maven Central.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/399
Use CreateStartScripts for examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/400
Make Channel/Server abstract classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/401
Stop running gradle in run-test-{client,server}.sh
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/402
Adding default implementation of onReady in Call and ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/403
Update generated proto output
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/404
Proto files are not recompiled if codegen has been changed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since we have checked in the generated code, we must re-generate them if 1) the proto files are changed, or 2) the codegen is changed, or 3) the version of protoc is changed.
The generateProto task uses the proto files as input, and I have confirmed that 1) works, but 2) and 3) don't.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/405
Recompile proto files if codegen has changed.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/406
Make README obvious that protobuf building is optional
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/407
isReady() should return false until stream allocated
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/408
Bad transport may be used for starting stream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently we reference activeTransport to the newly created transport before the new transport is started , so if the new transport failed starting with an exception, the subsequent stream still try to use the bad activeTransport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/409
Handle OkHttp throwing exception during start()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/410
Upgrade to protobuf-gradle-plugin:0.4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/411
OkHttp connection window does not reclaim outstanding connection window of closed stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Netty will return any unprocessed stream window to the connection window on stream closure, OkHttp does not currently do this.
See onStreamClosed in Nettys DefaultHttp2LocalFlowController.
This will surface if a stream is cancelled and there is a partial message in the Deframer as the Deframer intentionally does not return bytes if there are no pending requests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/412
routeGuideClient hangs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported by Martin, (I assume @magx2). @magx2, what git commit were you running at?
Terminal1-server:
$ ./gradlew routeGuideServer
:grpc-core:compileJava UP-TO-DATE
:grpc-core:animalSniffer
...
May 06, 2015 4:56:06 PM io.grpc.examples.routeguide.RouteGuideServer start
INFO: Server started, listening on 8980

Server is started; now running client. Terminal2-client:
$ ./gradlew routeGuideClient
:grpc-core:compileJava UP-TO-DATE
:grpc-core:animalSniffer
...
:grpc-examples:classes UP-TO-DATE
May 06, 2015 4:56:51 PM io.grpc.examples.routeguide.RouteGuideClient info
INFO: *** GetFeature: lat=409,146,138 lon=-746,188,906
// at this point everythings hangs

Stopping client with CTRL+C results in error in server:
May 06, 2015 4:57:50 PM io.netty.channel.DefaultChannelPipeline$TailContext exceptionCaught
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: An existing connection was forcibly closed by the remote host
    at sun.nio.ch.SocketDispatcher.read0(Native Method)
    at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
    at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
    at sun.nio.ch.IOUtil.read(IOUtil.java:192)
    at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:379)
    at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:311)
    at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:854)
    at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:242)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:115)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/413
Add more JUnit annotations to list of methods checkstyle will ignore
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/414
Fixing benchmarks build in eclipse.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/415
okhttp: Catch Exceptions thrown by the frist platform.getSelectedProtâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/416
changed the netty-codec-http2 depdendency to released version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/417
Add ping to ClientTransport and ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/418
Slight performance improvment for MutableHandlerRegistryImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here are the benchmark results from running on my laptop:
Benchmark                              (methodCountPerService)  (nameLength)  (serviceCount)  (useNewRegistry)   Mode  Cnt    Score    Error  Units
HandlerRegistryBenchmark.lookupMethod                      100            50             100             false  thrpt   20  332.830 Â±  9.159  ops/s
HandlerRegistryBenchmark.lookupMethod                      100            50             100              true  thrpt   20  377.629 Â± 12.240  ops/s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/419
Fix a bug that checked-in generated code are not re-compiled.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/420
can not compile with genetor code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java version "1.8.0_40"
Mac OS X 10.10.3
gradle version 2.4
protobuf version 3.0
I can use gradle compile when skipCodegen=true,but I can not compile when I want code gen.
First,It show me 'google/protobuf/compiler/java/java_names.h' file not found,then I copy the cpp file from protobuf/share to compiler/src/java_plugin/cpp.It show me unknown type name 'Atomic32'.
How can I do it? Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/421
Deferring stream creation until receiving SETTINGS from server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/422
Add property protoc=/path/to/protoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/423
Dockerfile for deployment
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Related to protocolbuffers/protobuf/issues/354
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/424
Allow 100 streams initially rather than 10.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/425
Simplify the build instructions now that Netty can be fetched from Maven
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So... we aren't confident we won't need to use the submodule in the future.
The plan is that our releases always use Netty artifacts on Maven Central. For the master branch we would try to stay on a Netty released artifact, but if we really need to we would still fallback to submodule. But then we have to delay a release until Netty releases.
That makes me wary of removing the submodule stuff.
Thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/426
Add documentation saying that transport has weaker API guarantees
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/427
Make it more obvious that JDK 8 is necessary for TLS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/428
Client-side Load Balancing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For the moment, all things client-side load balancing. Designs, requirements, etc. Can be split into separate issues as appropriate.
There is an internal load balancing design that needs to be made public. This is on @a11r's plate.
There is want to support ZooKeeper. It may need a different Channel implementation than the one necessary for the doc @a11r will share.
@louiscryan
@jhump
@mzhaom
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/429
Update docs to reflect current status of ALPN on older versions of Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/430
okhttp: Sends reset if client receives halfClose before sending halfClose.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/431
Implement writes to the channel using a dedicated write queue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Difference in performance from MaxQpsBenchmark
AFTER-------------------------------
Benchmark                                    (channelCount)  (maxConcurrentStreams)   Mode  Cnt      Score      Error  Units
MaxQpsBenchmark.measureUnary:callsPerSecond               1                      10  thrpt   20  17233.925 Â±  765.450  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               1                     100  thrpt   20  17494.865 Â± 1069.966  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               1                    1000  thrpt   20  16806.718 Â± 2000.184  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                      10  thrpt   20  26280.909 Â± 1800.194  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                     100  thrpt   20  30651.307 Â± 2506.293  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                    1000  thrpt   20  30850.247 Â± 2760.220  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                      10  thrpt   20  42930.248 Â± 1463.644  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                     100  thrpt   20  44527.268 Â± 1342.846  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                    1000  thrpt   20  46026.291 Â± 2705.484  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                      10  thrpt   20  30151.448 Â± 1601.576  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                     100  thrpt   20  35231.488 Â±  993.181  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                    1000  thrpt   20  37890.380 Â± 4221.883  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                      10  thrpt   20  28447.637 Â± 1190.671  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                     100  thrpt   20  30699.913 Â±  652.101  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                    1000  thrpt   20  28769.108 Â± 3196.432  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                      10  thrpt   20  28440.326 Â± 1507.982  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                     100  thrpt   20  29217.955 Â± 2022.133  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                    1000  thrpt   20  26925.591 Â± 3144.744  ops/s
AFTER-------------------------------
Benchmark                                    (channelCount)  (maxConcurrentStreams)   Mode  Cnt       Score      Error  Units
MaxQpsBenchmark.measureUnary:callsPerSecond               1                      10  thrpt   20   14919.476 Â± 1049.194  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               1                     100  thrpt   20   48554.047 Â± 3809.628  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               1                    1000  thrpt   20   55975.008 Â± 2687.428  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                      10  thrpt   20   27070.917 Â±  856.241  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                     100  thrpt   20   83444.590 Â± 4580.374  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               2                    1000  thrpt   20   85941.249 Â± 6032.673  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                      10  thrpt   20   48875.571 Â± 2497.066  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                     100  thrpt   20  110715.074 Â± 7999.329  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               4                    1000  thrpt   20  107040.913 Â± 3820.023  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                      10  thrpt   20   75139.737 Â± 1588.738  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                     100  thrpt   20   69458.655 Â± 2679.446  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond               8                    1000  thrpt   20   72043.815 Â± 2902.249  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                      10  thrpt   20   64267.215 Â± 2748.387  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                     100  thrpt   20   52057.030 Â± 1480.486  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              16                    1000  thrpt   20   49996.458 Â± 3400.733  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                      10  thrpt   20   57700.415 Â± 1273.293  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                     100  thrpt   20   55044.654 Â± 1725.707  ops/s
MaxQpsBenchmark.measureUnary:callsPerSecond              32                    1000  thrpt   20   45458.060 Â± 7053.582  ops/s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/432
updates to test native epoll
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/433
Requesting more messages from the Deframer causes unnecessary context-switching
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the case of a incoming stream of messages the flow-control window may accommodate more than one message. If the deframer has several messages in its currently held buffer we end up doing a lot of context switching to request more messages out as we end up with a sequence like
deframer.request(1) -> jump to app thread -> onPayload() -> call.request(1) -> jump to event loop -> deframer.request(1)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/434
Fixing benchmarks build on non-linux systems.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/435
okhttp: Enable TLS for Http2OkHttpTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/436
ServerCalls binding utilities are too general
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Generated server bindings use only two methods in ServerCalls to adapt a service. The lack of differentiation between the different modes of streaming causes too many calls to 'request' more messages from flow control in scenarios where no more messages are available.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/437
Delete the generated files only before generateProto.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM. Thanks! This will be nice.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/438
Some more minor flush optimizations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/439
Make it more obvious JDK 8 is commonly necessary
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/440
OkHttp does not return connection flow control for DATA of unknown stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It returns early.
https://github.com/grpc/grpc-java/blob/master/okhttp/src/main/java/io/grpc/transport/okhttp/OkHttpClientTransport.java#L501
It seems like we can just move the windowUpdate handling before the return.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/441
WINDOW_UPDATE for unknown streams causes exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As discovered by @madongfly. It is very easy to get a WINDOW_UPDATE for an unknown stream. For instance, if we sent RST_STREAM and there is a WINDOW_UPDATE en route from the server already.
https://github.com/grpc/grpc-java/blob/master/okhttp/src/main/java/io/grpc/transport/okhttp/OutboundFlowController.java#L97
It seems we should just ignore such WINDOW_UPDATES instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/442
okhttp: don't crash if receive window_update for an non-exit stream which may have existed.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/443
okhttp: update connection window when receives DATA for existed streams.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/444
Disable Netty eventloop graceful termination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/445
Update AUTH-README.md with Android TLS/ALPN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/446
Adding support for UDS to benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/447
Add new benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler - FYI as you're refactoring  benchmarks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/448
Implement shutdownNow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For both ChannelImpl and ServerImpl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/449
Consider delaying terminated state until application no longer processing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In ServerImpl and ChannelImpl, we proceed to terminated as soon as all the transports have terminated. However, we should probably wait for all the SerializingExecutors to drain, since that is more of what the application would expect and it is useful to know that all the workers are done.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/450
Decrease ArrayDeque memory in SerializingExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/451
Set likely final size of array in toHttp2Headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/452
Netty streams should reduce the capacity of pooled buffers passed to sendFrame
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a small write and flush is passed through the framer we hold the full 4k of the buffer until the write completes. By reducing the capacity of a pool direct buffer to the readably byte limit we immediately release the unwritten portion of the buffer back to the pool.
This may or may not have an impact on performance and utility should be evaluated by bencmarking. It may improve performance by making more bytes available to thread-local allocation. The most likely benchmarks to be impacted would be streaming ones that write and flush many messages in a tight loop as it would alleviate buffer-arena locks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/453
Investigate performance implications of hard-coded outbound flow-control buffer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The outbound flow-controller assumes as 32k memory buffer as the ideal pending write limit to determine if a stream is available for further writes (as indicated by AbstractStream.isReady).
This may be sub-optimal,  for example in the single stream case it would limit a flow-control aware message producer for exhausting the connection window.
An alternate solution is to allow each stream to accept messages if
(a) The pending writes for a stream are less than the connection window size
(b) A configured memory allocator indicates that more buffers are available in the allocator pool.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/454
Consider implementing pull / batch write to optimize flushing for streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For streaming calls that can produce a batch of messages as a unit consider adding an interface that allows for a single flush to propagate through the framer to the transport.
In the case of outbound flow-controlled streams it should be possible for a producer to generate a sequence of messages that produce a single flush in response to the onReady (and onPayload) callbacks where the sequence of writes terminates when isReady becomes false.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/455
Implement compute_engine_creds interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/456
Implement service_account_creds interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/457
Implement jwt_token_creds interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#jwt_token_creds
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/458
Interop tests and servers should all use the same flow control window
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now we are generally using 1 MB as the connection window size and 64 KB as the stream flow control window. However, the tests were written assuming we were using the defaults of 64 KB for both. Also, it seems in the future we will be changing the flow control windows more. Java for instance is considering upping the window to 1 MB after putting in better memory handling. Java is also expecting to auto-tune the flow control window size based on the bandwidth-delay product.
We should specify that interop clients and servers should hard-code a fixed connection and stream window size. Given that we want to find bugs with the interop tests, I suggest 64 KB for both, but I'm open to alternatives.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/459
AbstractTransportTest.veryLarge{Request,Response} very slow with TLS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I recently noticed that building grpc-java took an additional 30s. I tracked it down to OkHttp enabling TLS for its Http2OkHttpTest. Each test consumes ~12 seconds when using TLS, but is < 200 ms without TLS. It shouldn't take 12s to send 10 MB... The problem exists with Netty as well.
Since each test is run twice (once for OkHttp, once for Netty), that means the tests are ~50 seconds on the critical path of our ~1.5 minute build time.
I don't have many ideas as to why it could be so slow. It could be that the ciphers are really slow, but that is really, really slow. It is important to me that it impacts Netty and OkHttp equally.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/460
Support messages with unknown length in framer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We will need some tagging interface or similar in order to detect when available() (or some other method) knows the message length.
This does not mean we would make sure that available() in the inbound direction (because compression makes that hard).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/461
Remove thread-hop required for blocking stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Once #150 CallOptions is supported, we can use a per-call direct executor for blocking stubs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/462
Decide whether gRPC will use options in proto for methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be possible to attach options, such as compression and default timeout, to methods. @a11r was thinking that we wouldn't have such options, but @louiscryan had been thinking we would. It doesn't seem we feel too strongly one way or the other, but we just need to get consensus and move forward.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/463
Making client-side negotiation more pluggable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/464
Rename integration-testing to interop-testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/465
Commit codegen'd files missing from 43038a5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/466
Fix minor issues with release scripts/documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/467
Using SSLCertificateSocketFactory for TLS handshake doesn't work externally for Android older than 5.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, internal Android projects are using SSLCertificateSocketFactory for TLS handshake, but since ALPN only works well with Android 5.0 or newer, they use NPN for Android 4.4 and older.
It works just because internal OKHttp has been hacked to support NPN.
With the external OKHttp, it will failed as:
com.google.common.util.concurrent.UncheckedExecutionException: io.grpc.StatusRuntimeException: INTERNAL: Failed starting transport
    at io.grpc.stub.Calls.getUnchecked(Calls.java:117)
    at io.grpc.stub.Calls.blockingUnaryCall(Calls.java:129)
    at io.grpc.android.integrationtest.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:331)
    at io.grpc.android.integrationtest.IntegrationTester.emptyUnary(IntegrationTester.java:93)
    at io.grpc.android.integrationtest.IntegrationTester.runTest(IntegrationTester.java:72)
    at io.grpc.android.integrationtest.GrpcTestTask.doInBackground(GrpcTestTask.java:53)
    at io.grpc.android.integrationtest.GrpcTestTask.doInBackground(GrpcTestTask.java:12)
    at android.os.AsyncTask$2.call(AsyncTask.java:288)
    at java.util.concurrent.FutureTask.run(FutureTask.java:237)
    at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
    at java.lang.Thread.run(Thread.java:841)
Caused by: io.grpc.StatusRuntimeException: INTERNAL: Failed starting transport
    at io.grpc.Status.asRuntimeException(Status.java:428)
    at io.grpc.stub.Calls$UnaryStreamToFuture.onClose(Calls.java:324)
    at io.grpc.ChannelImpl$CallImpl$ClientStreamListenerImpl$3.run(ChannelImpl.java:402)
    at io.grpc.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:152)
    ... 3 more
Caused by: java.lang.RuntimeException: protocol negotiation failed
    at com.squareup.okhttp.OkHttpTlsUpgrader.upgrade(OkHttpTlsUpgrader.java:95)
    at io.grpc.transport.okhttp.OkHttpClientTransport.start(OkHttpClientTransport.java:293)
    at io.grpc.ChannelImpl.obtainActiveTransport(ChannelImpl.java:199)
    at io.grpc.ChannelImpl.access$600(ChannelImpl.java:55)
    at io.grpc.ChannelImpl$CallImpl.start(ChannelImpl.java:266)
    at io.grpc.stub.Calls.asyncServerStreamingCall(Calls.java:174)
    at io.grpc.stub.Calls.unaryFutureCall(Calls.java:86)
    at io.grpc.stub.Calls.blockingUnaryCall(Calls.java:129)
    at io.grpc.android.integrationtest.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:331)
    at io.grpc.android.integrationtest.IntegrationTester.emptyUnary(IntegrationTester.java:93)
    at io.grpc.android.integrationtest.IntegrationTester.runTest(IntegrationTester.java:72)
    at io.grpc.android.integrationtest.GrpcTestTask.doInBackground(GrpcTestTask.java:53)
    at io.grpc.android.integrationtest.GrpcTestTask.doInBackground(GrpcTestTask.java:12)
    at android.os.AsyncTask$2.call(AsyncTask.java:288)
    at java.util.concurrent.FutureTask.run(FutureTask.java:237)
    at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
    ... 3 more
]>
    at io.grpc.android.integrationtest.TesterActivityTest.testGrpc(TesterActivityTest.java:65)
    at java.lang.reflect.Method.invokeNative(Native Method)
    at android.test.InstrumentationTestCase.runMethod(InstrumentationTestCase.java:214)
    at android.test.InstrumentationTestCase.runTest(InstrumentationTestCase.java:199)
    at android.test.ActivityInstrumentationTestCase2.runTest(ActivityInstrumentationTestCase2.java:192)
    at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:191)
    at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:176)
    at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:554)
    at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1701)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/468
Fail travis build if codegen isn't committed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/469
Simplifying usage of native transports.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/470
Don't use a list for benchmarks deps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/471
Improve invalid argument message for address
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/472
Don't use reflection for epoll/unix domain sockets
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/473
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/474
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/475
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/476
okhttp: outbound flow control.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86, please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/477
Revert swapping to the "canonical HTTP mapping"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Commit 4332c2f swapped to the status-suggested HTTP mappings, but these are really broken for gRPC. I had actually thought I had already reverted the commit, so I was shocked to see it was still in-place.
grpc/grpc@5b53e35 describes examples of specific issues with the mapping.
I want to revert this change immediately, but I don't want to do it just before a release, so I'll delay until after 0.7.0 is cut.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/478
Add support for indeterminate length messages. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/479
Improve synchronization in obtainActiveTransport()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Split out of #322
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/480
Making test certs more shareable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL ... this is in part to help with development of the Jetty test (in the Netty module).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/481
Adding alpn_boot configuration to the parent build file.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/482
Upgrade okhttp to 2.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/483
Adding test for gRPC clients running inside Jetty.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I think it would be a bit hacky to create a unit test to reproduce the Jetty environment.  To reproduce (and fix) the problem, I ended up just running Jetty locally and deploying a gRPC-enabled web app.  The solution is captured here: #180 (comment).
I'm abandoning this and will create a new PR for the switch to Netty ALPN plus documentation for Jetty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/484
Add service_account_creds test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I rebased (to have the okhttp upgrade commit) and verified it works for okhttp too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/485
Add compute_engine_creds test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/486
accidental complication error happend problem
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I compile my grpc project, sometimes it is ok but sometimes it has the following compilation error:

XXXXGrpc.java:22: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchRequest.PARSER),
^
XXXXGrpc.java:23: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchResponse.PARSER));
^
XXXXGrpc.java:28: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchRequest.PARSER),
^
XXXXGrpc.java:29: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchResponse.PARSER));
^
XXXXGrpc.java:34: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchRequest.PARSER),
^
XXXXGrpc.java:35: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchResponse.PARSER));
^
XXXXGrpc.java:40: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchRequest.PARSER),
^
XXXXGrpc.java:41: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SearchAllResponse.PARSER));
^
XXXXGrpc.java:46: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SuggestRequest.PARSER),
^
XXXXGrpc.java:47: error: package io.grpc.protobuf does not exist
io.grpc.protobuf.ProtoUtils.marshaller(com.engzo.search.protoc.SuggestResponse.PARSER));

sometimes ok sometimes not. very weird.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/487
Handle IOException thrown by FrameReader.nextFrame() as PROTOCOL_ERROR.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In current implementation, we treat the IOException thrown by FrameReader.nextFrame() as the "IO" issue, so we just close the connection and don't send anymore.
But actually, it may throw IOException for protocol errors like: invalid frame size, RST_STREAM with stream id 0, invalid values in SETTINGS etc, in such cases, we should send a GOAWAY before closing the connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/488
Release commit for 0.7.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/489
Add download and usage instructions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/490
Upgrade to OkHttp 2.4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just released. The API changes are known to break us. Let's look at what it'll take to upgrade.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/491
Upgrade OkHttp to 2.4.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/492
Let people use compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's been implemented for a while, but no way to turn it on.
We don't have a way to determine if the remote supports compression; that may need to be considered. We should also make sure we interop with C, which is doing compression soon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/493
Add User-Agent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/494
Simplify configuration of flow control windows
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Stream window should really always be the same as the connection window.  We should just expose a single lever for this ... default to 1MB.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/495
Add SelectedProtocolQuerier to get protocol selected by NPN on Android.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/496
DeferredInputStream has unused generic parameter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/497
Switching to Netty's ALPN support.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL.  I'll rebase once #480 is committed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/498
Catch Exception thrown when query NPN selected protocol on a socket tâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/499
Renaming AUTH_README to SECURITY_README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/500
Remove unused imports.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM. Please make sure to run with checkstyle enabled before pushing in the future.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/501
okhttp: Call onError for IOException thrown by FrameReader.nextFrame().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm concerned about conflating general I/O errors with protocol errors. Can you provide an example of one of those IOExceptions that is a protocol error? If it's in our code, it seems like making a special ProtocolErrorIOException or Http2IOException to communicate clearly would be a good idea.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/502
Allow for batching writes to the framer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Need to allow applications to perform a sequence of writes that cause a single flush in the framer to improve throughput.
The typical example for this would be an application thats wants to write messages until isReady() is false and to do more writes when onReady() is called. Even if the application is not flow-control aware (i.e is not using isReady) it would still be useful to allow write batching for bursty streams
One simple option for doing this would be to delay the outbound framer flush while executing  onPayload/isReady callbacks though this would only help cases where sends are done inside these callbacks by the same thread. A more thorough API change is probably warranted.
To give some performance context the change described above allows the FlowControlledMessagesPerSecondBenchmark to go from ~700kqps to ~4Mqps on my box
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/503
Instructions to run the examples fail
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps:
Clone repo, checkout either "v0.7.x" (at commit 186a9b2) or "master" (at commit 0782c04). Follow instructions here: cd examples/, then ../gradlew installDist --stacktrace.
Output:
[...]
:grpc-core:animalSniffer
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils.class:74: Undefined reference: com.google.protobuf.Descriptors.Descriptor com.google.protobuf.Message.getDescriptorForType()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils.class:74: Undefined reference: String com.google.protobuf.Descriptors.Descriptor.getFullName()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$1.class:60: Undefined reference: Object com.google.protobuf.Parser.parseFrom(java.io.InputStream)
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$1.class:60: Undefined reference: com.google.protobuf.MessageLite
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$1.class:51: Undefined reference: com.google.protobuf.MessageLite
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$2.class:78: Undefined reference: byte[] com.google.protobuf.Message.toByteArray()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$2.class:85: Undefined reference: com.google.protobuf.Parser com.google.protobuf.Message.getParserForType()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$2.class:85: Undefined reference: Object com.google.protobuf.Parser.parseFrom(byte[])
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$2.class:85: Undefined reference: com.google.protobuf.Message
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/ProtoUtils$2.class:75: Undefined reference: com.google.protobuf.Message
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:74: Undefined reference: int com.google.protobuf.MessageLite.getSerializedSize()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:75: Undefined reference: void com.google.protobuf.MessageLite.writeTo(java.io.OutputStream)
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:87: Undefined reference: byte[] com.google.protobuf.MessageLite.toByteArray()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:99: Undefined reference: int com.google.protobuf.MessageLite.getSerializedSize()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:107: Undefined reference: com.google.protobuf.CodedOutputStream com.google.protobuf.CodedOutputStream.newInstance(byte[], int, int)
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:108: Undefined reference: void com.google.protobuf.MessageLite.writeTo(com.google.protobuf.CodedOutputStream)
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:109: Undefined reference: void com.google.protobuf.CodedOutputStream.flush()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:110: Undefined reference: void com.google.protobuf.CodedOutputStream.checkNoSpaceLeft()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:117: Undefined reference: byte[] com.google.protobuf.MessageLite.toByteArray()
/Users/jcanizales/git/grpc-java/core/build/classes/main/io/grpc/proto/DeferredProtoInputStream.class:129: Undefined reference: int com.google.protobuf.MessageLite.getSerializedSize()
:grpc-core:animalSniffer FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-core:animalSniffer'.
> Signature errors found. Verify them and ignore them with the proper annotation if needed.

* Try:
Run with --info or --debug option to get more log output.

* Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':grpc-core:animalSniffer'.
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:69)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:306)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:23)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:88)
    at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62)
    at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
    at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:68)
    at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:62)
    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:55)
    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:149)
    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:106)
    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:86)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:80)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33)
    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:36)
    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:26)
    at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:51)
    at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:169)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:237)
    at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:210)
    at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35)
    at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:206)
    at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
    at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
    at org.gradle.launcher.Main.doAction(Main.java:33)
    at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:54)
    at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:35)
    at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
    at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30)
    at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:127)
    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)
Caused by: org.gradle.api.GradleException: Signature errors found. Verify them and ignore them with the proper annotation if needed.
    at be.insaneprogramming.gradle.animalsniffer.AnimalSnifferTask$_performAnimalSniffer_closure3.doCall(AnimalSnifferPlugin.groovy:115)
    at be.insaneprogramming.gradle.animalsniffer.AnimalSnifferTask.performAnimalSniffer(AnimalSnifferPlugin.groovy:104)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:218)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:211)
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:200)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:585)
    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:568)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
    ... 47 more


BUILD FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/504
Netty throws exception when creating > 1 TLS transport.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When attempting to create multiple TLS transports from the same builder, Netty throws an exception:
io.netty.channel.ChannelPipelineException: io.grpc.transport.netty.ProtocolNegotiators$SslBootstrapHandler is not a @Sharable handler, so can't be added or removed multiple times.
    at io.netty.channel.DefaultChannelPipeline.checkMultiplicity(DefaultChannelPipeline.java:564)
    at io.netty.channel.DefaultChannelPipeline.addFirst0(DefaultChannelPipeline.java:114)
    at io.netty.channel.DefaultChannelPipeline.addFirst(DefaultChannelPipeline.java:108)
    at io.netty.channel.DefaultChannelPipeline.addFirst(DefaultChannelPipeline.java:291)
    at io.netty.channel.DefaultChannelPipeline.addFirst(DefaultChannelPipeline.java:246)
    at io.grpc.transport.netty.ProtocolNegotiators$AbstractBufferingHandler.channelRegistered(ProtocolNegotiators.java:192)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelRegisteredNow(ChannelHandlerInvokerUtil.java:32)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRegistered(DefaultChannelHandlerInvoker.java:50)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRegistered(AbstractChannelHandlerContext.java:114)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRegistered(DefaultChannelPipeline.java:833)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:487)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.access$100(AbstractChannel.java:401)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:461)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/505
Allowing Netty TLS bootstrap handler to be sharable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/506
Move BufferingHttp2ConnectionEncoder upstream to Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
BufferingHttp2ConnectionEncoder is solving a relatively generic use case.  I would like to explore the possibility of this class being extracted out of gRPC and contributed upstream to Netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/507
Blocking stub don't throw StatusRuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Instead, it throws RuntimeExecutionException with a StatusRuntimeException as a cause. Is that what we want?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/508
Adding default User-Agent for netty and okhttp.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/509
Rename Call to ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 @ejona86 I'm wondering if we should hold off on this until the dust settles from Wolfgang's API work ... I suspect some of this might change again as a result.  WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/510
Introduce support for calls as composable objects
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Let's suppose we call it "Callable" (actual name may differ), and it is related to Call as is f.i. Iterable to Iterator, or Observable to Observer in the Rx pattern.
The basic contract would be:
class Callable<I, O> {
   abstract Call<I, O> newCall(Channel ch);
}

Basic creation operations for Callable would be:
static Callable<I, O> create(MethodDescriptor<I, O> method);
static Callable<I, O> create(BiFunction<I, O> function);

Sequential composition would be supported, as well as various ways to parallelize execution:
<Q> Callable<I, Q> followedBy(Callable<O, Q> second);
Callable<List<I>, List<O>> inParallel();
...

Building blocks for dealing with API programming patterns would be supported:
Callable<I, O> retrying(RetryOptions options);
<R> Callable<I,R> paging(Class<R> resourceType, PagingOptions options);

Additional scenarios which might be supported by callables or related means:

Resource modification (Read-Modify-Write cycle), with conditions
Media upload and download
Long running operations
PubSub
Conversion to/from Rx and to/from Java 8 streams (no need to reinvent the wheel here. If someone wants to do processing of responses or produce requests, those frameworks should have everything)
...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/511
Consolidate Method descriptor classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Now we have three classes for representing a method: MethodDescriptor, ServerMethodDefinition, Method. They all have the method name and marshallers. We list their differences below:

MethodDescriptor is used on client when making a call. It has options and MethodType (unary, streaming etc)
Method passes information from IDL to the runtime. It has MethodType.
ServerMethodDefinition is used on server for a registered method. It has the ServerCallHandler.

Their content overlap a lot. They should be consolidated. Here is the plan:

Make it clear that MethodDescriptor is a static representation of the method definition from IDL. It will be used on both client-side and server-side.
Change ServerMethodDefinition to contain a MethodDescriptor
Delete Method. Use MethodDescriptor to pass information from IDL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/512
Enable Travis for all branches
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/513
Upgrade to protobuf-3.0.0-alpha-3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, LGTM.
Nice finding so many places that reference the old version :).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/514
Document how to copy credentials for docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... I'll assume it works :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/515
Support for custom status codes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.Status seems to be restricted to the built-in status codes provided, although javadoc suggests that new status codes can be used as long as they are not conflicting. Adding a factory method such as "Status.forCode" should be possible although this would require that the status code type be changed from an enum to integer constant. This may be a small price to pay for the added flexibility.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/516
Excessive logging of Status{Runtime}Exception in server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a service throws Status{Runtime}Exception it gets logged regardless of error class. There should probably be a distinction between "client" errors such as NOT_FOUND, INVALID_ARGUMENT which should not be logged (or at least not as FATAL) and other server errors (INTERNAL, UNKNOWN, etc) similar to how HTTP errors are categorized.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/517
"WARN java.lang.IllegalStateException: Refcount has already reached zero" during shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are frequently seeing this exception during server shutdown but not in all cases. I did a little digging and it looks like the SharedResourceHolder on DEFAULT_EXECUTOR is being called twice in ServerImpl.java: once when transportClosed() is called and again in serverShutdown(). Looks like serverShutdown() first shuts down all transports, so perhaps this is what is triggering the call to transportClosed() before it attempts to release the holder again for a second time.
Thanks,
David
INFO  [2015-06-07 21:52:09,390] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@21bd20ee{/,null,UNAVAILABLE}
WARN  [2015-06-07 21:52:09,400] io.netty.util.concurrent.DefaultPromise: An exception was thrown by io.grpc.transport.netty.NettyServer$2.operationComplete()
! java.lang.IllegalStateException: Refcount has already reached zero
! at com.google.common.base.Preconditions.checkState(Preconditions.java:173) ~[guava-18.0.jar:na]
! at io.grpc.SharedResourceHolder.releaseInternal(SharedResourceHolder.java:147) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.SharedResourceHolder.release(SharedResourceHolder.java:115) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.AbstractServerBuilder$1.run(AbstractServerBuilder.java:120) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.ServerImpl.checkForTermination(ServerImpl.java:204) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.ServerImpl.access$300(ServerImpl.java:64) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.ServerImpl$ServerListenerImpl.serverShutdown(ServerImpl.java:227) ~[grpc-core-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.transport.netty.NettyServer$2.operationComplete(NettyServer.java:140) ~[grpc-netty-0.8.0-SNAPSHOT.jar:na]
! at io.grpc.transport.netty.NettyServer$2.operationComplete(NettyServer.java:134) ~[grpc-netty-0.8.0-SNAPSHOT.jar:na]
! at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680) ~[netty-common-4.1.0.Beta5.jar:4.1.0.Beta5]
! at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:845) [netty-common-4.1.0.Beta5.jar:4.1.0.Beta5]
! at io.netty.util.concurrent.DefaultPromise$LateListenerNotifier.run(DefaultPromise.java:873) [netty-common-4.1.0.Beta5.jar:4.1.0.Beta5]
! at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322) [netty-common-4.1.0.Beta5.jar:4.1.0.Beta5]
! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356) [netty-transport-4.1.0.Beta5.jar:4.1.0.Beta5]
! at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703) [netty-common-4.1.0.Beta5.jar:4.1.0.Beta5]
! at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_45]
! at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_45]
! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_45]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/518
In-Process Transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be useful to have a light-weight, low-overhead, in-process transport. It could be used in testing, using gRPC to an endpoint that may be in the same process, and bridging from other protocols (like REST or SOAP).
Today, we recommend using Netty's in-process transport for testing. This has the same benefit of using fakes, in that it tests more of the system's actual behavior. This still seems preferred for testing, but it does cause messages to be serialized and de-serialized.
For the design, I propose we implement an in-memory client/server transport (not a Channel/Server). Implementing a transport instead of Channel/Server lets Channel/Server continue to handle the listener threading model and would keep more behavior in sync (especially error handling). In order to prevent serializing messages, the InputStream passed to the transport would be the same InputStream passed out of the transport. Marshaller.parse() could then do an instanceof check and avoid serialization.
For example, for proto we would add something like the following to parse() in ProtoUtils, since messages are immutable:
if (stream instanceof DeferredProtoInputStream) {
  return ((DeferredProtoInputStream) stream).message();
}
The transport itself would not create any threads and do all its work in the caller's thread. I think it wouldn't even need to use locks for thread safety, as Stream is not thread-safe. If the application uses directExecutor for Channel and Server, then no threads would be created.
@jhump
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/519
Reorganizing the deployment docs.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @zhangkun83 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/520
Add ALPN setting path for Android older than 5.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OkHttp only support setting ALPN on Android 5.0+ since 2.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/521
Support setting ALPN for Android older than 5.0, OkHttp(2.3+) implemeâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you please provide more description as to what is different about this code and what was being done previously.
Does this support using jetty_alpn?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/522
Netty Client does not detect when ALPN was not used
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I tried to reproduce the APLN silence failure, I expected the following change fails our tests, but not, all tests still passed.
diff --git a/interop-testing/src/test/java/io/grpc/testing/integration/Http2NettyTest.java b/interop-testing/src/test/java/io/grpc/testing/integration/Http2NettyTest.java
index 504c815..2ae8160 100644
--- a/interop-testing/src/test/java/io/grpc/testing/integration/Http2NettyTest.java
+++ b/interop-testing/src/test/java/io/grpc/testing/integration/Http2NettyTest.java
@@ -37,6 +37,7 @@ import io.grpc.transport.netty.GrpcSslContexts;
 import io.grpc.transport.netty.NettyChannelBuilder;
 import io.grpc.transport.netty.NettyServerBuilder;

+import io.netty.handler.ssl.ApplicationProtocolConfig;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
@@ -74,7 +75,8 @@ public class Http2NettyTest extends AbstractTransportTest {
       return NettyChannelBuilder
           .forAddress(TestUtils.testServerAddress(serverPort))
           .sslContext(GrpcSslContexts.forClient().trustManager(
-                  TestUtils.loadCert("ca.pem")).build())
+                  TestUtils.loadCert("ca.pem"))
+              .applicationProtocolConfig(ApplicationProtocolConfig.DISABLED).build())
           .build();
     } catch (Exception ex) {
       throw new RuntimeException(ex);

The problem itself is not a big deal, but investigating it may expose some hidden bugs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/523
Allow specification of open-loop vs closed-loop test in qpstest.proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
As we move toward interoperable QPS testing, please allow the ClientConfig in qpstest.proto specify the type of load to deliver. I would suggest that you support variable open-loop request arrival processes as in https://github.com/grpc/grpc/tree/master/test/cpp/qps , but ultimately Poisson process is the most important.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/524
Allow specification of open-loop vs closed-loop test in qpstest.proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
As we move toward interoperable QPS testing, please allow the ClientConfig in qpstest.proto specify the type of load to deliver. I would suggest that you support variable open-loop request arrival processes as in https://github.com/grpc/grpc/tree/master/test/cpp/qps , but ultimately Poisson process is the most important.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/525
Support NPN with Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It isn't useful for jetty_alpn, but when using OpenSsl, using ALPN_AND_NPN in the netty application negotiation config allows us to support more platforms without needing users to install OpenSSL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/526
Support NPN on Android when Play Services Security Provider (PSSP) not available
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Attempts and their fallbacks:

If installed, use PSSP with ALPN and NPN
If on Android 5.0 or later, use ALPN and NPN
If on Android 4.1 or later, use NPN
Fail or let the application author install some alternative security provider (e.g., build and ship Conscrypt themselves)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/527
Verify Protocol Negotiation completed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems if neither ALPN nor NPN occur/available we just happily continue connecting and think that negotiation occurred. We should instead check that the protocol negotiated and fail if it didn't.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/528
Properly set inbound and outbound connection and stream window sizes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/529
Cleanup io.grpc package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Rename DeferredInputStream as it doesn't necessarily have to be deferred.  Consider making it an interface.
 Move SharedResourceHolder into transport
 SerializingExecutor into transport
 Rename KnownLength
 Add available method with documentation to KnownLength
 Move MethodType into MethodDescriptor
 Move Marshaller into MethodDescriptor
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/530
Add the Android interop test App.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should use the same gradlew as in the root of the project. Just do ../gradlew instead of ./gradlew
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/531
ClientAuthInterceptor's ctor requires an Executor, but never use it.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/532
Changing Netty handlers to properly set initialSettings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/533
ensure that terminationRunnable is invoked only once during shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fixes #517
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/534
Leverage Netty's write coalescing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/535
Testing that buffered streams clean up properly upon disconnect.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/536
Investigate Netty stream closure handling logic
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the Netty handlers, we seem to have various ways that we can detect stream and handle stream closure. We should try to simplify this logic so that it's less error prone.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/537
Error When Compiling grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I try to compile grpc-java I get the following error:
8:10: fatal error: 'google/protobuf/io/zero_copy_stream.h' file not found
"#include <google/protobuf/io/zero_copy_stream.h>
^
1 error generated.
:grpc-compiler:compileJava_pluginExecutableJava_pluginCpp FAILED
libprotoc is version 3.0 and it is currently installed in /usr/local/lib and I've tried this on Linux and Mac OSX.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/538
Add ClientInterceptors "inside" ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is an alternative to #64.
It could be useful to have a set of interceptors "inside" ChannelImpl. These interceptors would always be used. The could be immutable and added via a AbstractChannelBuilder.addInterceptor() or maybe mutated added after creation on ChannelImpl. Today, adding after creation doesn't cause issues since only interceptCall is part of ClientInterceptor. However, if any other methods were added to the interface it could easily cause problems.
There are two main use cases:

Simple users who don't want to maintain as many object references. Adding to the inside of ChannelImpl means they don't need to maintain both a ChannelImpl reference and the topmost Channel reference, as they could be the same object. These are simpler scenarios that only have one chain of interceptors.
Auth construction factory. Authentication commonly needs a combination of transport and Metadata configuration. For example, using TLS (optionally with client certificates) and then OAuth. The auth mechanism can change in the environment, for example, by not using TLS if the server is on the same trusted network. Having a single Auth-aware factory would be easier to use, as is the design of google-auth-library-java.

The feature would have the downfall of having multiple ways of doing what appears to be the same thing (via ClientInterceptors and via the AbstractChannelBuilder). It would increase user code's (unnecessary) dependency on ChannelImpl, because they wouldn't be forced to use Channel. It might also encourage a few users to create multiple ChannelImpls to keep things "simple."
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/539
Firming up client stream closure scenarios.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/540
Rename OkHttpChannelBuilder.setConnectionSpec to connectionSpec
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We aren't prefixing any of the other builder methods with set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/541
Move DEFAULT_CONNECTION_SPEC to OkHttpChannelBuilder and make OkHttpClientTransport package-private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is little reason for OkHttpClientTransport to be public. DEFAULT_CONNECTION_SPEC should just be the initial value of connectionSpec in the OkHttpChannelBuilder (instead of the current null).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/542
Pass timeout header in ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/543
Cleanup of NettyClientTransportTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 this is a pretty easy one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/544
Avoid GCM in unit tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/545
Make Channel hierarchy more meaningful
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler wrote on issue 64:

I think the problem here is that the term "channel" ~= "transport", but "interceptor" != "transport". I think it would be better to provide a more abstract interface that is responsible for creating calls and then all of these "things" would implement/extend that. Something like this:
interface CallFactory {
   Call newCall(MethodDescriptor method);
}
class MyInterceptor implements CallFactory {
    ...
}
interface Channel extends CallFactory {
    ...
    void shutdown();
}
class ChannelImpl implements Channel {
    ...
}

Discussion continued further. This issue is for these class renames/additions.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/546
Throw error for Netty when Jetty ALPN not configured.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/547
Recommend tcnative instead of jetty-alpn-boot
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need to make sure there are builds of tcnative for Debian-compatible OpenSSL, first though.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/548
Have different abstract base types for each stub type; use it instead of Calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, channel (and soon, callOptions) are defined in AbstractStub, but the generated code uses them. It could be a good idea to have abstract base types for each stub type that uses channel so that the generated code doesn't.
This also moves the call of Channel.newCall into non-generated code. In all, this should have the generate code hard-code fewer things.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/549
Update Travis to use protobuf3-alpha3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/550
Backport the supporting of ALPN on Android older than 5.0.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Did you have to do any manual merging?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/551
Some cleanup for okhttp:
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/552
Use exit() for integration test client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/553
Make ChannelImpl.obtainActiveTransport's fast path lock-free
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/554
Blocking calls should error with StatusRuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/555
Make the code clearer, fixes #531.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/556
Add instructions for setting up traffic shaping on loopback
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ctiller fyi
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/557
Migrate Windows Jenkins-based testing to grpc-testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Jenkins host we set things up on is going away. We should migrate the setup to the grpc-testing project.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/558
Using grpc with TLS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I'm working on grpc in android, and I want to use a self signed certificate.
OkHttpChannelBuilder.forAddress(mHost, mPort)
.sslSocketFactory(TestUtils.getSslSocketFactoryForCertainCert(TestUtils.loadCert("my_cert")))
.build();

But when I want to send request, a exception of type io.grpc.StatusRuntimeException is throw.
It's the good way to initialise TLS in grpc ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/559
In compiler documentation, use grpc-java as plugin name
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/560
Rename getSslSocketFactoryForCertainCert to be more clear what cert is provided
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It isn't clear that the File should point to a CA certificate. It should be renamed to be clear.
createSslSocketFactoryWithCa or newSslSocketFactoryForCa or similar.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/561
Exposing AbstractBufferingHandler so it can be used by custom protocoâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/562
Initial context API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/563
Use 1MB as the max payload size in benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/564
Revert swapping to the "canonical HTTP mapping"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/565
Ignore initial HEADERS with a 1xx :status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Headers with a 1xx status code in HTTP/1.1 are supposed to be ignored. In HTTP/2, there is a clear example of their usage.
I don't think 1xx status codes are all that important/common, but we should follow the spec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/566
Rename getSslSocketFactoryForCertainCert to be newSslSocketFactoryForCa.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why are we bothering to deprecate a method name in a testing utility?  This seems like overkill.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/567
Update usage of deprecated API, and add back two accidentally removed blank lines.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/568
ChannelImpl's constructor shouldn't be public
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ChannelImpl is really expected to be constructed from AbstractChannelBuilder. Using the builder allows us to more easily change the arguments as time goes on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/569
Stop using intrinsic locks in ChannelImpl/ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I originally used intrinsic locks for expediency. We were still designing quite a bit and we were still using Service. It seems swapping away from intrinsic locks makes sense, as we have no want/need to allow users to compose method calls into higher-order atomic calls.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/570
Are Interceptors are executed in an unintuitive order?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// interceptor1 is run before interceptor2
ClientInterceptors.intercept(channel, interceptor1, interceptor2);

// interceptor2 is run before interceptor1
channel = ClientInterceptors.intercept(channel, interceptor1);
channel = ClientInterceptors.intercept(channel, interceptor2);

This seems like it would get really confusing if you call intercept multiple times with multiple interceptors each time:
channel = ClientInterceptors.intercept(channel, interceptor2,
                                                interceptor1);
channel = ClientInterceptors.intercept(channel, interceptor4,
                                                interceptor3);

It seems the first interceptor listed should most likely be the interceptor nearest the library. If there was a single mutable interceptor list then the current behavior would make more sense.
Note that on server-side the application and library are reversed, so reversing the order would make the first interceptor nearest the application.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/571
Refactor OkHttpProtocolNegotiator, move Android related operations into an inner class.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/572
ServerServiceDefinition.getMethods should return a Collection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now it has a return type of ImmutableList, which 1) requires a specific Guava implementation and 2) there is no need for order of the methods. For instance, in the current implementation we could use methodLookup.values().
Note that having "Collection" as the return type but actually returning an ImmutableList is fine though.
I could be convinced that returning a List or Set is appropriate, but if we return Collection now we could actually change to using a List or Set in the future and remain API compatible (since the class is final).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/573
The generated Service.methods() should return a Collection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For similar reasoning to #572. Just limiting our API surface.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/574
Add CallOptions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/575
Maven plugin instructions are incomplete
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The build instructions do not seem to work.  The maven-protoc-plugin is neither in Maven Central nor does it appear to be in the Sonatype snapshot repository.  Which repository should we use?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/576
Apply client side timeouts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The contract to close() is very important, but it's also not as hard to satisfy at it would seem.
Firstly, you should realize that almost all stream processing occurs within the transport, and the transport is single-threaded. In Netty's case, this is because it runs on its own thread. In OkHttp, it acquires a lock. So state checking, in general, is already thread-safe.
It appears that OkHttp does not acquire the lock in these code paths, but instead uses an atomic operation on a map. I do find it very difficult to reason about the thread-safety of various calls; it requires way too much knowledge of how the pieces interact to verify. But I also do believe that the current code is relatively bug-free of thread safety issues.
Secondly, we guarantee to serialize all callbacks, thus we can even have non-volatile state that prevents any notifications after closed. It would be good not to rely on that, though, because it means somewhere else our code was in an inconsistent state, but in general it can be a good safety net. I see some bugs with it now though (like we don't close the message if closed).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/577
Android interop test should create channel in background thread.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When the host is not an ip address, addressing resolving will cause NetworkOnMainThreadException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/578
OkHttpClientTransport.start should be async
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Connecting should be run in an executor. The main problem is that we currently can't create the frameWriter (an AsyncFrameWriter) until we have connected. The frameReader doesn't seem to be as big of an issue as we can just delay executing clientFrameHandler.
We could try to use the same SerializingExecutor that is used inside AsyncFrameWriter. We would need to lazily initialize some things used on that thread, but we would be able to guarantee that the connection is started before real writes occur and they would be automatically queued.
This would fix the true problem that is causing #577.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/579
Use hostname instead of InetAddress for Socket creation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/580
For demonstration purpose, will be closed after discussion.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/581
Error zero_copy_stream.h file not found during ./gradlew installDists
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running ./gradlew installDists I receive the following error message:
In file included from /Users/me/projects/grpc-java/compiler/src/java_plugin/cpp/java_generator.cpp:1:
/Users/Sven.Bendel/projects/grpc-java/compiler/src/java_plugin/cpp/java_generator.h:8:10: fatal error: 'google/protobuf/io/zero_copy_stream.h' file not found
#include <google/protobuf/io/zero_copy_stream.h>
         ^

Am I missing something? I am just trying to get the example server up and running via run-test-server.sh.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/582
Simplifying flow control window config for Netty.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/583
OkHttp's cancellation is not properly synchronized
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OkHttpClientStream.sendCancel() calls finishStream() from an application thread. But finishStream() calls transportReportStatus() without any lock held. That is not synchronized correctly, as transportReportStatus() may only be called from the transport thread (i.e., while lock is held).
It seems that all usages of streams is done while lock is held except for within finishStream() and data(). data() can actually race with finishStream() and end up sending DATA frames after the RST_STREAM. It seems it would be best to just have stream protected by lock, because it having its own synchronization isn't providing much benefit and isn't leading to correct code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/584
Set inboundPhase() when receiving trailers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL ... this is an easy one ;)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/585
Adding handling for stream exhaustion in Netty.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/586
Use default type of KeyStore in Android interop test App, so that it can work on lower versions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please take a look, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/587
Migrate from PARSER to parser() as a way of getting the parser of a protobuf message.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM. Thanks!
We have the version a lot of places...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/588
Add the bintray repository for Maven protoc-plugin in the example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/589
Add an option to Android interop test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/590
Closing stream buffering encoder when inactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
@Scottmitch @buchgr you may be interested as well, since I'd like to make the same changes to Netty's encoder.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/591
Support NPN fallback for Android.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/592
Suggest -PskipCodegen in run-test-{client,server}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/593
Minor fixes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Assigning to @zhangkun83 since these fix some warnings that showed up internally.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/594
benchmark/ has two README.md's
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The readme at "benchmarks/src/jmh/java/io/grpc/benchmarks/netty/README.md" is in the java source directory, which seems a poor place for a readme. It should be integrated into the README.md at "benchmarks/README.md"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/595
Fix the potential deadlock.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/596
Fake infinite timeout; 1s is not a good hard-coded timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/597
Improve Exception backtrace for blocked streaming
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/598
Memory leaking when using ALPN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We're experiencing a slow memory leak with 0.7.1 when using ALPN and TLS. The server is built and started with this code :
NettyServerBuilder builder = NettyServerBuilder.forPort(port);
definitions.forEach(builder::addService);
SslContext context = SslContextBuilder.forServer(keyCertPathprivateKeyPath).build();
builder.sslContext(context);
ServerImpl server = builder.build();
server.start();

This is the alpn version that we're using.
-Xbootclasspath/p:/usr/lib/java/alpn-boot-8.1.3.v20150130.jar"
Running a heap dump, we're seeing a huge amount of SSLEngineImpl objects stored in a concurrent hash map :

The server is running behind a Amazon ELB. This might be related since the Amazon load balancer would open connections every once in a while to the server and to ping and make sure the server is live. Unfortunately it takes a long time to replicate, the server would run out of memory after 36 hours or so, but it doesn't seem like the number of requests
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/599
Android interop test: Use proto plugin to generate the needed code.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am going to push the protobuf-gradle-plugin to Maven Central today, so that you can depend on it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/600
Set hard-coded deadline to just under 1 year
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/601
Fixing leak of SSLEngine for Jetty ALPN/NPN servers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/602
Error message when connecting with TLS to closed port unhelpful
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I connect to a random port that is not open, the error message is not helpful.
$ ./run-test-client.sh --server_port=1234
Gradle is no longer run automatically. Make sure to run
'./gradlew installDist -PskipCodegen=true' or
'./gradlew :grpc-interop-testing:installDist -PskipCodegen' after any changes.
-PskipCodegen=true is optional, but requires less setup.
Running test empty_unary
Jul 07, 2015 11:02:03 AM io.grpc.transport.netty.ProtocolNegotiators$AbstractBufferingHandler fail
SEVERE: Transport failed during protocol negotiation
io.grpc.StatusRuntimeException: UNAVAILABLE: Channel closed while performing protocol negotiation
    at io.grpc.Status.asRuntimeException(Status.java:428)
    at io.grpc.transport.netty.ProtocolNegotiators.unavailableException(ProtocolNegotiators.java:175)
    at io.grpc.transport.netty.ProtocolNegotiators.access$000(ProtocolNegotiators.java:72)
    at io.grpc.transport.netty.ProtocolNegotiators$AbstractBufferingHandler.close(ProtocolNegotiators.java:261)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeCloseNow(ChannelHandlerInvokerUtil.java:133)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeClose(DefaultChannelHandlerInvoker.java:276)
    at io.netty.channel.AbstractChannelHandlerContext.close(AbstractChannelHandlerContext.java:238)
    at io.netty.channel.AbstractChannelHandlerContext.close(AbstractChannelHandlerContext.java:197)
    at io.netty.channel.DefaultChannelPipeline.close(DefaultChannelPipeline.java:987)
    at io.netty.channel.AbstractChannel.close(AbstractChannel.java:200)
    at io.netty.channel.ChannelFutureListener$2.operationComplete(ChannelFutureListener.java:56)
    at io.netty.channel.ChannelFutureListener$2.operationComplete(ChannelFutureListener.java:52)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:603)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:563)
    at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:424)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:276)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:292)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:527)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

Exception in thread "main" io.grpc.StatusRuntimeException: UNKNOWN
    at io.grpc.Status.asRuntimeException(Status.java:428)
    at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:105)
    at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:115)
    at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:257)
    at io.grpc.testing.integration.AbstractTransportTest.emptyUnary(AbstractTransportTest.java:148)
    at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:203)
    at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:192)
    at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:79)
Caused by: io.netty.channel.ChannelException: Pending write on removal of SslHandler
    at io.netty.handler.ssl.SslHandler.handlerRemoved0(SslHandler.java:411)
    at io.netty.handler.codec.ByteToMessageDecoder.handlerRemoved(ByteToMessageDecoder.java:209)
    at io.netty.channel.DefaultChannelPipeline.callHandlerRemoved0(DefaultChannelPipeline.java:627)
    at io.netty.channel.DefaultChannelPipeline.callHandlerRemoved(DefaultChannelPipeline.java:621)
    at io.netty.channel.DefaultChannelPipeline.remove0(DefaultChannelPipeline.java:450)
    at io.netty.channel.DefaultChannelPipeline.destroyDown(DefaultChannelPipeline.java:898)
    at io.netty.channel.DefaultChannelPipeline.destroyUp(DefaultChannelPipeline.java:867)
    at io.netty.channel.DefaultChannelPipeline.destroy(DefaultChannelPipeline.java:859)
    at io.netty.channel.DefaultChannelPipeline.fireChannelUnregistered(DefaultChannelPipeline.java:843)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:696)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/603
Remove Method and switch its users to MethodDescriptor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/604
Upgrade to protobuf-gradle-plugin 0.5.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/605
BufferingHttp2ConnectionEncoder does not shutdown properly on channelInactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler
There is a nasty race condition during the handling of channelInactive in NettyClientHandler which goes a bit like this....

NettyClientHandler.channelInactive -> for each active stream report closure to GRPC
NettyClientHandler.channelInactive -> Http2ConnectionHandler.channelInactive -> Http2ConnectionHandler.BaseDecoder.channelInactive -> for each active stream call close -> BufferingHttp2ConnectionEncoder.Http2ConnectionAdapter.onStreamClose -> try creating new stream -> adds stream to active list (OOPS! this stream is never closed)

This reproduces for NettyClientTransportTest.bufferedStreamsShouldBeClosedWhenTransportTerminates with 5.0beta5.
Having streams being created as a side-effect of channel inactivation is undesirable. Potential fixes include

Reorder teardown in Http2ConnectionHandler.BaseDecoder.channelInactive so encoders are closed() before streams are closed.
Make BufferedHttp2ConnectionEncoder check channel.isActive() when trying to create streams.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/606
Improve docs to describe close as being last method called
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/607
Metadata.Key's name is non-null; don't check for null
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/608
Make sure error status codes are consistent with other implementations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/609
Implement proper reconnection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implies exponential backoff, etc.
https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/610
Fixing some compiler warnings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 should be an easy one :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/611
Try to simplify server method definition
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/612
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/613
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/614
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/615
May need to tweak ordering of complete() and close()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We shouldn't be getting the "successful complete() without close()" exception. It seems it is caused by another exception and us not cleaning up the stream well.
It isn't the point of this issue to fix the "flow control window exceeded" exception. That is being investigated elsewhere.
Jul 09, 2015 4:11:07 PM io.grpc.transport.netty.NettyServerHandler onStreamError
WARNING: Stream Error
io.netty.handler.codec.http2.Http2Exception$StreamException: Flow control window exceeded for stream: 1
    at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:100)
    at io.netty.handler.codec.http2.DefaultHttp2LocalFlowController$DefaultState.receiveFlowControlledFrame(DefaultHttp2LocalFlowController.java:365)
    at io.netty.handler.codec.http2.DefaultHttp2LocalFlowController.receiveFlowControlledFrame(DefaultHttp2LocalFlowController.java:239)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:223)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:46)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:392)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:223)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:130)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:100)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:293)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:336)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
    at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1069)
    at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:939)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:127)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

Jul 09, 2015 4:11:07 PM io.netty.util.concurrent.DefaultPromise notifyListener0
WARNING: An exception was thrown by io.grpc.transport.netty.NettyServerHandler$2.operationComplete()
java.lang.IllegalStateException: successful complete() without close()
    at io.grpc.transport.AbstractServerStream.complete(AbstractServerStream.java:198)
    at io.grpc.transport.netty.NettyServerHandler$2.operationComplete(NettyServerHandler.java:262)
    at io.grpc.transport.netty.NettyServerHandler$2.operationComplete(NettyServerHandler.java:259)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:603)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:563)
    at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:406)
    at io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator.trySuccess(Http2CodecUtil.java:288)
    at io.netty.handler.codec.http2.Http2CodecUtil$SimpleChannelPromiseAggregator.trySuccess(Http2CodecUtil.java:192)
    at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82)
    at io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:644)
    at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:260)
    at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:339)
    at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:318)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:799)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:311)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:766)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1234)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355)
    at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:272)
    at io.netty.handler.ssl.SslHandler.flush(SslHandler.java:478)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355)
    at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:272)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:392)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355)
    at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:272)
    at io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:997)
    at io.netty.channel.AbstractChannel.flush(AbstractChannel.java:210)
    at io.grpc.transport.netty.WriteQueue.flush(WriteQueue.java:131)
    at io.grpc.transport.netty.WriteQueue.access$000(WriteQueue.java:48)
    at io.grpc.transport.netty.WriteQueue$1.run(WriteQueue.java:58)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:322)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/616
During shutdown, Netty should gracefully wait for RPCs to complete before terminating the connection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently it is just calling "channel.close();" which brings down the TCP connection and cleans up all the RPCs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/617
Recommended IntelliJ code style settings are out of date
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I downloaded and imported the GoogleStyle code style settings xml, as recommended in Contributing.md. It doesn't seem like this project and its checkstyle are actually conforming to those style settings (which is fine, I like the prevailing gRPC style better!) A few things in particular keep coming up:

Import order: GoogleStyle has static imports at the bottom, doesn't separate grpc imports. This is configured in Code Style > Java > Imports > Import Layout.
Method argument wrapping: GoogleStyle has method call arguments and declaration parameters on the next line aligned to the opening paren. This is configured in Code Style > Java > Wrapping and Braces > Method declaration parameters > Align when multiline, as well as the same option under Method call arguments.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/618
Support TLS for okhttp benchmark.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/619
Add simple server timeout 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/620
OkHttp should use SSLSocketFactory.getDefault() by default
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should default to using TLS. Right now setting sslSocketFactory enables TLS. We should have a separate option for enabling/disabling TLS. It could easily be a boolean, but we might choose a enum to expand it later; either way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/621
Separate ServerCall binding utilities per method type.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/622
AbstractStream should enforce calling thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In AbstractStream, there are several javadoc comments that read:
"This must be called from the transport thread, since a listener may be called back directly."
While this is informative, it would be even better if it was enforced.  It would be a good idea to call Thread.currentThread().getId(), or some similar check to make sure that the transport thread is actually the one making the call.  In cases where holding a lock is tantamount to being threadsafe, checking Thread.holdsLock() would also be possible.  Ideally these cases could be wrapped up in some sort of assertTransportThread() method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/623
okhttp: make transport.start() async.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/624
Reduce flow control window for interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/625
Add basic unit tests to Abstract Stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/626
OkHttpClientTransport.newCall should be async
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our API is async, and so doing blocking for MAX_CONCURRENT_STREAMS is breaking that. We should go fully async.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/627
Redundant/different default window size used in okhttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
DEFAULT_INITIAL_WINDOW_SIZE and DEFAULT_WINDOW_SIZE
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/628
Remove OkHttpClientTransport.DEFAULT_INITIAL_WINDOW_SIZE, use Utils.DEFAULT_WINDOW_SIZE instead.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The two aren't identical in value or usage; one is used for sending, one for receiving. However, it does seem that the distinction is not very clear; removing DEFAULT_INITIAL_WINDOW_SIZE makes sense.
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/629
okhttp: Enable TLS by default.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The negotiation types are really transport-specific. It seems they should really be left as separate. I don't want a enum that is the union of each negotiation type of each transport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/630
Minor Readability changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
R= @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/631
Migrate from PARSER to parser() as a way of getting the parser of a protobuf message.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/632
Sanitize ClientCalls.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/633
Minor readability changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't think we should add final everywhere unless it adds some value for that particular instance. In these cases, I think it is useless effort because these APIs are internal and we are free to add final later without real issue. Similarly, making package-private classes final seems to have limited benefit. Going through this process with classes in io.grpc package would make more sense, but not for io.grpc.transport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/634
Use shared scheduler for ServerImpl deadline support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#576 was merged slightly before #619, so we are able to use a single thread for deadlines on server-side and client-side. That isn't super-important, since we don't expect more than one server generally, but could is still maybe a nice-to-have. At the very least, the TODO could be removed if we decided not to bother.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/635
Consider renaming DUPLEX_STREAMING to BIDI_STREAMING
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I thought a while back it was decided to use "bidi" or "bidirectional" streaming to describe a call that has both server and client streaming. I appers C, C++, Node.js, Ruby, and PHP use "bidi." It appears C# uses "duplex." It appears Go did not define the concept. I couldn't find what Obj-C and Python use.
We would need to change it in ClientCalls, ServerCalls, and MethodDescriptor.MethodType.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/636
Catch exceptions thrown by Executor.execute
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
direct executor lets RuntimeExceptions pass through the call stack. We need to defend against that in places we would permit direct executor. Even without direct executor, execute can throw with rejected exception, so it is really a case we should handle.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/637
Rename "payload" to "message"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Call has onPayload and sendPayload. Such things should use "message" instead; little sense in having different names for the entity.
We should try to maintain backward compatibility for a bit for this. We can simply make the new "message" versions of the methods and have the new versions call the old versions. When we remove the old version we make the methods abstract on Call.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/638
Get rid of AbstractServiceDescriptor as it is no longer useful
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/639
ServerCall.onCancel should not be called for server-initiated close(CANCELLED)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For reasons possibly lost to history, we decided to notify the server's onCompleted after the server completed with non-OK status codes, except for CANCELLED which notifies onCancel.
For whatever reason CANCELLED triggers onCancel, DEADLINE_EXCEEDED probably should as well. However, it might be good to re-discover the reason for the behavior, and maybe only call onCanel if there was an error.
I don't believe we are following the documentation today. It seems AbstractStream only triggers onCancel when an error occurs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/640
In-process transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86, I think this looks pretty good. I started going through reviewing each commit, but maybe that's premature? I'm a little concerned about having to register them by name into a static set. Code that wants to start multiple servers in the same JVM would have to generate unique names.
Do we need the client and server to be so de-coupled? From my perspective, I'd prefer ditch the static registry and require callers to supply an InProcessServer when building the client, to make the link explicit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/641
Are GRPC support server sends messages to the client drivingï¼Ÿ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello everyone,sometimes I want to send something from server to client directly,not response by client call request,whether GRPC supports such operations currentlyï¼Ÿ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/642
Improve Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Change looks easy to understand. Nice work.

Forgive me if already discussed, but what's your opinion on just using
LinkedHashMap vs conditionally TreeMap for consistent ordering for tests?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/643
Replace DeferredInputStream with interface Drainable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/644
Minimize context switches between app & net threads when requesting more messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/645
Cannot find symbol makeImmutable() and isMutable() at compile time
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I tried to compile my proto with Maven using the configuration reported in the how-to:
      <configuration>
        <protocArtifact>com.google.protobuf:protoc:3.0.0-alpha-3.1:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:0.7.1:exe:${os.detected.classifier}</pluginArtifact>
      </configuration>

However I managed to get it work only changing to alpha-2
<protocArtifact>com.google.protobuf:protoc:3.0.0-alpha-2:exe:${os.detected.classifier}</protocArtifact>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/646
Fix flaky OkHttp test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We're seeing an OkHttp test fail randomly, with the output below.
io.grpc.transport.okhttp.OkHttpClientTransportTest > outboundFlowControl FAILED
    Argument(s) are different! Wanted:
    frameWriter.data(
        false,
        3,
        <any>,
        32773
    );
    -> at io.grpc.transport.okhttp.OkHttpClientTransportTest.outboundFlowControl(OkHttpClientTransportTest.java:462)
    Actual invocation has different arguments:
    frameWriter.data(
        false,
        3,
        Buffer[size=16384 md5=c975385526568787c9110176db80e1ca],
        16384
    );
    -> at io.grpc.transport.okhttp.AsyncFrameWriter$9.doRun(AsyncFrameWriter.java:160)
        at sun.reflect.GeneratedConstructorAccessor3.newInstance(Unknown Source)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
        at io.grpc.transport.okhttp.OkHttpClientTransportTest.outboundFlowControl(OkHttpClientTransportTest.java:462)

    java.lang.AssertionError: expected:<0> but was:<1>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:118)
        at org.junit.Assert.assertEquals(Assert.java:555)
        at org.junit.Assert.assertEquals(Assert.java:542)
        at io.grpc.transport.okhttp.OkHttpClientTransportTest.tearDown(OkHttpClientTransportTest.java:170)ï¿½
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/647
implement health checking service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
defined in "gRPC Health Checking Protocol"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/648
Split ClientCall into its own class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo +1 to breaking out the call impl ... might be easier to review if you created a separate PR to just move the code.  After it's committed, you could then rebase this PR on it so it's easier to see the diff.  WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/649
Replace Metadata.Trailers and Metadata.Headers with just Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Headers, path can be removed (just use a different MethodDescriptor; if we really need it it the future, it can be added to CallOptions) and authority can move to CallOptions. At that point, there isn't a distinction between headers and trailers and we can just have "Metadata".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/650
Implement oauth2_auth_token
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't know if any API additions need to be done to make this use case easy.
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#oauth2_auth_token
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/651
 Server reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/652
Specify locale for toLowerCase in Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/653
Q: How to declare rpc method without input and returns messages?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is it possible to define rpc method without input and returns messages?
something like:
    service myservice {
        rpc heartbeat() {}
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/654
Fix protobuf plugin usage in README.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Excellent. @zhangkun83, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/655
Benchmark: Enable/Disable TLS for okhttp accordingly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/656
Reverse interceptor execution order
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/657
Add ClientInterceptors "inside" ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/658
Allow using in-process transport without the registry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice to avoid the registry when you are able to pass objects around. That prevents the need to have to determine a unique name. The most obvious case is in tests, but it is actually just generally useful.
#640 had some discussion about options for doing it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/659
Add Executor wrapping to Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As can be seen in the commit message, I renamed "wrap(Executor)" to wrapDynamic. @louiscryan has suggested "wrapPropagating", which isn't unreasonable. Neither of us cared too much, but I thought that even wrapFixed "propagated" the context. Any other names or +1s for names is appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/660
Use mutation methods for stub reconfiguration.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/661
Change AbstractTransportTest to propagate server delay in request
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Commit 3e26b99#diff-cf14d5396f1bd6ab4bcf9c37e7756356R143 introduced the use of an AtomicLong to manage server delay and also created a server delay interceptor.  Neither of these are needed since the integration test request messages support propagating server delay.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/662
Minor readability changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/663
Error handling fix and minor improvements
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/664
Java warnings in Context API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In lookup method: found raw type: io.grpc.Context.Key
missing type arguments for generic class io.grpc.Context.Key
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/665
Add reconnection logic
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/666
Add missing generics to Context internals
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/667
Simplify locking model of OkHttp Transport, avoid potential deadlock.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/668
Invert User-Agent order so application-provided string comes first
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RFC 7231Â§5.5.3 says:

By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software.

Combined with the example, it seems that we should put the application-provided string first.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/669
Send an RST_STREAM frame on server deadline
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is the "Details" link for Visual Studio CI working for you? It sends me to localhost:8080.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/670
Remove ServerDelayInterceptor from AbstractTransportTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@johnbcoughlin Thanks for the patch!
Cherry-picked as 1ac64bd
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/671
Correctly handle unknown http2 error code.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
And do you think we should sync the map with okhttp ErrorCode
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/672
Alternate Channel Reconnect implementation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/673
Stop using intrinsic lock in ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, LGTM. Please improve the commit message.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/674
Stop using intrinsic locking in ChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. Please improve commit message.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/675
OkHttp: sync error map with gRpc spec.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/676
Adjust @GuardedBy to pass internal GuardedBy Checking.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
And maybe we should start using error prone?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/677
Add a status to Transport shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/678
Adding support for NPN fallback.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/679
Fix flaky test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cherry-picked as a36f4af
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/680
Breaking out ClientCallFactory abstract class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan @ejona86 @wrwg @zhangkun83 PTAL.  I suspect that this may be a bit controversial, but I'd like to get the discussion started.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/681
Attaching Metadata to error Status responses...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm not sure what the "best practice" is for returning application-level error information (would be very useful to understand Google's own internal practice for guidance), but certainly one approach is to attach trailing headers with application error information to error responses. Setting additional headers via thread-local using a server interceptor seems easy enough, but for client-side it seems particularly awkward capturing metadata on a per-call basis using an interceptor. I see examples in MetadataUtils for capturing "last set headers" on a stub or channel but this is only useful for testing and cannot capture on a per-call basis. Other option would be to use the async stub and a thread-local to pass the metadata information along to StreamObserver.onError() but this loses the convenience of using the blocking and future stubs. I'm not sure if the same approach works for a blocking or future stub since the listener may be invoked in a different thread.
Will the context api once fully integrated make this easy, or would it make sense to have a way to "attach" metadata to a Status object (perhaps this would be desirable anyway for convenience)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/682
Make new stream call asynchronous when the MAX_CONCURRENT_STREAMS is reached.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/683
Add a transport ready for use with retry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/684
Rename onPayload to onMessage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/685
Forcibly cast in interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/686
Rename sendPayload to sendMessage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/687
Fix UNKNOWN status without description
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-java/core/src/main/java/io/grpc/ChannelImpl.java
    
    
         Line 311
      in
      d2b1b37
    
  
  
    

        
          
           transportShutdown(Status.UNKNOWN); 
        
    
  



  
    
      grpc-java/netty/src/main/java/io/grpc/transport/netty/NettyClientHandler.java
    
    
         Line 212
      in
      3e26b99
    
  
  
    

        
          
           stream.transportReportStatus(Status.UNKNOWN, false, new Metadata.Trailers()); 
        
    
  


We should basically always provide a description, so that users have a hope of distinguishing whether an error is local or remote. The NettyClientHandler should be converting the HTTP/2 error code to a status.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/688
Make ServerImpl Use the common Scheduled Executor Service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/689
Switch ALPN/NPN to advertise only h2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/690
Remove all support for Payload
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/691
Upgrade protobuf-gradle-plugin to 0.6.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/692
Make any lib-generated UNKNOWN have description
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/693
android-interop-testing fails to build due to lint failures
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The installDebug task works, but the build task does not. It seems like some of the warnings could be ignored (like literal strings), but some other ones need to be properly dealt with ("NewApi: Calling new methods on older versions").
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/694
Double-closure of call during interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I find it in the stderr of the test report of Netty, Netty local channel, and OkHttp. I see it printed out to my console once, so I think that may be from the InProcess test.
This exception very likely means we have a bug and are double-closing.
java.lang.IllegalStateException: call already closed
    at com.google.common.base.Preconditions.checkState(Preconditions.java:173)
    at io.grpc.ServerImpl$ServerCallImpl.close(ServerImpl.java:507)
    at io.grpc.ForwardingServerCall.close(ForwardingServerCall.java:65)
    at io.grpc.testing.TestUtils$1$1.close(TestUtils.java:109)
    at io.grpc.stub.ServerCalls$ResponseObserver.onError(ServerCalls.java:237)
    at io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher.dispatchChunk(TestServiceImpl.java:277)
    at io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher.access$000(TestServiceImpl.java:207)
    at io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher$1.run(TestServiceImpl.java:219)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/695
Notify transportReady() in Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/696
In-process transport deadlock during shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Simultaneously shutting down both server and client sharing the same in-process transport can lead to a deadlock. During server shutdown, the transport lock is held while calling transportShutdown on the channel listener, which attempts to lock the channel. At the same time, channel.shutdownNow() holds the channel lock while also trying to lock the transport which leads to a deadlock:
Found one Java-level deadlock:
=============================
"AccountServer STOPPING":
  waiting to lock monitor 0x00007f88221d72a8 (object 0x000000076eb28a20, a io.grpc.ChannelImpl),
  which is held by "main"
"main":
  waiting to lock monitor 0x00007f8824015488 (object 0x000000076c2afb38, a io.grpc.transport.inprocess.InProcessTransport),
  which is held by "AccountServer STOPPING"

Java stack information for the threads listed above:
===================================================
"AccountServer STOPPING":
    at io.grpc.ChannelImpl$TransportListener.transportShutdown(ChannelImpl.java:281)
    - waiting to lock <0x000000076eb28a20> (a io.grpc.ChannelImpl)
    at io.grpc.transport.inprocess.InProcessTransport.notifyShutdown(InProcessTransport.java:151)
    - locked <0x000000076c2afb38> (a io.grpc.transport.inprocess.InProcessTransport)
    at io.grpc.transport.inprocess.InProcessTransport.shutdown(InProcessTransport.java:140)
    - locked <0x000000076c2afb38> (a io.grpc.transport.inprocess.InProcessTransport)
    at io.grpc.ServerImpl$ServerListenerImpl.serverShutdown(ServerImpl.java:240)
    - locked <0x000000076bfe81a8> (a io.grpc.ServerImpl)
    at io.grpc.transport.inprocess.InProcessServer.shutdown(InProcessServer.java:77)
    - locked <0x000000076be7fdc0> (a io.grpc.transport.inprocess.InProcessServer)
    at io.grpc.ServerImpl.shutdown(ServerImpl.java:135)
    - locked <0x000000076bfe81a8> (a io.grpc.ServerImpl)
    at com.pexlabs.grpc.AbstractGrpcServer.shutDown(AbstractGrpcServer.java:42)
    at com.google.common.util.concurrent.AbstractIdleService$2$2.run(AbstractIdleService.java:69)
    at com.google.common.util.concurrent.Callables$3.run(Callables.java:95)
    at java.lang.Thread.run(Thread.java:745)
"main":
    at io.grpc.transport.inprocess.InProcessTransport.shutdown(InProcessTransport.java:136)
    - waiting to lock <0x000000076c2afb38> (a io.grpc.transport.inprocess.InProcessTransport)
    at io.grpc.ChannelImpl.shutdown(ChannelImpl.java:128)
    - locked <0x000000076eb28a20> (a io.grpc.ChannelImpl)
    at io.grpc.ChannelImpl.shutdownNow(ChannelImpl.java:149)
    - locked <0x000000076eb28a20> (a io.grpc.ChannelImpl)
    at com.pexlabs.grpc.AbstractGrpcClient.close(AbstractGrpcClient.java:25)
    at com.pexlabs.test.TestUtil$1.doStop(TestUtil.java:25)
    at com.google.common.util.concurrent.AbstractService.stopAsync(AbstractService.java:204)
    at com.google.common.util.concurrent.ServiceManager.stopAsync(ServiceManager.java:327)
    at com.pexlabs.test.TestContext.after(TestContext.java:75)
    at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:50)
    at org.junit.rules.RunRules.evaluate(RunRules.java:20)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)

Found 1 deadlock.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/697
netty: Vastly improve connection error handling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/698
Don't hold channel/server lock when shutting down transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/699
Fix shutting down a never-started ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/700
Pass URI to Credentials.getRequestMetadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ServiceAccountJwtAccessCredentials needs the URI, or requires the user to specify it ahead of time. Specifying it ahead of time is a pain and hard to know which strings are needed.
We will need to add a way to get the scheme and authority from ClientCall or Channel.
@anthmgoogle, FYI. @louiscryan and I agreed on this and have a gRPC-integration solution in mind. That means we will soon always be specifying the URI and passing the defaultAudience would no longer be necessary for our usage.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/701
Android-Interop-test: fix lint errors/warnings, enable proguard.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/702
compute_engine_creds and service_account_creds failing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
They were added in 926a2c1 and ac4952c, but since 131ba5d the tests look like they have been failing.
@madongfly, do you want to fix it?
$ /var/local/git/grpc-java/run-test-client.sh --use_tls=true --server_port=443 --server_host=grpc-test.sandbox.google.com --server_host_override=grpc-test.sandbox.google.com --default_service_account=<snip> --oauth_scope=https://www.googleapis.com/auth/xapi.zoo --test_case=compute_engine_creds
...
Running test compute_engine_creds
Exception in thread "main" java.lang.NullPointerException
    at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:210)
    at io.grpc.auth.ClientAuthInterceptor.<init>(ClientAuthInterceptor.java:67)
    at io.grpc.testing.integration.AbstractTransportTest.computeEngineCreds(AbstractTransportTest.java:748)Shutting down

    at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:219)
    at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:192)
    at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:79)

$ /var/local/git/grpc-java/run-test-client.sh --use_tls=true --server_port=443 --server_host=grpc-test.sandbox.google.com --server_host_override=grpc-test.sandbox.google.com --service_account_key_file=<snip> --oauth_scope=https://www.googleapis.com/auth/xapi.zoo --test_case=service_account_creds
...
Running test service_account_creds
Exception in thread "main" java.lang.NullPointerException
    at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:210)
    at io.grpc.auth.ClientAuthInterceptor.<init>(ClientAuthInterceptor.java:67)
    at io.grpc.testing.integration.AbstractTransportTest.serviceAccountCreds(AbstractTransportTest.java:716)
    at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:223)Shutting down

    at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:192)
    at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:79)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/703
Fix serviceAccountCreds test and computeEngineCreds test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That does mean that we don't shutdown the executor in all cases, but I'm content to let the GC do that in a test.
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/704
Implement per_rpc_creds
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#per_rpc_creds
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/705
Implement timeout_on_sleeping_server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#timeout_on_sleeping_server
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/706
Implement unimplemented_method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md#unimplemented_method
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/707
Make the change on status effective.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM. Note that the colon should have been on the next line ("the break comes before the symbol").
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/708
OkHttp should use plaintext in TransportBenchmark
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/709
Backport ef106e0 and 248f575 to 0.7.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/710
Switch ALPN/NPN to advertise only h2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/711
Renamed Server payload to message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, thanks for noticing. LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/712
Rename Duplex to Bidi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/713
ServerEssentials needs more Javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/714
Core gRPC package needs documention
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The default javadoc generated is missing package level documentation
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/715
AbstractChannelBuilder should be renamed AbstractChannelImplBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is to match ChannelImpl.  If ChannelImpl gets renamed in #680, it should be updated accordingly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/716
Create a grpc.internal package 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some classes that should not be part of the public API should be moved to an internal package.  Additionally, grpc.transport should also be moved to grpc.internal.transport
This shouldn't be api breaking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/717
Change the javadoc in MutableHandlerRegistry to not say Impl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is already a MutableHandlerRegistryImpl, the javadoc on MutableHandlerRegistry is somewhat confusing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/718
Remove All Deprecated Classes before Beta
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are a number of classes in core that are Deprecated.  Since it will likely be impossible to remove them later without breakage, they should be removed now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/719
Spell SNAPSHOT correctly, for full effect
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/720
Add package descriptions for transport, netty and okhttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/721
Add available() to KnownLength
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/722
Marshaller should use "deserializing" rather than parsing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Javadoc verbiage in the Marshaller should use appropriate negative and positive words.
Questions raised:
Are parse() and stream() inverses of each other?  (group says yes)
Are serialize and stream inverses of each other?
Should Marshaller use marshal() and unmarshal()?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/723
Add javadoc to Context.CancellationListener
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/724
NanoProtoInputStream should be package private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/725
Enforce character restriction for AsciiMarshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
AsciiMarshaller is used for HTTP2 Headers.  Since HTTP2 is more restrictive about what ascii characters can be used, AM should either be more clear about what characters are accepted, or enforce such restrictions.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/726
ServerCall Handler should take a method descriptor rathe than a string
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/727
Move Authority from Headers to ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This was a maybe thing to do, but creating an issue for it anyways.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/728
Review the generics on ServerCallHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Maybe add a super and extends.   The context for this issue was how would a proxy be implemented.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/729
ServerInterceptor.interceptCall should take a method descriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently it takes the name of the method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/730
SharedResourceHolder should be moved to the internal package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/731
Add "set" and "add" method prefixes to AbstractChannelBuilder (e.g. addInterceptor)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our API is currently not consistent between how builders are implemented.  Considering the pervasiveness of the set, get, add, with, and other prefixed methods of Proto and the existing stubby implementations, consistency should be swing towards these style methods.
Also, AbstractServerBuilder should be changed likewise
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/732
AbstractChannelBuilder.buildEssentials should have a javadoc 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/733
Delete ChannelEssentials
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since ChannelEssentials only affects transports, it should likely be deleted.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/734
Deprecated Channel.newCall should be deleted 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Clients should use the non deprecated sibling newCall.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/735
ChannelImpl.awaitTerminated should be renamed awaitTermination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This makes it make the spelling of ExecutorService shutdown methods.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/736
ChannelImpl.TIMEOUT_KEY should be private 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Possibly moved to the internal package.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/737
Remove ChannelImpl.ping (or possible mark it experimental)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It isn't clear that ping will be part of the long term gRPC interface (and is easy to add back in later if needed).  Either remove it or mark it experimental.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/738
Deprecated inner classes of ClientInterceptor should be removed 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/739
CheckedForwardingClientCall should cancel delegate on failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should also document whether it cancels or not, even if we end up not cancelling the delegate.
@ejona86 do you remember if there were reasons to not do this?  If so, are they stronger than the reason that cancelling should still be done?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/740
Add @Experimental to Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Or add some other way to denote that Context is still being tried out, and may change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/741
Consider shortening generic names (BuilderT, RequestT, MethodDescriptor<>, ServerCall<>, ServerCall.Listener, ServerMethodDefinition etc.)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are a lot of places where the generic parameters are kind of long, and could be made more concise without surrendering readability.   The classes listed in the title are some but not all of classes that could benefit from this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/742
Metadata.Key.asciiName should be private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Because the returned value is mutable, it should be limited to being modified by our own code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/743
Remove second MethodDescriptor.create method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
currently there are two methods, one that takes the fully qualified name and one that takes the service and method name.  Since the rest of core is using the fully qualified name, the second create method doesn't need to be part of our API.  (and can be easily added back if there is demand).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/744
SerializingExecutor should be moved to be internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/745
Maybe remove Server and rename ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It may be worth keeping Server as a base to ServerImpl (in order to add methods later on like getServerAddress)
This was a contentious issue, but needs to be resolved before going beta.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/746
ServerImpl.awaitTerminated should be renamed awaitTermination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the same as the change in #735
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/747
Make ServerCall.Listener methods no ops
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some Listeners may not care about implementing every method.  Thus, ServerCall.Listener methods should provide No-op default methods.  This has the downside that users of this class may not override correctly, or miss understanding how to listen.  However, since this is an advanced api, it may be reasonable to ask clients to understand how this class works.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/748
Make ClientCall.Listener methods no ops
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Same issues raised in #747
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/749
Make ServerServiceDefinition.getMethod private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This method was only intended for internal use.  ServerServiceDefinition.getMethods should be used instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/750
Remove  Status.OperationRuntimeException and Status.OperationException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These are deprecated in favor of StatusException and StatusRuntimeException
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/751
Add javadoc to clarify equality on Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Are Statuses equal based on code, code and message, or even as far as the throwable?  The javadoc for equals should clarify this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/752
Fix javadoc on Status.asException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I believe you asked for this, but I am now fuzzy on the details of why. Assigning to you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/753
Make NanoProtoInputStream package private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/754
Fix javadoc, and remove deprecated OperationException classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/755
Remove Status.OperationRuntimeException and Status.OperationException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Doh! You and @carl-mastrangelo raced for #754. If you make sure to assign the issue to yourself, that can prevent duplicated effort.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/756
Change awaitTerminated to awaitTermination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/757
Remove deprecated ClientInterceptors classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/758
Tighten up some access limit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/759
okhttp: using pending stream to queue writings before the connection is connected.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently we use the serializing executor to implicitly queue writings before the connection is connected.
As we've added an obvious queue inside pending stream, using it to queue writings during connecting makes more sense.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/760
okhttp: pending stream should be cancellable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current implementation will throw a NPE
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/761
OkHttp: make the pending stream cancellable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/762
Reorganize packages.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, this LGTM. I mainly question whether @nmittler would have anything to contribute to the names before we do them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/763
Make serverInterceptor use MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/764
Improve generics in {Client,Server}Interceptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/765
Flake: Cannot transition phase from STATUS to MESSAGE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in https://travis-ci.org/grpc/grpc-java/builds/74499477:
io.grpc.testing.integration.Http2NettyLocalChannelTest > deadlineExceeded FAILED
    java.lang.AssertionError: expected:<Status{code=DEADLINE_EXCEEDED, description=null, cause=null}> but was:<Status{code=UNKNOWN, description=null, cause=java.lang.IllegalStateException: Cannot transition phase from STATUS to MESSAGE}>

Not much to go on. This can just track occasions that we see it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/766
Remove Deprecated newCall method on Channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we may want to hold off on this, because we haven't done a release that includes CallOptions yet (I think).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/767
Remove deprecated classes from ServerInterceptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/768
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/769
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/770
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/771
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/772
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/773
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/774
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/775
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/776
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/777
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/778
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/779
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/780
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/781
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/782
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/783
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/784
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/785
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/786
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/787
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/788
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/789
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/790
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/791
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/792
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/793
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/794
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/795
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/796
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/797
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/798
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/799
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/800
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/801
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/802
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/803
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/804
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/805
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/806
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/807
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/808
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/809
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/810
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/811
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/812
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/813
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/814
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/815
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/816
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/817
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/818
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/819
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/820
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/821
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/822
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/823
Annotate ServerEssentials and buildEssentials() with @Internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/824
Prevent using metadata with invalid keys
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should restrict the characters that are permitted in keys, as we have no way to send many characters (like colon, unicode, etc).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/825
Remove unnecessary instanceof check
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... make it so! :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/826
Remove the first MethodDescriptor constructor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/827
Rename parse and stream to marshal and unmarshal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Out of my own experience, the first time I the word "marshal", I didn't know what it meant. The fact that Marshaller uses "parsing and serialization" in its javadoc indicates that the word "marshal" is not as widely understood as "parse", "serialize" and "deserialize". I would imagine the javadocs of marshal() and unmarshal() would also need to refer to "serialize" and "deserialize" for users to comprehend. If that's the case, I would just name them as serialize() and deserialize() instead.
@ejona86 @nmittler @madongfly WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/828
Skip io.grpc.internal in javadoc.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/829
Call ClientTransport.Listener.transportReady() in a more appropriate time.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently we call it after the TCP connection is connected, we should call it after receiving the settings frame, so that we know for sure that the server accepted the connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/830
OkHttp: Call ClientTransport.Listener.transportReady() after receivinâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/831
StatusRuntimeException: INTERNAL: Invalid protobuf byte sequence
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A user of Cloud Bigtable reported a bug on a really large streaming response: googleapis/java-bigtable-hbase#407.  Any advice on how to address the stack trace below?
8, 2015 3:21:15 PM io.grpc.SerializingExecutor$TaskRunner run
GRAVE: Exception while executing runnable io.grpc.ChannelImpl$CallImpl$ClientStreamListenerImpl$2@6965a9c6
io.grpc.StatusRuntimeException: INTERNAL: Invalid protobuf byte sequence
at io.grpc.Status.asRuntimeException(Status.java:428)
at io.grpc.protobuf.ProtoUtils$1.parse(ProtoUtils.java:64)
at io.grpc.protobuf.ProtoUtils$1.parse(ProtoUtils.java:52)
at io.grpc.MethodDescriptor.parseResponse(MethodDescriptor.java:105)
at io.grpc.ChannelImpl$CallImpl$ClientStreamListenerImpl$2.run(ChannelImpl.java:384)
at io.grpc.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Caused by: com.google.bigtable.repackaged.com.google.protobuf.InvalidProtocolBufferException: Protocol message was too large. May be malicious. Use CodedInputStream.setSizeLimit() to increase the size limit.
at com.google.bigtable.repackaged.com.google.protobuf.InvalidProtocolBufferException.sizeLimitExceeded(InvalidProtocolBufferException.java:110)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.tryRefillBuffer(CodedInputStream.java:1131)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.refillBuffer(CodedInputStream.java:1081)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.ensureAvailable(CodedInputStream.java:1068)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.readRawBytesSlowPath(CodedInputStream.java:1203)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.readBytes(CodedInputStream.java:517)
at com.google.bigtable.v1.Column.(Column.java:52)
at com.google.bigtable.v1.Column.(Column.java:13)
at com.google.bigtable.v1.Column$1.parsePartialFrom(Column.java:822)
at com.google.bigtable.v1.Column$1.parsePartialFrom(Column.java:816)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.readMessage(CodedInputStream.java:495)
at com.google.bigtable.v1.Family.(Family.java:61)
at com.google.bigtable.v1.Family.(Family.java:13)
at com.google.bigtable.v1.Family$1.parsePartialFrom(Family.java:923)
at com.google.bigtable.v1.Family$1.parsePartialFrom(Family.java:917)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.readMessage(CodedInputStream.java:495)
at com.google.bigtable.v1.ReadRowsResponse$Chunk.(ReadRowsResponse.java:185)
at com.google.bigtable.v1.ReadRowsResponse$Chunk.(ReadRowsResponse.java:145)
at com.google.bigtable.v1.ReadRowsResponse$Chunk$1.parsePartialFrom(ReadRowsResponse.java:904)
at com.google.bigtable.v1.ReadRowsResponse$Chunk$1.parsePartialFrom(ReadRowsResponse.java:898)
at com.google.bigtable.repackaged.com.google.protobuf.CodedInputStream.readMessage(CodedInputStream.java:495)
at com.google.bigtable.v1.ReadRowsResponse.(ReadRowsResponse.java:60)
at com.google.bigtable.v1.ReadRowsResponse.(ReadRowsResponse.java:13)
at com.google.bigtable.v1.ReadRowsResponse$1.parsePartialFrom(ReadRowsResponse.java:1651)
at com.google.bigtable.v1.ReadRowsResponse$1.parsePartialFrom(ReadRowsResponse.java:1645)
at com.google.bigtable.repackaged.com.google.protobuf.AbstractParser.parsePartialFrom(AbstractParser.java:192)
at com.google.bigtable.repackaged.com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:209)
at com.google.bigtable.repackaged.com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:215)
at com.google.bigtable.repackaged.com.google.protobuf.AbstractParser.parseFrom(AbstractParser.java:49)
at io.grpc.protobuf.ProtoUtils$1.parse(ProtoUtils.java:61)
... 7 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/832
Provide a way to set client side proto size limit.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cloud Bigtable has server size proto message limit of > 64MB. The current size limit on the client size is 64MB (default) in CodedInputStream.java. CodedInputStream.setSizeLimit() can be used to override the default value. Cloud Bigtable would like a way to set the proto message limit on the client side so that users can work with larger data set.
Related reported issue: googleapis/java-bigtable-hbase#407
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/833
Remove deprecated method.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/834
Implement Connection Backoff Interop test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM. Very clean, thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/835
Sync branch android to head.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We found a Contributor License Agreement for you (the sender of this pull request) and all commit authors, but as best as we can tell these commits were authored by someone else.  If that's the case,  please add them to this pull request and have them confirm that they're okay with these commits being contributed to Google.  If we're mistaken and you did author these commits, just reply here to confirm.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/836
Remove proto size restriction when parsing protos.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/837
Removing transport shutdown hooks from channel builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly @ejona86 @zhangkun83 @carl-mastrangelo PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/838
Mark Compression API @Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some pieces of compression are already checked in to master. There is a question if they will be api-stable in time for beta. We need to do something with what is checked in to release. Determining whether that is revert the changes or mark the API as @Experimental is the point of this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/839
Add a "comment" attribute to ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We can attach link to the issue, doc or issue in there.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/840
Netty: Use status INTERNAL instead of UNKNOWN for underlying Http2Exception.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/841
Add some Unit tests to Abstract Client Stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/842
gRPC SSL Examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Please advise on where I can find  java examples on client-server authentication for SSL?
Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/843
Avoid deprecation warning on import
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/844
Update the code example to use our own API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/845
Fix Comment in MutableHandlerRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/846
Implement unimplemented_method test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fix #706
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/847
Fix documentation on ClientCall.request().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/848
Reconnect interop test is broken.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
./interop-testing/build/install/grpc-interop-testing/bin/reconnect-test-client --use_okhttp=true
Starting test:
io.grpc.StatusRuntimeException: UNKNOWN
    at io.grpc.Status.asRuntimeException(Status.java:428)
    at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:154)
    at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:104)
    at io.grpc.testing.integration.ReconnectServiceGrpc$ReconnectServiceBlockingStub.start(ReconnectServiceGrpc.java:127)
    at io.grpc.testing.integration.ReconnectTestClient.runTest(ReconnectTestClient.java:96)
    at io.grpc.testing.integration.ReconnectTestClient.main(ReconnectTestClient.java:123)
Caused by: java.lang.IllegalArgumentException: Unable to find decompressor for message encoding identity
    at com.google.common.base.Preconditions.checkArgument(Preconditions.java:145)
    at io.grpc.internal.AbstractStream.setDecompressor(AbstractStream.java:306)
    at io.grpc.internal.AbstractClientStream.inboundHeadersReceived(AbstractClientStream.java:122)
    at io.grpc.internal.Http2ClientStream.transportHeadersReceived(Http2ClientStream.java:106)
    at io.grpc.netty.NettyClientStream.transportHeadersReceived(NettyClientStream.java:113)
    at io.grpc.netty.NettyClientHandler.onHeadersRead(NettyClientHandler.java:202)
    at io.grpc.netty.NettyClientHandler.access$900(NettyClientHandler.java:78)
    at io.grpc.netty.NettyClientHandler$LazyFrameListener.onHeadersRead(NettyClientHandler.java:528)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:316)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:265)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:54)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader$2.processFragment(DefaultHttp2FrameReader.java:450)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:459)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:226)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:130)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:100)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:293)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:336)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:127)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Test failed!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/849
Travis fails due to un-run codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://travis-ci.org/grpc/grpc-java/builds/76536465
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#   modified:   interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java
#
no changes added to commit (use "git add" and/or "git commit -a")
Error Working directory is not clean. Forget to commit generated files?

The issue seems caused by an incomplete rebase with #826. The modified code-generated file just needs to be committed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/850
Commit ReconnectServiceGrpc.java generated by current codegen.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm how can grpc-protobuf:test be failed by this PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/851
Add SERVICE_NAME constant to service container
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Huh. Oops. Yeah, that is useful :).
@zhangkun83, I'd feel more comfortable if you reviewed this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/852
Netty: Call ClientTransport.Listener.transportReady() after receivingâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/853
Grpc client not invoking gRPC call after establishing SSL handshake (Using ALPN)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
It seems that the SSL handshake is successful when the client try to establish a connection to the server. The log ends with the following at server-side:
io.netty.handler.ssl.SslHandler (SslHandler.java:setHandshakeSuccess(1251)) - [id: 0x7db3896c, /172.27.41.162:23913 => /172.27.44.228:7001] HANDSHAKEN: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
while the client side log ends with:
SETTINGS: ack=false, settings={HEADER_TABLE_SIZE=4096, ENABLE_PUSH=0, MAX_CONCURRENT_STREAMS=0, INITIAL_WINDOW_SIZE=66560, MAX_FRAME_SIZE=16384, MAX_HEADER_LIST_SIZE=2147483647}

However, after some tracing, the RPC methods that were invoked by the client, seemed to be stucked at  getUnchecked(Future future) in io.grpc.stub.Calls at this line where it does return future.get();
The client code to call the server is as follows:
boolean useTls = config.getString("use.ssl").equalsIgnoreCase("true") ? true : false;
InetAddress address = null;
    try {
        address = InetAddress.getByName(serverHost);
    } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    SslContext sslContext = null;
    if (useTls) {
        try {
            sslContext = GrpcSslContexts.forClient().trustManager(loadCert("serverselfsignedcert.pem","C:\\temp\\serverselfsignedcert.pem")).build();
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    channel = NettyChannelBuilder
            .forAddress(new InetSocketAddress(address, serverPort))
            .streamWindowSize(65*1024).connectionWindowSize(65*1024)
            .negotiationType(
                    useTls ? NegotiationType.TLS
                            : NegotiationType.PLAINTEXT)
            .sslContext(sslContext).build();

    blockingStub = PeerImplGrpc.newBlockingStub(channel);

    ByteString byteStrKey = ByteString.copyFrom(HashUtil.encode("abc", serverHost.getBytes()));
    PeerId request = PeerId.newBuilder().setPeerId(byteStrKey).build();
    checkPeerAlive(request, response);
    Response test = blockingStub.checkPeerAlive(request);

I also amended the implementation of TestUtils loadCert method to the following:
public static File loadCert(String name, String path) throws IOException {
    FileInputStream in = new FileInputStream(new File(path));
    File tmpFile = File.createTempFile(name, "");
    tmpFile.deleteOnExit();

    BufferedWriter writer = new BufferedWriter(new FileWriter(tmpFile));
    try {
        int b;
        while ((b = in.read()) != -1) {
            writer.write(b);
        }
    } finally {
        writer.close();
        in.close();
    }

    return tmpFile;
}

Is there something that I might have missed out?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/854
{Channel,Server}.awaitTerminated should wait for application to complete processing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As we discussed, we were going to have awaitTerminated() wait until all application notifications execute. We can achieve that by tracking number of unclosed calls (clientcall or servercall): when creating a new call register it, and after the application listener's close is called de-register it. In awaitTerminated it would wait for the registrations to become empty/zero.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/855
Rename HttpUtil to GrpcUtil.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/856
Moving a few common utilities to GrpcUtil.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
But I see in some of the files the constants are static imported, in other files are referenced as GrpcUtil.XXX, should we keep a consistent style?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/857
MessageDeframer stalled logic needs review
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently there is a bug that results in the MessageDeframer not being stalled when stream is being closed (in error scenarios), resulting in the stream listener not being called immediately.  Specific lines of review include:
return unprocessed.readableBytes() > 0 || (nextFrame != null && nextFrame.readableBytes() > 0);
And a proposed change (WIP):
  stalled = (unprocessed.readableBytes() == 0);

  if (endOfStream) {
    if (!stalled) {
      listener.endOfStream();
    } else if (nextFrame != null || nextFrame.readableBytes() > 0) {//FIXME
      // We've received the entire stream and have data available but we don't have
      // enough to read the next frame ... this is bad.
      throw Status.INTERNAL.withDescription("Encountered end-of-stream mid-frame")
          .asRuntimeException();
    } else if (stalled) {
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/858
Use status UNAVAILABLE for IOException thrown by OkHttp reading path,â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/859
:grpc-protobuf:test fails frequently on Travis.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/860
Reducing the size of the "large" proto in ProtoUtilsTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/861
Adding maxMessageSize config option
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/862
OkHttp: Make sure TransportListener.transportReady() can only be callâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/863
Remove size restriction when parsing nano protos
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/864
Quick work around for Rst bug
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/865
Update Java doc for a508c1d4f5024c2a5fd6d103edcab43542293ae7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/866
Add a Shared Executor Service 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/867
Make ServerImpl constructor pakcage-private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/868
Makes application-provided string comes first in User-Agent.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/869
Minor cleanup in deframer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/870
GrpcSslContext bug for mutual authentication 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
My 1-way SSL authentication is working with the codes below, however, it doesn't seem to work for 2-way. I understand that by declaring the appropriate SslContext, we should be able to enable mutual authentication. I have already invoked the appropriate keyManager/trustManager, any idea why the mutual authentication did not take place?
I followed the steps to set up jetty ALPN at https://github.com/grpc/grpc-java/blob/master/SECURITY.md.

@ Server:
SslContext sslContext = GrpcSslContexts.forServer(new File(pathToOwnCertPemFile), new File(pathToOwnPrivateKeyPemFile)).trustManager(new File(pathToClientCertPemFile)).build();

ServerImpl server = NettyServerBuilder
        .forPort(port)
        .sslContext(sslContext)
        .addService(MyGrpc.bindService(new MyGrpcService()))
        .build().start();

@ Client:
SslContext sslContext = GrpcSslContexts.forClient().trustManager(new File(pathToServerCertPemFile)).keyManager(new File(pathToOwnCertPemFile), new File(pathToOwnPrivateKeyPemFile)).build();

ChannelImpl channel = NettyChannelBuilder.forAddress(host, port)
                .negotiationType(NegotiationType.TLS)
                .sslContext(sslContext).build();

blockingStub = MyGrpc.newBlockingStub(channel);

Upon inspection of the SSL debug logs, I noticed that the CertificateRequest message (as stated in https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake), was never sent to the client to initiate the Client Authentication.
An excerpt of my server log is as follows:

*** ECDH ServerKeyExchange
Signature Algorithm SHA512withRSA
Server key: Sun EC public key, 256 bits
public x coord: 81392923578261760187813715443713168545877454618233337093852615933913992434989
public y coord: 26389586381130695169212775668808794166799180199461581135201001980310825571555
parameters: secp256r1 NIST P-256, X9.62 prime256v1
*** ServerHelloDone
[write] MD5 and SHA1 hashes: len = 1617
0000: 02 00 00 56 03 03 55 DF 34 10 9C 73 B5 00 C2 70 ...V..U.4..s...p
0010: FD B8 CC 36 5B 83 87 70 5B 74 A3 D2 AD B7 75 3B ...6[..p[t....u;

Am I missing out something? Or is it an inherent bug in gRPC?
Appreciate any advice on this problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/871
Determine API stability story for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For Android, we are considering alternative transport implementations, for example, Cronet. That would imply we may not support OkHttp in the future. We need to be able to communicate the API stability of OkHttp's presence.
One possibility is that we have an Android-specific class that is able to choose the "correct" transport to use on Android. We would have to communicate that using OkHttp directly would not be API stable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/872
Enforce content-type on client and server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/873
Jmh Benchmarks don't work
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
$ gradle :grpc-benchmarks:jmh
Trying to run that results in a bunch of errors printed out to the screen.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/874
Design Auth to combine normal credentials with TLS creds
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a want to guarantee that credentials are treated as a whole to guarantee invariants. For example, it is not appropriate to send a JWT over an unencrypted connection.
There may be other constraints that are missing, but it is not fully clear yet. I'll update the issue as more is known.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/875
InProcessTransport doesn't call onReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The in-process transport supports flow control and supports isReady(), but it never calls onReady(). It seems to be just an oversight/bug. Since the in-process transport connects immediately, onReady() should probably be called on the client immediately in newStream().
Locking will be a little interesting since for a single request() both client and server listeners may need to be called (because numMessages can be > 1). It looks like {client,server}Requested() could maybe return a boolean for whether {client,server}Requested > 0 && {client,server}Requested <= numMessages, which would imply onReady() should be called.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/876
Add comment field to ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/877
Add experimental api to compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
Just the PR title is a little confusion, I thought you are adding new APIs before seeing the code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/878
Document equals and hashCode on Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/879
Set Minimum Guava version to 18.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Google internally was stuck using Guava 14.0 for legacy reasons, but it appears that the restriction has been lifted.  We should set the minimum supported guava version to 18 since the older one had bugs and  performance issues.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/880
Change ExperimentalApi field 'comment' to 'value'
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks! LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/881
Fixing the benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/882
Rename onValue to onNext in StreamObserver 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/883
Make ClientCall listener methods noops
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/884
Removing unused method in ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/885
Make ServerCall.Listener methods Nops
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/886
Implement per_rpc_creds test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/887
OkHttp: race between sendCancel and sendFrame.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If sendCancel is called (by timeout for example) before the stream is started, a following sendFrame will cause a NPE:
java.lang.NullPointerException
    at io.grpc.okhttp.OkHttpClientStream.sendFrame(OkHttpClientStream.java:197)
    at io.grpc.internal.AbstractClientStream.internalSendFrame(AbstractClientStream.java:199)
    at io.grpc.internal.AbstractStream$2.deliverFrame(AbstractStream.java:128)
    at io.grpc.internal.MessageFramer.commitToSink(MessageFramer.java:297)
    at io.grpc.internal.MessageFramer.flush(MessageFramer.java:255)
    at io.grpc.internal.AbstractStream.flush(AbstractStream.java:178)
    at io.grpc.ClientCallImpl.sendMessage(ClientCallImpl.java:213)
    at io.grpc.stub.ClientCalls$CallToStreamObserverAdapter.onNext(ClientCalls.java:210)
    at io.grpc.testing.integration.AbstractTransportTest.timeoutOnSleepingServer(AbstractTransportTest.java:843)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:74)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/888
Implement timeout_on_sleeping_server test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #705
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/889
OkHttp: Fix race condition between sendCancel and sendFrame
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/890
Remove the unnecessary code example of using TLS on Anroid
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/891
Move grpc common examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/892
Add unit tests for AbstractServerStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/893
Fix flakiness in test timeoutOnSleepingServer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/894
Add a way to distinguish between advertised message encodings, and add tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo just so I understand ... what does "advertising an encoding" mean? I don't see any mention of it in the wire spec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/895
Mark generated MethodDescriptors @ExperimentalAPI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For Android, we may want to lazy-create MethodDescriptors in order to prevent cascading of static initializations of all dependent protos for all methods. That would mean making accessor methods instead of static fields.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/896
Upgrade to protobuf3-b1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's released. It's on Maven Central. It's required for beta.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/897
Trash HandlerRegistry.Method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We only need the ServerMethodDefinition. ServerServiceDefinition requires a list of all contained methods, which would make it painful for proxies. So lookup should just return the method definition.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/898
Add authority to HandlerRegistry.lookupMethod
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should be possible to do virtual hosting; that requires authority. It would just be an additional string to lookupMethod (presumably as the first parameter).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/899
Move io.grpc.stub.StreamRecorder to testing package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It really is only used in testing. I'm not wild about the class in general, but reducing its usage to tests addresses the primary concerns.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/900
Remove the hack that generates nano package names.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should use a helper function from protobuf, which is more reliable, but not there yet (protocolbuffers/protobuf/issues/778)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/901
Upgrade to protobuf-3.0.0-beta-1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The nano generator from protobuf starts to add .nano to the message package names, while protobuf doesn't provide a helper function to get the proper class name for now. We have to use a hack to add nano for now. Protobuf team will add the helper function in the next release. (Tracking issue #900).
Protobuf also provide an in-file option to go back to the original package name. Because it is carried in the FileOptions which is a proto message, checking this option requires us to generate this C++ class thus would require some change to the build of grpc-compiler. Since protobuf team plans to eliminate this option for good, I don't think it's worth the effort to support it. @ejona86 WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/902
Draft of Android specific Channel builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/903
Annotate method descritpor files in the generated code with ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/904
Add test to prove RST closes stream, and remove hack from transport to force closure.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/905
Fix broken interop test, using new StreamObserver API.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/906
Upgrade to latest netty-tcnative
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/907
Check javanano_use_deprecated_package in the message's FileDescriptor, not the current file's.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/908
Update to protobuf beta for Android interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/909
ClientAuthInterceptor should signal callers on 401s
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If clients are signaled of 401s, they can do clean up by, for example, invalidating Credentials by calling GoogleAuthUtil.clearToken(Context, String);
https://developers.google.com/android/reference/com/google/android/gms/auth/GoogleAuthUtil.html#clearToken(android.content.Context, java.lang.String)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/910
Fields in MethodDescriptor can't be null
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/911
Move StreamRecorder to testing package.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/912
Ease use of JWT by passing URI to auth library
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/913
Build failed with exception "Failed to apply plugin [id 'com.google.protobuf']"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I compile protobuf and grpc "by hand" for my system. protobuf is version 3.0.0-beta-1. protoc is in the PATH, and the lib, include and pkgconfig directories are set in CFLAGS, CPPFLAGS, LDFLAGS, LD_LIBRARY_PATH, and PKG_CONFIG_PATH, respectively. The compile of grpc-java worked with 0.7.1 and 0.7.2, but fails with 0.8.0. Here the grpc-java build log as far as it may help:
mkdir -p /data/emmenlau/thirdparty && \
    cd /data/emmenlau/thirdparty/ && \
    rm -fr grpc-java-0.8.0 && \
    tar -xzf /home/emmenlau/thirdparty/grpc-java-0.8.0.tar.gz && \
    cd grpc-java-0.8.0 && \
    export CFLAGS="-fPIC ${CFLAGS}" && \
    export CPPFLAGS="-fPIC ${CPPFLAGS}" && \
    export PATH="/data/emmenlau/thirdparty/bin:${PATH}" && \
    export CFLAGS="-I/data/emmenlau/thirdparty/include ${CFLAGS}" && \
    export CPPFLAGS="-I/data/emmenlau/thirdparty/include ${CPPFLAGS}" && \
    export LDFLAGS="-L/data/emmenlau/thirdparty/lib ${LDFLAGS}" && \
    export LD_LIBRARY_PATH="/data/emmenlau/thirdparty/lib:${LD_LIBRARY_PATH}" && \
    export PKG_CONFIG_PATH="/data/emmenlau/thirdparty/lib/pkgconfig:${PKG_CONFIG_PATH}" && \
    gradle build -x test

Download https://repo1.maven.org/maven2/org/kt3k/gradle/plugin/coveralls-gradle-plugin/2.0.1/coveralls-gradle-plugin-2.0.1.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.3/httpmime-4.3.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcomponents-client/4.3/httpcomponents-client-4.3.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/project/7/project-7.pom
Download https://repo1.maven.org/maven2/org/codehaus/groovy/modules/http-builder/http-builder/0.7.1/http-builder-0.7.1.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.3/httpclient-4.3.pom
Download https://repo1.maven.org/maven2/net/sf/json-lib/json-lib/2.3/json-lib-2.3.pom
Download https://repo1.maven.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.16/nekohtml-1.9.16.pom
Download https://repo1.maven.org/maven2/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.pom
Download https://repo1.maven.org/maven2/net/sf/ezmorph/ezmorph/1.0.6/ezmorph-1.0.6.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.3/httpcore-4.3.pom
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcomponents-core/4.3/httpcomponents-core-4.3.pom
Download https://repo1.maven.org/maven2/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.pom
Download https://repo1.maven.org/maven2/org/kt3k/gradle/plugin/coveralls-gradle-plugin/2.0.1/coveralls-gradle-plugin-2.0.1.jar
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.3/httpmime-4.3.jar
Download https://repo1.maven.org/maven2/org/codehaus/groovy/modules/http-builder/http-builder/0.7.1/http-builder-0.7.1.jar
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.3/httpclient-4.3.jar
Download https://repo1.maven.org/maven2/net/sf/json-lib/json-lib/2.3/json-lib-2.3-jdk15.jar
Download https://repo1.maven.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.16/nekohtml-1.9.16.jar
Download https://repo1.maven.org/maven2/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar
Download https://repo1.maven.org/maven2/net/sf/ezmorph/ezmorph/1.0.6/ezmorph-1.0.6.jar
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.3/httpcore-4.3.jar
Download https://repo1.maven.org/maven2/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar
Download https://repo1.maven.org/maven2/com/google/protobuf/protobuf-gradle-plugin/0.6.1/protobuf-gradle-plugin-0.6.1.pom
Download https://repo1.maven.org/maven2/com/google/protobuf/protobuf-gradle-plugin/0.6.1/protobuf-gradle-plugin-0.6.1.jar

FAILURE: Build failed with an exception.

* Where:
Build file '/data/emmenlau/TargetInfectX/screeningBee-ubuntu-x86_64-gcc4.9.2-tmp/screeningBee/Tools/BeeStorageProviderAPI/thirdparty/grpc-java-0.8.0/build.gradle' line: 63

* What went wrong:
A problem occurred evaluating project ':grpc-benchmarks'.
> Failed to apply plugin [id 'com.google.protobuf']
   > Could not generate a proxy class for class com.google.protobuf.gradle.ProtobufSourceDirectorySet.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/914
Refactoring channel API.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/915
Adding missing RunWith annotation for tests.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/916
Rename CHECK and FAIL macros to avoid conflict with internal macros when syncing backâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/917
Hit the frame size limit of 100MB. Any way to increase this limit?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2015-09-01 16:14:57 WARN  ResumingStreamingResultScanner:103 - IOExceptionWithStatus:
com.google.cloud.bigtable.grpc.io.IOExceptionWithStatus: Error in response stream
at com.google.cloud.bigtable.grpc.scanner.ResultQueueEntry.getResponseOrThrow(ResultQueueEntry.java:66)
at com.google.cloud.bigtable.grpc.scanner.StreamingBigtableResultScanner$ResponseQueueReader.getNextMergedRow(StreamingBigtableResultScanner.java:75)
at com.google.cloud.bigtable.grpc.scanner.StreamingBigtableResultScanner.next(StreamingBigtableResultScanner.java:136)
at com.google.cloud.bigtable.grpc.scanner.StreamingBigtableResultScanner.next(StreamingBigtableResultScanner.java:1)
at com.google.cloud.bigtable.grpc.scanner.ResumingStreamingResultScanner.next(ResumingStreamingResultScanner.java:90)
at com.google.cloud.bigtable.grpc.scanner.ResumingStreamingResultScanner.next(ResumingStreamingResultScanner.java:1)
at com.google.cloud.bigtable.hbase.ReadFirstRow.getRow(ReadFirstRow.java:60)
at com.google.cloud.bigtable.hbase.ReadFirstRow.main(ReadFirstRow.java:109)
Caused by: io.grpc.StatusRuntimeException: INTERNAL: Exception deframing message
at io.grpc.Status.asRuntimeException(Status.java:428)
at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:264)
at io.grpc.ClientCallImpl$ClientStreamListenerImpl$3.run(ClientCallImpl.java:317)
at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Caused by: io.grpc.StatusRuntimeException: INTERNAL: Frame size 155458981 exceeds maximum: 104857600,
at io.grpc.Status.asRuntimeException(Status.java:428)
at io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:336)
at io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:239)
at io.grpc.internal.MessageDeframer.deframe(MessageDeframer.java:175)
at io.grpc.internal.AbstractStream.deframe(AbstractStream.java:270)
at io.grpc.internal.AbstractClientStream.inboundDataReceived(AbstractClientStream.java:154)
at io.grpc.internal.Http2ClientStream.transportDataReceived(Http2ClientStream.java:134)
at io.grpc.netty.NettyClientStream.transportDataReceived(NettyClientStream.java:119)
at io.grpc.netty.NettyClientHandler.onDataRead(NettyClientHandler.java:219)
at io.grpc.netty.NettyClientHandler.access$800(NettyClientHandler.java:79)
at io.grpc.netty.NettyClientHandler$LazyFrameListener.onDataRead(NettyClientHandler.java:546)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:234)
at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:46)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:392)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:223)
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:130)
at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:100)
at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:293)
at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:336)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1069)
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:944)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:127)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:703)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/918
Display the required Protobuf version when building codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/919
Make shared Executors daemons, and implement shutdownNow()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/920
Upgrade protobuf-gradle-plugin to 0.7.0 in v0.8.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Resolves #913
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/921
Prevent status from impacting how ServerCall.Listener is invoked
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/922
Issues when generating server/client stubs from .proto files. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've generated and ran client and server stubs painlessly for python using
protoc -I . --python_out=. --grpc_out=. --plugin=protoc-gen-grpc=which grpc_python_plugin <protofilename>
I've been trying t generate client stubs for android using
protoc  --java_out=output_folder --plugin=protoc-gen-grpc-java=/home/vagrant/grpc-java-0.8.0/compiler/build/binaries/java_pluginExecutable/protoc-gen-grpc-java  --grpc-java_out=output <protofilename>
Here's my .proto file https://gist.github.com/ybv/95debcb49169e8d8d3d1 After trying to codegen as specified in http://www.grpc.io/docs/tutorials/basic/java.html#generating-client-and-server-code and https://github.com/grpc/grpc-java/tree/master/compiler#compiling-and-testing-the-codegen using the command pasted above, I ended up with these files:
CleanText.java                 LCEProto.java                  TranslatedText.java            TransRequest.java CleanTextOrBuilder.java        LinkContentExtractorGrpc.java  TranslatedTextOrBuilder.java   TransRequestOrBuilder.java
When I try to make a new object (of my request message type) I couldn't set the object properties like this https://github.com/grpc/grpc-java/blob/master/examples/android/app/src/main/java/io/grpc/helloworldexample/HelloworldActivity.java#L64
Also it seems weird that my codegen has created different files for different messages, where as here, https://github.com/grpc/grpc-java/blob/master/examples/android/app/src/main/java/io/grpc/helloworldexample/HelloworldActivity.java#L17-L18 they seem to be classes inside the outer class? What am I missing here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/923
Implement jwt_token_creds interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/924
Require content-type in Headers or Trailers-only
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
By the Spec:

Implementations should expect broken deployments to send non-200 HTTP status codes in responses as well as a variety of non-GRPC content-types and to omit Status & Status-Message. Implementations must synthesize a Status & Status-Message to propagate to the application layer when this occurs.

It appears that unsupported Content Types (such as "text/html; charset=UTF-8") can be returned with error information from some servers, which would be useful to propagate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/925
Create stable builders that use Netty, like is being done for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
"Default" ChannelBuilder is the current proposed name. This would need to be in its own artifact because it would depend on Netty. It's unclear what its artifact and package name should be.
This is necessary because we are marking Netty's builders as @ExperimentalApi; we need a stable API for client and servers to use.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/926
NettyServer prematurely releases worker event loop
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
777e928 causes flaky server shutdown, as the individual transports out-live the server.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/927
ReferenceCounted is useless
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
777e928 introduced reference counting for channel builders, but nothing ever does a retain(), making it useless.
I thought the original reason to propose having reference counting was so that transports would retain() their factory and then ChannelImpl would release() the factory immediately on shutdown(). As the transports shutdown they would each release() and any shared resources would naturally be released.
@nmittler, FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/928
Fix generated code reference for intellij projects.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/929
Document valid characters allowed in metadata keys
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 there is a checkstyle failure, but otherwise LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/930
Remove HandlerRegistry.Method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/931
Document valid characters for AsciiMarshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/932
Supporting OpenSSL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/933
Tracking Issue for Handler Registry being experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We're currently marking all of the HandlerRegistries as ExperimentalAPI. We should decide on the appropriate interface and move toward making them public.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/934
Fix Travis breakage caused by checkStyle failure.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/935
Random Http2NettyTest.deadlineExceeded() failure.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Saw this failure at https://travis-ci.org/grpc/grpc-java/builds/78476097, may wroth taking a look.
io.grpc.testing.integration.Http2NettyTest > deadlineExceeded FAILED
    java.lang.AssertionError: expected:<Status{code=DEADLINE_EXCEEDED, description=null, cause=null}> but was:<Status{code=UNKNOWN, description=null, cause=io.netty.util.IllegalReferenceCountException: refCnt: 0}>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/936
Avoid using Parser in Proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Swap to passing in MessageLite instead of Parser in ProtoUtils. This would allow optimizing startup time to avoid creating the parser (today we would create the parser, but in the future we wouldn't need to).
(less obvious, but may still be a good idea) Rename Parser to MessageNanoFactory (with newInstance() method). Similiar reasoning to above, but would need nano changes to make possible (but there are several options for nano changes that we could use)

1 should be for beta. If we want to do 2, it should be for beta, but if it slips, we'll just deal with it and not do it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/937
Replace use of ExecutorService with Executor in builders
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
We don't depend on ExecutorService so we can downgrade the requirement here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/938
Add a missing channel builder methods not copied in b687bdc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/939
Add an authority header to HandlerRegistry.lookupMethod
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM ... why are we adding it to the api if it's not being used?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/940
Enabling openssl in interop-testing scripts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/941
Update comment in MethodDescriptor.Marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I had a different understanding of the change requested in #722, "Marshaller should use 'deserializing' rather than parsing." I thought that meant instead of:

A typed abstraction over message parsing and serialization.

We would have:

A typed abstraction over message serialization and deserialization.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/942
Daemonize shared threads, and make sure each thread has a name
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. Note that the daemonizing work is not complete. There are OkHttp and Netty threads that also must be marked daemon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/943
Use Executor in stable builder APIs instead of ExecutorService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/944
Daemonize OkHttp and Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/945
Daemonize InProcess threads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. Those threads are expected to be very short lived, but it doesn't hurt.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/946
Support SSL mutual authentication
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reported by @megapowers
Hi all,
I am currently using gRPC 8.0 with ALPN and I am trying to implement a 2-way SSL authentication between a client and server.
However, upon inspection of the SSL debug logs, I noticed that the CertificateRequest message (as stated in https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake), was never sent to the client to initiate the Client Authentication.
An excerpt of my server log is as follows:
...
*** ECDH ServerKeyExchange
Signature Algorithm SHA512withRSA
Server key: Sun EC public key, 256 bits
public x coord: 81392923578261760187813715443713168545877454618233337093852615933913992434989
public y coord: 26389586381130695169212775668808794166799180199461581135201001980310825571555
parameters: secp256r1 NIST P-256, X9.62 prime256v1
*** ServerHelloDone
[write] MD5 and SHA1 hashes: len = 1617
0000: 02 00 00 56 03 03 55 DF 34 10 9C 73 B5 00 C2 70 ...V..U.4..s...p
0010: FD B8 CC 36 5B 83 87 70 5B 74 A3 D2 AD B7 75 3B ...6[..p[t....u;
...

The code I am using at server is as follows:
SslContext sslContext = GrpcSslContexts.forServer(new File(pathToOwnCertPemFile), new File(pathToOwnPrivateKeyPemFile)).trustManager(new File(pathToClientCertPemFile)).build();

ServerImpl server = NettyServerBuilder
.forPort(port)
.sslContext(sslContext)
.addService(MyGrpc.bindService(new MyGrpcService()))
.build().start();
The code I am using at my client is as follows:
SslContext sslContext = GrpcSslContexts.forClient().trustManager(new File(pathToServerCertPemFile)).keyManager(new File(pathToOwnCertPemFile), new File(pathToOwnPrivateKeyPemFile)).build();

ChannelImpl channel = NettyChannelBuilder.forAddress(host, port)
.negotiationType(NegotiationType.TLS)
.sslContext(sslContext).build();

blockingStub = MyGrpc.newBlockingStub(channel);
asyncStub = MyGrpc.newStub(channel);
Am I missing out something? Or is it an inherent bug in gRPC?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/947
Remove Metadata.Headers and Metadata.Trailers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/948
Only release event loops when unused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/949
Revert "Merge pull request #940 from nmittler/interop_openssl"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/950
When tcnative is enabled, OkHttp tests timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It fails like https://travis-ci.org/grpc/grpc-java/builds/78663746 . #949 reverted the change. It is unclear what the issue is.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/951
Update auth library to fix jwt_token_creds interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/952
okhttp: Skip trash data for finished stream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Otherwise the remaining data would pollute the next read.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/953
Port test cases in AbstractTransportTest to android interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/954
Replace Parser in proto utils to instance-based API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/955
Travis OOM
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://travis-ci.org/grpc/grpc-java/builds/78680055
May be due to addition of Android build. It doesn't yet consistently fail, but we can use this for tracking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/956
okhttp: Skip trash data for finished stream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/957
Make android interop test buildable by Travis.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI - Not sure we should commit this just yet. Requiring the android SDK has made building unstable for some folks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/958
Remove uncessary javaee_api dependency as it causes trouble on androiâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/959
Cannot compile Android targets
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When trying to do a gradle build from a clean client, I get the following error:
Creating configuration testReleasePublish.
Creating configuration testReleaseProvided.
Creating configuration testReleaseWearApp.
Build tools null missing. Downloading...
Failed to notify ProjectEvaluationListener.afterEvaluate(), but primary configuration failure takes precedence.
org.gradle.internal.event.ListenerNotificationException: Failed to notify project evaluation listener.
    at org.gradle.internal.event.BroadcastDispatch.dispatch(BroadcastDispatch.java:98)
    at org.gradle.internal.event.BroadcastDispatch.dispatch(BroadcastDispatch.java:31)
    at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
    at com.sun.proxy.$Proxy11.afterEvaluate(Unknown Source)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.notifyAfterEvaluate(LifecycleProjectEvaluator.java:67)
    at org.gradle.configuration.project.LifecycleProjectEvaluator.evaluate(LifecycleProjectEvaluator.java:61)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:488)
    at org.gradle.api.internal.project.AbstractProject.evaluate(AbstractProject.java:86)
...


Cause 1: java.lang.NullPointerException: Cannot invoke method startsWith() on null object
    at org.codehaus.groovy.runtime.NullObject.invokeMethod(NullObject.java:88)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.NullCallSite.call(NullCallSite.java:32)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:54)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
    at com.jakewharton.sdkmanager.internal.PackageResolver.resolveCompileVersion(PackageResolver.groovy:101)
    at com.jakewharton.sdkmanager.internal.PackageResolver.resolve(PackageResolver.groovy:60)
    at com.jakewharton.sdkmanager.internal.PackageResolver$resolve$0.call(Unknown Source)

...
Cause 2: java.lang.IllegalStateException: buildToolsVersion is not specified.
    at com.google.common.base.Preconditions.checkState(Preconditions.java:176)
    at com.android.build.gradle.BasePlugin.createAndroidTasks(BasePlugin.groovy:444)
    at com.android.build.gradle.BasePlugin$_createTasks_closure13_closure17.doCall(BasePlugin.groovy:415)
    at com.android.build.gradle.BasePlugin$_createTasks_closure13_closure17.doCall(BasePlugin.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)

....

* Where:
Build file '/tmp/grpc-java/android/delegate.gradle' line: 14

* What went wrong:
A problem occurred evaluating root project 'android'.
> org/gradle/api/publication/maven/internal/DefaultMavenFactory

When running with --stacktrace:
Caused by: java.lang.NoClassDefFoundError: org/gradle/api/publication/maven/internal/DefaultMavenFactory
    at org.gradle.api.plugins.AndroidMavenPlugin.apply(AndroidMavenPlugin.java:88)
    at org.gradle.api.plugins.AndroidMavenPlugin.apply(AndroidMavenPlugin.java:57)
    at org.gradle.api.internal.plugins.ImperativeOnlyPluginApplicator.applyImperative(ImperativeOnlyPluginApplicator.java:35)
    at org.gradle.api.internal.plugins.RuleBasedPluginApplicator.applyImperative(RuleBasedPluginApplicator.java:43)
    at org.gradle.api.internal.plugins.DefaultPluginManager.doApply(DefaultPluginManager.java:144)
    at org.gradle.api.internal.plugins.DefaultPluginManager.apply(DefaultPluginManager.java:112)
    at org.gradle.api.internal.plugins.DefaultObjectConfigurationAction.applyType(DefaultObjectConfigurationAction.java:113)
    at org.gradle.api.internal.plugins.DefaultObjectConfigurationAction.access$200(DefaultObjectConfigurationAction.java:36)
    at org.gradle.api.internal.plugins.DefaultObjectConfigurationAction$3.run(DefaultObjectConfigurationAction.java:80)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/960
Revert "Draft of Android specific Channe builder"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI, if you feel comfortable bumping the min gradle version to 2.4 or 2.5, you may not need to revert this.  (or if possible, selectively pick the dependency based on the current gradle version).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/961
Let transports be service providers for generic usage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/962
Fix flow-control documentation on Stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/963
Adding tc_native to interop test scripts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/964
okhttp: Skip trash data for finished stream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/965
Support using client and server with existing FDs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the Java equivalent of grpc/grpc#3250.
I think this may just be Netty work; we could possibly enhance the epoll transport to have an address time that allows specifying the fd int directly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/966
Defer explicit flushing of messages written during the onReady callback.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/967
Update examples in light of daemon threads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
At the very least, the hello world server example is broken, because it exits immediately. It needs a call to server.awaitTerminated(). This was caused by the swapping to daemon threads in 07a7279.
As reported on StackOverflow.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/968
java.lang.NoClassDefFoundError: com.squareup.okhttp.internal.spdy.Http2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when launch to the following line[ HelloReply reply = stub.sayHello(message) ] , runtime exception occurs,java.lang.NoClassDefFoundError: com.squareup.okhttp.internal.spdy.Http2
Following the the MainActivity:
package grpc.pm.com.grpcclient;

import android.os.AsyncTask;
import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.squareup.okhttp.ConnectionSpec;

import java.util.concurrent.TimeUnit;

import io.grpc.ManagedChannel;
import io.grpc.examples.GreeterGrpc;
import io.grpc.examples.nano.Helloworld.HelloRequest;
import io.grpc.examples.nano.Helloworld.HelloReply;
import io.grpc.okhttp.NegotiationType;
import io.grpc.okhttp.OkHttpChannelBuilder;


public class MainActivity extends ActionBarActivity {
    Button mBtn;
    EditText mSendText;
    TextView mResult;
    public static final String TAG = "MainActivity";

    public void findViewById(){
        mBtn = (Button) findViewById(R.id.sendBtn);
        mSendText = (EditText) findViewById(R.id.sendEt);
        mResult = (TextView) findViewById(R.id.result);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        findViewById();

        initView();

        mBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                sendToServer();
            }
        });

        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread thread, final Throwable ex) {

                ex.printStackTrace();
                System.exit(0);
            }
        });

    }

    public void initView(){

    }

    public void sendToServer(){
        mBtn.setEnabled(false);
        new GrpcTask().execute();

        /*new Thread(new Runnable() {
            String mHost = "192.168.1.2";
            String mText = mSendText.getText().toString();
            int mPort = 50051;
            @Override
            public void run() {
                ManagedChannel channel = OkHttpChannelBuilder.forAddress(mHost, mPort).build();
                HelloRequest message = new HelloRequest();
                message.name = mText;
                GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(channel);
                HelloReply reply = stub.sayHello(message);
                String res = reply.message;
                Log.d(TAG,res);
                mResult.setText(res);
            }
        }).start();*/
    }

    private class GrpcTask extends AsyncTask<Void, Void, String> {
        private String mHost;
        private String mMessage;
        private int mPort;
        private ManagedChannel mChannel;

        @Override
        protected void onPreExecute() {
            mHost ="192.168.1.2";
            mPort = 50051;
            mMessage = mSendText.getText().toString();
            mResult.setText("");
        }

        private String sayHello(ManagedChannel channel) {
            GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(channel);
            HelloRequest message = new HelloRequest();
            message.name = mMessage;
            HelloReply reply = stub.sayHello(message);
            Log.d(TAG, "send successfully");
            return reply.message;
        }

        @Override
        protected String doInBackground(Void... nothing) {
            try {
                Log.d(TAG,"doInBackground begin......");
                OkHttpChannelBuilder builder = OkHttpChannelBuilder.forAddress(mHost, mPort);
                //builder = builder.connectionSpec(ConnectionSpec.CLEARTEXT);
                builder = builder.negotiationType(NegotiationType.PLAINTEXT);
                mChannel =  builder.build();
                String res = sayHello(mChannel);
                return res;
            } catch (Exception e) {
                e.printStackTrace();
                return "sayHello Failed... : " + e.getMessage();
            }
        }

        @Override
        protected void onPostExecute(String result) {
            try {
                Log.d(TAG, "onPostExecute"+result);
                mChannel.shutdown().awaitTermination(1, TimeUnit.SECONDS);
            } catch (Exception e) {
                Thread.currentThread().interrupt();
            }
            mResult.setText(result);
            mSendText.setEnabled(true);
        }
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/969
Move decompressor setting to Server Impl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/970
Update server to await termination in the main thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, LGTM, but this does not fix #967. Please verify the other examples as well; I know routeguide is also broken.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/971
Add an example compressing client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/972
Squash generics
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/973
Running ./gradlew build leaves behind a javadoc/ directory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This makes it difficult to do a "git add ." command after running tests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/974
Error during servers-side TLS negotiation leads to erroneous stacktrace
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to the fact that we always register the HTTP/2 handler on the server side, if a TLS error causes forced shutdown of the connection, the HTTP/2 handler also dumps a stacktrace which is not helpful and could be confusing to the user:
Sep 08, 2015 1:21:09 PM io.grpc.netty.ProtocolNegotiators$1 fail
WARNING: TLS negotiation failed for new client. OpenSSL version: 0x1000105f [OpenSSL 1.0.1e 11 Feb 2013]. ALPN supported: false. Enabled ciphers=[TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_RC4_128_SHA, TLS_ECDH_ECDSA_WITH_RC4_128_SHA, TLS_ECDH_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_RC4_128_MD5, TLS_RSA_WITH_RC4_128_MD5]. 
java.lang.Exception: Failed protocol negotiation: Unable to find compatible protocol.
    at io.grpc.netty.ProtocolNegotiators$1.userEventTriggered(ProtocolNegotiators.java:105)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeUserEventTriggeredNow(ChannelHandlerInvokerUtil.java:75)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeUserEventTriggered(DefaultChannelHandlerInvoker.java:135)
    at io.netty.channel.AbstractChannelHandlerContext.fireUserEventTriggered(AbstractChannelHandlerContext.java:149)
    at io.netty.handler.ssl.SslHandler.setHandshakeSuccess(SslHandler.java:1240)
    at io.netty.handler.ssl.SslHandler.setHandshakeSuccessIfStillHandshaking(SslHandler.java:1219)
    at io.netty.handler.ssl.SslHandler.wrapNonAppData(SslHandler.java:613)
    at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1061)
    at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:965)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:327)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:153)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:157)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:946)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)

Sep 08, 2015 1:21:09 PM io.netty.handler.codec.http2.Http2ConnectionHandler processGoAwayWriteResult
SEVERE: Sending GOAWAY failed: lastStreamId '0', errorCode '0', debugData ''. Forcing shutdown of the connection.
javax.net.ssl.SSLException: SSLEngine closed already

Sep 08, 2015 1:21:09 PM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.handler.codec.http2.Http2Exception: HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 
    at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:82)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.readClientPrefaceString(Http2ConnectionHandler.java:322)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:263)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:445)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeLast(ByteToMessageDecoder.java:382)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:286)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:421)
    at io.grpc.netty.NettyServerHandler.channelInactive(NettyServerHandler.java:230)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelInactiveNow(ChannelHandlerInvokerUtil.java:56)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelInactive(DefaultChannelHandlerInvoker.java:92)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:135)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelInactiveNow(ChannelHandlerInvokerUtil.java:56)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelInactive(DefaultChannelHandlerInvoker.java:92)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:135)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:306)
    at io.netty.handler.ssl.SslHandler.channelInactive(SslHandler.java:706)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelInactiveNow(ChannelHandlerInvokerUtil.java:56)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelInactive(DefaultChannelHandlerInvoker.java:92)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:135)
    at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:928)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:674)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
    at java.lang.Thread.run(Thread.java:745)

The first stacktrace is correct, but the second one is thrown by the HTTP/2 handler's deactivated logic.
We might consider waiting until the TLS negotiation succeeds before registering the HTTP/2 handler.  This should be safe since the server will not be sending anything until it begins receiving data.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/975
Mark ServerCalls, MethodDescriptor.create, MethodDescriptor.Marshaller and a few others ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These are generally used by the generated code. There are some plans for doing Android-driven performance work on the generated code, and there are some options being discussed that would impact these APIs.
For beta, we've agreed that it is fine for generated code to depend on ExperimentalApi. For GA, that will not be allowed to be the case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/976
Use service provider for server-side 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is effectively #961 for getting a ServerBuilder. It would only use Netty today.
Whether we extend the current ManagedChannelProvider to allow creating server builders or make a parallel path is up for discussion, but honestly we should just flip a coin and go with one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/977
Use stub call options for compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/978
Fixing erroneous server log when TLS nego fails
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/979
Fixing okhttp hang when TLS nego fails.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly @ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/980
Add client-side logging for TLS negotiation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/981
VC++ building info seems out of date
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Visual C++ Protobuf link in ./COMPILING.md seems broken. The following Visual C++ section also needs some update with the default include and lib paths.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/982
Add proper generics to ManagedChannelProvider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
oof ... thanks :)
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/983
Recommend OpenSSL in  SECURITY.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/984
Enable warnings for rawtypes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/985
StreamObserver.onError(Throwable t) hard to use or unintuitive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public interface StreamObserver<V>  {
  void onError(Throwable t);
  // ... more methods declared.
}
For client calls with streaming responses, when could the error be a Throwable and not a Status?
It seems more fitting that onError(..) would take a Status instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/986
StreamObserver used also for unary calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
StreamObserver is used for all responses, even when the response is not a stream. To easier understand the generated API it'd be better if unary responses would be treated as such and have a different Observer that suggests that there will only be one response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/987
Reduce API surface of AbstractStub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/988
Add a server Provider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/989
PARSER has private access
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using protoc-3.0.0-beta-1-win32 and protoc-gen-grpc-java-0.7.2-windows-x86_64.exe to generate code from a proto file. But the Grpc file has this line "io.grpc.protobuf.ProtoUtils.marshaller(grpc.grpcsvc.Grpcsvc.HelloRequest.PARSER)". Then java compiler complains because PARSER has private access in another generated file. Am I using the wrong protoc or plugin?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/990
Prevent construction of container classes and reduce API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/991
Http2OkHttpTest.receivedDataForFinishedStream is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in: https://travis-ci.org/grpc/grpc-java/builds/79687899
io.grpc.testing.integration.Http2OkHttpTest > receivedDataForFinishedStream FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
        at com.google.common.util.concurrent.AbstractFuture$Sync.get(AbstractFuture.java:285)
        at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:116)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:149)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:104)
        at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:210)
        at io.grpc.testing.integration.AbstractTransportTest.emptyUnary(AbstractTransportTest.java:155)
        at io.grpc.testing.integration.Http2OkHttpTest.receivedDataForFinishedStream(Http2OkHttpTest.java:118)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/992
Discourage users from running the codegen for the example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/993
Enable license header checking in checkstyle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/994
Implement cork/uncork in client and server calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
By adding a cork/uncork to defer flushing messages we can significantly improve throughput for streaming operations when messages sizes are significantly smaller than the flow-control window
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/995
Mark classes in testing as ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/996
Basic implementation of corking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TLDR;  Impact is significant across the board but in particular it helps in the non-direct executor case significantly more
With corking
Benchmark                                                          (channelCount)  (clientExecutor)  (maxConcurrentStreams)  (responseSize)   Mode  Cnt        Score        Error  Units
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                       1           SMALL  thrpt   20   748010.445 Â±  11056.456  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                       2           SMALL  thrpt   20   787603.691 Â±   9216.387  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                      10           SMALL  thrpt   20   833604.307 Â±  20504.497  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                     100           SMALL  thrpt   20   747409.964 Â±  20994.393  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                       1           SMALL  thrpt   20  1182869.604 Â±  61495.293  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                       2           SMALL  thrpt   20  1039064.457 Â±  20749.094  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                      10           SMALL  thrpt   20  1085170.265 Â±  24539.003  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                     100           SMALL  thrpt   20   910051.011 Â±  74268.573  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                       1           SMALL  thrpt   20  1444956.843 Â±  81101.309  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                       2           SMALL  thrpt   20  1609690.720 Â± 108433.473  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                      10           SMALL  thrpt   20  1560337.018 Â± 152004.123  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                     100           SMALL  thrpt   20  1379330.221 Â± 112759.558  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                       1           SMALL  thrpt   20  1672837.571 Â±  70588.569  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                       2           SMALL  thrpt   20  1769621.126 Â±  33891.535  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                      10           SMALL  thrpt   20  1716542.116 Â±  49576.274  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                     100           SMALL  thrpt   20  1459977.770 Â±  31524.513  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                       1           SMALL  thrpt   20  2758350.501 Â±  90416.723  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                       2           SMALL  thrpt   20  2868168.313 Â± 103377.954  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                      10           SMALL  thrpt   20  2584746.771 Â±  88402.278  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                     100           SMALL  thrpt   20  2127286.038 Â±  93638.693  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                       1           SMALL  thrpt   20   824270.235 Â±  26016.129  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                       2           SMALL  thrpt   20   904179.135 Â±  37499.004  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                      10           SMALL  thrpt   20   920983.094 Â±  35914.129  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                     100           SMALL  thrpt   20   858945.797 Â±  55156.034  ops/s

Baseline
Benchmark                                                          (channelCount)  (clientExecutor)  (maxConcurrentStreams)  (responseSize)   Mode  Cnt       Score       Error  Units
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                       1           SMALL  thrpt   20  463224.233 Â± 15075.820  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                       2           SMALL  thrpt   20  418996.088 Â± 39517.380  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                      10           SMALL  thrpt   20  419147.532 Â± 35825.976  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1           DEFAULT                     100           SMALL  thrpt   20  365772.704 Â± 39481.162  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                       1           SMALL  thrpt   20  486607.330 Â±  4937.475  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                       2           SMALL  thrpt   20  431439.527 Â± 34487.554  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                      10           SMALL  thrpt   20  440799.390 Â± 19609.886  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               1            DIRECT                     100           SMALL  thrpt   20  384496.307 Â± 30644.773  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                       1           SMALL  thrpt   20  623000.712 Â± 57579.747  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                       2           SMALL  thrpt   20  677841.301 Â± 44452.386  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                      10           SMALL  thrpt   20  710803.468 Â± 59832.742  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2           DEFAULT                     100           SMALL  thrpt   20  541989.044 Â± 68496.324  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                       1           SMALL  thrpt   20  782277.645 Â± 42270.805  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                       2           SMALL  thrpt   20  725217.369 Â± 29801.642  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                      10           SMALL  thrpt   20  744944.708 Â± 61464.357  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               2            DIRECT                     100           SMALL  thrpt   20  591086.072 Â± 90409.945  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                       1           SMALL  thrpt   20  782448.903 Â± 27561.783  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                       2           SMALL  thrpt   20  811964.327 Â± 19292.966  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                      10           SMALL  thrpt   20  808832.437 Â± 27356.478  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4           DEFAULT                     100           SMALL  thrpt   20  713170.043 Â± 37491.770  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                       1           SMALL  thrpt   20  805919.726 Â± 18514.909  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                       2           SMALL  thrpt   20  793134.550 Â± 30305.765  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                      10           SMALL  thrpt   20  808890.842 Â± 23483.865  ops/s
FlowControlledMessagesPerSecondBenchmark.stream:messagesPerSecond               4            DIRECT                     100           SMALL  thrpt   20  734703.539 Â± 46585.597  ops/s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/997
Add overrideAuthority for Channel construction
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/998
Add usePlaintext to ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/999
Possible race condition ServerImpl between start() and shutdown()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I believe it may be possible if start and stop are called concurrently that the shared executor may not get released.  I'm not sure if this is an actual problem, but it does go against the @ ThreadSafe annotation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1000
Support starting a Server with basic TLS configuration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should be able to start a secure server using just stable APIs. There should be some way to specify the cert chain and private key.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1001
Swap examples over to stable builders for channel/server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1002
Add a message accept encoding header
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1003
Make tcnative available to the interop scripts.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1004
Private ServerMethodDefinition constructor; avoid create() in codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Make ServerMethodDefinition constructor private?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1005
Make builderFor* public on Providers, and update examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1006
Use tls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1007
Mark some APIs codegen uses experimental to allow for optimizations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1008
Update Client Examples to use ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1009
Start 1.0.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1010
Simplify upgrade path for stubs toward using flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We currently do not expose flow control semantics directly in the stub. Inbound flow control implicitly "consumes" bytes upon returning from onNext.  Outbound is simply not exposed at all. As it stands, developers needing flow control would either have to rewrite their client to use the Channel API directly, or perform some tricks using interceptors (or handler registries on the server-side).
We need an easy way to allow developers who begin by using the stub API to upgrade their code to interact with flow control directly.
/cc @louiscryan @ejona86 @Scottmitch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1011
Add Header name character restrictions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1012
C++ Server Response Content Type null
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unary call for a blocking stub fails on Android at:
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/Http2ClientStream.java#L97
with:
09-12 02:45:02.561 2330-2347/? E/JOBS: error while executing job
09-12 02:45:02.561 2330-2347/? E/JOBS: io.grpc.StatusRuntimeException: INTERNAL: Invalid content-type: null
Works fine after commenting out the check.
Skimming through the c++ server code shows content-type is not being set on the response?
Not sure where is the right place to raise this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1013
Deprecate OkHttpChannelBuilder#overrideHostForAuthority
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1014
request() need to be documented as thread-safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For both server and client
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1015
Enforce sending headers before messages on server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is for both v0.9.0 branch and master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1016
Remove stray request() in server-sending path
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is for both v0.9.0 branch and master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1017
The run-test-server.sh exits immediately
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After changing to using daemon threads by default, this script stopped working.  We need to update the server to keep alive until cancelled (e.g. ctrl+c).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1018
Make Interop Server block until shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM ... thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1019
Make Interop Server block until shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1020
request() is thread-safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1021
C++ doesn't send content-type
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Although C++ should be sending a content-type, it currently isn't. We'll need to figure out our interop story for Java.
Caused by: io.grpc.StatusRuntimeException: INTERNAL: Invalid content-type: null

Metadata({grpc-status=[0]})
    at io.grpc.Status.asRuntimeException(Status.java:428)
    at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:156)
    at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:106)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1022
Fix broken tutorial link.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you. I've also cherry-picked it to the v0.9.x branch as db8324c
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1023
Don't let server start if already shutting down
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1024
Restrict api
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A race with using the UI (me typing space before the UI was fully open) created this prematurely. It is against the wrong branch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1025
Restrict api
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1026
Checkstyle shouldn't rely on current directory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1027
Fix the double-closure of server call for interop tests.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly, LGTM. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1028
Temporarily ignore content type
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1029
Fix test checking for invalid content type
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1030
Allow commas in Metadata values
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is not a Java-specific decision. We need consensus from other implementations.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1031
Update tcnative version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Even though it doesn't directly impact our users, we should update the tcnative version used by our interop tests, etc.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1032
Fix Android example.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1033
Upgrade maven-os-plugin in README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1034
Update Android example.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1035
Mark Status*Exception.getStatus() final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1036
Change version to 0.10.0-SNAPSHOT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1037
Add a Changes document to keep track of release notes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have roughly copied the format of the VLC changelog, which I find has the right balance of important issues.  Also I expect to keep the whole version history in here, with each new branch only keeping track of changes that have been made to them.
https://www.videolan.org/developers/vlc-branch/NEWS
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1038
Put Grpc codegen in nano package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should probably follow suit and append a "nano" package to our generated class unless the nano option is specified that disables the new protoc behavior.
@zhangkun83, WDYT? Since this requires regenerating the code, I'm fine with doing this post-Beta.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1039
Updating tcnative and osdetector
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ain't that pretty. @nmittler, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1040
Updating tcnative and osdetector
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1041
Update Android example.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1042
Remove javatutorial; it duplicates grpc.io website
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1043
0.9.0 release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1044
Pass decompressor registry around and make it less static
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1045
classifierWithLikes breaks protobuf-gradle-plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1046
Releases can be uploaded without signing being successful
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We configure signing to be required, but it isn't working for some reason.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1047
Netty has many classes not marked @Internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1048
Load-balancing ManagedChannelImpl.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1049
Update the comments in proguard-rules files.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1050
Add benchmark and test for serializing executor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1051
Split newCall from starting a call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1052
Remove examples/protos?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm not sure if anything are using them. They are confusing to people because it makes people think they need them in that location for their own project.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1053
netty: IOException should map to UNAVAILABLE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
NIO can throw java.io.IOException: Connection reset by peer. In general, it seems that IOException would be UNAVALIABLE, although there are certainly outliers given the heavy overloading/abuse of IOException in Java.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1054
Address key protobuf performance issues
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is something of a coverall issue and should be factored out into separate issues for each individual piece of work. Listed here are a number of areas for improving the interaction between protobuf and GRPC to improve overall performance and reduce memory pressure on the system.
In rough order of priority....

Implement some basic protobuf benchmarks independent of GRPC (scrape the web or extract Googles) as a framework for experimenting with optimizations
Provide the ability to have a 0-copy approach for writing out large binary sequences (byte buf, file region etc) to the transport without copying
Provide the ability to read protobufs so that they can be written out again with 0-copy for large sequences. This includes writes to transport and to files
Document a pattern for transferring a large binary sequence as chunks and utility functions to chunk & dechunk those to application code. File transfer is a common use-case here
Consider supporting deserialized protobuf backed by pooled buffers (speculative). Would require the notion of a releasable protobuf

@nmittler @ejona86 - Feel free to pile on / cc folks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1055
Remove unused protos.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1056
Is grpc-java stable enough to use in production environment?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, i notice that there were 5 releases for grpc-java, and Is grpc-java stable enough to use in production environment?
Thanks & Best Regards!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1057
Make io.grpc.Status.STATUS_LIST be static final, not just static.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you! Merged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1058
Reduce OkHttp dependency, copy needed classes into our repository.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I haven't updated the Copyright info since I'm not sure what it should be, completely replace it to our version? or make some modification based on the original version? any suggestions?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1059
Send a single SETTINGS frame from Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have an old TODO to update Netty once we upgrade to 4.1.0.Beta6 (which we have done): 
  
    
      grpc-java/netty/src/main/java/io/grpc/netty/NettyClientHandler.java
    
    
         Line 134
      in
      aefefb5
    
  
  
    

        
          
           // TODO(nmittler): this is a temporary hack as we currently have to send a 2nd SETTINGS 
        
    
  

.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1060
Use Netty's buffering encoder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We currently use a copy of Netty's buffering encoder, we should switch to using theirs and deleting the grpc version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1061
grpc-java does not work with grpc-cpp anymore?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It used to work to run greeter_client.cc from grpc-cpp with HelloWorldServer from grpc-java, but this seems not to work anymore with grpc-0_11_0 release and latest protobuf anymore. There are multiple problems: first, to get HelloWorldServer compiled with the proto example file, I needed to fiddle with the java "package" in several places. After the compile worked, the client connects to the server but nothing happens. The remote method sayHello() seems never to return. Only when killing the server the client will finally return an (unsuccessful) response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1062
Issues with proto class naming, and service naming, in grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have two problems (or difficulties) when using the helloworld.proto from grpc examples.
(1) The proto-file is named helloworld (lowercase) and contains "package helloworld;" (also lowercase). But the derived grpc java class file is called "Helloworld.java" (first letter uppercase). This breaks my build instructions. In grpc-cpp the file stays lowercase. Why is grpc-java changing the name?
(2) The bigger problem comes from the name of the service rpc method. helloworld.proto advertises the service "rpc SayHello (HelloRequest) returns (HelloReply) {}", note the camel-case! In grpc-cpp the method consistently has the same name. But in grpc-java in HelloWorldServer.java, the method suddenly changes its name to sayHello (note the lowercase first letter). This is quite inconsistent and confusing. Could this be changed? Why is grpc-java meddeling with the casing?
To generate the java code, I'm using latest protobuf 3.0.0-beta-1:
/thirdparty/bin/protoc -I="/tmp/Proto" --java_out="/tmp/ProtoGenJava" --java_plugin_out="/tmp/ProtoGenJava" --plugin="protoc-gen-java_plugin=/thirdparty/bin/protoc-gen-grpc-java" "/tmp/Proto/helloworld.proto"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1063
Updating Netty to send a single SETTINGS frame.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1064
Remove Netty test that fails with upstream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1065
Remove unused function in netty test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1066
Reduce memory usage in test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
And I've verified that after this change, the previous bug #952 can still be detected by this test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1067
Fixing benchmarks.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
@Scottmitch FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1068
Put nano generated code into nano package, unless option javanano_useâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1069
Adding homepage and mailing list to the README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
/cc @wrwg
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1070
Update Windows building instructions for proto3b1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1071
Fixing flaky test Http2NettyTest.deadlineExceeded()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1072
Prepare channel layer for upcoming load-balancing changes.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1073
Introduces the grpc-callable sub-project. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@wrwg, I took a look-over and the code seemed very readable and straight-forward. I only was looking from a low-level perspective. I'm going to look over it from a high-level next.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1074
Add at least one example of how to use TLS 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The example directories don't show how to properly set up a TLS connection.  Since this is likely the first place people look for how to set up a server, at least one of the examples (new or existing) should show how.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1075
Correct the order of arguments.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1076
Remove setDecompressor() from ClientStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Method calls on ClientStream are supposed to be initiated by the channel layer or the application. setDecompressor(), however, is called from within the stream implementation when receiving headers from the server. It shouldn't be on the ClientStream public interface. It may make sense to only have it in an abstract implementation.
However, it may stay on ServerStream, because it's called outside of the stream implementation, when the server creates the stream.
@carl-mastrangelo
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1077
Correct the order of arguments.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1078
Move decompressor setting down into the AbstractStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. @ejona86 do you want to take a look too?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1079
Replace broken link in example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1080
Add protection against attacks using malicious protobuf messages.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It'd be good to to be able to specify the maximum message size on wire that the server tries to parse in order to protect from OOM errors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1081
Investigate if Application protocols should be required
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI: This is more of a collection of thoughts that an actual issue.  The existing behavior might actually be correct.
When doing HTTP2 over TLS, the spec says that the next protocol "h2" can be used when negotiating using ALPN/NPN.  Currently today, the netty server accepts any next protocol, as long as there is one.  Specifically, sending a next protocol of "gibberish" does not cause the server to fail the connection.  This is controlled by SelectedListenerFailureBehavior.ACCEPT in our GrpcSslContexts class.
Intuitively, it seems like if the wrong protocol is specified by a client, the connection should fail.  If no protocol is specified, it seems like the server should entertain the possibility that the client wants to speak HTTP2, and not fail the connection.
The spec indicates a limited set of TLS requirements, of which application protocol negotiation doesn't appear to be on the list.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1082
This checks the make sure that the negotiated application protocol is one that GRPC supports ("h2").
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1083
Update README to reference 0.9.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1084
Fix missing version bump of protobuf to b1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1085
Update Windows building instructions for proto3b1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1086
[Android-interop-test] Support non-tls test and replace a deprecated â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1087
Eventually Support HTTP/1.1 Upgrade 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the spirit of playing nicely with an ecosystem of other HTTP clients, we should support a bare minimum upgrade path from an HTTP/1.1 client.
This is pretty low priority, but is part of the HTTP/2 spec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1088
Many Netty public classes missing @Internal/@ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1089
testNoDeadlockOnShutdown flaky since DelayedStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in https://travis-ci.org/grpc/grpc-java/builds/82854873 (rebuild fixed)
io.grpc.internal.ManagedChannelImplTest > testNoDeadlockOnShutdown FAILED
    java.lang.NullPointerException: mockTransport returned null stream
        at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:226)
        at io.grpc.internal.ClientCallImpl$DelayedStream.createStream(ClientCallImpl.java:468)
        at io.grpc.internal.ClientCallImpl$DelayedStream.access$900(ClientCallImpl.java:380)
        at io.grpc.internal.ClientCallImpl$DelayedStream$StreamCreationTask.run(ClientCallImpl.java:432)
        at io.grpc.internal.ClientCallImpl$DelayedStream.<init>(ClientCallImpl.java:442)
        at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:164)
        at io.grpc.internal.ManagedChannelImplTest.testNoDeadlockOnShutdown(ManagedChannelImplTest.java:298)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1090
Enable OS X on Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Deleting. I meant to make this on my repo.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1091
Use OpenSSL 1.0.2 on Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need 1.0.2 to have ALPN to test OkHttp against Netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1092
Enable tcnative for unit tests in interop-testing; OkHttp should Assume ALPN available
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That will disable OkHttp tests if you don't have a new enough OpenSSL installed, but Travis will still correctly do the testing.
Depends on #1091
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1093
Have OpenSSL v1.0.2 available to unit tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1094
transportFailsOnStart flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seen in https://travis-ci.org/grpc/grpc-java/builds/83191873 (logs lost)
io.grpc.internal.ManagedChannelImplTest > transportFailsOnStart FAILED
    org.mockito.exceptions.verification.TooLittleActualInvocations: 
    mockTransportFactory.newClientTransport();
    Wanted 2 times:
    -> at io.grpc.internal.ManagedChannelImplTest.transportFailsOnStart(ManagedChannelImplTest.java:236)
    But was 1 time:
    -> at io.grpc.internal.TransportSet$1.run(TransportSet.java:159)
        at io.grpc.internal.ManagedChannelImplTest.transportFailsOnStart(ManagedChannelImplTest.java:236)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1095
Stub mockTransport.newStream() to prevent NPE.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1096
Use timeout when verifying setDecompressionRegistry()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1097
Exception not caught with Netty before plaintext handshake completes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported on grpc-io mailing list, a user saw this error. It seems the client was immediately disconnecting, but that is likely a separate issue. The server should handle it better though.
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: Connection reset by peer
at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:312)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:854)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:245)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:112)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)

Oct 01, 2015 9:52:14 PM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.handler.codec.http2.Http2Exception: HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 
at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:82)
at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.readClientPrefaceString(Http2ConnectionHandler.java:322)
at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:263)
at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:445)
at io.netty.handler.codec.ByteToMessageDecoder.decodeLast(ByteToMessageDecoder.java:382)
at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:286)
at io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:421)
at io.grpc.netty.NettyServerHandler.channelInactive(NettyServerHandler.java:227)
at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelInactiveNow(ChannelHandlerInvokerUtil.java:56)
at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelInactive(DefaultChannelHandlerInvoker.java:92)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:135)
at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:928)
at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:674)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1098
Allow host authority override.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1099
implement timeout_on_sleeping_server interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1100
Use one codegen class for all Nano factories
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1101
Adding consistent exception handling for Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1102
Redundant logging when connection failed.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
And SEVERE is too heavy for it.
It should be fixed in Netty, but create this issue for gRpc users tracking it.
Oct 05, 2015 2:00:16 PM io.netty.handler.codec.http2.Http2ConnectionHandler processGoAwayWriteResult
SEVERE: Sending GOAWAY failed: lastStreamId '3', errorCode '0', debugData ''. Forcing shutdown of the connection.
javax.net.ssl.SSLException: SSLEngine closed already
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1103
Headers are a major source of slowness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the metadata handling has a number of inefficiencies that materially affect performance.
Netty

We convert MethodDescriptor into Http2Headers for every call. Could be cached
We have no way of storing a validation result or derived value with a header cached by HPACK. E.g validating that the content-type is correct is done on the string value even though the value is effectively constant when emitted by HPACK.

Performance benchmark UnaryCallQpsBenchmark shows that header handling is ~10% of total CPU cost.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1104
Android studio fails to compile 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
on Android Studio 1.4, add grpc-java to gradle of android project, and there is no other lib in dependencies
dependencies {
    compile 'io.grpc:grpc-all:0.9.0'
}

Execution failed for task ':app:dexDebug'.
com.android.dex.DexException: Multiple dex files define Lcom/squareup/okhttp/OkHttpTlsUpgrader;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1105
Give dependency example for android clients.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1106
Add authority work around for OkHttp channels
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1107
Update documentation for CGM, in light of jre8u60
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1108
OkHttpClientTransport.shutdown() not safe to call if never started.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a OkHttpClientTransport is created, and then shutdown without starting, it throws an NPE.  This is surprising behavior because other shutdown methods (such as on ServerImpl) are safe to call shutdown on at any time.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1109
OkHttpClientTransportTest is overly strict in mock verification
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the process of adding a test for OkHttpClientTransport, I found that mocked behavior is checked for on every test.  I attempted to add the first test that did not use mocks, but caused the test to fail.  This is because the @ After  annotation in the test does verifications on mocks regardless of the test.
This is a misuse of @ After annotations.  They are not part of the test, but a means to clean up state.  Even if every test does the same verification, it is still not appropriate to put verification code here, because it puts stress on every other test added later on.  Making it hard to add tests is something we do not want.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1110
Allow non-host based authorities in OkHttp transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1111
transportShutdown() should be called before calling transportTerminated().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With the changes of TransportSet, transportShutdown() must be called before calling transportTerminated().
10-06 15:32:45.917  5126  5126 E AndroidRuntime: FATAL EXCEPTION: OkHttpClientTransport
10-06 15:32:45.917  5126  5126 E AndroidRuntime: Process: com.google.android.apps.fireball, PID: 5126
10-06 15:32:45.917  5126  5126 E AndroidRuntime: java.lang.IllegalStateException: Listener is still attached to activeTransportFuture. Seems transportTerminated was not called.
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at com.google.common.base.Preconditions.checkState(Preconditions.java:173)
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at io.grpc.internal.TransportSet$TransportListener.transportTerminated(TransportSet.java:249)
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at io.grpc.okhttp.OkHttpClientTransport$ClientFrameHandler.run(OkHttpClientTransport.java:606)
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
10-06 15:32:45.917  5126  5126 E AndroidRuntime:    at java.lang.Thread.run(Thread.java:818)
10-06 15:32:45.918   745  1319 W ActivityManager:   Force finishing activity com.google.android.apps.fireball/.ui.photoviewer.FireballPhotoViewActivity
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1112
[okhttp] Make sure transportShutdown() always be called before callinâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1113
empty_stream interop tests fails against Go server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
empty_stream, java client, go server
Running test empty_stream
Oct 09, 2015 10:59:50 PM io.grpc.internal.TransportSet$1 run
INFO: Created transport 'io.grpc.netty.NettyClientTransport@332c01ed
Oct 09, 2015 10:59:53 PM io.netty.util.internal.ThreadLocalRandom getInitialSeedUniquifier
WARNING: Failed to generate a seed from SecureRandom within 3 seconds. Not enough entropy?
Oct 09, 2015 10:59:53 PM io.grpc.internal.TransportSet$TransportListener transportReady
INFO: Transport 'io.grpc.netty.NettyClientTransport@332c01ed is ready
Oct 09, 2015 10:59:55 PM io.grpc.internal.TransportSet$TransportListener transportShutdown
INFO: Transport 'io.grpc.netty.NettyClientTransport@332c01ed is being shutdown
Exception in thread "main" Wanted but not invoked:
streamObserver.onCompleted();
-> at io.grpc.testing.integration.AbstractTransportTest.emptyStream(AbstractTransportTest.java:320)

However, there were other interactions with this mock:
streamObserver.onError(
    io.grpc.StatusRuntimeException: INTERNAL: Invalid content-type: null
);
-> at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:266)


    at io.grpc.testing.integration.AbstractTransportTest.emptyStream(AbstractTransportTest.java:320)
    at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:228)
    at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:207)
    at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:80)
Shutting down

FLAKE: cloud_to_cloud:java:go_server:empty_stream [ret=1, pid=31237]

https://grpc-testing.appspot.com/job/gRPC_interop_master/180/console
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1114
Support NPN for OkHttp non-Android path.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This code path may never have a real user, but it will gain some convenience for running our tests against a server that only supports NPN.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1115
Sync the Android example back to internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1116
Integrate cronet as a grpc Java transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1117
Up code coverage for Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1118
Cover more low hanging fruit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1119
Add initial Protocol Negotiation tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1120
Expose timeout_on_sleeping_server test to interop test client.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1121
Add "using std::to_string" to java_generator.cpp, it is needed by intâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1122
Supporty unary retry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems to be a pretty common use-case.  We should support this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1123
modify .gitignore to ignore Emacs files
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As a vim user, I feel it necessary to point out that there is a better text editor available for your use.
In spite of that, LGTM. I'll be merging it in
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1124
Expose unimplemented_method test to interop test client.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1125
Investigate using jdk8 Base64 encoder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Guava base64 Coder we are currently using has possible performance issues, and may not be present in some android situations that can't use Guava.  Investigate if the jdk8 speed up is enough to justify using it, or the android native coder.  There appears to be a Guava release that could address these coming up, but we may need a fix sooner.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1126
Prepare codebase for per-platform implementations.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1127
IGNORE -- FOR TESTING ONLY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1128
Addressing concurrency issue in MessageFramer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1129
Netty authority override
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 I have to admit I haven't taken a hard look at how the channel builders work since your commit this morning, so if something in the PR doesn't make sense, or there is a better way to do it, please let me know.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1130
Support osx on Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1131
Fix flake in ManagedChannelImplTest.transportFailsOnStart
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1132
Pass transportFuture to DelayedStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, when DelayedStream is created it ends up calling clientTransportProvider a second time. However, we already have a transportFuture available, we should just use it instead.
This was the second half of what was causing the #1131 flake.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1133
Delete ManagedChannelImplTest.transportFailsOnStart
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1134
NameResolverRegistry and better-defined target string.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1135
POC: Separating outbound/inbound stream state
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI @ejona86 @carl-mastrangelo @zhangkun83 @madongfly
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1136
Pass the initial transportFuture to DelayedStream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1137
Implement gRPC LB client as GrpclbLoadBalancer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1138
Propagate absent port from NameResolver to ManagedChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a target URI doesn't contain a port, NameResolver should propagate this absence to ManagedChannelImpl, who can based on encryption is in use or not, select 443 or 80 as the actual port.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1139
Publicize ClientTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ClientTransport, which is currently internal API, is exposed via the LoadBalancer interface, which is public. ClientTransport needs to be public, and ClientStream also needs to be public because GrpcLoadBalancer will need to make RPC calls and decorate ClientTransport/ClientStream to attach LB tokens.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1140
Support alternative DNS servers in DnsNameResolver.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1141
Implement round-robin in SimpleLoadBalancer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1142
Decide how to select a NameResolver for a URI.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have two options. Currently it's try-and-fail. The other option is keep a map that maps schemes to NameResolvers.
Quote from @ejona86 in #1134

My concern about this is that order matters and you won't notice if a scheme is double-registered. It also has no avenues for optimization because the registry is basically knowledge-less.
We can leave it as-is for now, but we'd need to decide on things before it goes stable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1143
Support grpc-testing Jenkins infrastructure for Windows building
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1144
Make the total headers size limit configurable.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We may want to have our own limit, but before we decide the number, should just remove the current limit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1145
Add uri checking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1146
ContextTest.innerDeadlineCompletesBeforeOuter flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.ContextTest > innerDeadlineCompletesBeforeOuter FAILED
    java.lang.AssertionError: expected same:<io.grpc.Context$CancellableContext@1a2f009> was not:<null>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotSame(Assert.java:737)
        at org.junit.Assert.assertSame(Assert.java:680)
        at org.junit.Assert.assertSame(Assert.java:691)
        at io.grpc.ContextTest.innerDeadlineCompletesBeforeOuter(ContextTest.java:399)

As seen at https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/63/console . Parallel building was on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1147
OkHttpClientTransportTest.windowUpdateWithInboundFlowControl flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.okhttp.OkHttpClientTransportTest > windowUpdateWithInboundFlowControl FAILED
    Wanted but not invoked:
    frameWriter.rstStream(3, CANCEL);
    -> at io.grpc.okhttp.OkHttpClientTransportTest.windowUpdateWithInboundFlowControl(OkHttpClientTransportTest.java:499)

    However, there were other interactions with this mock:
    frameWriter.synStream(
        false,
        false,
        3,
        0,
        [:scheme: https, :method: POST, :authority: notarealauthority:80, :path: /fakemethod, user-agent: grpc-java-okhttp/0.10.0-SNAPSHOT, content-type: application/grpc, te: trailers]
    );
    -> at io.grpc.okhttp.AsyncFrameWriter$5.doRun(AsyncFrameWriter.java:124)

    frameWriter.windowUpdate(3, 32773);
    -> at io.grpc.okhttp.AsyncFrameWriter$13.doRun(AsyncFrameWriter.java:209)

    frameWriter.windowUpdate(0, 32773);
    -> at io.grpc.okhttp.AsyncFrameWriter$13.doRun(AsyncFrameWriter.java:209)
        at io.grpc.okhttp.OkHttpClientTransportTest.windowUpdateWithInboundFlowControl(OkHttpClientTransportTest.java:499)

As seen at https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/64/console . Parallel building was on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1148
OkHttpClientTransportTest.receiveDataWithoutHeaderAndTrailer flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.okhttp.OkHttpClientTransportTest > receiveDataWithoutHeaderAndTrailer FAILED
    java.util.concurrent.TimeoutException: Timeout waiting for task.
        at com.google.common.util.concurrent.AbstractFuture$Sync.get(AbstractFuture.java:269)
        at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:96)
        at io.grpc.okhttp.OkHttpClientTransportTest.startTransport(OkHttpClientTransportTest.java:184)
        at io.grpc.okhttp.OkHttpClientTransportTest.initTransport(OkHttpClientTransportTest.java:157)
        at io.grpc.okhttp.OkHttpClientTransportTest.receiveDataWithoutHeaderAndTrailer(OkHttpClientTransportTest.java:917)

As seen at https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/65/console . Parallel building was on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1149
OkHttpClientTransportTest.cancelStreamForDeadlineExceeded flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.okhttp.OkHttpClientTransportTest > cancelStreamForDeadlineExceeded FAILED
    java.util.concurrent.TimeoutException: Timeout waiting for task.
        at com.google.common.util.concurrent.AbstractFuture$Sync.get(AbstractFuture.java:269)
        at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:96)
        at io.grpc.okhttp.OkHttpClientTransportTest.startTransport(OkHttpClientTransportTest.java:184)
        at io.grpc.okhttp.OkHttpClientTransportTest.initTransport(OkHttpClientTransportTest.java:157)
        at io.grpc.okhttp.OkHttpClientTransportTest.cancelStreamForDeadlineExceeded(OkHttpClientTransportTest.java:392)

As seen at https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/66/console . Parallel building was on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1150
Assert that timeouts didn't occur in Context tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1151
Scala support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would a codegen plugin that generates canonical Scala stubs on top of the Java runtime be an appropriate addition to this repo?
Is there work on official gRPC Scala support being done elsewhere?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1152
Add followup ProtocolNegotiators.tls tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1153
Update okhttp javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1154
NameResolver can now produce addresses without ports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1155
Increase code coverage of Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1156
Add unit tests for SizeEnforcingInputStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1157
Make test cover ClientCallImpl.DelayedStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
DelayedStream is mostly uncovered by tests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1158
Support default port in NameResolver.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1159
Deflake OkHttpClientTransportTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1160
The wrong class name gets generated by Gradle task in an Android project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using grpc for one of my Android project. I create proto folder. Added the classpath for protobuf plugin. and this task in build.gradle.
protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.0.0-beta-1'
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:0.9.0'
        }
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                javanano {
                    // Options added to --javanano_out
                    option 'ignore_services=true'
                }
            }

            task.plugins {
                grpc {
                    // Options added to --grpc_out
                    option 'nano=true'
                }
            }
        }
    }
}
When I built the project - the contents of the proto folder were:
com.package.service -> ServiceGrpc.java
com.package.service.nano -> Service.java
But ServiceGrpc.java was refering to ServiceOuterClass somehow. When I manually renamed ServiceOuterClass with Service, everything seems to be working fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1161
Guard against NPE in Netty handlers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL ... should be an easy one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1162
Increase coverage for CallOptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1163
Add tests for nano proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1164
Http2NettyLocalChannelTest.deadlineExceeded flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.testing.integration.Http2NettyLocalChannelTest > deadlineExceeded FAILED
    java.lang.AssertionError: expected:<Status{code=DEADLINE_EXCEEDED, description=null, cause=null}> but was:<Status{code=UNKNOWN, description=null, cause=io.netty.util.IllegalReferenceCountException: refCnt: 0}>

As seen at https://travis-ci.org/grpc/grpc-java/jobs/87931180 (rebuilt since then). It was on OS X
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1165
Fix a NPE in ManagedChannelImpl.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1166
Downgrade mockito, and fix tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1167
Deflake Call Options test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1168
OkHttpClientTransportTest > windowUpdateWithInboundFlowControl is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.okhttp.OkHttpClientTransportTest > windowUpdateWithInboundFlowControl FAILED
    Argument(s) are different! Wanted:
    frameWriter.windowUpdate(0, 32773);
    -> at io.grpc.okhttp.OkHttpClientTransportTest.windowUpdateWithInboundFlowControl(OkHttpClientTransportTest.java:494)
    Actual invocation has different arguments:
    frameWriter.windowUpdate(3, 32773);
    -> at io.grpc.okhttp.AsyncFrameWriter$13.doRun(AsyncFrameWriter.java:209)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
        at io.grpc.okhttp.OkHttpClientTransportTest.windowUpdateWithInboundFlowControl(OkHttpClientTransportTest.java:494)

70 tests completed, 1 failed
:grpc-okhttp:test FAILED

https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/106/console
and
https://grpc-testing.appspot.com/view/Pull%20requests/job/gRPC-Java-PR-Windows/105/console
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1169
[OkHtpp] Correct windowUpdateWithInboundFlowControl test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1170
Clarify the audience of internal API.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1171
Resolve Netty hostname when connecting.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @zhangkun83 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1172
Allowing AbstractBufferingHandler to be extended.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1173
Idea: Expose Metadata from Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Status object is almost always created from Metadata; it would be logical to expose the Metadata from status.  This would make it possible to get access to the Trailers from a call without resorting to using Context or an Interceptor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1174
Make the header list size limit configurable on both client and serve side.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there no way of limiting this in OkHttp?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1175
Connection window should auto-refill
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Consider an application with 2 streams, A and B. A receives a stream of messages and the application pops off one message at a time and makes a request on stream B. However, if receiving of data on A has caused the connection window to collapse, B will not be able to receive any data and the application will deadlock. The only way (currently) to get around this is to use multiple connections for the streams, which would needlessly complicate the application code.
The C implementation already solves the problem by auto-refilling the connection window, so Java and the other languages should just follow suit here.
Created PR netty/netty#4423 in Netty to support configuring the local flow controller to auto-refill.  Until that's in, we should probably just set the connection window to MAX_INT for now.
@louiscryan @ejona86 @ctiller @a11r
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1176
Set connectionWindow to MAX_INT.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1177
V0.9.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1178
Allow client to specify ProtocolNegotiator in NettyChannelBuilder.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1179
Brew update twice, to work around Brew issue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1180
Use assertEquals instead of assertTrue(Range.contains)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1181
netty: IOException during connecting should map to UNAVAILABLE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We've seen an UNKNOWN status with cause of io.netty.channel.ConnectTimeoutException: connection timed out. This should be UNAVAILABLE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1182
Allow Netty server override for ProtocolNegotiator
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1183
Header handling performance improvements
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Before
Benchmark                                   (channelCount)  (maxConcurrentStreams)   Mode  Cnt      Score      Error  Units
UnaryCallQpsBenchmark.unary:callsPerSecond               4                      10  thrpt   20  56351.222 Â± 4321.110  ops/s

After
Benchmark                                   (channelCount)  (maxConcurrentStreams)   Mode  Cnt      Score      Error  Units
UnaryCallQpsBenchmark.unary:callsPerSecond               4                      10  thrpt   20  62603.657 Â± 4517.008  ops/s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1184
Remove the use of MoreObjects/Objects from CallOptions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Google-internal stuff that was on Guava 14 is no longer the case; it's all on HEAD now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1185
Migrating from Objects.ToStringHelper to MoreObjects.ToStringHelper.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1186
fix typo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1187
Use ServerBuilder interface in AbstractTransportTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1188
Any transport future in ClientCallImpl should be cancelled if the call is cancelled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Before the NameResolver returns any resolved address, the LoadBalancer issues blank transport futures to the channel, keeps track of them and will fulfill them when NameResolver returns something.
If the NameResolver takes too long or even forever to return something, the calls may exceed their deadlines, then be cancelled and may be retried. Today cancelling the call won't cancel the transport future it holds, this will become a leak in the LoadBalancer who keeps track of the blank transports. We will need to:

Change TransportSet.obtainActiveTransport() to return a new future each time. Today it returns the same future for all requests. Sometimes the future is passed directly to the call, and a call cancelling a future will unintentionally fail other calls.
Change ClientCallImpl to cancel the transport future when the call is cancelled, including deadline-exceeded.
Make sure the LoadBalancers remove cancelled blank futures from the tracking list.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1189
Can not build grpc-java in Linux Centos 7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I need to build grpc-java in Linux Centos 7 but had a problem, please help
../gradlew java_pluginExecutable
*** Building codegen requires Protobuf version 3.0.0-beta-1
*** Please refer to https://github.com/grpc/grpc-java/blob/master/COMPILING.md#how-to-build-code-generation-plugin
:grpc-compiler:compileJava_pluginExecutableJava_pluginCpp UP-TO-DATE
:grpc-compiler:linkJava_pluginExecutable
/usr/bin/ld: cannot find -lstdc++
collect2: error: ld returned 1 exit status
:grpc-compiler:linkJava_pluginExecutable FAILED
FAILURE: Build failed with an exception.


What went wrong:
Execution failed for task ':grpc-compiler:linkJava_pluginExecutable'.

A build operation failed.
Linker failed while linking protoc-gen-grpc-java.
See the complete log at: file:///home/rasdaman/test_server/rasdaman/GRPC/grpc/grpc_java_root/compiler/build/tmp/linkJava_pluginExecutable/output.txt



Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.


BUILD FAILED
Total time: 7.732 secs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1190
Implement Happy Eyeballs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With the addition of load balancing, the interaction with OkHttp connection handling has gotten a bit strange. OkHttp is currently ignoring the resolved address of the DnsNameResolver. In order to use the IP address returned by DnsNameResolver we would need to implement Happy Eyeballs. We will want to use Happy Eyeballs with Netty as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1191
Implement idle channel state or swap back to lazy TCP creation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With the addition of load balancing we are now actively reconnecting. If no RPCs are occurring on the channel we really want to drop all TCP connections, especially on mobile. Since GFE and other servers are likely to shut down idle connections, swapping back to lazy connection creation should be "good enough" for now, in case that is easier than implementing idle detection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1192
Improve usability of multi-valued ASCII keys
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For keys like Grpc-Accept-Encoding ["gzip", "deflate"] is semantically equivalent to ["gzip,deflate"]. We should have a utility or tweak our API to make encourage applications to handle multi-valued metadata correctly.
A separate but related issue is that users of Keys have to be aware of whether the key is for ascii or binary, since you are likely to use the get() methods differently between the two. It might be good to have some "meta" key that could behave identically between the two.
For example, we could have something like:
public interface MultivalueMarshaller<C,S> {
  List<S> splitValues(C combined);
  C combineValues(List<S> separate);
}
Which could be used as a special key:
new Metadata.Key.of("Grpc-Accept-Encoding", new MultivalueAcceptEncoding(), new AcceptEncodingMarshaller());

The key would always act as if there was only one value, and would typically be used with Metadata.get().
I'm not 100% sold on the example solution, because it seems we keep adding more and more layers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1193
Add simple tests for OkHttpProtocolNegotiator coverage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1194
Remove notion of stack from thread-local binding in Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1195
Add even more coverage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1196
Java to Java RPC calls, without the proto IDL files and Proxy apart from stub.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Java, the builtin RPC mechanism "RMI" and serialization mechanism is very old, and has many severe issues with timeouts, soft versioning, etc. So, with distributed java to java services which happens naturally when the services are evolved over time, the following kind of API is preferred which is a Java Proxy based instead of stub.
ExampleService exampleService = grpcClientManager.get(ExampleService.class).build();
exampleService.sayHello();

public interface ExampleService {
    public String sayHello();
    public Future<String> sayHi();
}
For Java-to-Java calls, Building stubs and IDL files are unintuitive and extra efforts, better to make use of marking the interfaces with annotations.  I searched and found a similarly implemented library called  Swift for Thrift . It would be great if grpc supports annotation based one,
Ex:https://github.com/facebook/fbthrift/blob/master/thrift/tutorial/java/swift/client/src/main/java/com/facebook/swift/exampleclient/ExampleService.java
I feel it is easier and simple, with Java proxy apart from stub. We will be able to always generate the proto IDL files from the java source for RPC with other languages.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1197
Update -bin header restrictions, and re introduce string interning.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1198
Minor cleanup of ClientCallImpl header normalization
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1199
Re add support for periods in metadata key names
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1200
Create BlankFutureProvider which is reused among LoadBalancers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1201
Add tests to ManagedChannelImpl and fix a minor uri parsing bug
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1202
Add directExecutor() to Channel and Server Builders. Fixes #368.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1203
Implementation of context binding for servers and clients
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 worth an initial review. Still adding unit tests for server but client unit tests and integration tests are in place
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1204
Switch to use Executor instead of ExecutorService where we don't need it
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some benchmarks
Before
Benchmark                                   (channelCount)  (maxConcurrentStreams)   Mode  Cnt       Score      Error  Units
UnaryCallQpsBenchmark.unary:callsPerSecond               1                      10  thrpt   20   12701.774 Â±  672.164  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               1                     100  thrpt   20   50460.543 Â± 1991.761  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               1                    1000  thrpt   20   43994.030 Â± 4627.185  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                      10  thrpt   20   25394.865 Â± 1172.532  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                     100  thrpt   20   83723.793 Â± 9044.291  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                    1000  thrpt   20   73084.762 Â± 9515.067  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                      10  thrpt   20   50828.970 Â± 4391.662  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                     100  thrpt   20  113618.368 Â± 1898.532  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                    1000  thrpt   20   97190.744 Â± 2162.832  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                      10  thrpt   20   81407.111 Â± 1622.743  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                     100  thrpt   20   62781.673 Â± 1714.861  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                    1000  thrpt   20   60119.207 Â± 3934.070  ops/s

After
Benchmark                                   (channelCount)  (maxConcurrentStreams)   Mode  Cnt       Score      Error  Units
UnaryCallQpsBenchmark.unary:callsPerSecond               1                      10  thrpt   20   14115.534 Â±  625.781  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               1                     100  thrpt   20   46233.564 Â± 6020.062  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               1                    1000  thrpt   20   51611.494 Â± 1194.361  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                      10  thrpt   20   47194.316 Â± 2706.383  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                     100  thrpt   20   85691.272 Â± 6258.795  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               2                    1000  thrpt   20   72939.409 Â± 8803.213  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                      10  thrpt   20   45257.520 Â± 2507.887  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                     100  thrpt   20  129795.210 Â± 4035.769  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               4                    1000  thrpt   20  106075.847 Â± 4250.647  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                      10  thrpt   20  120928.208 Â± 2365.616  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                     100  thrpt   20  155078.165 Â± 4040.154  ops/s
UnaryCallQpsBenchmark.unary:callsPerSecond               8                    1000  thrpt   20  105319.533 Â± 3551.960  ops/s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1205
Context deadline propagation should cascade
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a server receives an RPC with a deadline, does work and issues RPCs as part of the contract of fulfilling that outer RPC then those inner RPCs should carry the outer deadline to the downstream servers.
Deadlines should be propagated explicitly in metadata for logging purposes as well as being propagated by cascading cancellation via Context.
Relatedly it should be simple for servers to opt out of deadline propagation when use-cases demand it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1206
Resolve whether context cancellation propagates depth-first or breadth-first
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current context cancellation order is unspecified.
Suggested algorithm is breadth-first so that higher level work is cancelled before lower-level work. The primary reason for this is that if higher-level work is cleanly cancelled then it can cleanly handle / ignore errors bubbling up from the cancellation of lower-level work. In depth-first it would be hard for higher-level work to distinguish between the failure modes bubbling up from lower-level work.
@lukesandberg
@adriancole
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1207
Minor refactor of decompression handling server side
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1208
Fix placeholder in the error message of Preconditions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1209
Notify listeners before notifying child contexts of cancellation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1210
Enable LB and Naming for Netty.forAddress(String,int)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1211
Target name processing doesn't handle IPv6 well
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[::1]:80 would appear to be a valid target name, but doesn't work with our current naming. %5B::1%5D:80 would work though. We need to define what should happen with IPv6 addresses and make any necessary changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1212
How should basic LB interact with reconnect
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a server is available on both IPv4 and IPv6, then it will have two addresses and we will perform reconnects on the two independently. That doesn't seem too bad. Although if one of them works and the other doesn't some RPCs may occasionally (say, because we got a GOAWAY on the good connection) be routed to the bad IP's transport where it might get "stuck" for a while before erring. This could probably be solved by waiting until transports are healthy before assigning RPCs.
Some hosts have many more IPs, such as google.com which has 11 IPv4 and one 1 IPv6. Having 12 TransportSets each trying to connect with independent backoff seems "not great." It's unclear what the behavior should be though. Maybe combine the backoff between all the IPv4 addresses and pick the next for each attempt?
Note also that there is interaction with #1191, since any TransportSet used once will effectively forever continue trying to connect, even if we have other transports to the same host that are healthy.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1213
Upgrading to Netty 4.1.0.Beta8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1214
Split out server call impl, add explicit tests and remove an impossble case
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1215
Okhttp transport should use resolved address.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, OkHttp transport resolves the host name by itself, the underlying implementation tries all the resolved address one by one, until one connected successfully.
We should only connect with the passed-in resolved address, and shutdown the transport if it can not connect, let the load balance channel layer creates a new transport with a new address.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1216
grpc OOME and NPE in simple JMH benchmark
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
First I post here and put all things in this gist.
The problem is the memory goes very high, sooner or later will cause OOME, and there is a strange NPE
Exception in thread "grpc-default-executor-68" java.lang.OutOfMemoryError: Direct buffer memory
    at java.nio.Bits.reserveMemory(Bits.java:658)
    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)
    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
    at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:645)
    at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:228)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:204)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:132)
    at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:262)
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:157)
    at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:93)
    at io.grpc.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:66)
    at io.grpc.internal.MessageFramer.writeKnownLength(MessageFramer.java:182)
    at io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:135)
    at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:125)
    at io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:165)
    at io.grpc.internal.AbstractServerStream.writeMessage(AbstractServerStream.java:108)
    at io.grpc.internal.ServerImpl$ServerCallImpl.sendMessage(ServerImpl.java:496)
    at io.grpc.stub.ServerCalls$ResponseObserver.onNext(ServerCalls.java:241)
    at play.bench.BenchGRPC$CounterImpl$1.onNext(BenchGRPC.java:194)
    at play.bench.BenchGRPC$CounterImpl$1.onNext(BenchGRPC.java:191)
    at io.grpc.stub.ServerCalls$2$1.onMessage(ServerCalls.java:191)
    at io.grpc.internal.ServerImpl$ServerCallImpl$ServerStreamListenerImpl.messageRead(ServerImpl.java:546)
    at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1.run(ServerImpl.java:417)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
io.grpc.StatusRuntimeException: CANCELLED
    at io.grpc.Status.asRuntimeException(Status.java:430)
    at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:266)
    at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$3.run(ClientCallImpl.java:320)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$2@312546d9
java.lang.NullPointerException
    at io.netty.buffer.PoolChunk.initBufWithSubpage(PoolChunk.java:378)
    at io.netty.buffer.PoolChunk.initBufWithSubpage(PoolChunk.java:369)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:194)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:132)
    at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:262)
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:157)
    at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:93)
    at io.grpc.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:66)
    at io.grpc.internal.MessageFramer.writeKnownLength(MessageFramer.java:182)
    at io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:135)
    at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:125)
    at io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:165)
    at io.grpc.internal.AbstractServerStream.writeMessage(AbstractServerStream.java:108)
    at io.grpc.internal.ServerImpl$ServerCallImpl.sendMessage(ServerImpl.java:496)
    at io.grpc.stub.ServerCalls$ResponseObserver.onNext(ServerCalls.java:241)
    at play.bench.BenchGRPCOOME$CounterImpl.inc(BenchGRPCOOME.java:150)
    at play.bench.CounterServerGrpc$1.invoke(CounterServerGrpc.java:171)
    at play.bench.CounterServerGrpc$1.invoke(CounterServerGrpc.java:166)
    at io.grpc.stub.ServerCalls$1$1.onHalfClose(ServerCalls.java:154)
    at io.grpc.internal.ServerImpl$ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerImpl.java:562)
    at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$2.run(ServerImpl.java:432)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1217
Updating the server1 cert so that it can be used with Go.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1218
Add Decompressor method to ServerStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We don't want to do this as part of your other PR, since it is actually dependent on this change and would be part of the refactor?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1219
Auto-refill connection window
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1220
Move decompressor setting to the AbstractServerStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1221
Consider allowing clients to provide cancellation details
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When designing Context we decided that cancel(Throwable) could be useful for debugging where a cancellation came from. In general, I'm not a fan of using that information for changing behavior, but it is very helpful for debugging.
Currently ClientCall.cancel() does not accept any arguments, because there is no way for the client to inform the server of any reasoning (and aren't too interested in that scenario, because servers can't really trust clients too much). When reviewing #1203, I saw that Context auto-propagation can make it quite opaque why a call was cancelled. We could have ClientCall.cancel(String desc, Throwable t) which will end up notifying the application onClose() with a Status.CANCELLED.withDescription(desc).withCause(t).
That would allow us to propagate a Context's failure exception as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1222
Fix build failure due to unused import.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM ... feel free to incorporate whichever way you'd prefer :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1223
Clarify specs for target strings, especially for IPv6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Resolves #1211
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1224
Implement QpsWorker for Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
go/grpc-performance-testing-setup
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1225
NPE in ProtoInputStream.drainTo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.lang.NullPointerException: null
        at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:210)
        at com.google.common.io.ByteStreams.copy(ByteStreams.java:65)
        at io.grpc.protobuf.ProtoInputStream.drainTo(ProtoInputStream.java:74)
        at io.grpc.internal.MessageFramer.writeToOutputStream(MessageFramer.java:224)
        at io.grpc.internal.MessageFramer.writeKnownLength(MessageFramer.java:185)
        at io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:135)
        at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:125)
        at io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:165)
        at io.grpc.internal.ClientCallImpl.sendMessage(ClientCallImpl.java:204)
        at com.google.cloud.bigtable.grpc.io.ReconnectingChannel$DelayingCall.sendMessage(ReconnectingChannel.java:122)
        at io.grpc.ForwardingClientCall.sendMessage(ForwardingClientCall.java:65)

It looks like if you call drainTo() twice then it will NPE. Calling drainTo() twice is sort of strange, so I wouldn't expect this to be critical, but we should still not NPE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1226
A failing test deletes Messages.java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running ./gradlew build, if a test fails part way through protobuf-nano/src/generated/test/javanano/io/grpc/protobuf/nano/Messages.java  is deleted.  This causes noise when running git status or other git commands.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1227
Expose message compression on Server Call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1228
OkHttpClientStream should coalesce pending flushes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In OkHttpClientStream.start(), there may be pending data to write.  If multiple of the writes ask to flush, they should  be coalesced into a single flush at the end.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1229
Update the out of date Java doc for ClientTransport.newStream(), and â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1230
[okhttp] Use upper layer passed-in resolved address instead of resolvâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For the test, it's hard to write a single test to verify this behavior, so I ended up with two separate tests:

In the ManagedChannelImplTest, verifies that when the ClientTransport.start() calls listener.transportShutdown(), the retry will use the second resolved address.
In the OkHttpClientTransportTest, verifies that calling start() with an address to an unreachable server will trigger listener.transportShutdown().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1231
Move the pick-first logic from SimpleLoadBalancer to TransportSet.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1232
Map IOException during connecting to UNAVAILABLE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1233
coalesce pending flushes in OkHttpClientStream.start().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1234
Move delayed stream out of ClientCallImpl, and add tests for createStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1235
Reduce advertised Netty API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1236
Remove double-"brew update" as now unnecessary
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1237
ScheduledExecutorService won't log the exception if the task throws
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unlike Executor.execute(), which lets the thread's default exception handler to log anything thrown from the task, ScheduledExecutorService.schedule() expects you to get the exceptions from the returned ScheduledFuture, and will not log the exceptions.
As we want to log everything thrown from inside the executors, and don't want to check the ScheduledFuture each time we use ScheduledExecutorService, we probably need to create our own ScheduledExecutorService that logs the exceptions and avoid using the vanilla version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1238
hello-world-server example fails with Java 7 and long hostname
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The failures seems to be this old JDK bug:
http://mail.openjdk.java.net/pipermail/net-dev/2012-July/004603.html
I couldn't figure out where getLocalHostName() was getting invoked from within the gRPC code, however. It would be nice to be able to work around this somehow. Possibly by registering some kind of custom resolver?
$ ./build/install/grpc-examples/bin/hello-world-server
*** buffer overflow detected ***: /usr/lib/jvm/java-7-openjdk-amd64/bin/java terminated
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(__fortify_fail+0x37)[0x7f49a48a30e7]
/lib/x86_64-linux-gnu/libc.so.6(+0xeefa0)[0x7f49a48a1fa0]
/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libnet.so(Java_java_net_Inet4AddressImpl_getLocalHostName+0x1b2)[0x7f4998a6faf2]
[0x7f499ef94d98]
======= Memory map: ========
00400000-00401000 r-xp 00000000 08:01 413464                             /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
00600000-00601000 r--p 00000000 08:01 413464                             /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
00601000-00602000 rw-p 00001000 08:01 413464                             /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
0142d000-01601000 rw-p 00000000 00:00 0                                  [heap]
80600000-81b00000 rw-p 00000000 00:00 0 
81b00000-8ac00000 rw-p 00000000 00:00 0 
8ac00000-8fa00000 rw-p 00000000 00:00 0 
8fa00000-d8e80000 rw-p 00000000 00:00 0 
d8e80000-db600000 rw-p 00000000 00:00 0 
db600000-100000000 rw-p 00000000 00:00 0 
7f4992f5f000-7f4992f67000 r-xp 00000000 08:01 413530                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libmanagement.so
7f4992f67000-7f4993166000 ---p 00008000 08:01 413530                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libmanagement.so
7f4993166000-7f4993167000 r--p 00007000 08:01 413530                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libmanagement.so
7f4993167000-7f4993168000 rw-p 00008000 08:01 413530                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libmanagement.so
7f4993168000-7f4993179000 r-xp 00000000 08:01 413516                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libnio.so
7f4993179000-7f4993378000 ---p 00011000 08:01 413516                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libnio.so
7f4993378000-7f4993379000 r--p 00010000 08:01 413516                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libnio.so
7f4993379000-7f499337a000 rw-p 00011000 08:01 413516                     /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libnio.so
7f499337a000-7f49933b6000 r-xp 00000000 08:01 145083                     /lib/x86_64-linux-gnu/libpcre.so.3.13.1
7f49933b6000-7f49935b6000 ---p 0003c000 08:01 145083                     /lib/x86_64-linux-gnu/libpcre.so.3.13.1
7f49935b6000-7f49935b7000 rw-p 0003c000 08:01 145083                     /lib/x86_64-linux-gnu/libpcre.so.3.13.1
7f49935b7000-7f49935c3000 r-xp 00000000 08:01 411786                     /usr/lib/x86_64-linux-gnu/libffi.so.5.0.10
7f49935c3000-7f49937c3000 ---p 0000c000 08:01 411786                     /usr/lib/x86_64-linux-gnu/libffi.so.5.0.10
7f49937c3000-7f49937c4000 rw-p 0000c000 08:01 411786                     /usr/lib/x86_64-linux-gnu/libffi.so.5.0.10
7f49937c4000-7f49937c5000 r-xp 00000000 08:01 411789                     /usr/lib/x86_64-linux-gnu/libgthread-2.0.so.0.3200.4
7f49937c5000-7f49939c4000 ---p 00001000 08:01 411789                     /usr/lib/x86_64-linux-gnu/libgthread-2.0.so.0.3200.4
7f49939c4000-7f49939c5000 r--p 00000000 08:01 411789                     /usr/lib/x86_64-linux-gnu/libgthread-2.0.so.0.3200.4
7f49939c5000-7f49939c6000 rw-p 00001000 08:01 411789                     /usr/lib/x86_64-linux-gnu/libgthread-2.0.so.0.3200.4
7f49939c6000-7f49939d9000 r-xp 00000000 08:01 131451                     /lib/x86_64-linux-gnu/libresolv-2.13.so
7f49939d9000-7f4993bd8000 ---p 00013000 08:01 131451                     /lib/x86_64-linux-gnu/libresolv-2.13.so
7f4993bd8000-7f4993bd9000 r--p 00012000 08:01 131451                     /lib/x86_64-linux-gnu/libresolv-2.13.so
7f4993bd9000-7f4993bda000 rw-p 00013000 08:01 131451                     /lib/x86_64-linux-gnu/libresolv-2.13.so
7f4993bda000-7f4993bdc000 rw-p 00000000 00:00 0 
7f4993bdc000-7f4993bfa000 r-xp 00000000 08:01 131420                     /lib/x86_64-linux-gnu/libselinux.so.1
7f4993bfa000-7f4993df9000 ---p 0001e000 08:01 131420                     /lib/x86_64-linux-gnu/libselinux.so.1
7f4993df9000-7f4993dfa000 r--p 0001d000 08:01 131420                     /lib/x86_64-linux-gnu/libselinux.so.1
7f4993dfa000-7f4993dfb000 rw-p 0001e000 08:01 131420                     /lib/x86_64-linux-gnu/libselinux.so.1
7f4993dfb000-7f4993dfc000 rw-p 00000000 00:00 0 
7f4993dfc000-7f4993dff000 r-xp 00000000 08:01 411790                     /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0.3200.4
7f4993dff000-7f4993ffe000 ---p 00003000 08:01 411790                     /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0.3200.4
7f4993ffe000-7f4993fff000 r--p 00002000 08:01 411790                     /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0.3200.4
7f4993fff000-7f4994000000 rw-p 00003000 08:01 411790                     /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0.3200.4
...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1239
Add integration test for disabled GCM
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Disabling GCM is common when using Jetty ALPN+JDK7 (not available) or JDK8 (for performance reasons). We should add a test to verify that non-GCM connection succeed, similar to the existing NPN tests.
With tcnative, there is little reason to use GCM, but not everyone has swapped from Jetty ALPN yet. This seems Netty-specific, since Android should be making use of the security provider which doesn't have the same issue as normal Java.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1240
Custom Serialization [question]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello guys,
Do you think that it is feasible using the current codebase, to avoid using protocol buffers and switch to another serialization mechanism? If so, can you point me to the places where one should do it ?
Regards, B.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1241
Connections handling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello! Is it possible to handle connections(their statuses) on the server side?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1242
Grpc fails to build from clean on Windows x64 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I suspect that the fix for this is simple, but it's still bad experience to have gradle.bat build fail on the first run.  I included the log file from trying to build.  The error happens in integration tests with "Received close_notify during handshake"
log.txt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1243
Update Android interop test App to use ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1244
[Android-interop-test] Fail the instrumentation if any exception is tâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1245
When creating Status from Throwable retain the outer exception as the cause
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 minor improvement
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1246
Shut down NameResolver when shutting down Channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1247
Lint
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1248
Add cascading cancellation tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1249
Add compressor registry, and auto negotiate compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1250
Keep our certs used for testing the same with their internal version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The certs for this have problems interacting with the Go Interop test.  Can you try running the entire grpc interop suite before submitting this?  It should be as simple as:
tools/run_tests/run_interop_tests.py -s all -l all --http2_interop --use_docker
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1251
Netty Server does not observe channelInactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If the TCP connection goes down, gRPC isn't noticing because nothing is observing the channelInactive() notification on the channel pipeline. I confirmed that channelInactive() is called, but saw that an outstanding streaming RPC was not cancelled.
This likely applies to both client-side and server-side; I only verified it broken on server-side.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1252
Add missing @RunWith, it is required internally
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly Nice catch, LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1253
ClientCallImpl operations race with Context cancellation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With be60086, we don't create the stream when the Context is cancelled, so the following request(), sendMessage(), halfClose() will encounter an IllegalStateException like:
java.lang.IllegalStateException: Not started
    at com.google.common.base.Preconditions.checkState(Preconditions.java:178)
    at io.grpc.internal.ClientCallImpl.request(ClientCallImpl.java:257)
    at io.grpc.ForwardingClientCall.request(ForwardingClientCall.java:50)
    at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:199)
    at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:173)
    at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:135)

@louiscryan, FYI, I'll send you a PR to fix it soon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1254
Remove outdated and misleading JavaDoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1255
Call ClientStreamListener directly from current thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1256
Should ClientCall.cancel be thread-safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If it were thread-safe, we would no longer throw IllegalStateException for other methods when closed.
Internally cancel is already thread-safe. The main question is whether it is more useful for applications to cancel calls without synchronization or to notice bugs where they write to closed calls. There is also a question of whether having cancel be thread-safe causes undue burden to interceptors.
This is technically an API change, but mostly just relaxes the API. Interceptors are the only things that may not necessarily support the new semantics, but most should simply delegate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1257
Create a No-op stream in ClientCallImpl.start() if the Context has beâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM, but we should eventually use the same implementation with DelayedStream.NOOP_CLIENT_STREAM as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1258
Don't leak streams and avoid creating cancelled streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1259
The GRPCLB LoadBalancer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1260
Close active streams on channelInactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1261
Replace name in TODO to a known name, otherwise MOE will complain aboâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1262
Close active streams on channelInactive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1263
Expose compression on ClientCall and Server Call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1264
Make TestUtils able to read from input stream.  This makes it easier â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1265
use maven plugin can not generate service code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use maven plugin(maven-protoc-plugin) for generating grpc code,but i only can generate message.please help me,thx~
command: mvn protoc:compile
proto file:
syntax = "proto3";

package com.test;

option java_multiple_files = false;
option java_package = "com.test";
option java_outer_classname = "SMS";
option java_generic_services = true;

message SMSRequest {
    string phone_num = 1;
}

message SMSResponse {
    int32 code = 1;
    string time = 2;
    string message = 3;
}

service SMSService {
    rpc register(SMSRequest) returns (SMSResponse);
}
compile info:
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: osx
[INFO] os.detected.arch: x86_64
[INFO] os.detected.classifier: osx-x86_64
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test.server.sms.test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-protoc-plugin:0.4.2:compile (default-cli) @ test.server.sms.test ---
Downloading: https://repo.maven.apache.org/maven2/com/google/protobuf/protoc/3.0.0-beta-1/protoc-3.0.0-beta-1.pom
Downloaded: https://repo.maven.apache.org/maven2/com/google/protobuf/protoc/3.0.0-beta-1/protoc-3.0.0-beta-1.pom (5 KB at 1.8 KB/sec)
Downloading: https://repo.maven.apache.org/maven2/com/google/protobuf/protoc/3.0.0-beta-1/protoc-3.0.0-beta-1-osx-x86_64.exe
Downloaded: https://repo.maven.apache.org/maven2/com/google/protobuf/protoc/3.0.0-beta-1/protoc-3.0.0-beta-1-osx-x86_64.exe (5481 KB at 525.7 KB/sec)
[INFO] Compiling 1 proto file(s) to /Users/app/Desktop/a/test.server.sms.test/target/generated-sources/protobuf/java
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 14.208 s
[INFO] Finished at: 2015-12-09T01:21:42+08:00
[INFO] Final Memory: 10M/191M
[INFO] ------------------------------------------------------------------------

Process finished with exit code 0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1266
Move default scheme decision from ManagedChannelImpl to NameResolverFactory.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1267
Fine-tune pick-first logic to honor address order
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Naming systems may sort the addresses so that an address that appears earlier has higher priority, which means being closer and/or faster. We may want to take this into consideration when reconnecting.
Today, if a connection was made successfully and later disconnected, we try reconnecting starting from the next address, and if that succeeds we will stick with it while it may be inferior to the first addresses that may also be working.
A better approach could be starting from the first address if we just disconnected from an address that have been working. However, we should be careful of servers that can be connected and even go through TLS handshake, but have trouble serving actual RPCs. We don't want be trapped in such pitfalls. A safe logic may be: start at the beginning of the list only if the previous address has served a reasonable amount of RPC traffic.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1268
Avoid unnecessary reconnect due to addresses being reshuffled in EquivalentAddressGroup
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today if the addresses in an EquivalentAddressGroup are reshuffled (which DNS might do), ManagedChannelImpl will see it as a different EquivalentAddressGroup, and creates a new TransportSet for it, which is wasteful. We need to find a way to update the address list in and reuse the original TransportSet.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1269
Revert to lazy-connection.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1270
Move ServerCall unary check and add tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1271
Fix bug where server wouldn't declare the negotiated compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1272
Don't use thread context's class loader for Android.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As http://stackoverflow.com/questions/13407006/android-class-loader-may-fail-for-processes-that-host-multiple-applications says, if users use android:sharedUserId or android:process, the thread context's class loader will be replaced with a dummy implementation.
And calling Thread.currentThread().setContextClassLoader() before whenever the ManagedChannelBuilder is created is silly.
After discussed with @ejona86, we agreed to use this.getClass().getClassLoader() for Android case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1273
Use getClassLoader() instead of Thread.currentThread().getContextClasâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1274
TESTING Use brew to install protobuf on Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There isn't a dev bottle available, so no real benefit to building ourselves.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1275
Swap to "old" link for OpenSSL download with Travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What's the motivation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1276
Implement Channel IDLEness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are currently lazy-initializing transports in order to allow the Channel to reach a state similar to IDLE. However, we should actively disconnect the TCP connection after inactivity in order to not rely on server idle checks and to comply with the gRPC IDLE semantics.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1277
Resource leak in v0.9.0 and v0.12.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After running GRPC for a while I get the following error (with io.netty.leakDetection.level=advanced):
LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 1
#1:
    Hint: 'DefaultChannelPipeline$HeadContext#0' will handle the message from this point.
    io.netty.buffer.CompositeByteBuf.touch(CompositeByteBuf.java:1615)
    io.netty.buffer.CompositeByteBuf.touch(CompositeByteBuf.java:42)
    io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:264)
    io.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeData(DefaultHttp2FrameWriter.java:142)
    io.netty.handler.codec.http2.Http2OutboundFrameLogger.writeData(Http2OutboundFrameLogger.java:42)
    io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData.write(DefaultHttp2ConnectionEncoder.java:356)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.write(DefaultHttp2RemoteFlowController.java:674)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.writeBytes(DefaultHttp2RemoteFlowController.java:645)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.writeAllocatedBytes(DefaultHttp2RemoteFlowController.java:544)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.visit(DefaultHttp2RemoteFlowController.java:44)
    io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1100)
    io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.writePendingBytes(DefaultHttp2RemoteFlowController.java:310)
    io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:204)
    io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355)
    io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:272)
    io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:997)
    io.netty.channel.AbstractChannel.flush(AbstractChannel.java:226)
    io.grpc.netty.WriteQueue.flush(WriteQueue.java:131)
    io.grpc.netty.WriteQueue.access$000(WriteQueue.java:48)
    io.grpc.netty.WriteQueue$1.run(WriteQueue.java:58)
    io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
    io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    java.lang.Thread.run(Thread.java:745)
Created at:
    io.netty.buffer.CompositeByteBuf.<init>(CompositeByteBuf.java:63)
    io.netty.buffer.AbstractByteBufAllocator.compositeDirectBuffer(AbstractByteBufAllocator.java:193)
    io.netty.buffer.AbstractByteBufAllocator.compositeBuffer(AbstractByteBufAllocator.java:171)
    io.netty.channel.CoalescingBufferQueue.compose(CoalescingBufferQueue.java:156)
    io.netty.channel.CoalescingBufferQueue.remove(CoalescingBufferQueue.java:132)
    io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder$FlowControlledData.write(DefaultHttp2ConnectionEncoder.java:351)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.write(DefaultHttp2RemoteFlowController.java:674)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.writeBytes(DefaultHttp2RemoteFlowController.java:645)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.writeAllocatedBytes(DefaultHttp2RemoteFlowController.java:544)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.visit(DefaultHttp2RemoteFlowController.java:44)
    io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.forEachActiveStream(DefaultHttp2Connection.java:1100)
    io.netty.handler.codec.http2.DefaultHttp2Connection.forEachActiveStream(DefaultHttp2Connection.java:135)
    io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.writePendingBytes(DefaultHttp2RemoteFlowController.java:310)
    io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:204)
    io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355)
    io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:272)
    io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:997)
    io.netty.channel.AbstractChannel.flush(AbstractChannel.java:226)
    io.grpc.netty.WriteQueue.flush(WriteQueue.java:131)
    io.grpc.netty.WriteQueue.access$000(WriteQueue.java:48)
    io.grpc.netty.WriteQueue$1.run(WriteQueue.java:58)
    io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
    io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356)
    io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    java.lang.Thread.run(Thread.java:745)

This looks similar to #336 but not quite identical. This happens on a 64-bit Linux machine running Oracle Java 1.8.0. I'm happy to provide more information if required.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1278
Don't compress empty messages.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If given a zero byte message, compression should not be enabled.  Decompression is fair game.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1279
Some changes to Android interop test App:
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@madongfly LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1280
Provide client service definition for frameworks to avoid reflection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An API similar to the existing ServerServiceDefnition would be great for the client side. Such an API would remove the necessity of reflection

ClientServiceDefinition d = GeneratedServiceGrpc.getDefinition();
d.getMethods() -> returns the method descriptors
d.getServiceName()
d.createFutureClientStub(channel, ...) -> creates a new Future Stub 
d.createBlockingClientStub(channel, ...)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1281
Check that zero length messages don't get the compression bit set.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #1278
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1282
Cancel the transport future when the call is cancelled.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1283
[code refactor]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1284
Propagate headers/trailers if response isn't gRPC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I discussed with some other devs, and there weren't major concerns. Still some people in the wider grpc team to discuss with, but in general it isn't viewed as outrageous.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1285
Fix gaurded by
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1286
Bump test coverage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1287
More each coverage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1288
Removed unsused variables
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1289
Allow support for nanosecond timeouts, and use nanoseconds consistentâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo is there a specific reason for allowing nanos? I wouldn't expect ScheduledThreadPoolExecutor to be anywhere close to nanosecond accuracy?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1290
Propagate RuntimeException's back to caller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using ManagedChannelImpl, if a method of ClientCall.Listener (possibly also of ClientCall itself) throws a RuntimeException, the exception propagates up into SerializingExecutor. The executor will log it under SEVERE but cannot take corrective action. The thread initiating ClientCalls.blockingUnaryCall or its cousins will block forever waiting for a response.
Ideally, the exception should be thrown back in the thread that called blockingUnaryCall.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1291
GrpclbLoadBalancerTest is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Depending on how fast the balancing() test method is run, it can sometimes mix up the results of the transports.  I have disabled the test in the mean time, with a todo to re enable it.
java.lang.AssertionError: expected same:<Transport for [address=/127.0.0.1:4000, attrs={}]> was not:<Transport for [address=/127.0.0.1:4001, attrs={}]>
    at org.junit.Assert.fail(Assert.java:88)
    at org.junit.Assert.failNotSame(Assert.java:737)
    at org.junit.Assert.assertSame(Assert.java:680)
    at org.junit.Assert.assertSame(Assert.java:691)
    at io.grpc.grpclb.GrpclbLoadBalancerTest.balancing(GrpclbLoadBalancerTest.java:154)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1292
Make BlankFutureProvider preserve the order.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1293
[OkHttp]Add hostname verification.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Netty is calling SSLParameters.setEndpointIdentificationAlgorithm("HTTPS") to enable the verification, according to http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html, HTTPS corresponding to RFC2818.
So we use com.android.okhttp.internal.tls.OkHostnameVerifier (which claims be consistent with RFC2818) to do the work.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1294
Split start from newCall, and specify method calling order restrictions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1295
Java - Write sample code for setting and reading error details
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java issue for grpc/grpc#4543.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1296
Use a List in BlankFutureProvider instead of LinkedHashSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Objects added to blankFutures are created just before being added, so it is guaranteed there won't be duplicates. The only operations for supporting the API are add() and iterate(). Thus, ArrayList and LinkedList are both strictly better than LinkedHashSet.
Previously, a ConcurrentHashMap was used which allowed greater concurrency, but since #1292 added guaranteed completion order full synchronization is necessary.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1297
GRPCLB fallback mode.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1298
Update type and comment in Timeoutmarshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1299
Add interfaces to generated rpc service classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, service stub classes (not sure if it's the best name to call it) generated by gRPC don't implement any interfaces (
  
    
      grpc-java/examples/src/generated/main/grpc/io/grpc/examples/helloworld/GreeterGrpc.java
    
    
         Line 17
      in
      59c1a6a
    
  
  
    

        
          
           public class GreeterGrpc { 
        
    
  

). It makes it impossible to dynamically build server composed of service classes provided in users's app via annotations for example.
I propose we create a GrpcServiceStub interface defining at least bindService (but we should probably add newStub, newBlockingStub and newFutureStub to it as well) so that we can easily cast Class objects to GrpcServiceStub and dynamically build server.
Also, it would be nice to add marker interface (``GrpcService`) to the service interfaces (
  
    
      grpc-java/examples/src/generated/main/grpc/io/grpc/examples/helloworld/GreeterGrpc.java
    
    
         Line 48
      in
      59c1a6a
    
  
  
    

        
          
           public static interface Greeter { 
        
    
  

) for the same reasons.
What do you think?
cc @jh
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1300
missing io/netty/util/ByteString
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I am trying to made a simple Grpc client and a server for it.
And this is the code for the client
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.netty.NettyChannelBuilder;

public class GrpcClient {
    ManagedChannel grpcChannel = NettyChannelBuilder.forAddress("127.0.0.1", 2009)
            .usePlaintext(true)
            .build();

    public GrpcClient() {   
    }
    public static void main(String[] args) {
        new GrpcClient();
    }   
}
And I get a error every time I run it.
And this is it
Exception in thread "main" java.lang.NoClassDefFoundError: io/netty/util/ByteString
    at io.grpc.netty.Utils.<clinit>(Utils.java:65)
    at io.grpc.netty.NettyChannelBuilder$NettyTransportFactory.<init>(NettyChannelBuilder.java:245)
    at io.grpc.netty.NettyChannelBuilder$NettyTransportFactory.<init>(NettyChannelBuilder.java:217)
    at io.grpc.netty.NettyChannelBuilder.buildTransportFactory(NettyChannelBuilder.java:194)
    at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:91)
    at com.alibaba.geabase.GrpcClient.<init>(GrpcClient.java:10)
    at com.alibaba.geabase.GrpcClient.main(GrpcClient.java:18)
Caused by: java.lang.ClassNotFoundException: io.netty.util.ByteString
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)

The server had the same problem when I was using grpc-all-0.9.0, and turned back to normal when switch to grpc-all-0.9.0-2.jar. But client still fails. I also update netty to 4.1.0 to fix the problem.
I really needs your help. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1301
Updates the README.md to add instructions to start test server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1302
Fix issues discovered by internal GRPCLB integration test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1303
Status.augmentDescription violates spec
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From Justin Rudd on mailing list...
Status.augmentDescription adds a '\n' (byte value 10) to the description of a Status which ends up in the header "grpc-message". But the value of "grpc-message" is dropped because of the method isSpecCompliantAscii in TransportFrameUtil.
I've worked around it by just not using augmentDescription. But I thought you'd like to know.
Also, it would be awesome if Status allowed for adding custom headers.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1304
Time for the first time a rpc service is used is way longer than that of the following usage.  
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I would first paste my snippet here
public void testOriginalAPI() {
    ManagedChannel grpcChannel = NettyChannelBuilder.forAddress("127.0.0.1", 60000)
            .usePlaintext(true)
            .build();

    QueryServiceInterfaceBlockingStub blockingStub =  QueryServiceInterfaceGrpc.newBlockingStub(grpcChannel);
    QueryProtocol.QueryRequest request = QueryProtocol.QueryRequest.newBuilder().setQueryString("hello").build();
    long start = System.currentTimeMillis();
    QueryProtocol.ResultInJson result = blockingStub.queryToJson(request);
    long end = System.currentTimeMillis();
    long duration = end - start;
    System.out.println("Time for first query with original API: " + duration);

    start = System.currentTimeMillis();
    result = blockingStub.queryToJson(request);
    end = System.currentTimeMillis();
    duration = end - start;
    System.out.println("Time for second query with original API: " + duration);
}

And what I got from the output is:
Time for first query with original API: 500ms
Time for second query with original API: 11ms

It seems that the grpc channel is opened right at the first time it is used.
Is there any way I can get the real connection before I use it to get feedback from server.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1305
More information for debugging.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1306
OkHttp Client stream and transport are tightly coupled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The interaction between the client stream and transport for OkHttp stream starting is tightly coupled.  As brought up in #1294, we should take a look at how these two classes interact and make some clear boundaries (or possibly merge them).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1307
ScheduledFutureTask cancellation does not guarantee queue removal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GRPC users using timeout may observe a memory leak when using long RPC timeouts with calls that complete quickly.
In ClientCallImpl we add a Runnable to trigger the timeout to a ScheduledExecutorService and retain a ScheduledFuture to that we can cancel the timeout if the call completes before that time.
The issue is that calling ScheduleFuture.cancel is not guaranteed to remove the task from the executors queue and so a leak of ClientCallImpl and its retained objects can occur.
We use ScheduledThreadPoolExecutor as the default and can call setRemoveOnCancelPolicy(true) to cause the task to be correctly removed from the queue. We would need a strong guarantee that a ScheduledExecutorService with this behavior is being used to rely on it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1308
Fix memory leak with cancellation timeouts
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1309
Update Compression API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 friendly ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1310
how can i use protocol buffer's message toString() method for utf8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to print protocol buffer's message log in console ,but i use toString() method and get below info.how can i use toString for utf8,thx.
logger.info(xx.toString());
result is:
message: "\347\231\276\345\272\246\345\234\260\345\233\276\350\260\203\347\224\250\345\244\261\350\264\245:\345\205\254\351\246\206,\351\224\231\350\257\257\347\240\201:1"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1311
Exception when configuring SSL: "Jetty ALPN/NPN has not been properly configured." (and possible solution)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am unable to configure an SSL gRPC.
SslContextBuilder sslBuilder = GrpcSslContexts.forServer(new File("a"), new File("b"))
sslBuilder.build();

Causes this exception:
Exception in thread "main" java.lang.IllegalArgumentException: Jetty ALPN/NPN has not been properly configured.
        at io.grpc.netty.GrpcSslContexts.selectApplicationProtocolConfig(GrpcSslContexts.java:143)
        at io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:120)
        at io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:109)
        at io.grpc.netty.GrpcSslContexts.forServer(GrpcSslContexts.java:90)

I think the root cause is here:
/**
   * Indicates whether or not the Jetty ALPN jar is installed in the boot classloader.
   */
  static boolean isJettyAlpnConfigured() {
    try {
      Class.forName("org.eclipse.jetty.alpn.ALPN", true, null);
      return true;
    } catch (ClassNotFoundException e) {
      return false;
    }
  }

This method is restricting the search to the boot classloader, which I don't think is correct. i.e. in the following code, the first line executes fine, but the second line throws CNFE (despite the class being loaded), causing isJettyAlpnConfigured() to return false:
System.out.println("Class loaded? " + org.eclipse.jetty.alpn.ALPN.class);
System.out.println("Maybe not: " + Class.forName("org.eclipse.jetty.alpn.ALPN", true, null));

I suspect the Class.forName(String) variant should be used instead (which doesn't throw CNFE), but maybe there was some good rationale for restricting to the boot classpath?
FWIW I am using alpn-api-1.1.2.v20150522.jar with the following other deps:
grpc-all-0.9.0.jar
hpack-0.10.1.jar
netty-all-4.1.0.Beta6.jar
okhttp-2.4.0.jar
okio-1.6.0.jar
protobuf-java-3.0.0-beta-1.jar
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1312
gRPC distributed deployment (load-balancing)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, æ‚¨å¥½ã€‚å¦‚æžœæˆ‘åœ¨å¤šå°æœºå™¨ä¸Šéƒ¨ç½²å¤šä¸ªserverã€‚ æ€Žä¹ˆè®©ä¸€ä¸ªclient side è®¿é—®å¤šä¸ªserverã€‚å¹¶ä¸”å®žçŽ°è´Ÿè½½å‡è¡¡ï¼Ÿ è°¢è°¢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1313
Support utf-8 percent encoded grpc.message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See grpc/grpc#4672
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1314
Revert "More information for debugging."
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Maybe keep the toString()s?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1315
Fix unsynchronized access in InProcessTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1316
Optimize blocking calls to avoid app thread pool
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, assigning to you because of the CallOptions and Stub changes. We can discuss whether the gain is worth the complexity.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1317
Fix OkHttp bug where streams could be started after they had been canâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1318
Avoid NettyServerBuilder in security documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1319
BufferingHttp2ConnectionEncoder forgets GO_AWAY received
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The BufferingHttp2ConnectionEncoder needs to remember that a GO_AWAY was received and immediately reject incoming requests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1320
Raise method visibility in Channel Providers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1321
More precise exception handling in examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1322
Reduce number of codegen'd classes needed for Services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Nicely done! LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1323
Start 0.13.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1324
Add GRPC + TLS integration tests (notably, test important security properties)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1325
GRPC with TLS mutual authentication: Server accepts untrusted client certificate
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A Java GRPC server configured to require client authentication appears to accept client certificates issued by CAs that the server does not trust. If so, this is a dangerous security vulnerability.
Here is a minimal project that reproduces the problem.  Curiously, pretty much exactly the same code works correctly when part of the grpc-java repository's test suites; see the tests added in this pull request.
Perhaps I'm simply missing something; perhaps there is a genuine bug; or perhaps there is some subtle interaction of JARs or whatnot that causes this code to work in some environments but to be silently dangerous in others.
Output of the minimal project is below.  This output is from Java 1.8.0_65 on Mac OS X (El Capitan); the test fails in the same way on Linux (Debian 8).  The output shows that the SSL engine in use is OpenSSL.
$ ./run_test 
Netty can use OpenSSL: true
Running test...
Jan 16, 2016 9:51:02 PM io.grpc.internal.TransportSet$1 run
INFO: Created transport io.grpc.netty.NettyClientTransport@1e7c7811(localhost/127.0.0.1:64417) for localhost/127.0.0.1:64417
Jan 16, 2016 9:51:02 PM io.grpc.internal.TransportSet$TransportListener transportReady
INFO: Transport io.grpc.netty.NettyClientTransport@1e7c7811(localhost/127.0.0.1:64417) for localhost/127.0.0.1:64417 is ready
Exception in thread "main" Jan 16, 2016 9:51:02 PM io.grpc.internal.TransportSet$TransportListener transportShutdown
INFO: Transport io.grpc.netty.NettyClientTransport@1e7c7811(localhost/127.0.0.1:64417) for localhost/127.0.0.1:64417 is being shutdown
Jan 16, 2016 9:51:02 PM io.grpc.internal.TransportSet$TransportListener transportTerminated
INFO: Transport io.grpc.netty.NettyClientTransport@1e7c7811(localhost/127.0.0.1:64417) for localhost/127.0.0.1:64417 is terminated
java.lang.AssertionError: TLS handshake should have failed, but didn't; received RPC response: text: "Request said: dummy text"

    at org.junit.Assert.fail(Assert.java:88)
    at io.grpc.testing.integration.TlsTest.serverRejectsUntrustedClientCert(TlsTest.java:84)
    at RunTest.main(RunTest.java:14)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1326
Add some initial integration tests for GRPC's TLS support.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1327
Add GRPC + TLS integration tests (notably, test important security properties)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1328
Make Benchmark Client terminate after running
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
It would be nice if we could properly shutdown the event loops, but that would require some restructuring of things.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1329
Making choice of OpenSSL more explicit in SECURITY doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1330
Receiving ClosedChannelException instead of actual error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We aren't reporting a helpful error in very simple connectivity cases, like the server port is closed. Here is what it looks like when using the interop client against a non-existent server:
$ ./build/install/grpc-interop-testing/bin/test-client
Running test empty_unary
...
Exception in thread "main" io.grpc.StatusRuntimeException: UNAVAILABLE
        at io.grpc.Status.asRuntimeException(Status.java:431)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:157)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:106)
        at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:212)
        at io.grpc.testing.integration.AbstractTransportTest.emptyUnary(AbstractTransportTest.java:164)
        at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:220)
        at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:209)
        at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:80)
Caused by: java.nio.channels.ClosedChannelException

It seems the problem may also impact other, much harder to diagnose, issues like client certificate validation (like in #1327).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1331
Make handling of GoAwayClosedStreamException more consistent.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1332
Use tcnative for interop unit tests when possible.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1333
Error in java grpc files generated by compiler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am generating protocol buffer code with the following command:
protoc --plugin=protoc-gen-grpc-java=/path/to/grpc-java/compiler/build/binaries/java_pluginExecutable/protoc-gen-grpc-java --grpc-java_out=/path/to/testproject/src/ --java_out=/path/to/testproject/src/ --proto_path=/path/to/testproject/protoc/ /path/to/testproject/protoc/Protofile.proto

I get the following error in Intellij.
Error:(29, 66) java: cannot find symbol
  symbol:   method parser()
  location: class Test.Protofile.B
Error:(30, 66) java: cannot find symbol
  symbol:   method parser()
  location: class Test.Protofile.C
Error:(84, 37) java: callOptions has private access in io.grpc.stub.AbstractStub
Error:(84, 11) java: channel has private access in io.grpc.stub.AbstractStub
Error:(108, 37) java: callOptions has private access in io.grpc.stub.AbstractStub
Error:(108, 11) java: channel has private access in io.grpc.stub.AbstractStub
Error:(133, 37) java: callOptions has private access in io.grpc.stub.AbstractStub
Error:(133, 11) java: channel has private access in io.grpc.stub.AbstractStub

Protofile:
syntax = "proto2";
package Test;

service A {
  rpc A (B) returns (C) {}
}
message B {
  repeated double field_a = 1;
  repeated double field_b = 2;
}
message C {
  repeated double field_a = 1;
  repeated double field_b = 2;
}

The dependencies I use are:
grpc-all-0.9.0, guava-18.0, protobuf-java.3.0.0-beta-2 (I also tried guava-19 and beta 1)
Also see the generated files:
https://gist.github.com/JoostvDoorn/c69f14a485144276545b
uname -a
Linux joost-EX58-UD5 3.11.0-19-generic #33-Ubuntu SMP Tue Mar 11 18:48:34 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
java -version
java version "1.7.0_91"
OpenJDK Runtime Environment (IcedTea 2.6.3) (7u91-2.6.3-0ubuntu0.14.04.1)
OpenJDK 64-Bit Server VM (build 24.91-b01, mixed mode)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1334
Fix broken noClientAuthFailure test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I failed to add the @Ignore on the test I said that was failing here. How did it pass on Windows? Maybe OpenSSL isn't being loaded on Windows.
Since I really would hope not all the tests are ignored, I'm enabling basicClientServerIntegrationTest because it "works on my computer" for both tcnative and jetty alpn. If it works on Travis and Jenkins as well, then I'll call it good.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1335
Investigate whether tcnative is being enabled on Jenkins Windows build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context: #1334 (comment)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1336
Backport OkHttp security fix from d948330ef28f1f5b57752d4af61abf812a00eba7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1337
backport to 0.12: Making choice of OpenSSL more explicit in SECURITY doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1338
Bump to v0.9.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You can add another commit to this PR to bump the version to 0.9.2-SNAPSHOT, so that the two commits will be merged to upstream together and we can make sure there will be only one commit in 0.9.1, which will be tagged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1339
Version bumps for v0.12.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Update examples/android/app/build.gradle ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1340
Use docker cp to copy files to docker containers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1341
Wait 5 seconds, not over an hour
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1342
memory leak in io.grpc.internal.TransportSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We experienced an issue where our grpc-java clients filled up their heaps and the entire cluster went down. The cause appears to be a list of futures in io.grpc.internal.TransportSet. 5 of these sets would consume 47% of a 30GB heap. The cluster was running without issue for a month.
Context: Our clients each make about 10,000 requests/s to a cluster of 80 servers. The problem began when the cluster of servers was restarted. The clients filled their heaps and effectively died. A restart of the clients resolved the immediate issue, but we want to fix the root cause.
The clients each maintain a single blocking stub for each of the 80 servers. We enforce a 10ms timeout using withDeadlineAfter(). All calling threads reuse the same blocking stub.
We did manage to get a heap dump of an offending client. We noticed that about 5 blocking stubs account for 47% of the retained heap on the machine. ~70 blocking stubs have the expected ~1kb size. I'm attaching a screenshot of the Dominator Tree report from Eclipse Memory Analyzer showing the problem. The labels on the columns are "shallow heap", "retained heap" and "retained heap %". This shows that a single io.grpc.internal.TransportSet has references to effectively a linked-list of RunnableExecutorPair objects each containing a Future. This linked list is 1.6 GB in size, where each element is about 1.5kb.
Any thoughts? What can I do to help debug this?
We are running grpc-java master as of Dec 9. v0.9 has a bug that makes it unusable for us.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1343
Deadline can fire before stream started
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In ClientCallImpl the deadline is scheduled before stream.start(). However, if the deadline has already elapsed the runnable will be executed immediately and race with the start. I've only looked into how OkHttp may be impacted.
I believe a NullPointerException would be thrown when trying to notify the stream listener due to the cancellation. However, due to #1237 the exception won't be logged. Thus, this will result in a hung stream that never completes with no logging as to what went wrong.
This was discovered due to timeout_on_sleeping_server on android being flaky, because it uses a very small timeout. The test would fail at awaitCompletion.
@carl-mastrangelo, FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1344
can put the service instances on different ports?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
i want to  create  gRPC server in python with client in java , and start up multiple service instances on different ports, can  it work ? and the client how to support  different ports ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1345
grpc 0.12.0 with protobuf-3.0.0-beta-2 ?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've compiled grpc 0.12.0 with protobuf-3.0.0-beta-2 as suggested in a recent git issue, and as in grpc/grpc@f4c74fa. Now grpc-java 0.12.0 does not compile anymore as it seems to require explicitly protobuf-3.0.0-beta-1?
*** Building codegen requires Protobuf version 3.0.0-beta-1
*** Please refer to https://github.com/grpc/grpc-java/blob/master/COMPILING.md#how-to-build-code-generation-plugin

FAILURE: Build failed with an exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1346
../gradlew java_pluginExecutable fatal error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hiï¼Œ
environmentï¼š
java version "1.7.0_79"
Mac OS X 10.10.5
Gradle 2.10
protobuf version 3.0
I have configured  'export CXXFLAGS="-I/usr/local/protobuf-3.0.0-beta-2/include" LDFLAGS="-L/usr/local/protobuf-3.0.0-beta-2/lib"'  in the ~/.bash_profile fileï¼š

fatal error infoï¼š
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1347
Parameterize TlsTest for TLS provider and shutdown channels
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I need to add an additional assume that checks if openssl is available.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1348
Run make with as many cores as available
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1349
Use generics for LoadBalancer to avoid ClientTransport exposure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Generally looks good. If you add Channel makeChannel(T) to TransportManager, GrplbLoadBalancer will no longer see ClientTransport and SingleTransportChannel.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1350
Use instance equality for Context.Key
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1351
Replace AUTHORITY_KEY with ClientStream.setAuthority
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, friendly ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1352
Log start of test and don't wait forever
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1353
Require a ScheduledExecutorService to be provided to Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1354
Cancel server context when call is cancelled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1355
GOAWAY with OK maps to INTERNAL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP/2 graceful shutdown starts with a GOAWAY with code OK.  We currently map that to a INTERNAL, which would not imply that clients should attempt a retry.  We should change this to UNAVAILABLE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1356
Avoid cancel before start, which is not handled in transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1357
Revert minor grammar tweaks to avoid syncing readme
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Comma comma down doobie do down down.
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1358
Overload ProtocolNegotiator.newHandler to accept an authority.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the case of a load balanced channel, there is a need to provide a possibly different authority to the backend than the load balancer.  It looks like  ProtocolNegotiator.newHandler would be a good place to add this functionality.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1359
Netty should call transportShutdown on GOAWAY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This will cause TransportSet to divert new traffic away from the transport which would prevent many failed RPCs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1360
POM missing for protoc-gen-grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For 0.12.0 it was manually deleted (because it was causing errors; probably because it is wrong), but it was missing already for 0.9.1. It may be because we upgraded from gradle 2.3 to gradle 2.8.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1361
Update gradle to 2.10
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1362
Fix grpc-compiler build.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1363
Upgrade to protobuf-gradle-plugin 0.7.4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1364
Upgrade to protobuf-3.0.0-beta-2 and protobuf-nano-3.0.0-alpha-5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM.
It looks like the windows build had some trouble :(
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1365
Change status of HTTP/2 NO_ERROR to UNAVAILABLE.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1366
Document where to put proto files when using build plugins
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1367
Update to Netty 4.1.0CR1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1368
YA Compression API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1369
Fix a concurrent modification in BlankFutureProvider.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1370
Failing to build java interop image
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seems like some of the in-process interop tests are executed during the java build and they are failing.
https://grpc-testing.appspot.com/job/gRPC_interop_master/2635/consoleFull
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1371
Fix OOM errors that happen occasionally
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1372
Fix executor propagation in CallOptions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM.
@zhangkun83, it looks like I failed to modify the constructor when I added the executor to CallOptions (in #1316)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1373
Fix artifact upload for compiler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1374
Update to netty 4.1.0.CR1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1375
Update netty-tcnative to 1.1.33.Fork11.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1376
Run TLS integration tests using OpenSSL also.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1377
Mark ChannelHandler.exceptionCaught implementation deprecated to fix warning
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1378
Audit which APIs should stay experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A lot of methods have been marked Experimental API.  We should go over what methods should become standard before doing our GA release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1379
Fix NPE in ProtoInputStream.drainTo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1380
Add header logging to calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To make debugging easier, there should be some way to log metadata that comes with Client Calls, and possibly Server calls.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1381
hello_world.proto in Java differs from copy in main repo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the grpc repo it is at examples/protos/helloworld.proto . Most importantly the response is HelloReply in one and HelloResponse in the other.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1382
Partially synchronize helloworld.proto with main repository
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1383
Fixing a typo in Http2ClientStream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1384
Help steer new users away from copying our build.gradle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1385
A few more example proto tweaks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM.  Consider adding the java opts to the main repo too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1386
Fix race condition in Compression Test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What is the race? I would expect the blocking unaryCall to provide enough synchronization between Fzip and the test. anyRead should only be used in one thread, and anyWritten should only be used in another.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1387
Add to RELEASING docs for updating JavaDoc and README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1388
Update README to reference 0.12.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1389
Update README to point to protobuf-gradle-plugin 0.7.4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1390
Remove deprecated call and TODO in Protocol negotiators
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1391
Negotiation Handlers should implement ChannelHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1392
Log full Status on Android test failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1393
Update Android test build to use current grpc snapshot and support Gradle 2.10
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, friendly ping. I expect it to be easy to review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1394
Automated readability/efficiency tweaks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 friendly ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1395
DelayedClientTransport and fix TransportSet.shutdown() semantics.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for working on this!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1396
Improve test coverage of ProtoUtils
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1397
Add transport-level test suite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
netty
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1398
Update to netty-4.1.0.CR2 for SNI fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We want this:
netty/netty@e220c56
We are hitting the SNI problem (netty/netty#4746) with tests on GCE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1399
Interop's deadlineExceeded test is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.testing.integration.Http2NettyLocalChannelTest > deadlineExceeded FAILED
    java.lang.AssertionError: expected:<Status{code=DEADLINE_EXCEEDED, description=null, cause=null}> but was:<Status{code=INTERNAL, description=Failed to frame message, cause=io.netty.util.IllegalReferenceCountException: refCnt: 0}>

As seen on OS X Travis (since rebuilt):
https://travis-ci.org/grpc/grpc-java/jobs/107847923
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1400
DNS: use Netty's asynchronous DNS resolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current Netty-based transport doesn't use Netty's asynchronous DNS resolver, which means the client hangs if hostnames cannot be resolved. This is really bad if you are reusing an eventloop from other parts of a program and this eventloop is not supposed to block. gRPC should at least expose the necessary APIs to be able to override the default DNS resolver.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1401
ProtocolNegotiators leaks ByteBufs on failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported by @trask in #1277 with repro repo at https://github.com/trask/grpc-netty-leak-repro. The key distinguishing feature is BufferUntilChannelActiveHandler in the log here:
SEVERE: LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 2
#2:
        Hint: 'ProtocolNegotiators$BufferUntilChannelActiveHandler#0' will handle the message from this point.

When looking at the code, it is obvious it doesn't release when it fails the promise. This leak only happens when failing to establish a connection to the server.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1402
netty: release buffered objects when failed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Good catch! LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1403
Access unparsed data in interceptor?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like to make a caching interceptor that uses the raw binary of the message as a key, and the raw binary of a response as the value so that I can avoid any ser/der costs on the server.  Is it possible to get access to the InputStream that goes through the Listener before it calls "call.method.parse(inputStream)" ?
Maybe there's a different/better way to do this and avoid serialization costs?  I suppose I could use a header approach and have a server interceptor look for a "CacheKey" header and use that for lookup.  It requires a bit more cooperation from the client though which I'd like to avoid if possible.
Thanks for any pointers!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1404
Fix InProcessTransport to call onReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1405
Minor hygenic changes related to Executors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1406
Raise visibility of Netty Channel Builder Ctor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, this is a fix when extending NettyChannelBuilder? If so, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1407
Name resolution failures can cause the call to hang.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If an exception is thrown from NameResolver.Listener.onUpdate(), the call hangs indefinitely and is never closed.  This is a problem if the actual name resolution succeeds, but is not successfully set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1408
Potential risk of deadlock from calling listeners under locks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Methods of ClientTransport.Listener and ServerTransportListener are usually called under a lock. The biggest reason for locking is to guarantee the ordering of multiple methods on the same listener.
However, these listeners usually call into channel layer code, and may in turn acquire locks from there, which forms a transport lock -> channel lock lock order. On the other hand, when channel layer calls into transport layer, it's possible to form a channel lock -> transport lock lock order, which makes deadlock possible.
It's unlikely an issue today because there is an implicit rule today that channel layer will not hold any lock while calling into transport. However, as the code base grows, it will become harder to keep track of such requirement.
A possible solution is to always schedule listener calls on a serialized executor, with the cost of a thread, so that listener order can be guaranteed without the need of locking. There may be better options.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1409
Add getter for metadata store
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1410
Make thread-safety ownership of Metadata explicit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86  LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1411
Usages of OkHttpClientTransport.toGrpcStatus should add status details about the source of the code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now you can get a status of INTERNAL: Internal error which isn't very useful. If it had RST_STREAM in the description though then it would be much more useful.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1412
Add some debugging flags
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1413
Generator assumes packed=true on repeated scalars
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please see this report for context grpc/grpc#5174
The long story short however is that it seems my server implementation was emitting a packed=true representation of a repeated int32 field, and NodeJS could not parse it.  Once I added packed=true to the proto definition, Node could begin to read the values returned from my Java server.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1414
add pom.xml to examples/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently there is only gradle build.gralde file.  Add pom.xml please!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1415
add pom.xml for grpc-java examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1416
Delete unused CancelStreamCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1417
Add support for codecov.io
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1418
In blocking stubs, throw Status.CANCELLED on interruption
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1419
move maven-protoc-plugin to maven central
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
any reason why some of the components, like maven-protoc-plugin, are in bintray? can this be moved to maven central instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1420
gprc-all is published without sources
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# curl -s http://central.maven.org/maven2/io/grpc/grpc-all/0.12.0/grpc-all-0.12.0-sources.jar | jar t
META-INF/
META-INF/MANIFEST.MF
#
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1421
different grpc components depends on the same dependencies but of different versions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This looks quite unsafe.
Dependency convergence error for com.google.code.findbugs:jsr305:3.0.0 paths to dependency are:
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-core:0.12.0
      +-com.google.code.findbugs:jsr305:3.0.0
and
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-auth:0.12.0
      +-com.google.auth:google-auth-library-oauth2-http:0.3.0
        +-com.google.http-client:google-http-client:1.19.0
          +-com.google.code.findbugs:jsr305:1.3.9

[WARNING] 
Dependency convergence error for com.twitter:hpack:v1.0.1 paths to dependency are:
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-netty:0.12.0
      +-io.netty:netty-codec-http2:4.1.0.Beta8
        +-com.twitter:hpack:v1.0.1
and
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-netty:0.12.0
      +-com.twitter:hpack:0.10.1

[WARNING] Rule 1: org.apache.maven.plugins.enforcer.DependencyConvergence failed with message:
Failed while enforcing releasability the error(s) are [
Dependency convergence error for com.google.code.findbugs:jsr305:3.0.0 paths to dependency are:
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-core:0.12.0
      +-com.google.code.findbugs:jsr305:3.0.0
and
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-auth:0.12.0
      +-com.google.auth:google-auth-library-oauth2-http:0.3.0
        +-com.google.http-client:google-http-client:1.19.0
          +-com.google.code.findbugs:jsr305:1.3.9
, 
Dependency convergence error for com.twitter:hpack:v1.0.1 paths to dependency are:
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-netty:0.12.0
      +-io.netty:netty-codec-http2:4.1.0.Beta8
        +-com.twitter:hpack:v1.0.1
and
  +-io.grpc:grpc-all:0.12.0
    +-io.grpc:grpc-netty:0.12.0
      +-com.twitter:hpack:0.10.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1422
Allow for interceptors to send and receive messages of byte[] type.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1423
Update netty-tcnative to 1.1.33.Fork13.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1424
Update netty-tcnative to 1.1.33.Fork13.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1425
Context forwarding between client and server?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The comments on the Context object aren't completely clear to me what it forwards and does.  For example, here 
  
    
      grpc-java/core/src/main/java/io/grpc/Context.java
    
    
         Line 52
      in
      6e94cf3
    
  
  
    

        
          
            * A context propagation mechanism which carries deadlines, cancellation signals, 
        
    
  

 the comment says
/**
 * A context propagation mechanism which carries deadlines, cancellation signals,
 * and other scoped values across **API boundaries** and between threads. Examples of functionality
 * propagated via context include:
 * <ul>
 *   <li>Deadlines for a local operation or remote call.</li>
 *   <li>Security principals and credentials.</li>
 *   <li>Local and distributed tracing context.</li>
 * </ul>
 */

I've seen the tests for deadline propagation added recently, but I'm working on a tracing context interceptor, and it isn't clear to me if I should expect the information in the context to automatically forward downstream, or if I should be pulling that information out of the context and sending it along in a header?  I've looked at the Client and Server Impls for example, and while things like deadlines propagate and cascade downstream, it not clear to me if/how the arbitrary value objects are supposed to
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1426
Sporadic NullPointerException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm getting this sporadically on slow travis-ci machines.  Haven't seen it on other machines.  My guess is that the listener is being executed before the channel field assignment occurs so channel is null.
java.lang.NullPointerException: null
    at io.grpc.netty.NettyClientTransport$1.operationComplete(NettyClientTransport.java:168) ~[grpc-netty-0.12.0.jar:0.12.0]
    at io.grpc.netty.NettyClientTransport$1.operationComplete(NettyClientTransport.java:164) ~[grpc-netty-0.12.0.jar:0.12.0]
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:683) ~[netty-common-4.1.0.CR2.jar:4.1.0.CR2]
    at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:854) [netty-common-4.1.0.CR2.jar:4.1.0.CR2]
    at io.netty.util.concurrent.DefaultPromise$LateListenerNotifier.run(DefaultPromise.java:882) [netty-common-4.1.0.CR2.jar:4.1.0.CR2]
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339) [netty-common-4.1.0.CR2.jar:4.1.0.CR2]
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356) [netty-transport-4.1.0.CR2.jar:4.1.0.CR2]
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742) [netty-common-4.1.0.CR2.jar:4.1.0.CR2]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_31]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_31]
    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_31]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1427
Switching to netty-tcnative-boringssl-static
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1428
Raise visibility of netty Channel Builder, and provide a way to pass â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. The test on Windows is failing, but I can't figure out what is wrong.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1429
d'oh, really raise the visibility
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1430
hpack is no longer a direct dependency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1431
Maven protoc plugin has a new name and is on Maven Central
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1432
Release commits
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1433
Start 0.14.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1434
Add simple BINARY_BYTE_MARSHALLER for processing raw headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1435
Pass -j to correct command
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1436
Improve procedure for creating release tag and branch
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1437
Fix flakiness in Cascading cancellation tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1438
Check for null Channel when creating stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if (channel == null) {
  throw new NullPointerException();
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1439
Annoying logging while running an app
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/TransportSet.java#L197
hbase(main):001:0> list
TABLE
Feb 17, 2016 6:37:04 PM com.google.bigtable.repackaged.io.grpc.internal.TransportSet$1 run
INFO: Created transport com.google.bigtable.repackaged.io.grpc.netty.NettyClientTransport@5f0f9947(bigtabletableadmin.googleapis.com/74.125.28.219:443) for bigtabletableadmin.googleapis.com/74.125.28.219:443
Feb 17, 2016 6:37:04 PM com.google.bigtable.repackaged.io.grpc.internal.TransportSet$TransportListener transportReady
INFO: Transport com.google.bigtable.repackaged.io.grpc.netty.NettyClientTransport@5f0f9947(bigtabletableadmin.googleapis.com/74.125.28.219:443) for bigtabletableadmin.googleapis.com/74.125.28.219:443 is ready
0 row(s) in 1.0900 seconds
=> []
hbase(main):002:0> 

This is in our Quickstart app, it would be really nice if it went away.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1440
Use new protoc maven plugin from Maven Central
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
License issue on maven-protoc-plugin has been resolved, and it's now pushed to maven central - yay!
sergei-ivanov/maven-protoc-plugin#11
Should update documentation and/or examples to use the the maven central plugin:
http://search.maven.org/#artifactdetails%7Corg.xolstice.maven.plugins%7Cprotobuf-maven-plugin%7C0.5.0%7Cmaven-plugin
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1441
Update README to reference 0.13.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1442
Be more thorough with waiting for all work to shutdown in Cascading cancellation test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
@nmittler
I still see flakiness in the build but it seems to be coming from the stackguard warning not the cascading tests
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1443
Fix Intellij syncing for some generated dirs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1444
Various improvements to Context API (doc, naming, deadlines, semantic clarity)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1445
Fix sporadic NullPointerException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1446
Remove references to io.grpc.internal from io.grpc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc is very close to having no references to io.grpc.internal. It would be useful to be able to depend on the API but not the implementation to not pull in unnecessary dependencies and provide cleaner builds that don't accidentally depend on the implementation. For instance, a library could have optional gRPC support, but depend on grpc-api even when grpc was not selected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1447
Create a grpc-api artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After #1446 we could make a grpc-api artifact that does not include io.grpc.internal. From the other issue:

It would be useful to be able to depend on the API but not the implementation to not pull in unnecessary dependencies and provide cleaner builds that don't accidentally depend on the implementation. For instance, a library could have optional gRPC support, but depend on grpc-api even when grpc was not selected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1448
Update to latest tcnative release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1449
Decrease log verbosity for transport status changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1450
Revert "Update to latest tcnative release"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1451
Update package name for grpc load balancer proto.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1452
Use Netty's StreamBufferingEncoder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1453
Revert the cascading test for the moment as its flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1454
Avoid WeightedFairQueueByteDistributor which is broken in Netty CR1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Grr.. Disregard. I was using netty CR1 instead of CR2 :(
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1455
Losing messages in 0.13.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've posted a repro to https://github.com/trask/grpc-lost-msgs-repro.  Just clone and run mvn test.
The repro sends 1000 messages to the server, but the server only ever sees around 30 of them (I'm running locally on windows, though I also see this issue on travis-ci linux).
I don't see this issue in 0.12.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1456
Avoid WeightedFairQueueByteDistributor which is broken in Netty CR1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1457
Limit memory during build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've run this a half dozen times without any failures. The flake rate is lower than that though, so I think we'll just need to observe over time if it fixes the issue. I do know it substantially decreased the flake rate of #1397, which for some reason was increasing memory/gc pressure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1458
Fix a bug ByteReadableBufferWrapper. We should set new buffer's limitâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zsurocking, LGTM, although would you mind adding a test in ReadableBufferTestBase?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1459
Artifacts should depend on particular version of grpc-core
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-core contains internal, unstable APIs. To prevent accidentally mis-matching artifact versions (say grpc-netty-0.12.0 coming from one source of dependencies and grpc-core-0.13.0 coming from another), any artifacts that depend on grpc-core should use [$VERSION] syntax instead of $VERSION to cause an error (because grpc-netty-0.12.0 can only use grpc-core-0.12.0; core shouldn't be silently upgraded) instead of runtime failure. Note that #1447 improves things, since something like grpc-stub and grpc-protobuf could depend just on grpc-api instead of a version-fixed grpc-core.
The syntax seems to be supported by Maven, maybe Gradle, and Ivy, but we may need to do some verification and additional investigation, since it isn't commonly used.
Other resources:
http://www.mojohaus.org/versions-maven-plugin/examples/resolve-ranges.html
http://guntherpopp.blogspot.com/2011/02/understanding-maven-dependency.html
http://guntherpopp.blogspot.com/2011/03/understanding-maven-dependency.html
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1460
Consider avoiding the copy in BINARY_BYTE_MARSHALLER
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the initial version of the PR to add BINARY_BYTE_MARSHALLER it did not do a copy. However, I suggested that we do a copy to prevent trouble with Metadata's caching of serialized encodings.
I may have been misguided though. It seems that even with the copy in place, mutating the byte[] would cause trouble for Metadata. It may be better to not copy, because it doesn't improve the situation, and update the documentation to simply say, "don't modify the byte[]s".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1461
Update to latest netty and tcnative.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1462
Create new AbstractTransportTest for Transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1463
DNS resolution expiration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It looks like the channel is somehow caching the IP resolved through DNS but never refreshing it. We are using grpc in AWS and since ELB's IPs change over time, we've run into issues and found out grpc clients are trying to connect to an old IP.
Code snippet:
private[this] val channel = NettyChannelBuilder.forAddress(httpHost, httpPort).negotiationType(NegotiationType.PLAINTEXT).build();
  private[this] val blockingStub = CrudGrpc.newBlockingStub(channel)
  private[this] def getStub = blockingStub.withDeadlineAfter(timeout.toNanos, TimeUnit.NANOSECONDS)

override def getEntity(id: String): Entity = {
  getStub.getEntity(id)
}
Is our assumption correct? Is there any issue in how are we using the client library? Would it be a bad practice (performance-wise at least) to create a new channel in each request?
Thanks in advance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1464
Set arbitrary NameResolver attributes via ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1465
Pass transports instead of futures of transports for new calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1466
Release commits for v0.13.1 + backported comments to make sed work
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1467
Use default keystore
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1468
Update README to reference 0.13.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1469
Codegen base class for services to extend
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should allow adding new methods to a service without breaking existing service implementations. The best way to do that seems to have service implementations extend a base class that responds with UNIMPLEMENTED for all methods. The class would also make creating fake/mock services during tests easier.
A similar problem can happen for stubs in tests. We may need something there as well.
See also grpc/grpc#5371
Edit: IOW, remove all interfaces from the generated code, since adding a method will break existing implementations of that interface.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1470
*Interceptor interceptForward methods?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would you be open to a pull request which allows users to pass in interceptors in forward order?  Meaning, if I pass in ServerInterceptors.interceptForward(svc, new A(), new B(), new C()) that I'll end up with interceptors being called in the order A -> B -> C rather than C -> B -> A?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1471
Bump Guava to 19.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would probably be good to verify that the v1 client libraries work with Guava 19 before we bump our version. I think they're on Guava 17 right now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1472
Merge DelayedStream's setError() into cancel()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1473
Fix bugs and improvements found by static analyser
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, now with a test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1474
Improve unary server stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Java unary stub is taking the form of an async service, where a single result is expected to return from a StreamObserver.
This can be error prone:

You can't tell from the stub whether it's unary or streaming multiple results
The code can easily call onNext one too many times, or not call onComplete

Unary gRPC stubs for several other stubs expects a single return value from the method. Java should follow the same convention:
https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_server.py
https://github.com/grpc/grpc/blob/master/examples/ruby/greeter_server.rb
https://github.com/grpc/grpc-go/blob/master/examples/helloworld/greeter_server/main.go
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1475
Improve client stream server side stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at this:
https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java#L187
This is super weird to have the "request input", Points, as a return value of a method, and the response RouteSummary, to be the input parameter of a method. I took a look at this for a while to figure out what's going on. I see it is forcing the implementation of StreamObserver interface to process the incoming Points, and thus requiring it to be a return value. I wonder if there is a better way of doing this.
Every other language stubs seems to generate sensible stubs where the input steam is in fact the parameter and not a return value, and they actually returns the actual RouteSummary as the return value of the method.
https://github.com/grpc/grpc-go/blob/master/examples/route_guide/server/server.go#L102
https://github.com/grpc/grpc/blob/master/examples/node/route_guide/route_guide_server.js#L156
https://github.com/grpc/grpc/blob/master/examples/python/route_guide/route_guide_server.py#L93
https://github.com/grpc/grpc/blob/master/examples/ruby/route_guide/route_guide_server.rb#L144
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1476
TransportSet should reset current index on transportReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If we successfully make a connection to an address, then that should mean the address is good. If it later is disconnected due to GOAWAY or transient failure we should start at the top of the list instead of trying less-desirable IPs.
This can cause errors, but any errors can already be gotten other ways, so it shouldn't be considered a major bug.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1477
Only link delayed transport AFTER real transport has called transportReady()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is no benefit of creating streams on a transport that has not called transportReady(), because they will be buffered anyway. Besides, transport connection may turn out to be a failure, which will fail the pending streams on it, spamming transient errors to the callers. Those streams, however, if created on a transport that has called transportReady(), would have a higher chance of success.
Proposed change: TransportSet calls setTransport on delayed transport in the transportReady() callback of the real transport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1478
Set arbitrary NameResolver attributes via ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1479
Add flow control sample documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
flow control mechanism is a little bit hard to understand. can you guys add some test to demonstrate its usage?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1480
WIP: Affinity based load balancer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1481
The asynchronous Channel is uncompleted,but I have never used asynchronous Channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The server print the logs as follows,and never stop until the server is shut down:
2016-02-25 19:31:42.664 [grpc-default-worker-ELG-2] ERROR i.netty.handler.codec.http2.Http2ConnectionHandler - Sending GOAWAY failed: lastStreamId '0', errorCode '1', debugData 'HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: '. Forcing shutdown of the connection.
java.nio.channels.ClosedChannelException: null
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1482
Add transport test for Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1483
Add transport test for OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1484
Rename interop's "AbstractTransportTest" to "AbstractInteropTest"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-testing now has an AbstractTransportTest which is a much more appropriate name for it than for interop's test class.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1485
why DEFAULT_FLOW_CONTROL_WINDOW in NettyServerBuilder set to 1048576?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in http2 doc, the max value of flow control window would be 2^31-1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1486
is server push feature used in anywhere in Grpc-java?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my rpc framework need this feature, so I'd like to reference the implementation of it in Grpc-java, but fail to find it in code.
can anyone help on this please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1487
Add a new interface for creating a channel in android tester app
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1488
Add more log into for cancellation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1489
Allow a listener to be passed to Contexts.interceptCall(...)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1490
Always start from the first address after a successful connection.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1491
Use impossible port for unreachability test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1492
CI should build examples/android and android-interop-testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1493
Bump grpc version used by examples/android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should also update the RELEASING doc so that the versions are updated as part of our process.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1494
Only link delayed transport AFTER real transport has called transportReady()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1495
How does deadline work?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm creating a blocking stub with deadline:
blockingStub = MyGrpc
        .newBlockingStub(channel)
        .withDeadlineAfter(3, TimeUnit.SECONDS);

and then I start calling method in a loop:
for (int i=0; i<100; i++) blockingStub.doSomething();

first 8 calls are handled correctly but others end with DEADLINE_EXCEEDED exception.
Looking at my gRPC server logs I can see that the 8th call (last succeeded call) is ~3 seconds after the 1st one, so I assume that the deadline I set is for all my calls.
How to set up a deadline per call ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1496
Test that gRPC clients and servers can handle concurrent RPCs.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1497
GRPC tests fail and hang with JDK 1.8.0_73
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Making the following change in build.gradle gets everything working again:
-        def alpnboot_version = '8.1.2.v20141202'
+        def alpnboot_version = '8.1.7.v20160121'

However, doing so would probably break the build for developers using an old JDK and for Travis.
Should the current logic for choosing the ALPN version accommodate more than one version of Java 8, or is the current approach intentional?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1498
Test that a GRPC client rejects untrusted server certs.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1499
Inlcude the file that was used to generate service descriptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1500
There is no warning that ManagedChannel.shutdownNow is not implemented
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems the important part of the comment was not copied in b687bdc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1501
Support various JDK versions when choosing the Jetty ALPN version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1502
Update netty in v0.13.x branch
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1503
Always schedule createTransportRunnable in the executor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1504
Bump gradle version to 2.11
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1505
Use Protobuf Json formatting for routeguide example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1506
Server Call Attributes PoC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1507
Make Route Guide client and server accept channel and server builders
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1508
Run createTransportRunnable outside of lock.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1509
Remove static initializer blocks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't see much of better error message when using a static method. I see something like ClassName.<clinit>(File.java:2) with the static block.
I've seen no wrapping exception (when I threw AssertionError) and I've seen ExceptionInInitializerError (when I threw RuntimeException), but I couldn't trigger a NoClassDefFoundError due to a failing initializer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1510
DelayedClientTransport and InProcessTransport means deadlock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a chance of deadlock when DelayedClientTransport is linked with an InProcessTransport. See /pull/1503.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1511
Add interceptForward methods for Client and Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1512
Replace RequestKey with Attributes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1513
TlsTest flakiness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Found on Travis linux when testing for #1508
io.grpc.testing.integration.TlsTest > noClientAuthFailure[OPENSSL] FAILED
    java.lang.AssertionError: expected:<UNAVAILABLE> but was:<UNKNOWN>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:118)
        at org.junit.Assert.assertEquals(Assert.java:144)
        at io.grpc.testing.integration.TlsTest.noClientAuthFailure(TlsTest.java:235)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1514
Add assertCodeEquals to TestUtils and swap code to use it
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
assertCodeEquals() (also here) is really helpful for debugging test failures from CI environments because it provides more information about the Status versus assertEquals(Code, Code). Issues like #1513 would have enough information to better understand what went wrong.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1515
Add more debug output in TlsTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1516
Treat ClosedChannelException as UNAVAILABLE to squelch test failures
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1517
Make Status code use percent encoding
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1518
Add missing override annotation to generated protos
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1519
Simplify using richer APIs in service implementations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While it is possible for service implementors to interact with richer features like inbound & outbound flow-control today by creating their own io.grpc.ServerCallHandler this is quite cumbersome to do. You would need to completely rewrite how your server was build and could not simply implement the generated service definition any more. In cases where only one of the methods in the service needs more control over flow-control this is quite messy
One proposal is to allow implementers to cast the StreamObserver they receive from the runtime to a richer type that allows for interaction with advanced features. This works for all generated service calls including unary calls.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1520
Json example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Nice!  It appears that a server would have to pick json or binary on a port with this approach?  I wonder if there might be a solution where a MethodDescriptor could contain multiple marshallers with the content-encoding specifying which to use?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1521
remove unused var
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1522
IOExceptions are INTERNAL because they are getting wrapped in Http2Exceptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Utils.statusFromThrowable will need to check the Http2Exception.cause() to see if it is an IOException (by recursively calling statusFromThrowable?).
I saw this with java.io.IOException: Broken pipe, which should be UNAVAILABLE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1523
Remove or use unused variables.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1524
Update HelloWorldClient.java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1525
netty: GOAWAY should trigger transportShutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1526
Don't hold a lock in DelayedStream when calling realStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1527
Run createTransportRunnable outside of lock.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1528
Doc Fixit: Java is missing from website Auth doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java is missing from this doc: http://www.grpc.io/docs/guides/auth.html
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1529
Adding RunWith annotation to ConcurrencyTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1530
Backport netty transportshutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Discussed offline. The transportShutdown problem could be pretty severe for some users (although nobody that we know of is hitting it frequently). We've already backported all the other Netty changes from master, so we have reasonable confidence the release branch will behave similarly to master (instead of some random, unexpected way due to a strange mixing of commits). So we'll move forward with the backport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1531
Use stream.cancel() instead of cancel() in ClientCallImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some error handling in ClientCallImpl is calling ClientCall.cancel() instead of stream.cancel(). For example, in sendMessage(). This causes incorrect throwing of IllegalStateException to later callers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1532
Examples of serving HTTP 1 request with servers running GRPC?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is there a example of using grpc/underlay netty to serve HTTP1/1 on the same port?
Cheers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1533
Simulate latency and GRPC thread safety gurantees
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We wrote an interceptor to simulate adding latency and injecting failures into client requests.  In doing so we may be violating thread safety guarantees in GRPC.  I was hoping someone could look this over and let me know if this implementation makes sense or if we should be doing something different.
First, some details about the implementation and expected behavior,

Failure behavior is provided by an injected FitContext.
Failure can be a delay, an error, or a combination of both.
Simulated errors are implemented as request cancellation.
The implementation is leveraging backpressure to avoid having to queue up requests and responses.  The request() call is delayed to simulate latency.
The solution works for request-response as well as streaming scenarios

Here's the interceptor code,
public class FitClientInterceptor implements ClientInterceptor {
    public static final String FIT_LAYER_NAME = "GrpcClient";

    private final FitContext fitContext;
    private final InjectionPoint injectionPoint;
    private final ScheduledExecutorService executor;

    public FitClientInterceptor(final FitContext fitContext, final ScheduledExecutorService executor) {
        this.fitContext = Preconditions.checkNotNull(fitContext);
        this.executor = Preconditions.checkNotNull(executor);
    }

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions, final Channel next) {
        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(next.newCall(method, callOptions)) {
            volatile boolean failureInjected = false;

            @Override
            public void start(final Listener<RespT> responseListener, final Metadata headers) {
                // Convert the cause to FIT error if failure was injected
                delegate().start(new ForwardingClientCallListener.SimpleForwardingClientCallListener<RespT>(responseListener) {
                    public void onClose(Status status, Metadata trailers) {
                        if (failureInjected && status.getCode() == Code.CANCELLED) {
                            delegate().onClose(Status.fromThrowable(new Throwable("Simulated Failure")), trailers);
                        }
                        else {
                            delegate().onClose(status, trailers);
                        }
                    }
                }, headers);
            }

            @Override
            public void request(int numMessages) {
                final InjectedFailure injectedFailure = fitContext.getFailure();
                if (injectedFailure.anyImpact()) {
                    if (injectedFailure.getDelay() > 0) {
                        executor.schedule(() -> { 
                                if (injectedFailure.shouldFail()) {
                                    failureInjected = true;
                                    delegate().cancel();
                                } else {
                                    delegate().request(numMessages); 
                                }
                            }, 
                            injectedFailure.getDelay(), TimeUnit.MILLISECONDS);
                    } else if (injectedFailure.shouldFail()) {
                        failureInjected = true;
                        delegate().request(numMessages);
                        delegate().cancel();
                    } else {
                        delegate().request(numMessages);
                    }
                }
                else {
                    delegate().request(numMessages);
                }
            }

            @Override
            public void halfClose() {
                // Special handling of requests where halfClose
                // is still called after immediate failure in request()
                if (!failureInjected) {
                    delegate().halfClose();
                }
            }

            @Override
            public void sendMessage(ReqT message) {
                // Special handling of UNARY requests where sendMessage
                // is still called after immediate failure in request()
                if (!failureInjected) {
                    delegate().sendMessage(message);
                }
            }
        };
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1534
TransportSet creates lots of transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Logs indicate that it is possible with a single Channel to get multiple transports for the same ip:port.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1535
Release commits for v0.13.2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1536
Remove allowance of ClientStream.sendCancel() before start()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It looks like it will trigger a NullPointerException. This could maybe be handled in AbstractClientStream, but I'm unsure if that's the best place.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1537
DelayedStream.setStream() should cancel the provided stream if not using it
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If cancel() or setStream() was previously called then setStream() throws away the stream argument. It should cancel() the stream to make sure resources are freed, although I think only DelayedClientTransport benefits.
This should not be done until after #1536. I don't know if OkHttp suffers a similar problem. If so, we may want to revisit whether it makes sense to allow streams to be cancelled before start().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1538
More logging in channel implementations.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1539
How to connect to unix socket?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using this code snippet to connect to gRPC server though a unix socket:
ManagedChannel channel = ManagedChannelBuilder.forTarget("unix:/tmp/imageresizer.socket")
        .usePlaintext(true)
        .build();

but I'm getting this exception: java.lang.IllegalArgumentException: cannot find a NameResolver for unix:/tmp/imageresizer.socket
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1540
It seems that CallOptions.withDeadlineAfter does not provide a fully functional timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CallOptions.withDeadlineAfter works when client and server are connected or can be connected but the server can not respond in time. When it comes to network partition, a CallOptions.blockingUnaryCall will wait about 30s to throw an exception despite the deadline.
I can walk around this by giving timeout parameters to the future.get() inside CallOptions.getUnchecked(Future future) like this
private static <V> V getUnchecked(Future<V> future) {
        try {
          return future.get(2, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          throw Status.CANCELLED.withCause(e).asRuntimeException();
        } catch (ExecutionException e) {
          throw Status.fromThrowable(e).asRuntimeException();
        } catch (TimeoutException e) {
          throw Status.fromThrowable(e).asRuntimeException();
        }
But I believe there should be a better way @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1541
Remove support for Nano's deprecated package names
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1542
Use bytes instead of a string for IP address.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1543
Update README to reference v0.13.2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1544
Improve updating hosted JavaDoc for copy/pasting commands
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1545
Allow for interaction with flow-control on server in service implementations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
@jhump
@jhspaybar
PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1546
If DNS resolution fails, the Channel is permanently failed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should probably update DnsNameResolver to continue retrying the DNS query until shutdown, at maybe a fixed rate of 1 minute or such. Overall, it's not a superb solution, but it fixes a lot of the problem and is expedient to implement.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1547
Rename older AbstractTransportTest to AbstractInteropTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1548
Remove last vestiges of ChannelImpl/ServerImpl from security doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1549
Simplify implementation of back-pressure in StreamObserver-based stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pending API changes can allow reactive/async pattern for interacting with flow control and applying back pressure: https://github.com/grpc/grpc-java/pull/1545/files
In many cases, automatic back-pressure in generated stubs could be very useful -- e.g. having calls to StreamObserve#onNext(T) block instead of queueing.
It's been pointed out that this could cause deadlock for bidi-streaming operations, so perhaps we can just not expose this functionality for bidi-streaming calls?
It may also be worth pointing out that most other runtimes (wrapped languages and Go) already expose streams via blocking operations and already require that apps be aware of and work-around possible deadlock issues resulting therefrom. So maybe providing similar mechanisms in Java is fine, with said caveats.
Another possible alternative could possibly be done in an extension/add-on instead of in GRPC. For example, wrapping streaming requests and responses with RxJava Observables may further simplify the async case enough to make the synchronous (and possibly-deadlock-prone) case unnecessary.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1550
Speed up NanoUtilsTest by 10s
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1551
Example of LoadBalancer implementation? 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is there a example we can see how to createa and use an  LoadBalancer  ? It should be able to deal with usual error and some health checking/retry etc.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1552
Unchecked exceptions can't be captured from a ServerInterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm attempting to add instrumentation to our gRPC service implementations using a ServerInterceptor, namely failure rates on a per-method basis. To do this, I'm using a SimpleForwardingServerCall, overriding the close method and then checking the status to see if the call succeeded.
When an unchecked exception is thrown from a service implementation:
@Override
    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
       throw new RuntimeException("BOOM!");
    }
and given an interceptCall method that looks something like this:
@Override
  public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
      MethodDescriptor<ReqT, RespT> method,
      ServerCall<RespT> call,
      final Metadata requestHeaders,
      ServerCallHandler<ReqT, RespT> next) {

    return next.startCall(method, new SimpleForwardingServerCall<RespT>(call) {
      @Override
      public void close(Status status, Metadata trailers) {
        logger.info("ERROR ENCOUNTERED"); // <-- never see this
        super.close(status, trailers);
      }
    }, requestHeaders);
  }
the close method is never called, so there isn't an opportunity to log the failure.
The exception seems to bubble up to the Executor instead:
Mar 15, 2016 12:26:59 PM io.grpc.internal.SerializingExecutor$TaskRunner run
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$2@3e694e4a
java.lang.RuntimeException: BOOM!
    at io.grpc.examples.helloworld.HelloWorldServer$GreeterImpl.sayHello(HelloWorldServer.java:98)
    at io.grpc.examples.helloworld.GreeterGrpc$MethodHandlers.invoke(GreeterGrpc.java:161)
    at io.grpc.stub.ServerCalls$1$1.onHalfClose(ServerCalls.java:147)
    at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:255)
    at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$2.runInContext(ServerImpl.java:458)
    at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:54)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745) 

I've also tried returning a ForwardingServerCallListener from interceptCall and the onComplete callback is invoked, but it doesn't have enough information for me to determine if the call was a failure.
Is there another API I can take a look at that will allow me to capture these failures?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1553
Synchronize benchmarking protos with grpc/grpc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1554
Add null check for channel and calloptions when creating stub.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1555
Use FastThreadLocalThread's in shared channel executor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While working on netty/netty@b88a980 I noticed that when using the blocking stub and the netty transport, we allocate in Netty's allocator from within the shared executor threads. Netty's allocator employs thread local caches that perform the majority of allocations. These caches are accessed via Netty's own threadlocal implementation FastThreadLocal, which is only "fast" when used in the context of a FastThreadLocalThread.
We should provide our own thread factory to the cached thread pool in order to create FastThreadLocalThreads. Additionally, we should override the Thread's run() method to do
  public void run() {
    try {
      super.run();
   } finally {
     FastThreadLocal.removeAll();
   }
  }

This will release all memory from a thread's cache when it is shutdown. That should happen quite frequently, with the pool sizing threads dynamically.
However, I don't know how to best implement this. The shared channel executor should be shared by all transport, client, server combinations running in a JVM. Also, I assume we can't rely on the Netty dependency to be there on Android?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1556
Change the way we pass SSLSession
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now, we're using Netty's channel attributes to pass SSLSession object from one place to another. It was a quick win when adding ServerCall#attributes() support.
We want to plumb it through as an argument.
Ref: https://github.com/grpc/grpc-java/pull/1506/files#r56371848
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1557
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1558
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1559
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1560
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1561
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1562
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1563
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1564
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1565
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1566
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1567
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1568
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1569
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1570
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1571
Create protobuf-lite project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current protobuf project can be used with lite, but only by excluding the protobuf dependency and adding your own dependency on lite (which is not yet available on Maven Central). That is weak, but also doesn't work in some compilation environments. We should create a separate protobuf-lite project, which protobuf can depend on, for LITE_RUNTIME users.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1572
Fix flaky DeadlineTest.runOnEventualExpirationIsExecuted()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1573
Remove references to Throwables.propagate
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1574
Add native support for Protobuf Lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM, thanks for doing this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1575
Context deadline propagation should cascade
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1576
Overload ServerBuilder.addService to take a Supplier of the service definition
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In general, servers want to instantiate a new method handler for each call to avoid polluted state. We'd like this to be handled by the framework, rather than asking application developers to remember it. The current API essentially pushes the responsibility to the application:

The Server is a singleton since it has a long-lived lifecycle
ServerBuilder.addService(ServerServiceDefinition service) requires that the service be instantiated at startup
FooServiceGrpc.bindService(FooService serviceImpl) also requires that the serviceImpl be instantiated. Thus, the FooService has to be a singleton with respect to the server lifecycle. That is, your implementation of the generated service stub has to be a singleton. So the app developer has to worry about the scope of the dependency chain from there down.

I propose overloading the generated code to take a Supplier of some sort: FooServiceGrpc.bindService(Supplier<FooService> serviceImplSupplier). This would let me pass a Guice Provider::get to the bindService method and get whatever Guice scoping I want on method calls. This lets me handle proper scoping in my own framework code rather than in every implementation of a stub.
Almost as good would be pushing the thunk-ness back a layer to ServerBuilder.addService(Supplier<ServerServiceDefinition> serviceSupplier), but I suspect that is harder to implement.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1577
Solve logging
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We used to have some INFO logs, but they were considered spam by some users (#1439), so they were reduced to FINE (#1449). In general, open source libraries don't log unless something is going wrong, and these log statements didn't imply something was wrong.
However, in #1538 INFO-level logs were added back (in a different place, but same effective event). These could be a lower level, but it seems difficult for users to enable a higher logging level.
We do know applications can do something like this to squelch what is logged:
// May need to save this reference
Logger log = Logger.getlogger("io.grpc");
log.setLevel(Level.WARNING);
More than one project has been annoyed with the logging-by-default, but the number of Java developers who can handle logging.properties seems limited.
On Android, things are even worse because most phones almost always return false from Log.isLoggable() for lower log levels. Developer phones (like debug builds of Android) will return true, but few develop on such phones. This means that even when you configure java.util.logging to log lower levels, they won't actually be logged. You can run a command like adb shell setprop log.tag.<MAGICTAG> VERBOSE for each class you want to log, where the MAGICTAG can be found from DalvikLogging.loggerNameToTag(), but this is so painful it isn't close to practical.
Note that most Android applications don't notice any problem with Log.isLoggable() because while it may return false, if you call the log anyway (say, via Log.v()) apparently it will be logged.
One developer suggested we use slf4j because it is "java best practices." I think in some part of the Java world it is, but it is unclear whether grpc exists in that part of the world. The number of developers that can configure java.util.logging, log4j, logback, or slf4j is certainly higher than just java.util.logging, but it will also become harder to direct users in how to enable logging when we need it for a report. It also has the deficiency that "If no binding is found on the class path, then SLF4J will default to a no-operation implementation" which is pretty bad for our WARNING statements.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1578
io.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before write could take place
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using latest GRPC java release, what could possbily be the reason?
Thanks
2016-03-23 13:58:51.999  WARN 1 --- [lt-worker-ELG-5] io.grpc.netty.NettyServerHandler         : Stream Error

io.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before write could take place
    at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:144) ~[netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.cancel(DefaultHttp2RemoteFlowController.java:464) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$DefaultState.cancel(DefaultHttp2RemoteFlowController.java:446) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.onStreamClosed(DefaultHttp2RemoteFlowController.java:110) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:347) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1241) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.deactivate(DefaultHttp2Connection.java:1183) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:533) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.Http2ConnectionHandler.closeStream(Http2ConnectionHandler.java:516) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onRstStreamRead(DefaultHttp2ConnectionDecoder.java:389) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onRstStreamRead(Http2InboundFrameLogger.java:78) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readRstStreamFrame(DefaultHttp2FrameReader.java:489) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:249) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:147) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:106) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:332) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:392) [netty-codec-http2-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:387) [netty-codec-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:245) [netty-codec-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:154) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:354) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:145) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:1078) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353) [netty-transport-4.1.0.CR3.jar!/:4.1.0.CR3]
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742) [netty-common-4.1.0.CR3.jar!/:4.1.0.CR3]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_72]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_72]
    at java.lang.Thread.run(Thread.java:745) [na:1.8.0_72]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1579
Error message built with Status exception builder is not serialized properly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Status.INTERNAL
                            .withDescription("internal error")
                            .augmentDescription("additional description")
                            .withCause(e)
                            .asRuntimeException()
creates an exception with detailedMessage containing '\n' character. In TransportFrameUtil this character fails the validation rule isSpecCompliantAscii, which results in grpc-message header being silently discarded.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1580
Fix Status.(equals|hashCode) to be based on Status.getCode().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ahhhh nvm :-D
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1581
Update Netty to 4.1.0-CR4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1582
okhttp integration tests fail with latest oracle jdk on OSX
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After updating to the latest Oracle JDK8u73 on OS X , the okhttp integration tests fail.
Running ./gradlew clean build on latest master (65d3847) gives me the below output and hangs there indefinitely.
:grpc-interop-testing:test
objc[25479]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_73.jdk/Contents/Home/bin/java and /Library/Java/JavaVirtualMachines/jdk1.8.0_73.jdk/Contents/Home/jre/lib/libinstrument.dylib. One of the two will be used. Which one is undefined.

io.grpc.testing.integration.Http2OkHttpTest > receivedDataForFinishedStream FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:445)
        at com.google.common.util.concurrent.AbstractFuture$TrustedFuture.get(AbstractFuture.java:79)
        at io.grpc.testing.integration.Http2OkHttpTest.receivedDataForFinishedStream(Http2OkHttpTest.java:133)

io.grpc.testing.integration.Http2OkHttpTest > wrongHostNameFailHostnameVerification FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:500)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:134)
        at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:214)
        at io.grpc.testing.integration.Http2OkHttpTest.wrongHostNameFailHostnameVerification(Http2OkHttpTest.java:155)

io.grpc.testing.integration.Http2OkHttpTest > veryLargeRequest FAILED
    java.lang.Exception: test timed out after 30000 milliseconds

io.grpc.testing.integration.Http2OkHttpTest > deadlineExceeded FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
> Building 74% > :grpc-interop-testing:test > 122 tests completed, 4 failed

Using jstack, I can see that gradle hangs at AbstractInteropTest.deadlineNotExceeded
"Test worker" #11 prio=5 os_prio=31 tid=0x00007fe0cd2bb000 nid=0x5103 waiting on condition [0x0000700001146000]
   java.lang.Thread.State: WAITING (parking)
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00000007a6a0bef8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
    at io.grpc.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:500)
    at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:134)
    at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:214)
    at io.grpc.testing.integration.AbstractInteropTest.deadlineNotExceeded(AbstractInteropTest.java:624)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)

The issue is always reproducable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1583
Implement the load worker for continuous benchmarking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr
@ejona86
PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1584
Create a stress test client for Java 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The specification for the stress test client is at : https://github.com/grpc/grpc/blob/master/tools/run_tests/stress_test/STRESS_CLIENT_SPEC.md
FYI: The C++ stress test client is here
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1585
Update Netty dependency to 4.1CR4.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #1581
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1586
WIP: Another retry interceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can one of the admins verify this patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1587
Add backoffPolicyProvider to managed chan builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1588
Use stream.cancel() instead of cancel() in ClientCallImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1589
Provide description to Status used in ClientCallImpl.cancel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now it is just Status.CANCELLED. We should give it a description so that it is more obvious it was generated locally (such as "Client cancelled call"). This is trivial, except plenty of tests fail, so they need to be updated to just check the Code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1590
Retries as a first-class feature
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Easy-to-enable, first-class API for having automatic retry any type of call. It would be good if this API supported hedging, where you preemptively issue a second RPC if the first is taking a while. Supporting hedging means that hedging would not need additional buffering.
This is larger in scope than #1122, which is only unary. This is related to #1570 and #1586, but more concerned with the API to expose to applications and the cross-language feature set. I've not yet looked at the policy in those PRs, so this says nothing about how I feel about the policy presented there. We can end up copying some of the policy in the PRs into this discussion.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1591
Refresh name resolution if all addresses failed to connect.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1592
Make CallOptions and AbstractStub use Deadline.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PTAL @ejona86 @louiscryan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1593
Return InProcessSocketAddr for InProcess server streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1594
Revert "Refactor ExponentialBackoffPolicy"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1595
Clean up bitrot from Android example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1596
Warn users shutdownNow doesn't behave as documented
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1597
Stop using grpc-all
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-all appears convenient, but it sort of makes a mess because it repackages. We could remove the repackaging logic and have it just pull in other dependencies, but it seems maybe better to have users just depend on the pieces they need.
Related: netty/netty#4671
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1598
Include sources for all files in 'fat' binary jar
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM. Tested the change locally. grpc-all-*-SOURCES.jar now contains sources.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1599
Only events from NameResolver-produced address should trigger resolution refresh
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently a failure on any TransportSet will trigger name resolution. However, the addresses of a TransportSet may also originate from an external load-balancing service, e.g., in GrpclbLoadBalancer. A failure on such TransportSet shouldn't trigger name resolution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1600
Round-robin LB should be aware of and skip bad servers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The round-robin logic in GrpclbLoadBalancer should listen to transport life-cycle events (handleTransportReady() and handleTransportShutdown()) to learn what servers are not usable, so that it can skip them. The round-robin logic will also be shared with the simple round-robin LoadBalancer (which is yet to be implemented).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1601
Trigger name resolution also when a live connection closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#1591 doesn't cover the case where some addresses have changed in the name system while some are still there and usable. This may end up trying to connect old addresses each time we reconnect. The solution is to also trigger a name resolution after a live connection has been closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1602
Retry DNS resolution when there is an error.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1603
Add RunWith annotation to AbstractStubTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1604
Trigger name resolution when a live connection closed.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1605
Ensure that gRPC Java implementation conforms to standard status codes in gRPC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Error code specification - https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1606
Message serialization occurs on transport thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TransportSet is calling setTransport() from the transportReady notification. setTransport() eventually ends up serializing messages. This means we are 1) running application-provided code on the transport thread and 2) performing expensive operations on the transport thread. We need to figure out a way to avoid serializing on the transport thread.
One type of option is to use an executor for setTransport(). Another type of option would be to actually serialize the message within DelayedStream.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1607
testConfigureDeadlineNanoTime is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen for https://travis-ci.org/grpc/grpc-java/jobs/119128181 (rerun, so log no longer visible):
io.grpc.stub.StubConfigTest > testConfigureDeadlineNanoTime FAILED
    java.lang.AssertionError: expected:<4.0276534E13> but was:<4.0276563E13>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:519)
        at org.junit.Assert.assertEquals(Assert.java:609)
        at io.grpc.stub.StubConfigTest.testConfigureDeadlineNanoTime(StubConfigTest.java:114)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1608
Fix flaky deadline test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1609
Codegen should observe lite=true flag instead of LITE_RUNTIME
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The LITE_RUNTIME option is to go away in protobuf because it makes using the same proto on server-side and client-side problematic. Instead, an option is going to be passed to protoc to enable Lite. We should do the same for gRPC. We can use lite=true for now; we can watch protoc to see what flag they end up using.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1610
Provide default implementation for NameResolver.refresh().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1611
Raise visibility of NettyTransportFactory to protected.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1612
Codegen should include proto-defined service/method comments in JavaDoc 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1613
Use lite argument in codegen instead of LITE_RUNTIME
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI: test.proto is copied for lite because lite doesn't yet support proto3 externally, so the only differences are proto2 vs proto3 and LITE_RUNTIME. Once the public protoc catches up then we can remove the extra file.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1614
android-interop-testing fails to ProGuard
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It may just be my machine, but android-interop-testing is failing to build. It may have appeared to work before because I wasn't doing "gradle install" of grpc first, however that doesn't seem like a full explanation given some other things I've been doing. In some ways I hope I've just hosed something on my machine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1615
Simplify nano flag to codegen to just 'nano' from 'nano=true'
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1616
CallOptionsTest.testToString is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://travis-ci.org/grpc/grpc-java/jobs/119406156, since rebuilt (so logs lost):
io.grpc.CallOptionsTest > testToString FAILED
    java.lang.AssertionError: expected:<-1.8554508E7> but was:<-4.2944444E7>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:519)
        at org.junit.Assert.assertEquals(Assert.java:609)
        at io.grpc.CallOptionsTest.testToString(CallOptionsTest.java:144)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1617
DeadlineTest.shortDeadlineEventuallyExpires is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/948/console
io.grpc.DeadlineTest > shortDeadlineEventuallyExpires FAILED
    java.lang.AssertionError: expected:<0.0> but was:<-6.401849E8>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:519)
        at org.junit.Assert.assertEquals(Assert.java:609)
        at io.grpc.DeadlineTest.shortDeadlineEventuallyExpires(DeadlineTest.java:73)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1618
Include protobuf-lite in javadoc and test coverage reporting
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1619
Remove Flakes caused by assertEquals
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1620
Fix UNAVAILABLE codes missing descriptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1621
Add an ability to run protobuf server as a Servlet 4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pls add an ability to run a protobuf v3 server as a Servlet 4 on any server with the Servlet 4 support.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1622
Anyone use gRPC in prod evn? please share your practice
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As title, please leave your product name, experience, anything you want to share
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1623
Update Netty dependency to 4.1CR5.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1624
Remove unused method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1625
javaPluginPath in gradle build does not work for me
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm building protobuf, grpc and grpc-java all from scratch, but without heavy customization. This mostly works, however grpc-java does only compile and work for me if I patch the gradle build:
--- build.gradle.org    2016-03-01 23:39:38.835011070 +0100
+++ build.gradle    2016-03-01 23:39:48.070902802 +0100
@@ -52,7 +52,7 @@
     ext {
         def exeSuffix = osdetector.os == 'windows' ? ".exe" : ""
         protocPluginBaseName = 'protoc-gen-grpc-java'
-        javaPluginPath = "$rootDir/compiler/build/exe/java_plugin/$protocPluginBaseName$exeSuffix"
+        javaPluginPath = "$rootDir/compiler/build/binaries/java_pluginExecutable/$protocPluginBaseName$exeSuffix"

         protobufVersion = '3.0.0-beta-2'
         protobufNanoVersion = '3.0.0-alpha-5'

I don't know why I seem to need a change in javaPluginPath? Is this due to my custom build of protobuf? I did not make any (intentional) changes to protobuf that would ring a bell...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1626
Context.fork shouldn't return a CancellableContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just because someone wants to fork a Context, doesn't mean they want that Context to be cancellable. In addition, it requires the caller to close the CancellableContext when they are done. Since it is trivial for the caller to also call withCancellation(), it seems best to return a plain Context.
@louiscryan, thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1627
Try out using Truth library
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1628
Support OkHttp3?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's been a while since stable OkHttp3 has been released and libraries depending on OkHttp started to support OkHttp3 as well. Is there any plan to support OkHttp3?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1629
io.grpc.StatusRuntimeException: INTERNAL: Failed to frame message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
message Test {
  bytes test = 1;
}

The above runtime exception is thrown when a field of type []byte is set to null and one tries to use it as service argument.
The code is executed on Android. I use protobuf-nano.
Default value for []byte is com.google.protobuf.nano.WireFormatNano.EMPTY_BYTES
The error is hard to spot. Is this stated in a documentation? Maybe it should be treated as a default value? Not sure.
protoc version: 3.0.0-beta-2
gRPC version: 0.13.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1630
Update Netty dependency to 4.1CR6.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1631
Add rst error detail in OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1632
deadlineExceeded interop test is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
intervalUs is used for consecutive responses. We cannot use it for the only response and expect a delay from server sending the response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1633
Fix deadlineExceed test. Correctly use intervalUs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#1632
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1634
Add Abstract{ServiceName} class in compiled service class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Added separate commit which regenerates protos after changes in compiler in first commit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1635
Force thread group on threads created by Netty's DefaultThreadFactory.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM, build failure seems unrelated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1636
Do I need to use common-pools to wrap ManagedChannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Do we need to implement a pool of ManagedChannel on the client side?
We are currently sharing a single ManagedChannel to a single target on whole application, but we are seeing some pretty weird behavior that channel went into permanent DEADLINE_EXCEEDED mode.
We havn't been able to replicated it locally and we are trying anything we can..
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1637
Fix flakes in Deadline testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1638
propagate unchecked exceptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1639
Pin versions on unstable packages: grpc-core internal and netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1640
Fix POM connection from svn to git
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1641
Add stress test client. Fixes #1584 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Errors seem unrelated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1642
Remove some array copies in metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1643
add a little detail about thread safety / fix typo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1644
Remove some more header copies.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1645
CallOptionsTest.withDeadlineNanoTime is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.CallOptionsTest > withDeadlineNanoTime FAILED
    java.lang.AssertionError: <-25128839 ns from now> and <-1322031 ns from now> should have been within <20000000ns> of each other
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
        at com.google.common.truth.Subject.failWithRawMessage(Subject.java:381)
        at io.grpc.testing.DeadlineSubject.access$400(DeadlineSubject.java:52)
        at io.grpc.testing.DeadlineSubject$1.of(DeadlineSubject.java:81)
        at io.grpc.CallOptionsTest.withDeadlineNanoTime(CallOptionsTest.java:161)

As seen (may have been restarted):
https://travis-ci.org/grpc/grpc-java/jobs/121289248
https://travis-ci.org/grpc/grpc-java/jobs/121487416
(<-33620603 ns from now> and <-2319629 ns from now> should have been within <20000000ns> of each other)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1646
StubConfigTest.testConfigureDeadlineNanoTime is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.stub.StubConfigTest > testConfigureDeadlineNanoTime FAILED
    java.lang.AssertionError: 20000000 < 45632697
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.assertTrue(Assert.java:41)
        at io.grpc.stub.StubConfigTest.testConfigureDeadlineNanoTime(StubConfigTest.java:116)

As seen in (may have been restarted):
https://travis-ci.org/grpc/grpc-java/jobs/121487417
https://travis-ci.org/grpc/grpc-java/jobs/121488444 (20000000 < 24579334)
https://travis-ci.org/grpc/grpc-java/jobs/118573602, which was before assertEquals float vs double fix, so it had:
io.grpc.stub.StubConfigTest > testConfigureDeadlineNanoTime FAILED
    java.lang.AssertionError: expected:<1.68848953E13> but was:<1.68849184E13>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:519)
        at org.junit.Assert.assertEquals(Assert.java:609)
        at io.grpc.stub.StubConfigTest.testConfigureDeadlineNanoTime(StubConfigTest.java:114)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1647
Provide base methods for Abstract stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1648
Add KeepAlive support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With our sue of gRPC Java across Google Compute Engine (GCE) L3 Load Balancers (Network Load Balancers), we seem to be hitting similar issues we had with gRPC in Go:
grpc/grpc-go#536
Basically Google L3 load balancers silently drop long-lasting TCP connections after 600 seconds.
While we were able to work around the issue by specifying a custom Dialer in Go:
func WithKeepAliveDialer() grpc.DialOption {
    return grpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {
        d := net.Dialer{Timeout: timeout, KeepAlive: *flagGrpcClientKeepAliveDuration}
        return d.Dial("tcp", addr)
    })
}
There seems to be no way of overriding the KeepAlive peridods for NettyClientTransport. We know it's possible to set the keep alive period in the kernel of the machines, but that's a bit of a stretch to expect the user-code programmers to know about it.
Can we either:

have the ability to specify the TCP keep alive period on create of channel
documentation around it, especially how it can cause hard-to-debug problems on GCE?

cc @ejona86 since he seems to have had opinions about it in #737
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1649
Adapt BindableService in ServerBuilder#addService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PS: The re-generated classes will conflict with changes in #1647 but it'll be very easy one to resolve - ./gradlew clean build will regenerate correct stubs so order of merging those PRs shouldn't matter.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1650
Deflake CallOptionsTest.withDeadlineNanoTime
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1651
Deflake StubConfigTest.testConfigureDeadlineNanoTime
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1652
Exceptions thrown in StreamObserver.onNext() may be swallowed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For unary calls it appears the exception is basically guaranteed to be swallowed.
See #1638 for some discussion. Basically we try to fail the call with a Status, but if the call already completed successfully (which is especially likely for unary calls) the exception is thrown away.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1653
Conventions and style
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've recently become an active contributor to the project and managed to have few of my PRs merged. My PRs received a lot of great feedback and good comments but also A LOT of convention/code style related ones. Everytime I receive one I feel really bad that I've wasted both mine and reviewer's time and only made whole review process longer by result. I tried really hard to improve in this area and conform to the coding standards but still noticeably failing at it and making nontrivial number of errors.
I really think that having conventions and pointing out inconsistencies in PRs is the right thing to do - please continue doing this - but I want to point out that we have two problems: tooling and style inconsistencies in existing code.
Regarding former, together with @ejona86 we tried to fix in google/styleguide#115. Latter is more tricky and partially fixable by former by having cohesive conventions. I don't think we should  create a massive "Fix style" type commit fixing all whitespaces and formatting because it'll only obfuscate git history but we need to agree which is the right convention with which we want to move forward and format every new code using it (case in point: indentation after line break in method definition is different between two methods in the same file )
One more time it'd like to emphasize that I'm not moaning about nitpicking but rather raising an issue which after solving will make lives better for both maintainers and contributors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1654
Fix proguard. Added three donotwarn for things we don't use at all inâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#1614
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1655
Android example fails to build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is basically the equivalent to #1614
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1656
Split-state AbstractStream; sending and receiving
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1657
OutOfBounds exception with NameResolvers and TransportSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Long story short, it appears there's an explicit array.get(0) that happens on the first outbound call, but if the NameResolver hasn't found any servers yet, this causes an exception.  Stack trace can be found below(SpectatorInterceptor is a proprietary metrics component, and the EurekaNameResolver simply uses Eureka to resolve a set of IP + port that can then be used to load balance).  In the case below, the list of servers the EurekaNameResolver passes to onUpdate is empty.
SEVERE: Exception while executing runnable io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$2@7d8bd17e
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
    at java.util.ArrayList.rangeCheck(ArrayList.java:653)
    at java.util.ArrayList.get(ArrayList.java:429)
    at java.util.Collections$UnmodifiableList.get(Collections.java:1309)
    at io.grpc.internal.TransportSet.scheduleConnection(TransportSet.java:197)
    at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:169)
    at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:381)
    at io.grpc.SimpleLoadBalancerFactory$SimpleLoadBalancer$1.get(SimpleLoadBalancerFactory.java:121)
    at io.grpc.SimpleLoadBalancerFactory$SimpleLoadBalancer$1.get(SimpleLoadBalancerFactory.java:119)
    at io.grpc.internal.BlankFutureProvider$FulfillmentBatch.link(BlankFutureProvider.java:128)
    at io.grpc.SimpleLoadBalancerFactory$SimpleLoadBalancer.handleResolvedAddresses(SimpleLoadBalancerFactory.java:119)
    at io.grpc.internal.ManagedChannelImpl$2.onUpdate(ManagedChannelImpl.java:165)
    at com.netflix.grpc.nameresolver.eureka.EurekaNameResolver$1.onNext(EurekaNameResolver.java:64)
    at com.netflix.grpc.nameresolver.eureka.EurekaNameResolver$1.onNext(EurekaNameResolver.java:61)
    at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onMessage(ClientCalls.java:305)
    at io.grpc.ForwardingClientCallListener.onMessage(ForwardingClientCallListener.java:51)
    at io.grpc.ForwardingClientCallListener.onMessage(ForwardingClientCallListener.java:51)
    at com.netflix.grpc.interceptor.spectator.SpectatorMetricsClientInterceptor$1$1.onMessage(SpectatorMetricsClientInterceptor.java:44)
    at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$2.runInContext(ClientCallImpl.java:423)
    at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:54)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1658
Print compiler version number in generated files
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM, but all the CIs are failing with the change, and it's not clear why.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1659
Update Netty dependency to 4.1.0.CR7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1660
Add an API on Channel for getting Channel security configuration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As required by #874, auth interceptors needs to know whether the channel is using secure transport, something like
enum SecurityFeature {
  AUTHENTICATION,
  INTEGRITY,
  PRIVACY
}

interface Channel {
  ...
  EnumSet<SecurityFeature> getSecurityFeatures()
}

The features are not necessarily orthogonal. For example, AUTHENTICATION is only useful when INTEGRITY is there, so we may want to make AUTHENTICATION automatically imply INTEGRITY. The enum may also be expanded when necessary.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1661
Convert Netty IOExceptions to UNAVAILABLE.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @carl-mastrangelo PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1662
Delayed transport creates real streams in executor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1663
Need to remove usages of Guava's Throwables.getCausalChain
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It is marked @Beta, so isn't appropriate in a library.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1664
Solve formatting problems once and for all
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
...by submitting to our benevolent autonomous overlords.  The Google standard formatter would solve all formatting debates, and could be pulled in as part of our tests:
https://github.com/google/google-java-format
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1665
ServerInterceptor close trigger MessageDeframer is already closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want implements ServerInterceptor for intercepting incoming calls to check valid authentication credentials.
Here is my java env and code snippet.
question is:

invoke serverCall.close and return null trigger NPE

exception stack:
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1@803a06c
java.lang.NullPointerException: startCall() returned a null listener for method com.elegantpay.merchant.api.DictService/SearchCNAPS
    at io.grpc.internal.ServerImpl$ServerTransportListenerImpl.startCall(ServerImpl.java:371)
    at io.grpc.internal.ServerImpl$ServerTransportListenerImpl.access$1100(ServerImpl.java:282)
    at io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1.runInContext(ServerImpl.java:326)
    at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:54)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)


invoke serverCall.close then return return new ServerCall.Listener(){} // empty Listener, trigger MessageDeframer is already closed Exception


Note: this exception is not appear at first time, should invoke client/stub again, the server side exception show up

exception stack:
WARNING: Exception processing message
java.lang.IllegalStateException: MessageDeframer is already closed
    at com.google.common.base.Preconditions.checkState(Preconditions.java:174)
    at io.grpc.internal.MessageDeframer.checkNotClosed(MessageDeframer.java:222)
    at io.grpc.internal.MessageDeframer.deframe(MessageDeframer.java:168)
    at io.grpc.internal.AbstractStream.deframe(AbstractStream.java:276)
    at io.grpc.internal.AbstractServerStream.inboundDataReceived(AbstractServerStream.java:155)
    at io.grpc.netty.NettyServerStream.inboundDataReceived(NettyServerStream.java:77)
    at io.grpc.netty.NettyServerHandler.onDataRead(NettyServerHandler.java:216)
    at io.grpc.netty.NettyServerHandler.access$300(NettyServerHandler.java:93)
    at io.grpc.netty.NettyServerHandler$FrameListener.onDataRead(NettyServerHandler.java:425)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:245)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:46)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:409)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:240)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:147)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:106)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:332)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:392)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:387)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:245)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:154)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:354)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:145)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:1078)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

env:
java version "1.7.0_72"
Java(TM) SE Runtime Environment (build 1.7.0_72-b14)
Java HotSpot(TM) 64-Bit Server VM (build 24.72-b04, mixed mode)

grpc version: compile 'io.grpc:grpc-all:0.13.2'

groovy code

import io.grpc.Metadata
import io.grpc.MethodDescriptor
import io.grpc.ServerCall
import io.grpc.ServerCallHandler
import io.grpc.ServerInterceptor
import io.grpc.Status

class MyInterceptor implements ServerInterceptor {
    @Override
    def <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            MethodDescriptor<ReqT, RespT> methodDescriptor,
            ServerCall<RespT> serverCall,
            Metadata metadata,
            ServerCallHandler<ReqT, RespT> serverCallHandler) {

        // for test
        serverCall.close(Status.UNAUTHENTICATED, new Metadata())

        return null // if close then return null trigger NPE
    }
}
so. is the bug? or what is the best practices doing this.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1666
create AuthorityOverridingTransportFactory instance only in need
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1667
Bump jmh version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1668
Add getting the port out of a Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1669
GrpcUtil.getGrpcUserAgent creates a lot of garbage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GrpcUtil.getGrpcUserAgent creates a lot of garbage based on profiling, showing up in the top 20.  It appears that this call was designed to mostly static and not change per call.
We should find a way to initialize this at channel creation time to make this not so messy.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1670
DefaultHttp2HeadersEncoder.encodeHeaders are slow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After GC and syscalls, io.netty.handler.codec.http2.DefaultHttp2HeadersEncoder.encodeHeaders takes the most CPU on a simple ping pong stress test. It accounts for about 3.3% of total program time.  The offending line is:
https://github.com/netty/netty/blob/83c349ffa94d3992c4ee511d3625afc0c97c12bb/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java#L68
I am not sure why this is so slow, but we should probably investigate it.  My test does nothing special with  headers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1671
Handle empty address list from NameResolver.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1672
Update benchmark gradle file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
There will be some other plugins we'll want to update to the new (unstable) syntax, but no need to do now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1673
Handle exceptions from LoadBalancer.handleResolvedAddresses()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1674
Rapidly cancelling a Call can overwhelm transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Doing something like
      ClientCall<Void, Void> call = channel.newCall(foo, CallOptions.DEFAULT);
      call.start(listen, new Metadata());
      call.sendMessage(null);
      call.halfClose();
      call.request(1);
      call.cancel();

rapidly in a loop causes memory to not get reclaimed.  Somehow netty is holding on to commands sent to it from the ClientCallImpl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1675
MessageFramer allocates 1 byte array
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Each RPC creates a message framer which has a ref to a BufferChainOutputStream, which always allocates a single byte array.  At a high number of concurrent RPCs, this accounts for a non trivial number of 1 byte arrays (like millions).
This should be easy to remove, and make the GC have an easier time.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1676
Reduce default max message size
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently DEFAULT_MAX_MESSAGE_SIZE is 100 MB. That's laughably high. We should reduce it down to at least 10 MB, but 1 MB would make me feel much better.
This needs to be done cross-language.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1677
Add javadoc to grpc codegen based on proto docs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1678
Maybe add overload of providing ExtensionRegistryLite to Marhsallers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Somehow, some way, extension registries need to be passable to the grpc unmarshalling code.  Right now there isn't a good way to do so, due to marshalling being directly referenced by the stub, rather than the server/channel.  This means any code that is using proto2 extensions won't work with grpc.  Some ideas:

Make the stub code accept an extension registry if the proto syntax that generated the file is proto2
Allow a way for the extension registry to be passed to the client or server
Something else.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1679
Rename internal.Server to internal.TransportServer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We didn't do this because we also have a ServerTransport, which is confusing in its own right.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1680
Fix compilation nags for generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1681
Allow use of a global ExtensionRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1682
Cancelling a call results in onClose never being invoked. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Consider the following code:
      final ClientCall<Void, Void> call = channel.newCall(..., ...);
      ClientCall.Listener<Void> listen =
          new ClientCall.Listener<Void>() {
            @Override
            public void onMessage(Void message) {
              call.cancel();
            }

            @Override
            public void onClose(Status status, Metadata trailers) {
              // NEVER CALLED!
            }
          };
      call.start(listen, new Metadata());
      call.sendMessage(msg);
      call.halfClose();
      call.request(1);

onClose will not be invoked, so it becomes impossible to know when the call is actually done.  This seems wrong.  If the call is cancelled from outside of the listener, onClose is invoked.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1683
protoc-gen-grpc-java crashed on MaxOS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I meet this problem when I was trying to generate code based on my .proto file, and the error stack trace is:
[ERROR] PROTOC FAILED: --grpc-java_out: protoc-gen-grpc-java: Plugin killed by signal 11.

[ERROR] /Users/nankonami/Documents/etcd4j/src/main/proto/etcd.proto [0:0]: --grpc-java_out: protoc-gen-grpc-java: Plugin killed by signal 11.

ERROR] Failed to execute goal org.xolstice.maven.plugins:protobuf-maven-plugin:0.5.0:compile-custom (default) on project etcd4j: protoc did not exit cleanly. Review output for more information. -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.xolstice.maven.plugins:protobuf-maven-plugin:0.5.0:compile-custom (default) on project etcd4j: protoc did not exit cleanly. Review output for more information.
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
    at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
Caused by: org.apache.maven.plugin.MojoFailureException: protoc did not exit cleanly. Review output for more information.
    at org.xolstice.maven.plugin.protobuf.AbstractProtocMojo.execute(AbstractProtocMojo.java:539)
    at org.xolstice.maven.plugin.protobuf.AbstractProtocCompileMojo.execute(AbstractProtocCompileMojo.java:31)
    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
    ... 19 more

And my pom.xml content is:

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <artifactTargetPath>${project.build.directory}</artifactTargetPath>
        <maven.compiler.source>1.7</maven.compiler.source>
        <maven.compiler.target>1.7</maven.compiler.target>
    </properties>

    <distributionManagement>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2</url>
        </repository>
    </distributionManagement>

    <dependencies>
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
            <version>3.0.0-beta-2</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-all</artifactId>
            <version>0.13.2</version>
        </dependency>
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpasyncclient</artifactId>
            <version>4.0.2</version>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>14.0.1</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.2.4</version>
        </dependency>

        <dependency>
            <groupId>org.eclipse.jetty</groupId>
            <artifactId>jetty-server</artifactId>
            <version>8.1.16.v20140903</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.eclipse.jetty</groupId>
            <artifactId>jetty-servlet</artifactId>
            <version>8.1.16.v20140903</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest-all</artifactId>
            <version>1.3</version>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.4.1.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.0</version>
                <configuration>
                    <!--
                      The version of protoc must match protobuf-java. If you don't depend on
                      protobuf-java directly, you will be transitively depending on the
                      protobuf-java version that grpc depends on.
                    -->
                    <protocArtifact>com.google.protobuf:protoc:3.0.0-beta-2:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:0.13.2:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

And java -version output is:
java version "1.7.0_55"
Java(TM) SE Runtime Environment (build 1.7.0_55-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.55-b03, mixed mode)

mvn -version output is:
Apache Maven 3.0.3 (r1075438; 2011-03-01 01:31:09+0800)
Maven home: /usr/share/maven
Java version: 1.7.0_55, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk1.7.0_55.jdk/Contents/Home/jre
Default locale: zh_CN, platform encoding: UTF-8
OS name: "mac os x", version: "10.7.5", arch: "x86_64", family: "mac"

protoc --version is:
libprotoc 3.0.0

I have no idea how to fix this issue, and hope you guys can help me. Thanks~
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1684
Update checkstyle version and sync style updates
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1685
QpsWorker doesn't terminate after it has run a client and QuitWorker has been invoked.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was able to successfully run a benchmarking scenario using Java QPS woker, and the worker that was running the server terminates fine, but the worker that acted as a client doesn't terminate.
Output from the worker:
INFO: Client Config 
server_targets: "localhost:60164"
outstanding_rpcs_per_channel: 1
client_channels: 1
async_client_threads: 1
load_params {
  closed_loop {
  }
}
payload_config {
  simple_params {
  }
}
histogram_params {
  resolution: 0.01
  max_possible: 6.0E10
}

Apr 18, 2016 1:36:40 PM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@58d8050a] Created with target directaddress:///localhost/127.0.0.1:60164
Apr 18, 2016 1:37:25 PM io.grpc.internal.ManagedChannelImpl maybeTerminateChannel
INFO: [ManagedChannelImpl@58d8050a] Terminated

after printing "Terminated" the process never finishes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1686
Adjust Java qps worker to work well with run_performance_tests.py
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1687
Fix QpsWorker shutdown properly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1688
some spelling mistakes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1689
Mark generated abstract class as Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1690
Don't allocate extra byte for each MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1691
Fix bugs in our protobuf code generator integration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1692
Fix some corner cases with MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1693
Android - Not referencing the Request and Response file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have imported the project and referring to the android code in examples , below is the build.gradle file I am using .
Thanks in Advance ,
Praveen Pandey
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1694
more friendly to dynamically add or remove services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1695
StressTestClientTest.gaugesShouldBeExported is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://travis-ci.org/grpc/grpc-java/jobs/124416631 (since rebuilt):
io.grpc.testing.integration.StressTestClientTest > gaugesShouldBeExported FAILED
    java.lang.AssertionError: gauges: [/stress_test/server_0/channel_0/stub_1/qps]
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.assertTrue(Assert.java:41)
        at io.grpc.testing.integration.StressTestClientTest.gaugesShouldBeExported(StressTestClientTest.java:158)

Also seen at https://travis-ci.org/grpc/grpc-java/jobs/124340841 (since rebuilt)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1696
Use correct Guava API in stress test client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Eww... @carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1697
Attach an exception to client-initiated CANCELLED.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1698
Android - nano folder not being referenced from the generated folder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi ,
Please help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1699
Bad ssl setup leads to requests never returning
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've shoot myself in a foot by copy-pasting code snippet between client and server code which looked almost identical ;)
I've been trying to make a call from client which was set up as follows:
sslCtx = GrpcSslContexts.configure(SslContextBuilder.forServer(getPrivateKey(), getX509CertificateChain())).build();

channel = NettyChannelBuilder.forAddress(host, port)
        .sslContext(sslCtx)
        .build();
Such setup, as you may already noticed,  is obviously incorrect on the client and the correct way to do this is to use SslContextBuilder.forClient instead of SslContextBuilder.forServer like this:
sslCtx = GrpcSslContexts.configure(SslContextBuilder.forClient().keyManager(getPrivateKey(),getX509CertificateChain())).build();
This lead to client being broken and handing indefinitely, after making a call, during handshake without throwing any error or other indication or notice of horribly wrong setup. It would be great if we could prevent from making this mistake somehow.
As an aside, would be nice if netty could provide overloaded versions of forClient just like it does for forServer. I might be missing something because I haven't looked into this deepy, but it doesn't seem that there's anything preventing from that (?).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1700
Decide if io.grpc.Attributes should be marked experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1701
Tracking Issue for BindableService being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1702
Check CallOptions affinity, deadline and compression methods to see if they should still be experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1703
Tracking issue for messageCompression being experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1704
Tracking Issue for Codec, Compressor, CompressionRegistry being Experimental. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
They may exist, even independent of turning off compression for public release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1705
Tracking Issue for  Context being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#262 was closed as fixed (and linked to by the Context.java file), but we still need to determine if we should commit to the API for 1.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1706
Tracking Issue for Deadline being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1707
DnsNameResolverFactory should be checked if still Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1708
Check if EquivalentAddressGroup should still be experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1709
MutableHandlerRegistry and HandlerRegistry need to be checked to see if still Experimental. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These have been around a long time, maybe its time the graduate to stable?
+cc: @louiscryan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1710
Tracking Issue for Server Attributes being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Other languages propagate these via a context, maybe they should be done that way?  In any case, these should be looked at to see if they are part of 1.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1711
Tracking Issue for ServerInterceptor being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These have been around for a while, do we want to keep them?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1712
Check if ServerInterceptors.useInputStreamMessages and .useMarshalledMessages  should still be experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These methods seem somewhat niche, should they be part of the API for the future?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1713
Consider removing ServerServiceDefinition, per the comment
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This class is experimental, and needs to be checked if it should be part of the stable API
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1714
Allow passing cancellation details to ClientCall.cancel()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1715
Document that Status's cause is not transmitted from server to client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1716
Throw away Status cause in InProcess transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To act like a normal transport, InProcess transport should throw away everything in the status but the code and message. Otherwise it will be misleading during testing and general usage.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1717
maven plugin generates puzzling custom protobuf file on windows x64
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I followed the Readme.md and used the maven plugin for protobuf-based codegen of proto files. After importing the maven plugin in project from pom.xml, I executed the command of protobuf:compile and protobuf:compile-custom and got the generated protobuf files.
But the generated custom grpc-java file of *Grpc.java is not compatible of java 8. The IDE of intellij idea told me that "@java.lang.Override is not allowed to when implementing interface method". I compared the generated *Grpc.java file with the *Grpc.java file in the io.grpc.examples in grpc-java repository. The file from github (for example, RouteGuideGrpc.java)  has abstract class AbstractRouteGuide, but using maven plugin can not generate the abstracte class.
Why the file generated by maven plugin is not compatible, and how can I generate the correct java file?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1718
Allow passing a message to ClientCall.cancel().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo @louiscryan FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1719
Ability to create unregistered in-process channels for a server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks like the issues in the CI tests are also happening on master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1720
Throw Status.UNAVAILABLE on connection refused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we want to catch io.netty.channel.ChannelException and re-throw as Status.UNAVIALIBLE when endpoint is unreachable:
http2.Http2ConnectionHandler - [id: 0x39fed2a5] Sending GOAWAY failed: lastStreamId '0', errorCode '2', debugData 'Connection refused: example.lukasz.local/127.0.0.1:12345'. Forcing shutdown of the connection.
io.netty.channel.ChannelException: Pending write on removal of SslHandler
    at io.netty.handler.ssl.SslHandler.handlerRemoved0(SslHandler.java:426)
[...]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1721
Fix lint warnings found on internal import
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1722
API to convert from Status.Code to Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Status.fromCodeValue(code.value()) isn't too bad, but it does seem a bit strange not having something more like Status.fromCode(Code). Alternatively, we could make Status.Code.status() public, but that doesn't seem to match the rest of the API as well.
@lukaszx0, FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1723
Fix javadoc warning.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1724
validate sslContext in Netty channel/server builder #1699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1725
Specify Status*Exception is to be used in StreamObserver.onError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1726
Update proto packages to reflect directory structure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1727
Checking null on proto fields just ain't right.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1728
Fix race in StressTestClientTest.gaugesShouldBeExported(). Fixes #1695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1729
Fix more null proto refs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1730
Cut the 0.14.0 release and start next cycle.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
examples/android/app/build.gradle also needs to be updated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1731
TESTING Avoid Linux artifacts on OSX brought in by cache
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This was supposed to be done on my github repo.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1732
Travis-CI caching is breaking OS X
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caching now seems to be supported on OS X, but it is sharing the cache between OS X and Linux and the OS X build is accidentally trying to use Linux binaries. We need to split out the protobuf binaries between the two systems.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1733
Allow cache to be shared between Linux and OS X
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Neato
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1734
Http2OkHttpTest.deadlineExceeded is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://travis-ci.org/grpc/grpc-java/jobs/125116142 (since rebuilt, and experiencing Travis-CI OS X caching breakage fixed later on master):
io.grpc.testing.integration.Http2OkHttpTest > deadlineExceeded FAILED
    java.lang.AssertionError: expected:<DEADLINE_EXCEEDED> but was:<UNKNOWN>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1735
Add tests for call.cancel() from within messageRead
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1736
Contexts missing private constructor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Contexts should not be instantiated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1737
Contexts.statusFromCancelled should be marked experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I question if any of our users will actually use the method. It can be moved into io.grpc.internal or it can be marked Experimental. If there is a use case for it, it'd be good to know, since it didn't come up during review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1738
Add private constructor to Contexts and mark statusFromCancelled expeâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1739
Revert "Update proto packages to reflect directory structure"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1740
Stop producing a fat grpc-all jar
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 why don't we just get rid of the all jar entirely?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1741
Return Context from fork instead of CancellableContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan, friendly ping. This should be an easy review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1742
Add a log message for unknown client streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1743
Add unit tests for proto-based JSON marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1744
Strip cause from InProcessTransport between client and server. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current coverage is 88.96%

Merging #1744 into master will increase coverage by +<.01%

@@             master      #1744   diff @@
==========================================
  Files           137        137          
  Lines          6888       6894     +6   
  Methods           0          0          
  Messages          0          0          
  Branches        993        994     +1   
==========================================
+ Hits           6126       6133     +7   
+ Misses          762        761     -1   
  Partials          0          0          

2 files (not in diff) in ...n/java/io/grpc/netty were modified. more

Misses +1
Hits -1


3 files (not in diff) in ...ava/io/grpc/internal were modified. more

Misses -4
Hits +4


1 files (not in diff) in ...rc/main/java/io/grpc were modified. more

Misses +1
Hits -1


File ...tub/ClientCalls.java (not in diff) was modified. more

Misses +3
Partials 0
Hits -3


File ...syncFrameWriter.java (not in diff) was modified. more

Misses -2
Partials 0
Hits +2


File ...rocessTransport.java was modified. more

Misses -1
Partials 0
Hits +1




Powered by Codecov. Last updated by 9de87e3...caf546d
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1745
setRemoveOnCancelPolicy is not called
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://codecov.io/gh/grpc/grpc-java/src/900f7e1/core/src/main/java/io/grpc/internal/GrpcUtil.java#L405
At least on OpenJDK, newSingleThreadScheduledExecutor() does not return a ScheduledThreadPoolExecutor. The documentation says:

Unlike the otherwise equivalent newScheduledThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.

So maybe we should be using newScheduledThreadPool(int) instead. But since that still isn't required to be a ScheduledThreadPoolExecutor, maybe we should just construct a ScheduledThreadPoolExecutor directly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1746
Disable codecov comment and changes status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1747
Try to use ScheduledThreadpoolExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current coverage is 88.88%

Merging #1747 into master will decrease coverage by -0.00%

@@             master      #1747   diff @@
==========================================
  Files           137        137          
  Lines          6888       6888          
  Methods           0          0          
  Messages          0          0          
  Branches        993        993          
==========================================
- Hits           6126       6122     -4   
- Misses          762        766     +4   
  Partials          0          0          

2 files (not in diff) in ...ava/io/grpc/internal were modified. more

Misses +3
Hits -3


2 files (not in diff) in ...rc/main/java/io/grpc were modified. more

Misses +1
Hits -1


File ...ternal/GrpcUtil.java was modified. more

Misses -1
Partials 0
Hits +1


File ...tub/ClientCalls.java (not in diff) was modified. more

Misses +3
Partials 0
Hits -3


File ...syncFrameWriter.java (not in diff) was modified. more

Misses -2
Partials 0
Hits +2




Powered by Codecov. Last updated by 9de87e3...c835d3d
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1748
remove the dependency on Guava's Throwables.getCausalChain #1663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1749
remove the dependency on Guava's Throwables.getCausalChain #1663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA (login here to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1750
Begin v0.15.0 Cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1751
V0.14.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1752
Remove m2 from Travis cache; it's unused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1753
Update Release docs to account for parallel upload
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1754
Disable parallel with argument for greater ease
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wanna update the other refs around this file too?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1755
Yet another attempt to fix StubConfigTest.testConfigureDeadlineNanoTime.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current coverage is 89.11%

Merging #1755 into master will not change coverage

@@             master      #1755   diff @@
==========================================
  Files           137        137          
  Lines          6895       6895          
  Methods           0          0          
  Messages          0          0          
  Branches        994        994          
==========================================
  Hits           6144       6144          
  Misses          751        751          
  Partials          0          0          

2 files (not in diff) in ...rc/main/java/io/grpc were modified. more

Misses -1
Hits +1


File ...etty/WriteQueue.java (not in diff) was modified. more

Misses +1
Partials 0
Hits -1




Powered by Codecov. Last updated by dda4ad7...3162d27
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1756
NettyTransportTest > newStream_duringShutdown FAILED flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.netty.NettyTransportTest > newStream_duringShutdown FAILED
    java.io.IOException: Failed to bind

        Caused by:
        java.net.BindException: Address already in use: bind

    java.lang.NullPointerException

Seen here: https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/1204/console
Unsure how this can happen, given that we pick a free port https://github.com/grpc/grpc-java/blob/master/netty/src/test/java/io/grpc/netty/NettyTransportTest.java#L51 ... and we shouldn't be racing with other tests ... unless they are run in parallel?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1757
Use return value of Status.augmentDescription
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM. Good catch!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1758
channel warm up per thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, all. I'm doing an experiment with grpc and find out that the first usage of grpc in a thread costs much more time than the subsequent ones doing the same thing. I tested it on a 2-core laptop and 24-core machines, and the same phenomena occurred on all of them. So I'm wondering if I'm using grpc wrong or something in grpc-java could be improved to avoid such situation. Below is my code and part of  the report.
import java.text.SimpleDateFormat;
import java.util.Date;

import me.gdbc.mocker.MockServer;
import me.proto.query.QueryProtocol.QueryRequest;
import me.proto.query.QueryProtocol.QueryResponse;

import me.proto.query.QueryServiceInterfaceGrpc.METHOD_QUERY;

import io.grpc.CallOptions;
import io.grpc.ManagedChannel;
import io.grpc.netty.NettyChannelBuilder;

public class WarmUp {

public static SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

public static QueryRequest request = QueryRequest.newBuilder().setQueryString("").build();
public static class QueryThread extends Thread {

    private String name;
    private ManagedChannel client;

    public QueryThread(String name, ManagedChannel client) {
        this.name = name;
        this.client = client;
    }

    public void run() {
        for (int i = 0 ; i < 300; i++) {
            long start = System.currentTimeMillis();
            try {
                //ClientCall<QueryRequest, QueryResponse> call =  client.newCall(METHOD_QUERY, CallOptions.DEFAULT);
                QueryResponse ret = io.grpc.stub.ClientCalls.blockingUnaryCall(client, METHOD_QUERY, CallOptions.DEFAULT, request);
                //QueryResponse ret = io.grpc.stub.ClientCalls.blockingUnaryCall(call, request);
                long duration = System.currentTimeMillis() - start;
                String show  = "" + ret + "\n" + df.format(new Date()) + "\n" + "cost " + duration + "ms in thread " + name;
                System.out.println(show);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }   
}

public static void main(String[] args) {
    int port = 9012;
    MockServer server = new MockServer(port);
    try {
        server.start();
        ManagedChannel channel = NettyChannelBuilder.forAddress("127.0.0.1", port).usePlaintext(true).build();
        io.grpc.stub.ClientCalls.blockingUnaryCall(channel, METHOD_QUERY, CallOptions.DEFAULT, request);
        for (int i = 0; i < 4; i++) {
            QueryThread th = new QueryThread(String.valueOf(i), channel);
            th.start();

        }

    } catch (Exception e) {
        e.printStackTrace();
    }
}

}

May 01, 2016 2:28:09 PM me.gdbc.mocker.MockServer start
INFO: Server started, listenning on 9012
May 01, 2016 2:28:09 PM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@326de728] Created with target 127.0.0.1:9012
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 76ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 67ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 68ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 66ms in thread 2
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 8ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 8ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 10ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 10ms in thread 2
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 8ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 10ms in thread 2
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 4ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 6ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 7ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 6ms in thread 3
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 6ms in thread 1
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 6ms in thread 0
result {
  props {
    intVal: 1
  }
}

2016-05-01 14:28:10
cost 6ms in thread 3
result {
  props {
    intVal: 1
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1759
Swap to 'fail fast' and 'ignore connectivity' behavior
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The other implementations are swapping to fail fast by default. We believe this is what users would typically assume our behavior to be and it behaves well with infinite deadlines, as well as being required by many latency-sensitive applications. These are not the same semantics as in Stubby, because gRPC will delay the RPC while in IDLE or CONNECTING until the state becomes READY or TRANSIENT_FAILURE.
Java today is doing neither 'fail fast' nor 'ignore connectivity', but instead something in-between because it delays while in TRANSIENT_FAILURE, but only one connection attempt.
This is a very important behavior change for users and must be done before GA.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1760
use Jetty ALPN agent instead of Jetty ALPN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1761
all: Update Readme to reflect latest release (0.14.0)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1762
Add connection window debug information.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This likely belongs in Netty somewhere, but I'm adding it here so I don't forget.  It would be super useful to be able to quickly look at the connection level window and stream window, likely as some sort of debug log output.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1763
Fix Attribute key lookup to properly compare Keys by string name
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1764
Tracking Issue for Attributes being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In #1700 it was decided that Attributes is still experimental.  This issue is acts the the reference from the source code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1765
Avoid $HOME in cache, since it varies
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Try out the foo: bar commit line?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1766
Tracking Issue for affinity being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

CallOptions.getAffinity
Calloptions.withAffinity
LoadBalancer.pickTransport
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1767
Tracking Issue for authority being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In regards to #67.
Specific usages:

CallOptions.getAuthority
CallOptions.withAuthority
ManagedChannelBuilder.overrideAuthority
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1768
NettyServerTransport.notifyTransport() logs at SEVERE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Logging at SEVERE is probably an overkill most of the time. There are rare cases that something higher would be useful, but I don't think we could easily distinguish between those cases. We should probably reduce the severity to something lower, although I'm sure what makes the most sense.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1769
Tracking Issue for DnsNameResolver being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In regards to #1707.
Specific usages:

DnsNameResolverFactory
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1770
Tracking Issue for NameResolution being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

EquivalentAddressGroup
ManagedChannelBuilder.nameResolverFactory
NameResolver
NameResolverRegistry
ResolvedServerInfo
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1771
Tracking Issue for Load Balancing being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

LoadBalancer
ManagedChannelBuilder.loadBalancerFactory
PickFirstLoadBalancerFactory
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1772
Tracking Issue for Plaintext being Experimental. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ManagedChannelBuilder.usePlaintext
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1773
Tracking Issue for Target Specification being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ManagedChannelBuilder.forTarget
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1774
Tracking Issue for Method Descriptor being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

MethodDescriptor.create
MethodDescriptor.extractFullServiceName
MethodDescriptor.generateFullMethodName
ServerMethodDefinition
ServerServiceDefinition.builder
ServerServiceDefintion.getMethods
ServerServiceDefinition.Builder.addMethod
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1775
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1776
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1777
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1778
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1779
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1780
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1781
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1782
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1783
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1784
Tracking Issue for Netty being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Despite Netty being the default and recommended transport, we mark is as experimental, implying it is not stable.  Once the transport layer is stable, this should be promoted.
Either we should commit to supporting it, or commit to a subset of the methods exposed.
Specific usages:

GrpcSslContexts
GrpcSslContexts.configure
NegotiationType
NettyChannelBuilder
NettyServerBuilder
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1785
Tracking Issue for OkHttp being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is no plan to make this API stable, given transport API instability.
Specific usages:

OkHttpChannelBuilder
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1786
Tracking Issue for JSON Marshalling being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ProtoUtils.jsonMarshaller
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1787
Tracking Issue for Extension Registry being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ProtoLiteUtils.setExtensionRegistry
ProtoUtils.setExtensionRegistry
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1788
Tracking Issue for (Call|ServerCall)StreamObserver being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

CallStreamObserver
ServerCallStreamObserver
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1789
Tracking Issue for MetadataUtils being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

MetadataUtils.attachHeaders
MetadataUtils.captureMetadata
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1790
Tracking Issue for ServerCalls being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ServerCalls
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1791
Tracking Issue for Testing utilities being Experimental. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages;

StreamRecorder
TestUtils
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1792
all: Finish adding tracking issues for ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1793
Refactor HandlerRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1794
context: Remove tests for Key Equality.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1795
Unimplemented service causes MessageDeframer exceptions in the log
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm seeing exceptions running grpc-java 0.14.0 in production (same with 0.13.2). Reproducible on both linux and mac with oracle jdk 1.8.0_66.
mai 05, 2016 10:12:52 AM io.grpc.internal.AbstractServerStream deframeFailed
WARNING: Exception processing message
java.lang.IllegalStateException: MessageDeframer is already closed
    at com.google.common.base.Preconditions.checkState(Preconditions.java:174)
    at io.grpc.internal.MessageDeframer.checkNotClosed(MessageDeframer.java:222)
    at io.grpc.internal.MessageDeframer.deframe(MessageDeframer.java:168)
    at io.grpc.internal.AbstractStream.deframe(AbstractStream.java:276)
    at io.grpc.internal.AbstractServerStream.inboundDataReceived(AbstractServerStream.java:156)
    at io.grpc.netty.NettyServerStream.inboundDataReceived(NettyServerStream.java:83)
    at io.grpc.netty.NettyServerHandler.onDataRead(NettyServerHandler.java:214)
    at io.grpc.netty.NettyServerHandler.access$200(NettyServerHandler.java:93)
    at io.grpc.netty.NettyServerHandler$FrameListener.onDataRead(NettyServerHandler.java:425)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:250)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:46)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:409)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:240)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:147)
    at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:39)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:111)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:331)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:391)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:387)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:245)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:154)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:354)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:145)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:1078)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:117)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:527)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:484)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:398)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:370)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:145)
    at java.lang.Thread.run(Thread.java:745)

I've found the following code reproduces the exceptions (the number of rounds required may vary as it doesn't happen for all requests):
        Server grpcServer = NettyServerBuilder.forPort(0).build();
        grpcServer.start();
        ManagedChannel channel = NettyChannelBuilder.forAddress("localhost", grpcServer.getPort()).usePlaintext(true).build();
        for (int x= 0; x < 100; ++x) {
            try {
                HealthGrpc.newBlockingStub(channel).check(HealthCheckRequest.getDefaultInstance());
            } catch (StatusRuntimeException e) {
                if (e.getStatus().getCode() != Code.UNIMPLEMENTED) {
                    throw new RuntimeException(e);
                }
            }
        }
        System.err.println("done");

If you replace Netty with InProcess, you can get the following exception (the number of rounds must be increased a lot, though):
mai 05, 2016 10:33:46 AM io.grpc.internal.SerializingExecutor$TaskRunner run
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1@2d83238d
java.lang.NullPointerException
    at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.internalCancel(InProcessTransport.java:484)
    at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.serverClosed(InProcessTransport.java:435)
    at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.access$1000(InProcessTransport.java:381)
    at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessServerStream.close(InProcessTransport.java:335)
    at io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1.runInContext(ServerImpl.java:316)
    at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:54)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1796
Make Code.status() public, add Status#fromCode()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1797
Differences in generating GreeterGrpc.java from github example using maven
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I've been playing with the examples and I cannot figure out why the GreeterGrpc.java file that I generate is different from the example shown here: https://github.com/grpc/grpc-java/blob/master/examples/src/generated/main/grpc/io/grpc/examples/helloworld/GreeterGrpc.java
In my GreeterGrpc.java, I am missing the abstract class that I need to extend to make everything work. Here's what I see:
package io.grpc.examples.helloworld;

import static io.grpc.stub.ClientCalls.asyncUnaryCall;
import static io.grpc.stub.ClientCalls.asyncServerStreamingCall;
import static io.grpc.stub.ClientCalls.asyncClientStreamingCall;
import static io.grpc.stub.ClientCalls.asyncBidiStreamingCall;
import static io.grpc.stub.ClientCalls.blockingUnaryCall;
import static io.grpc.stub.ClientCalls.blockingServerStreamingCall;
import static io.grpc.stub.ClientCalls.futureUnaryCall;
import static io.grpc.MethodDescriptor.generateFullMethodName;
import static io.grpc.stub.ServerCalls.asyncUnaryCall;
import static io.grpc.stub.ServerCalls.asyncServerStreamingCall;
import static io.grpc.stub.ServerCalls.asyncClientStreamingCall;
import static io.grpc.stub.ServerCalls.asyncBidiStreamingCall;

@javax.annotation.Generated("by gRPC proto compiler")
public class GreeterGrpc {

  private GreeterGrpc() {}

  public static final String SERVICE_NAME = "helloworld.Greeter";

  // Static method descriptors that strictly reflect the proto.
  @io.grpc.ExperimentalApi
  public static final io.grpc.MethodDescriptor<io.grpc.examples.helloworld.HelloRequest,
      io.grpc.examples.helloworld.HelloReply> METHOD_SAY_HELLO =
      io.grpc.MethodDescriptor.create(
          io.grpc.MethodDescriptor.MethodType.UNARY,
          generateFullMethodName(
              "helloworld.Greeter", "SayHello"),
          io.grpc.protobuf.ProtoUtils.marshaller(io.grpc.examples.helloworld.HelloRequest.getDefaultInstance()),
          io.grpc.protobuf.ProtoUtils.marshaller(io.grpc.examples.helloworld.HelloReply.getDefaultInstance()));

  public static GreeterStub newStub(io.grpc.Channel channel) {
    return new GreeterStub(channel);
  }

  public static GreeterBlockingStub newBlockingStub(
      io.grpc.Channel channel) {
    return new GreeterBlockingStub(channel);
  }

  public static GreeterFutureStub newFutureStub(
      io.grpc.Channel channel) {
    return new GreeterFutureStub(channel);
  }

  public static interface Greeter {

    public void sayHello(io.grpc.examples.helloworld.HelloRequest request,
        io.grpc.stub.StreamObserver<io.grpc.examples.helloworld.HelloReply> responseObserver);
  }

  public static interface GreeterBlockingClient {

    public io.grpc.examples.helloworld.HelloReply sayHello(io.grpc.examples.helloworld.HelloRequest request);
  }

  public static interface GreeterFutureClient {

    public com.google.common.util.concurrent.ListenableFuture<io.grpc.examples.helloworld.HelloReply> sayHello(
        io.grpc.examples.helloworld.HelloRequest request);
  }

  public static class GreeterStub extends io.grpc.stub.AbstractStub<GreeterStub>
      implements Greeter {
    private GreeterStub(io.grpc.Channel channel) {
      super(channel);
    }

    private GreeterStub(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      super(channel, callOptions);
    }

    @java.lang.Override
    protected GreeterStub build(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      return new GreeterStub(channel, callOptions);
    }

    @java.lang.Override
    public void sayHello(io.grpc.examples.helloworld.HelloRequest request,
        io.grpc.stub.StreamObserver<io.grpc.examples.helloworld.HelloReply> responseObserver) {
      asyncUnaryCall(
          getChannel().newCall(METHOD_SAY_HELLO, getCallOptions()), request, responseObserver);
    }
  }

  public static class GreeterBlockingStub extends io.grpc.stub.AbstractStub<GreeterBlockingStub>
      implements GreeterBlockingClient {
    private GreeterBlockingStub(io.grpc.Channel channel) {
      super(channel);
    }

    private GreeterBlockingStub(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      super(channel, callOptions);
    }

    @java.lang.Override
    protected GreeterBlockingStub build(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      return new GreeterBlockingStub(channel, callOptions);
    }

    @java.lang.Override
    public io.grpc.examples.helloworld.HelloReply sayHello(io.grpc.examples.helloworld.HelloRequest request) {
      return blockingUnaryCall(
          getChannel(), METHOD_SAY_HELLO, getCallOptions(), request);
    }
  }

  public static class GreeterFutureStub extends io.grpc.stub.AbstractStub<GreeterFutureStub>
      implements GreeterFutureClient {
    private GreeterFutureStub(io.grpc.Channel channel) {
      super(channel);
    }

    private GreeterFutureStub(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      super(channel, callOptions);
    }

    @java.lang.Override
    protected GreeterFutureStub build(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      return new GreeterFutureStub(channel, callOptions);
    }

    @java.lang.Override
    public com.google.common.util.concurrent.ListenableFuture<io.grpc.examples.helloworld.HelloReply> sayHello(
        io.grpc.examples.helloworld.HelloRequest request) {
      return futureUnaryCall(
          getChannel().newCall(METHOD_SAY_HELLO, getCallOptions()), request);
    }
  }

  private static final int METHODID_SAY_HELLO = 0;

  private static class MethodHandlers<Req, Resp> implements
      io.grpc.stub.ServerCalls.UnaryMethod<Req, Resp>,
      io.grpc.stub.ServerCalls.ServerStreamingMethod<Req, Resp>,
      io.grpc.stub.ServerCalls.ClientStreamingMethod<Req, Resp>,
      io.grpc.stub.ServerCalls.BidiStreamingMethod<Req, Resp> {
    private final Greeter serviceImpl;
    private final int methodId;

    public MethodHandlers(Greeter serviceImpl, int methodId) {
      this.serviceImpl = serviceImpl;
      this.methodId = methodId;
    }

    @java.lang.SuppressWarnings("unchecked")
    public void invoke(Req request, io.grpc.stub.StreamObserver<Resp> responseObserver) {
      switch (methodId) {
        case METHODID_SAY_HELLO:
          serviceImpl.sayHello((io.grpc.examples.helloworld.HelloRequest) request,
              (io.grpc.stub.StreamObserver<io.grpc.examples.helloworld.HelloReply>) responseObserver);
          break;
        default:
          throw new AssertionError();
      }
    }

    @java.lang.SuppressWarnings("unchecked")
    public io.grpc.stub.StreamObserver<Req> invoke(
        io.grpc.stub.StreamObserver<Resp> responseObserver) {
      switch (methodId) {
        default:
          throw new AssertionError();
      }
    }
  }

  public static io.grpc.ServerServiceDefinition bindService(
      final Greeter serviceImpl) {
    return io.grpc.ServerServiceDefinition.builder(SERVICE_NAME)
        .addMethod(
          METHOD_SAY_HELLO,
          asyncUnaryCall(
            new MethodHandlers<
              io.grpc.examples.helloworld.HelloRequest,
              io.grpc.examples.helloworld.HelloReply>(
                serviceImpl, METHODID_SAY_HELLO)))
        .build();
  }
}

I did notice that the examples published used might use a newer version of the compiler, but I'm not sure how this translates to maven from gradle. As a reference, here's my mvn file as well:
I use maven as my build system and this is the contents of my maven file:
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
   <groupId>example.occs</groupId>
   <artifactId>datamanager</artifactId>
   <packaging>jar</packaging>
   <version>1.0-SNAPSHOT</version>
   <name>datamanager</name>
   <url>http://maven.apache.org</url>
   <properties>
      <slf4jVersion>1.7.5</slf4jVersion>
      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
   </properties>
   <build>
      <extensions>
         <extension>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.4.1.Final</version>
         </extension>
      </extensions>
      <!-- Protobuf maven plugin (from grpc docs) -->
      <plugins>
         <plugin>
            <groupId>org.xolstice.maven.plugins</groupId>
            <artifactId>protobuf-maven-plugin</artifactId>
            <version>0.5.0</version>
            <configuration>
               <!--
          The version of protoc must match protobuf-java. If you don't depend on
          protobuf-java directly, you will be transitively depending on the
          protobuf-java version that grpc depends on.
        -->
               <protocArtifact>com.google.protobuf:protoc:3.0.0-beta-2:exe:${os.detected.classifier}</protocArtifact>
               <pluginId>grpc-java</pluginId>
               <pluginArtifact>io.grpc:protoc-gen-grpc-java:0.13.2:exe:${os.detected.classifier}</pluginArtifact>
               <outputDirectory>./src/target/java</outputDirectory>
               <protoSourceRoot>./src/main/resources</protoSourceRoot>
               <clearOutputDirectory>false</clearOutputDirectory>
            </configuration>
            <executions>
               <execution>
                  <goals>
                     <goal>compile</goal>
                     <goal>compile-custom</goal>
                  </goals>
               </execution>
            </executions>
         </plugin>
         <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-assembly-plugin</artifactId>
            <configuration>
               <archive>
                  <manifest>
                     <mainClass>occs.App</mainClass>
                  </manifest>
               </archive>
               <descriptorRefs>
                  <descriptorRef>jar-with-dependencies</descriptorRef>
               </descriptorRefs>
            </configuration>
         </plugin>
      </plugins>
   </build>
   <dependencies>
      <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>3.8.1</version>
         <scope>test</scope>
      </dependency>
      <dependency>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-api</artifactId>
         <version>1.7.21</version>
      </dependency>
      <dependency>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-log4j12</artifactId>
         <version>1.7.20</version>
      </dependency>
      <dependency>
         <groupId>io.grpc</groupId>
         <artifactId>grpc-all</artifactId>
         <version>0.13.2</version>
      </dependency>
      <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
         <version>3.0.0-beta-2</version>
      </dependency>
   </dependencies>
</project>

Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1798
BUG: Attributes broken in 0.14.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to a recent change in how attributes are stored it is no longer possible to look up attributes in an incoming request.  There's a fix for this in #1763.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1799
Remove an obsolete comment on ServerServiceDefinition.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1800
ClientInterceptor per call parameters
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our generated clients come pre-configured with a set of approximately 10 interceptors covering functionality from response caching to metrics reporting.  We'd like our users to be able to customize these interceptors per call.  What is the recommended mechanism to pass per call parameters to a client already configured with ClientInterceptors?
Here's an example for setting up a client
HelloStub client = HelloGrpc.newBlockingStub(
    ClientInterceptors.intercept(NettyChannelBuilder.forAddress("localhost:9000").build(),
        new ResponseCacheInterceptor()),
        new MetricsInterceptor()
    );
When using the client we'd like our users to do something like,
client.withOption(ResponseCacheInterceptor.CACHE_KEY, "foo")
    .sayHello(request);
But CallOptions currently does not support custom options.  Is something like this in the works?
Alternatively, we could use the Context but it seems overkill to go through a thread local for this.
Context.current().withValue(ResponseCacheInterceptor.CACHE_KEY, "foo").call(()-> {
    client.sayHello(request);
});
Any other recommendations on how this could be accomplished?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1801
Fix flakiness of testConfigureDeadlineNanoTime with warmup
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr, for testing this on my machine I set maxDelta = 0, which then just output the observed delta directly (by always failing).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1802
Netty server -> client messages apparently dropped in 0.13.2+
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am observing some strange behavior on grpc 0.13.2 and above, on my Macbook Pro. Diagnostic information at the bottom of this issue.
Essentially what seems to happen is that the call is correctly handled by the server, all the way through onComplete, but the client never receives any of the inbound frames. This happens for, say, 5% of calls.
I've attached an example log snippet, including annotations indicating where the various callbacks are invoked, as determined by our logging interceptors.
This doesn't reproduce on 0.13.1, but is consistently reproducible on 0.13.2. Unfortunately I was unable to come up with a minimal reproduction.
Any help is greatly appreciated! Thanks!
Client side:
*** ClientCall#start() ***

*** ClientCall#halfClose() ***

2016-05-06T16:41:33.658Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyClientHandler -
----------------OUTBOUND--------------------
[id: 0x9d2d086a, L:/127.0.0.1:59638 - R:/127.0.0.1:59512] HEADERS: streamId=1113, headers=DefaultHttp2Headers[:authority: 127.0.0.1:59512, :path: /inscriptive.sample.SampleService/Create, :method: POST, :scheme: http, trace_id: HJzC_U3l, grpc-accept-encoding: gzip, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.5], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
------------------------------------
2016-05-06T16:41:33.658Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyClientHandler -
----------------OUTBOUND--------------------
[id: 0x9d2d086a, L:/127.0.0.1:59638 - R:/127.0.0.1:59512] DATA: streamId=1113, padding=0, endStream=true, length=409, bytes=00000001940a1b74733a616a76766766513370593636476b5f4732676f715052504e12f4020a3b436f6e73756d657220507269636520496e64657820666f7220...
------------------------------------

Server side:
2016-05-06T16:41:33.658Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyServerHandler -
----------------INBOUND--------------------
[id: 0x50d7d3f3, L:/127.0.0.1:59512 - R:/127.0.0.1:59638] HEADERS: streamId=1113, headers=DefaultHttp2Headers[:authority: 127.0.0.1:59512, :path: /inscriptive.sample.SampleService/Create, :method: POST, :scheme: http, trace_id: HJzC_U3l, grpc-accept-encoding: gzip, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.5], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
------------------------------------

*** server interception chain invoked ***

2016-05-06T16:41:33.658Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyServerHandler -
----------------INBOUND--------------------
[id: 0x50d7d3f3, L:/127.0.0.1:59512 - R:/127.0.0.1:59638] DATA: streamId=1113, padding=0, endStream=true, length=409, bytes=00000001940a1b74733a616a76766766513370593636476b5f4732676f715052504e12f4020a3b436f6e73756d657220507269636520496e64657820666f7220...
------------------------------------

*** ServerCall.Listener#onHalfClose() ***

...

*** ServerCall#close(Status.OK) ***

2016-05-06T16:41:33.676Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyServerHandler -
----------------OUTBOUND--------------------
[id: 0x50d7d3f3, L:/127.0.0.1:59512 - R:/127.0.0.1:59638] HEADERS: streamId=1113, headers=DefaultHttp2Headers[:status: 200, grpc-encoding: gzip, grpc-accept-encoding: gzip, content-type: application/grpc], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
------------------------------------
2016-05-06T16:41:33.676Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyServerHandler -
----------------OUTBOUND--------------------
[id: 0x50d7d3f3, L:/127.0.0.1:59512 - R:/127.0.0.1:59638] DATA: streamId=1113, padding=0, endStream=false, length=5, bytes=0000000000
------------------------------------
2016-05-06T16:41:33.676Z DEBUG [grpc-default-worker-ELG-4-2] {} io.grpc.~.NettyServerHandler -
----------------OUTBOUND--------------------
[id: 0x50d7d3f3, L:/127.0.0.1:59512 - R:/127.0.0.1:59638] HEADERS: streamId=1113, headers=DefaultHttp2Headers[grpc-status: 0], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=true
------------------------------------

*** ServerCall.Listener#onComplete() ***

$ java -version
java version "1.8.0_74"
Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)

[jack:/Users/jack/src/inscriptive] (jack-grpc-14) >> uname -a
Darwin Jacks-MacBook-Pro.local 15.3.0 Darwin Kernel Version 15.3.0: Thu Dec 10 18:40:58 PST 2015; root:xnu-3248.30.4~1/RELEASE_X86_64 x86_64
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1803
Use the RoundRobinServerList in the SimpleLoadBalancer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This pull request moves the RoundRobinServerList into the io.grpc.internal package of core.  It also changes the SimpleLoadBalancer to use round robin across all ResolvedServerInfo objects rather than to treat all ResolvedServerInfo as a single EquivalentAddressGroup.  It has also made me want to raise a couple questions, so I'll add them here and can make an issue if that'd be better.
When writing this and making changes, I noticed that a number of tests expected all of the ResolvedServerInfo coming from the NameResolver to be treated as a single EquivalentAddressGroup and that as the first SocketAddress failed the tests were ensuring that the TransportSet was then trying to connect to other addresses.  This seems like reasonable behavior if for example the EquivalentAddressGroup was the IPv4 and IPv6 address rather than all addresses coming from the NameResolver.  I'm wondering, should the NameResolver be emitting EquivalentAddressGroups rather than ResolvedServerInfo?  It's not clear to me how I can have a list of 10 different machines that have multiple equivalent IPs for each machine and actually properly load balance them.  Would love to discuss this further.  Thanks
@ejona86 @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1804
Verify server sends grpc-accept-encoding appropriately
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If the client sends a gzip-encoded request and the server responds with headers (endStream=false) that does not include grpc-accept-encoding gzip, then the client should warn. This is misbehavior on the server-side and would ideally be detected.
Although I said "warn" above, we're actually aware of servers failing to do this properly today. So initially we can use FINE and eventually swap it to warn.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1805
grpc-all-0.14.0.jar on Maven Central is truncated (only 361 bytes)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-all-0.14.0.jar on Maven Central is truncated and appears corrupted. Note that the "Download the JAR" link on the grpc-java front page points at this corrupt file as well.
grpc-all-0.13.2.jar is 545KB.
see:
http://mvnrepository.com/artifact/io.grpc/grpc-all/0.14.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1806
docs: Don't suggest downloading grpc-all
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1807
Upgrade to Gradle 2.13
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
s/Upgradle/Upgrade
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1808
use maven plugin generate grpc code ,why only XXXGrpc.java been generated.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi,
i used  maven plugn to compile example helloworld.proto, and i  specialed the ${basedir}/src/main/java, the generated code only contain the GreeterGrpc.java,how can i ,generate
AddressBookProtos.java HelloReply.java HelloReplyOrBuilder.java HelloRequest.java HelloRequestOrBuilder.java 
at same time.
thank you .
maven:
<plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.0</version>
                <configuration>
                    <outputDirectory>${basedir}/src/main/java</outputDirectory>
                    <protocArtifact>com.google.protobuf:protoc:3.0.0-beta-2:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:0.14.0:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1809
Improve handling of stream ID exhaustion
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP/2 spec limits the number of stream identifiers to 2^30, which means a channel must create a new transport once the limit is reached.
A couple of challenges with the current implementation:

The exception "UNAVAILABLE: Stream IDs have been exhausted" is thrown, making the current RPC fail.
A new transport is only created once all RPCs are complete, which is a problem for slow RPC and long lived streams, as there's no upper bound for how long a stream can live.

The implication here is that a channel can become unavailable for a unbounded amount of time. Here's a couple of possible improvements:

Forcefully cancel active RPCs so that the transport can shutdown quickly and completely so that a new transport can be opened. This is somewhat consistent with the current behavior where RPCs fail due to Stream ID exhaustion, but is still suboptimal with the same set of problems the current implementation has with failing RPCs. Given that a client already has to deal with various error situations, this could be a good enough solution.
Start new transport without waiting for the current transpot to shut down. This has a worst case scenario of creating a transport per long lived stream per ~1 billion requests, which is perhaps rarely enough given that a few thousands requests per second should last a few days.

See background discussion on https://groups.google.com/d/msg/grpc-io/GfeL3lse6lM/PZ-cy8qkAwAJ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1810
Updating status codes to match the spec.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1811
Adding metadata to Status exceptions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1812
Stress test failures in Java client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to repro:
(I repro'ed this using a docker image. This may repro without the docker image too - I am not sure)

Built a Docker image for stress test:
Get the grpc repo  (you don't have to build it. Just need it for the docker scripts)

$ git clone https://github.com/grpc/grpc.git
$ cd grpc
$ export INTEROP_IMAGE=stress-test-java
$ export BASE_NAME=grpc_interop_stress_java
$ # Remember to be under the grpc directory
$ tools/run_tests/dockerize/build_interop_stress_image.sh
This will take a few minutes to build (if it fails in the middle, just retry one more time. Sometimes, it is flaky)

Start a docker container

$ docker run -i -t stress-test-java bash

Run  java interop server in the background in the container:

root@b44016cf1c83:/# /var/local/git/grpc-java/interop-testing/build/install/grpc-interop-testing/bin/test-server --port=8080 --use_tls=false &

Now run the interop client:

root@b44016cf1c83:/# /var/local/git/grpc-java/interop-testing/build/install/grpc-interop-testing/bin/stresstest-client --test_cases=empty_unary:1 --num_channels_per_server=5 --num_stubs_per_channel=5


You will see the following errors:
root@b44016cf1c83:/# /var/local/git/grpc-java/interop-testing/build/install/grpc-interop-testing/bin/stresstest-client --test_cases=empty_unary:1 --num_channels_per_server=5 --num_stubs_per_channel=5
May 10, 2016 2:04:14 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@7494e528] Created with target localhost:8080
May 10, 2016 2:04:14 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@5f282abb] Created with target localhost:8080
May 10, 2016 2:04:14 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@1786dec2] Created with target localhost:8080
May 10, 2016 2:04:14 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@4d41cee] Created with target localhost:8080
May 10, 2016 2:04:14 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@1b68ddbd] Created with target localhost:8080
[GC (Allocation Failure)  129024K->17912K(493056K), 0.0100072 secs]
[GC (Allocation Failure)  146936K->12744K(622080K), 0.0084358 secs]
[GC (Allocation Failure)  270792K->12672K(622080K), 0.0058763 secs]
[GC (Allocation Failure)  270720K->12664K(880128K), 0.0046501 secs]
[GC (Allocation Failure)  528760K->12704K(880128K), 0.0076892 secs]
[GC (Allocation Failure)  528800K->12744K(1392128K), 0.0086561 secs]
[GC (Allocation Failure)  1044936K->14822K(1392640K), 0.0067372 secs]
[GC (Allocation Failure)  1047014K->14902K(1330176K), 0.0009984 secs]
[GC (Allocation Failure)  1001526K->14982K(1286656K), 0.0008510 secs]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1813
interop-testing: Enable message compression for large unary tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1814
Add ability to MethodDescriptor to return classes of request and response.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
MethodDescriptor is parametrized by <RequestT, ResponseT> but programmatically it's not possible to get this classes. What do you think about adding 2 getters to MethodDescriptor and populating it in generated classes:
Class<RequestT> getRequestClass() / RequestT getRequestDefaultInstance() //returns new instance each call
Class<ResponseT> getResponseClass() / ResponseT getResponseDefaultInstance() //returns new instance each call.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1815
NPE from OkHttpChannelBuilder with ConnectionSpec.CLEARTEXT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm getting a NPE when I use OkHttpChannelBuilder with ConnectionSpec.CLEARTEXT.  I might be misusing the API, but I think it's actually an issue.
    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.CLEARTEXT).build();

    ManagedChannelImpl channel = OkHttpChannelBuilder.forAddress(host, port).connectionSpec(connectionSpec).build();

The problem is that Utils.convertSpec is calling spec.tlsVersions:
static ConnectionSpec convertSpec(com.squareup.okhttp.ConnectionSpec spec) {
    List<com.squareup.okhttp.TlsVersion> tlsVersionList = spec.tlsVersions();

And spec.tlsVersions assumes tlsVersions is non-null:
  public List<TlsVersion> tlsVersions() {
    TlsVersion[] result = new TlsVersion[tlsVersions.length];

But tlsVersions is always null (and enforced to be so) if not using TLS.
If this isn't me doing something wrong, I'm happy to send a patch.  I guess the patch should be to check whether TLS is enabled before calling tlsVersions, in Utils.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1816
interop-testing: Print JVM Flags by default for Stress tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1817
Make the OkHTTP transport AppEngine friendly. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How do we want to go getting these changes in?
Note that there is a conflict with master and checkstyle fails.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1818
core: Don't lose server call exception when message fails to close
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1819
netty: Stream ID exhaustion takes too long to swap transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is split out of #1809.

A new transport is only created once all RPCs are complete, which is a problem for slow RPC and long lived streams, as there's no upper bound for how long a stream can live.

This is because the transport does not call transportShutdown() immediately, but only once all the streams on that transport have completed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1820
netty: call transportShutdown immediately on ID exhaustion
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1821
health check service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1822
Allow ClientCall.cancel() before start ClientCall.start(). Remove allâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Note that it was not necessary to change OkHttpClientStream.cancel(...), as the overloaded start(Integer streamId) method as well as the null check logic around pendingData, is needed to handle MAX_CONCURRENT_STREAMS.
Well and Netty didn't support cancel before start in the first place.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1823
Don't enforce a timeout in stress test client. Fixes #1812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1824
ServerCallStreamObserverImpl should record where cancellation came from
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently a single boolean "cancelled" is set which loses where the observer was cancelled from.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1825
interop-testing: update testing protos to include compression fields
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the change also includes other changes unrelated to compression, but LGTM regardless.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1826
benchmarks: update to JMH 1.12
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1827
Implement shutdownNow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Assigning @zhangkun83, because I think he can probably do the best review overall. However, @nmittler and @carl-mastrangelo, would you mind being reviewing the Netty and OkHttp changes, respectively?
CC @zsurocking
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1828
core: Refactor TransportSet in prep for fail fast
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1829
push to client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems not support push. Am right?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1830
stub: use correct javadoc link for Guava
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1831
android-interop-test: Enable checkstyle; fix violations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1832
all: sample formatting with google-java-format
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1833
Automate builds
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be great if we could automate point releases by spinning up the appropriate VMs, building our protoc plugin on each, and uploading to maven central.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1834
benchmarks: use Concurrent Mark and Sweep GC for benchmark worker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1835
Make ServerCallHandler non-experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need to delay on this a bit more, until @louiscryan's work is done.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1836
benchmarks: revert use of CMS GC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1837
Status.fromThrowable loses description
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Throwable cause = checkNotNull(t);
    while (cause != null) {
      if (cause instanceof StatusException) {
        return ((StatusException) cause).getStatus();
      } else if (cause instanceof StatusRuntimeException) {
        return ((StatusRuntimeException) cause).getStatus();
      }
      cause = cause.getCause();
    }
    // Couldn't find a cause with a Status
    return UNKNOWN.withCause(t);

cause ends up being an exception other than Status{,Runtime}Exception, only the cause is added.  When converting the status back to trailers, it is ignored, which makes it hard to debug "UNKNOWN".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1838
benchmarks: add NETTY_EPOLL as an option for transport testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. What sort of performance numbers did epoll have?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1839
Improve interface separation between service descriptors and server dispatch
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86
@jhump
@lukaszx0
Made changes to RouteGuideGRPC to illustrate changes. Once we're happy with that Ill make code-gen changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1840
Implement Round Robin logic in SimpleLoadBalancerFactory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Round robin logic is not yet implemented. Is there any timeline for this?
Thanks,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1841
build: Update jetty for JDK 8u92
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1842
Add CallStreamObserver support to clients
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1843
Differentiate transport to LB services and to servers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1844
netty: don't revalidate when converting between Metadata and Http2Headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+cc: @louiscryan   ideas where the mystery speed up could be from?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1845
Simplify ServerCallHandler and add ServiceDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I personally don't have strong opinions, though I think I lean towards the approach here over the one in #1839.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1846
Custom CallOptions options
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1847
protolite: Use 'unused' variable to avoid CheckReturnValue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1848
Tracking Issue for Health Service APIs being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HealthStatusManager
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1849
Deadlines relative to call start
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now, it's not possible to set a deadline across all calls on a stub, doing something like stub.withDeadline(1, TimeUnit.SECONDS) starts counting right at this point, so when a single stub is injected and shared throughout the application, the deadline is quickly triggered :)
It would be nice to have something like stub.withDeadlineAfterStart(1, TimeUnit.SECONDS) that doesn't trigger until the newCall or start methods are called potentially.  This would allow me to configure my gRPC client with a deadline that is usable by default on all calls and also "correct" for my usage in how it counts down.  Is this something you'd be open to?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1850
Mistake in gRPC Basics: Java tutorial
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
http://www.grpc.io/docs/tutorials/basic/java.html#implementing-routeguide
says that we should declare service as:
private static class RouteGuideService implements RouteGuideGrpc.RouteGuide
but example file declares service implementation as:
private static class RouteGuideService extends RouteGuideGrpc.AbstractRouteGuide 
if class implements RouteGuideGrpc.RouteGuide then the server cannot be created as the next tutorial section says:
server = serverBuilder.addService(new RouteGuideService(features)).build();
because our service doesn't extend AbstractRouteGuide and thus doesn't implement BindableService interface.
A tiny problem but causes gRPC first timers like me some headache.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1851
core: Add unit test for Contexts.interceptCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1852
CascadingTest.testCascadingCancellationViaMethodTimeout is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/1389/console
io.grpc.testing.integration.CascadingTest > testCascadingCancellationViaMethodTimeout FAILED
    java.lang.AssertionError: expected:<3> but was:<0>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:118)
        at org.junit.Assert.assertEquals(Assert.java:555)
        at org.junit.Assert.assertEquals(Assert.java:542)
        at io.grpc.testing.integration.CascadingTest.testCascadingCancellationViaMethodTimeout(CascadingTest.java:160)

I think I've seen it flake on my own machine as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1853
netty: Fix test to support netty 4.1.0.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(Note that this change is backward compatible)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1854
netty: speed up header conversion by caching user agent string
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1855
benchmarks: add client/server header benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1856
netty: use custom Http2Headers class for encoding Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tests are failing because of improperly used mocks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1857
Tweak -Xlint warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1858
core,netty,okhttp: move user agent out of client call and into the transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+cc: @nmittler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1859
Client TLS documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1860
How to get socket address in an Interceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a mechanism for getting the address of the load balancer resolved server's socket address in a client interceptor?  And on the server, get the address of the calling client?  Our use case is that we'd like to log this information in addition to other metadata that is associated with this address.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1861
Metadata trailers are not passed to Status*Exception when using BlockingResponseStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @nmittler,
thanks for improving the error handling via #1811 and solving #681.
When using blockingStubs on the client the metadata trailers are not passed into the Status*Exception. Your changeset adds this ability to 2 of 3 onClose methods of stub/ClientCalls.java.
Did you just miss to add the trailer handling to the BlockingResponseStream class in 
  
    
      grpc-java/stub/src/main/java/io/grpc/stub/ClientCalls.java
    
    
         Line 485
      in
      641cb35
    
  
  
    

        
          
           buffer.add(status); 
        
    
  

 or is there another reason for dropping the trailers in this case?
Regards,
BjÃ¶rn
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1862
Add trailers to Status for BlockingResponseStream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1863
Fail-fast mode
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According to https://github.com/grpc/grpc/blob/master/doc/fail_fast.md, fail-fast mode is enabled by default. But it didn't say how to disable it.
I couldn't find much resource for fail-fast mode other than the file. Can anyone link me to related example/code/documentation? Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1864
docs: update documentation for client TLS in SECURITY.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1865
core: allocate less garbage iterators in Metadata.serialize
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This was found from the memory analysis of #1856
+cc: @buchgr
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1866
core/internal: fix regex pattern
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Test?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1867
benchmarks: use more realistic header counts in benchmark
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1868
okhttp: generate user agent once for whole transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1869
Tracking Issue for Custom CallOptions being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ServerCalls
AbstractStub
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1870
netty: Bump netty dep to 4.1.0.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ship it!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1871
Okhttp Headers performance improvements.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OkHttp performance has been lackluster for a while, likely due to it not being easy to benchmark.  (especially on android!).  It does some extra validation we don't need (since Metadata) already does it.  We should audit the okhttp path and add some benchmarks in order to measure improvement.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1872
Lots of garbage created by Netty's HPACK encoder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Netty takes great pains to not copy data unnecessarily, so it was surprising to find lots of garbage being created in the Hpack encoder.  Specifically, most of it comes from https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/StaticTable.java#L130
Which creates a new string for most (all?) headers.   We should fix this!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1873
Maybe make a custom Http2HeaderEncoder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the default Netty Http2HeaderEncoder grabs an iterator from an Http2Headers objects and iterates over the values, adding them to the table and serializing them to a ByteBuf.  We could save on a lot of allocations and cputime if we could pass an array directly in and skip Iterator.  We don't even have to deal with the hpack portions of this since we can reuse that API independent of the Http2HeaderEncoder interface.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1874
grpc tls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We created a server and a client with tls in nodejs. This works. Below is the snippet.
server code
function main() {
   var server = new grpc.Server();
    server.addProtoService(ogury_proto.Data.service, {sendMessage: sendMessage, sendMessageStream: sendMessageStream});
    var key_path = path.join(__dirname, './keys/server.key');
    var pem_path = path.join(__dirname, './keys/server.crt');

    var key_data = fs.readFileSync(key_path);
    var pem_data = fs.readFileSync(pem_path);
    server_creds = grpc.ServerCredentials.createSsl(null,
        [{private_key: key_data,
            cert_chain: pem_data}]);
    server.bind('0.0.0.0:50052', server_creds);
    server.start();
}

client code
var ca_path = path.join(__dirname, './keys/server.crt');
var ca_data = fs.readFileSync(ca_path);
var client = new ogury_proto.Data(process.env.HOST + ':50052', grpc.credentials.createSsl(ca_data));


We want to create a client in java that can communicate with the server in nodejs. But this does work. Below is the code for java client
channel = NettyChannelBuilder.forAddress(HOST, PORT)
            .sslContext(GrpcSslContexts.forClient().trustManager(ClientGrpcSimple.class.getResourceAsStream("/server.crt")).build())
            .negotiationType(NegotiationType.TLS)
            .build();

The error message server side is
E0525 16:55:46.838418837    6297 ssl_transport_security.c:437] SSL_read returned 0 unexpectedly.
E0525 16:55:46.838446628    6297 secure_endpoint.c:173]      Decryption error: TSI_INTERNAL_ERROR

Below is the command to generate our server.key and server.crt
# Create private key
openssl genrsa -des3 -out server.key 4096

# Create Certificate Signing Request
openssl req -new -key server.key -out server.csr

# Self sign certificate with our own private key
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

# Decrypt (des3) the private key in order to be used to decrypt ssl messages
openssl rsa -in server.key -out server.key

We tried to generate the key and the certificate following this link
https://github.com/grpc/grpc-java/tree/master/testing/src/main/resources/certs
But these commandes don't work, we couldn't follow.
Could you help us, please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1875
core: Promote Deadline API to stable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1876
core,netty,okhttp: move user agent removal closer to where it is set
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1877
{Netty,OkHttp}TransportTest.serverNotListening is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/1439/console
io.grpc.okhttp.OkHttpTransportTest > serverNotListening FAILED
    Wanted but not invoked:
    listener.transportTerminated();
    -> at io.grpc.internal.testing.AbstractTransportTest.serverNotListening(AbstractTransportTest.java:178)
    Actually, there were zero interactions with this mock.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1878
Stack Overflow when running AsyncClient
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
INFO: [ManagedChannelImpl@506e6d5e] Created with target directaddress:///localhost/127.0.0.1:1234
May 27, 2016 9:43:05 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@668bc3d5] Created with target directaddress:///localhost/127.0.0.1:1234
May 27, 2016 9:43:05 AM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@62043840] Created with target directaddress:///localhost/127.0.0.1:1234
Exception in thread "grpc-default-executor-32" java.lang.StackOverflowError
        at io.grpc.Context.removeListener(Context.java:454)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
        at io.grpc.Context.removeListener(Context.java:462)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1879
ConcurrencyTest.serverStreamingTest is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Build failed at ConcurrencyTest
https://travis-ci.org/grpc/grpc-java/jobs/133222725
Not sure if it is a known issue.
io.grpc.testing.integration.ConcurrencyTest > serverStreamingTest FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
        at io.grpc.testing.integration.ConcurrencyTest.serverStreamingTest(ConcurrencyTest.java:197)
205 tests completed, 1 failed
:grpc-interop-testing:test FAILED
FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':grpc-interop-testing:test'.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1880
benchmarks: honor transport in AsyncClient
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1881
More flexible SSL configuration API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today ServerBuilder.useTransportSecurity takes two files as parameter. However, sometimes only InputStreams for the key and cert files are available. Can we add an API to take two input streams?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1882
TransportSet shutdown() also shuts down the pending transport.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1883
java.lang.IllegalArgumentException when try to use ipv6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I guess this is caused by the scopeId:
java.lang.IllegalArgumentException: cannot find a NameResolver for directaddress:////0:0:0:0:0:0:0:0%0:10005 (Malformed escape pair at index 33: directaddress:////0:0:0:0:0:0:0:0%0:10005)
at io.grpc.internal.ManagedChannelImpl.getNameResolver(ManagedChannelImpl.java:238)
at io.grpc.internal.ManagedChannelImpl.(ManagedChannelImpl.java:159)
at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:205)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1884
benchmarks: use nextUp for nextDelay calculation in OpenLoopClient
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Interesting note: there are are significantly more floating point numbers between [0, 1.11E-16] than [1.11E-16, 1]   (approximately 18x more).  Not an issue since rnd is uniformly distributed, but interesting none the less.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1885
Cache results of DecompressorRegistry's known message encodings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Profiling shows a sizeable chunk of ClientCalls is spent in generating the grpc-accept-encoding headers.  This class was designed with a more dynamic use case in mind, but that is no longer the case.  Approximately 1.25% of all time spent in a call is from generating these headers.
This should be fixed by altering the class to be more expensive to create, but extremely fast to read.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1886
Allow specifying maximum number of connections on Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This will probably be implemented as part of a larger piece of work to control resources on server-side.
http://stackoverflow.com/questions/37338038/how-to-configure-maximum-number-of-simultaneous-connections-in-grpc
Note that slightly different metrics (like maximum number of streams across the server) may be better; I'm not trying to dictate the exact metric, just the need for this sort of control.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1887
core: add test for deframer closed exception. fixes #1795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1888
core: cache decompressor registry encodings, and make it copy on write
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1889
core: fix nags from linter in tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1890
NameResolver now emits a List<EquivalentAddressGroup> instead of List<ResolvedServerInfo>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is part 1 of what was discussed in part here #1803 .  Based on some concerns raised by @zhangkun83 I actually ended up emitting a List<EquivalentAddressGroup>, but I have the DnsNameResolver emit just a single EquivalentAddressGroup for all endpoints returned from the DNS query.  This may be enough to alleviate concerns around pick first behavior weirdness.  If not, I've also changed the SimpleLoadBalancer to concatenate all EquivalentAddressGroup into a single EquivalentAddressGroup.  My hope actually with the way I've implemented this is that we can rely on the DnsNameResolver to emit a single EquivalentAddressGroup and then make the SimpleLoadBalancer use a round robin load balancing strategy.  This will at least maintain current behavior for people using defaults(dns+simple lb).  This may not be desirable though if there are other things expecting a pick first lb and not using a name resolver that only emits a single EquivalentAddressGroup.  There's definitely still more discussion to happen here, but I'm hoping this is closer to a point where the NameResolver best knows what addresses are truly equivalent, and can decide if this means they're equivalent on a per resolution basis, or on a per server basis inside resolution(as we prefer with our EurekaNameResolver).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1891
testing: add tests for Netty bug where a channel would break after a â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This test reliably fails when using Netty CR7. Triggering the stream exception, and not invoking headersRead on the second stream.
FINE: Stream error for unknown stream 3
io.netty.handler.codec.http2.Http2Exception$StreamException: Received HEADERS frame for an unknown stream 3
    at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:124)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.shouldIgnoreHeadersOrDataFrame(DefaultHttp2ConnectionDecoder.java:567)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:293)
....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1892
netty: add toString() to GrpcHttp2Headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
meehhh .. should I add tests? :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1893
core: add test for complete() without close() exception in AbstractSeâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Admittedly the test is kind of silly ðŸ˜… ... but didn't really have a better idea.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1894
Cherry-pick fixes for 0.14.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler, ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1895
benchmarks: reset context in AsyncClient to avoid chaining.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1896
Fix URI construction.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1897
core: emit lists of lists from NameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please see #1890 for more context, but I think this is a much better approach and it should be simple to add a RoundRobinLoadBalancer once this is merged that round robins over the internal Lists.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1898
core/internal: add 3-arg newStream method to ClientTransport interface
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1899
added android:shareUserId then io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
added android:shareUserId then io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
help...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1900
core: A missed-out test for #1896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1901
Stabilize generated MethodDescriptor API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today, the generated method descriptors are available as fields. This should probably be changed to be behind a method of some sort so that they can be generated lazily (to reduce static class loading time for Android).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1902
codegen: Specify URL for ExperimentalApi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
s/codegen/compiler/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1903
netty: Bump Netty dependency to 4.1.1.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1904
netty: Use uber boringssl jar
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1905
Errors with concurrent server push
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I'm getting errors when making concurrent server pushes to the same client connection.
You can see simplified repro here https://github.com/trask/grpc-concurrent-server-push-issue-repro
Just clone and run mvn test to see repro.
It is supposed to send 100 messages, but generally the client does not receive 100, and there are errors logged in the process, e.g.
Exception in thread "pool-3-thread-2" java.lang.IllegalStateException: Cannot transition phase from MESSAGE to HEADERS
        at io.grpc.internal.AbstractStream.verifyNextPhase(AbstractStream.java:403)
        at io.grpc.internal.AbstractStream.outboundPhase(AbstractStream.java:395)
        at io.grpc.internal.AbstractServerStream.writeHeaders(AbstractServerStream.java:99)
        at io.grpc.internal.ServerCallImpl.sendHeaders(ServerCallImpl.java:148)
        at io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onNext(ServerCalls.java:276)
        at com.github.trask.ConcurrentServerPushTest.sendServerRequest(ConcurrentServerPushTest.java:67)
        at com.github.trask.ConcurrentServerPushTest.access$400(ConcurrentServerPushTest.java:19)
        at com.github.trask.ConcurrentServerPushTest$1.run(ConcurrentServerPushTest.java:52)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)

and
WARNING: Failed to release a message: SlicedAbstractByteBuf(freed)
io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1
        at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:111)
        at io.netty.buffer.AbstractDerivedByteBuf.release(AbstractDerivedByteBuf.java:62)
        at io.netty.buffer.CompositeByteBuf$Component.freeIfNecessary(CompositeByteBuf.java:1616)
        at io.netty.buffer.CompositeByteBuf.deallocate(CompositeByteBuf.java:1881)
        at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:116)
        at io.netty.buffer.AbstractDerivedByteBuf.release(AbstractDerivedByteBuf.java:62)
        at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:84)
        at io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:109)
        at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:265)
        at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:346)
        at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:321)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:859)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:375)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:826)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1436)
        at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
        at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:381)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:395)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:259)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:161)
        at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
        at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:381)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:395)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:259)
        at io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:1129)
        at io.netty.channel.AbstractChannel.flush(AbstractChannel.java:234)
        at io.grpc.netty.WriteQueue.flush(WriteQueue.java:131)
        at io.grpc.netty.WriteQueue.access$000(WriteQueue.java:48)
        at io.grpc.netty.WriteQueue$1.run(WriteQueue.java:58)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:373)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:145)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1906
Question on Android Requirements
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a grpc server written in go which serves through a valid https certificate,
and an Android client like the examples but without the usePlaintext(true) part.
The RPC services work fine for Android devices with sdk-version >= 21, but they fail for older devices with this exception:
io.grpc.StatusRuntimeException: UNAVAILABLE: No provided cause
    at io.grpc.Status.asRuntimeException(Status.java:503)
    at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:207)
    at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:140)
    at net.honarnama.nano.AuthServiceGrpc$AuthServiceBlockingStub.createAccount(AuthServiceGrpc.java:290)
    ... app stack
Caused by: javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0xb8adea90: Failure in SSL library, usually a protocol error
error:140740B5:SSL routines:SSL23_CLIENT_HELLO:no ciphers available (external/openssl/ssl/s23_clnt.c:486 0xac7ba990:0x00000000)
    at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:448)
    at io.grpc.okhttp.OkHttpProtocolNegotiator.negotiate(OkHttpProtocolNegotiator.java:106)
    at io.grpc.okhttp.OkHttpProtocolNegotiator$AndroidNegotiator.negotiate(OkHttpProtocolNegotiator.java:172)
    at io.grpc.okhttp.OkHttpTlsUpgrader.upgrade(OkHttpTlsUpgrader.java:74)
    at io.grpc.okhttp.OkHttpClientTransport$1.run(OkHttpClientTransport.java:345)
    at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
    ... 3 more
Caused by: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0xb8adea90: Failure in SSL library, usually a protocol error
error:140740B5:SSL routines:SSL23_CLIENT_HELLO:no ciphers available (external/openssl/ssl/s23_clnt.c:486 0xac7ba990:0x00000000)
    at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method)
    at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:405)
    ... 8 more

Using this mechanism I was able to perform the rpc call on an older device, but the suitable Google Play Services version isn't installed on more than half of the devices in my target population. Is there another way to make grpc work on theses devices? Like switching to Netty-based transport? Is there any sample of an android app usig Netty-based transport?
Thanks in advance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1907
protobuf beta 3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi! It seems we can update to protobuf beta 3, I think it would go here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1908
Upgrade to beta-3 for protocol buffers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1909
Improve debugging of tcnative loading
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If tcnative fails to load, it is painful to figure out why. We should include OpenSsl.unavailabilityCause() (or similar) when we fail to find any ALPN providers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1910
core: CallCredentials
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please review the whole diff.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1911
netty: Bump Netty dependency to 4.1.1.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1912
core: fail fast implementation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1913
StatusException and StatusRuntimeException not serializable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
StatusException and StatusRuntimeException are not serializable due to containing a Status object (which makes no attempt to be serializable) with no special handling.
Here's a snippet from the exception that arises:
... snip ...
Caused by: java.io.NotSerializableException: io.grpc.Status
    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)
    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)
    at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)
    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)
    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)
    at java.io.ObjectOutputStream.defaultWriteObject(ObjectOutputStream.java:441)
    at java.lang.Throwable.writeObject(Throwable.java:985)
    at sun.reflect.GeneratedMethodAccessor129.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    ... snip ...

Our use case is an RMI-like API to make calls to a server process which is then making gRPC calls. In this case an operation failed and then things go really wrong because we can't see the root problem since the real exception can't be serialized.
I think to be a "good citizen" the Status*Exceptions should be serializable so it would seem that either:

Status should also be
The status should be pulled apart and the pieces stored in the exception classes
Special serialization routines should be put in place to pull the Status apart on write and put them back together on read

If you know which approach you'd like to take, I'd be happy to implement it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1914
Make CallCredentials non-experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a tracking issue for removing @ExperimentalApi from CallCredentials-related API.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1915
Tracking Issue for CallOptions.withWaitForReady being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The opposite to 'fail fast' is documented as 'ignore connectivity' and in C. However, in Java we prefer to use 'wait for ready'.
Still some debates on naming the methods as pointed out in comments in #1912.

Let's mark it with @experimentalapi since the name of "non fail fast" is still a bit up for debate.
Do we want withFailFast(void) and withWaitForReady(void), or do we think the boolean withNonFailFast(true) is nicer?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1916
core: Add a RoundRobin LoadBalancer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should finish up #1803 and resolve #1141
@zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1917
benchmarks: add a header encoding benchmark
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1918
core: Fix CallOptions 'wait for ready' and toString()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
test failure seems unrelated.
io.grpc.DeadlineTest > defaultTickerIsSystemTicker[0] FAILED
    java.lang.AssertionError: <-23867801 ns from now> and <0 ns from now> should have been within <20000000ns> of each other
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
        at com.google.common.truth.Subject.failWithRawMessage(Subject.java:381)
        at io.grpc.testing.DeadlineSubject.access$400(DeadlineSubject.java:52)
        at io.grpc.testing.DeadlineSubject$1.of(DeadlineSubject.java:81)
        at io.grpc.DeadlineTest.defaultTickerIsSystemTicker(DeadlineTest.java:84)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1919
core: Overwrite values for existing custom call option keys, instead of keeping old values around.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1920
core: log exceptions thrown by Runnable's executed via schedule(..). â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1921
core: Improve fail fast status messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1922
core: Enable per-message compression bit by default
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Won't this set the bit when the negotiated encoding is identity?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1923
core: Move ACCEPT_ENCODING_JOINER to DecompressorRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1924
docs: Don't suggest using grpc-all
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler, ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1925
core: Add NameResolverProvider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1926
Stop creating a CancellableContext for ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in #1878, it is pretty easy to accidentally create long chains of Contexts when we create a new Context for each ClientCall. Thinking about it more, it seems creating a Context was a misstep. The RPC doesn't really mean "a unit of work" in the same way as it does for server-side, and it is unlikely that any result processing should be killed when the RPC completes (successfully or unsuccessfully). Also, only async stub sees the context, which seems like further evidence that there is nothing inherent that should cause us to create the Context.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1927
Get conscrypt working with Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://android.googlesource.com/platform/external/conscrypt/
& issues
https://code.google.com/p/android/issues/list?can=2&q=conscrypt&colspec=ID+Status+Priority+Owner+Summary+Stars+Reporter+Opened&cells=tiles
FYI @ejona86 @normanmaurer @louiscryan @Scottmitch @buchgr
Related to: netty/netty-tcnative#114
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1928
examples: make JSON code more obviously advanced
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo this LGTM, but I'm a bit concerned it may not be enough. Maybe move it to a separate package (maybe something like "advanced") like we do for experimental?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1929
IllegalStateException still happening for io.grpc.internal.TransportSet$TransportListener.transportTerminated on 0.15.SNAPSHOT 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After pulling in 13fe13b still getting this exception happening in some clients.
java.lang.IllegalStateException: Listener is still attached to activeTransport. Seems transportTerminated was not called.
     at com.google.common.base.Preconditions.checkState(SourceFile:173)
     at io.grpc.internal.TransportSet$TransportListener.transportTerminated(SourceFile:391)
     at io.grpc.okhttp.OkHttpClientTransport$ClientFrameHandler.run(SourceFile:647)
     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
     at java.lang.Thread.run(Thread.java:818)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1930
Swap Android docs to Protobuf Lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Protobuf lite is a much nicer API than nano and is very similar API-wise to normal protobuf. We should swap the example to lite instead of nano.
The README should also be swapped to encouraging protobuf-lite for Android instead of protobuf-nano.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1931
Revert commit 3528467612540f1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1932
ClientCallsTest.inprocessTransportOutboundFlowControl is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Build failure seen at
https://travis-ci.org/grpc/grpc-java/jobs/137573879
io.grpc.stub.ClientCallsTest > inprocessTransportOutboundFlowControl FAILED
    arrays first differed at element [1]; expected:<1> but was:<0>
        at org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)
        at org.junit.Assert.internalArrayEquals(Assert.java:473)
        at org.junit.Assert.assertArrayEquals(Assert.java:369)
        at org.junit.Assert.assertArrayEquals(Assert.java:380)
        at io.grpc.stub.ClientCallsTest.inprocessTransportOutboundFlowControl(ClientCallsTest.java:424)
21 tests completed, 1 failed
:grpc-stub:test FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1933
core: add transportInUse() to transport listener.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1934
stub: Improve ClientCall test to fail more obviously
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1935
okhttp: fix NPE when using CLEARTEXT connectionSpec
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1936
directExecutor on Server is broken if handler not found
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When directExecutor is used, failure to find a handler will call close() before setListener is called. This is effectively a manifestation of the concern presented in NettyServerHandler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1937
auth: MoreCallCredentials.from(Credentials)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1938
stub: Disable flaky test in ClientCallsTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1939
core: don't create a new context for each client call. Fixes #1926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Now that we don't create a new context for every call, are you concerned about Context.addListener / Context.removeListener being a synchronization point and the latter having linear running time? These operations are obviously a noop if the Context is not cancellable (like ROOT), but if many concurrent calls are done in a CancellableContext possibly across many threads, it might be an issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1940
Revert #1515 after 0.15 release.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From the discussion in #1330. Just so I don't forget.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1941
Commits for 0.14.1 release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1942
examples: Android example is now using lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1943
Implement connection attempt exponential timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is not for exponential backoff, but for exponential timeout. Currently the timeouts involved aren't tuned at all between attempts. We want to have a single timeout applying to all parts of the connection attempt, as defined in the connection backoff spec. This generally prevents the need for users to specify connect timeouts.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1944
Implement per-stream compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is to replace our current per-message compression for greater compression ratios. I don't think there is a public spec yet.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1945
Include QuickStart example in documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I wonder if the documentation can be impoved by pulling in quickstart examples from grcp.io? It took me about half an hour to even start experimenting after reading the GitHub documentation - then somebody showed me grpc.io example and it was SO much easier to start learning and experimenting using those examples.
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1946
gRPC server does not exit on OutOfMemoryError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I did a simple test as throwing java.lang.OutOfMemoryError in my service code. It seems that the error is caught in io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener.halfClosed() and its not re-thrown.
@Override
    public void halfClosed() {
      callExecutor.execute(new ContextRunnable(context) {
        @Override
        public void runInContext() {
          try {
            getListener().halfClosed();
          } catch (RuntimeException e) {
            internalClose(Status.fromThrowable(e), new Metadata());
            throw e;
          } catch (Throwable t) {
            internalClose(Status.fromThrowable(t), new Metadata());
            throw new RuntimeException(t);
          }
        }
      });
    }

Therefore the server will continue running.
The version of the gRPC is 0.15.0-SNAPSHOT
Is this expected behavior or it is a bug in the code?
Thanks,
Rado
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1947
ServerCallImpl's use of metadata in sendHeaders is thread-unsafe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ServerCallImpl uses metadata to determine compression settings in sendHeaders. However, that Metadata has already been passed to the application which is free to modify it. The acceptEncodings should just be saved as a field during the constructor instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1948
Delete the old ClientCall.cancel().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1949
Service implementation running in a different thread than "ServerCall<RespT>.request()"?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've implemented a simple ServerInterceptor whose intent is to grab the value of an header (a "trace ID") and place it in the MDC upon receiving a request (and to do the reverse when request handling finishes).
However I've noticed that the service implementation itself and the interceptor's close method are being run in a thread different than the one that originally runs the interceptor's request method. This causes contextual (MDC) information to be lost. These are my service's logs (the UUIDs are the "trace IDs"):
[2016-06-17 19:24:05.911] [ grpc-default-executor-0] [HeaderServerInterceptor] [8d0b9de0-b73b-41ad-a8f4-732b6a6997f9] MDC was set.
[2016-06-17 19:24:05.914] [ grpc-default-executor-1] [HeaderServerInterceptor] [5914fc54-f107-4c5f-b647-106537dc393d] MDC was set.
[2016-06-17 19:24:05.915] [ grpc-default-executor-0] [HeaderServerInterceptor] [fae36ee7-a017-44db-ae3e-04b36afd31a4] MDC was set.
[2016-06-17 19:24:05.921] [ grpc-default-executor-0] [HeaderServerInterceptor] [a7f6511d-1206-4639-bdc0-21319343fcb2] MDC was set.

[2016-06-17 19:24:05.946] [ grpc-default-executor-0] [     FooServiceGrpcImpl] [a7f6511d-1206-4639-bdc0-21319343fcb2] Hello from the service implementation!
[2016-06-17 19:24:05.946] [ grpc-default-executor-1] [     FooServiceGrpcImpl] [5914fc54-f107-4c5f-b647-106537dc393d] Hello from the service implementation!
[2016-06-17 19:24:05.946] [ grpc-default-executor-2] [     FooServiceGrpcImpl] [                                    ] Hello from the service implementation!
[2016-06-17 19:24:05.952] [ grpc-default-executor-3] [     FooServiceGrpcImpl] [                                    ] Hello from the service implementation!

[2016-06-17 19:24:07.526] [ grpc-default-executor-3] [HeaderServerInterceptor] [                                    ] Trailers will now be set.
( NullPointerException )

My interceptor's implementation is roughly the following:
public final class HeaderServerInterceptor implements ServerInterceptor {
  private static final Logger LOGGER = LoggerFactory.getLogger(HeaderServerInterceptor.class);

  @Override
  public <ReqT, RespT> Listener<ReqT> interceptCall(final MethodDescriptor<ReqT, RespT> method,
                                                   final ServerCall<RespT> call,
                                                   final Metadata headers,
                                                   final ServerCallHandler<ReqT, RespT> next) {
    return next.startCall(method, new SimpleForwardingServerCall<RespT>(call) {
      @Override
      public void request(final int numMessages) {
        final String requestId = headers.get(MetadataKeys.REQUEST_ID_KEY);
        MDC.put(MetadataKeys.REQUEST_ID_KEY_NAME, requestId);
        LOGGER.trace("MDC was set.");
        super.request(numMessages);
      }

      @Override
      public void close(final Status status,
                        final Metadata trailers) {
        final String requestId = MDC.get(MetadataKeys.REQUEST_ID_KEY_NAME);
        LOGGER.trace("Trailers will now be set.");
        trailers.put(MetadataKeys.REQUEST_ID_KEY, requestId); // NPE.
        super.close(status, trailers);
      }
    }, headers);
  }
}
Is this an expected behaviour that I should be prepared for, or am I facing some kind of issue on gRPC's side?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1950
android: Add ProGuard rules for NameResolverProvider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1951
protoc-gen-grpc-java snapshot doesn't have a mac build published
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys, we have tried to switch to the latest snapshot, but unfortunately only our
linux users were successful. Do you have plans to publish the mac snapshots to sonatype
or we should build on our own ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1952
core: Fix onReady race by adding DelayedStreamListener
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you paste the stacktrace to illustrate the issue, in the commit message? It would become very useful if we ever look back at this code and ask ourselves why the heck we made it so complicated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1953
POC: inprocess: Support anonymous servers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1954
API tweaks following 3df1446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1955
core: Avoid loading ManagedChannelProvider from NameResolverProvider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1956
Revert "Eliminate MethodDescriptor from startCall and interceptCall fâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1957
Reapply "Eliminate MethodDescriptor from startCall and interceptCall for servers"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1958
core: make BindableService no longer experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo lgtm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1959
core:  make ServerInterceptor non experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM.
I just realized that since #1956 the API changes aren't in until #1957. That's fine though. It just means #1957 has to be in before the release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1960
Remove unused variables
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1961
compiler: remove interfaces in codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1962
doc: Status's cause is not transmitted from server to client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@dapengzhang0 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1963
doc: add flow-control example to ClientCall javadoc.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1964
auth: revert ClientAuthInterceptor to its original implementation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1965
auth: handle null value from getRequestMetadata().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1966
netty: detect when ALPN was not used. Fixes #522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1967
core: add package level javadoc.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1968
Android Build Failed with an exception. Could not resolve all dependencies for configuration ':app:protobufToolsLocator_grpc'.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could not resolve all dependencies for configuration ':app:protobufToolsLocator_grpc'.

Could not find io.grpc:protoc-gen-grpc-java:0.15.0-SNAPSHOT.
Searched in the following locations:
file:/Users/mausam/Documents/Mausam/Android Studio 2.app/Contents/gradle/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/maven-metadata.xml
file:/Users/mausam/Documents/Mausam/Android Studio 2.app/Contents/gradle/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT.pom
file:/Users/mausam/Documents/Mausam/Android Studio 2.app/Contents/gradle/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT-osx-x86_64.exe
https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/maven-metadata.xml
https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT.pom
https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT-osx-x86_64.exe
file:/Users/mausam/.m2/repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/maven-metadata.xml
file:/Users/mausam/.m2/repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT.pom
file:/Users/mausam/.m2/repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT-osx-x86_64.exe
file:/Users/mausam/Library/Android/sdk/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/maven-metadata.xml
file:/Users/mausam/Library/Android/sdk/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT.pom
file:/Users/mausam/Library/Android/sdk/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT-osx-x86_64.exe
file:/Users/mausam/Library/Android/sdk/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/maven-metadata.xml
file:/Users/mausam/Library/Android/sdk/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT.pom
file:/Users/mausam/Library/Android/sdk/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/0.15.0-SNAPSHOT/protoc-gen-grpc-java-0.15.0-SNAPSHOT-osx-x86_64.exe
Required by:
android:app:unspecified
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1969
examples: move json server and client to advanced package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1970
core: mark Context as not experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1971
Add gitter chat icon to the README.md file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does this still need to happen?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1972
Keepalive in OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is splitting out the okhttp portion from #1648, since we are wanting to get it done before Keep-Alive in general is completed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1973
[proto3] Default value for message is null?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From this doc, default value for message field is null, while from the generated code, it seems the DEFAULT_INSTANCE of the message is returned, which is not null.
Is the doc wrong?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1974
core: close call when exceptions occur in onReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1975
Tracking Issue for Contexts.statusFromCancelled being experimental 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Forked from #1705
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1976
core: update issue for Contexts experimental status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1977
Flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1978
auth: Promote OAuth2 service accounts to JWT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1979
core: fix race with exception in onMessage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1980
core: clarify StreamObserver documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1981
Executor usage in ClientCallImpl races with channel shutdown and termination.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ManagedChannelImpl clear scheduledExecutor in shutdown(), and releases (which potentially closes) executor in maybeTerminateChannel().
Neither newCall() nor ClientCallImpl checks the shutdown state of the channel. ClientCallImpl relies on FailingClientTransport for the expected behavior. However, ClientCallImpl uses the passed in executors anyway, for scheduling the deadline timer and invoking the call listener.
If ClientCallImpl tries to schedule a deadline timer after the channel is shut down, it will get a NPE. If it runs the call listener after the shared executor has been closed, which is 1 second (SharedResourceHolder.DESTROY_DELAY_SECONDS) after all references are gone, e.g., the application calls Call.start() that late, it will get a RejectedExecutionException. Our current tests are not testing for the two cases.
This doesn't seem to be a serious issue. It only affect people who try to use Calls after the channel has been shutdown. I am yet to figure out a solution.
Anyway, it seems executor should be cleared after being returned to the shared pool, like scheduledExecutor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1982
cannot find a NameResolver exception for revision fc5197fbf4ca51bd76484b28e155beb52c0c0a90
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 @carl-mastrangelo
I check out the most recent commit, and find out that there is something wrong with channel initialisation.
package com.testbase;

import io.grpc.internal.ManagedChannelImpl;
import io.grpc.netty.NettyChannelBuilder;
import io.grpc.okhttp.OkHttpChannelBuilder;

public class Demo {
    public static void main(String[] args) {
        ManagedChannelImpl wrapped = OkHttpChannelBuilder.forAddress("127.0.0.1", 9999)
                  .usePlaintext(true)
                  .build();
    }
}

What I get is:
Exception in thread "main" java.lang.IllegalArgumentException: cannot find a NameResolver for     127.0.0.1:9999 (Illegal character in scheme name at index 0: 127.0.0.1:9999)
at io.grpc.internal.ManagedChannelImpl.getNameResolver(ManagedChannelImpl.java:257)
    at io.grpc.internal.ManagedChannelImpl.<init>(ManagedChannelImpl.java:167)
    at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:210)
    at com.testbase.Demo.main(Demo.java:11)

And the same exception for netty transport too. Replacing 127..0.0.1 with localhost doesn't work. It happens on all the IPv4 addresses I try.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1983
stub: create cancellation exception as runtime for all server calls, â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This changes the stack trace, but records closer to where the exception was actually created.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1984
core: Improve error message when lacking NameResolverProviders
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1985
Bump protobuf dependency to 3.0.0-beta-3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CC @bobbytables, @david-cao . This is similar to #1908 but deals with the warnings and swapping compiler project proto3 for Lite testing. This was delayed earlier because of the annoying warnings. However, we need proto3 Lite support for GA.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1986
core: Channel Idleness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation is done. I am going to write more tests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1987
testware: fix flakes caused by pickUnusedPort
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1988
examples: add an example showing how to get the error details from a â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was intentionally a little more verbose, so that examples are somewhat copy pasteable, and fit all context on a single screen.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1989
netty: improve flushing and object allocations in write queue.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Running the NoiseClient from netty/netty#5360 with this change, we write up to 15k buffers per flush, compared to 256 buffers before that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1990
core: add an awaitTermination method to ManagedChannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1991
compiler: deprecate interfaces and add ImplBase in codegen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One travis job failed at

io.grpc.netty.NettyTransportTest > ping_afterTermination FAILED
java.lang.AssertionError: expected:<Status{code=UNAVAILABLE, description=null, cause=null}> but was:<Status{code=UNKNOWN, description=null, cause=java.nio.channels.ClosedChannelException}>

but seems not related to the PR. Re-run the job...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1992
Keepalive support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The integration part with OkhttpClientTransport is not done yet. I will do it in another commit or pull request.
But this one should be already complete for review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1993
Implement status_code_and_message interop test in Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a spec, and implementations in some languages, but none in Java yet.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1994
core: ResettableTimer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1995
netty: fix incorrect usage of AsciString.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr yikes! LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1996
DNM: netty: add handler to combine small writes into larger buffer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You also need to ensure you release / flush the buffer when the channel is closed or the handler is removed

Am 30.06.2016 um 16:52 schrieb Jakob Buchgraber notifications@github.com:
This is a proof of concept that combines smaller ByteBufs into a larger ByteBuf by copying. The idea came out of a discussion with @normanmaurer today, where he dropped his wisdom on me :-). Amongst others he mentioned that passing many small buffers to writev can often be much slower than one big buffer to write. I decided to give it a try and implemented a WriteCombiningHandler that simply copies many smaller buffers into a bigger buffer. See the benchmark below.
Now, this is still quite early and I have to experiment and benchmark a lot more. Also, this handler does not interact well with a channel's writability and promise's aren't implemented correctly (yet). Also, the handler is quite dumb in that it just combines all writes. We could instead only combine buffers less than N bytes, and have different sized buffers to optimize for memory usage (i.e. don't allocate a 4KB buffer to merge 5 writes totalling 250 bytes). Many more sophisticated heuristics are conceivable.
Furthermore, @normanmaurer mentioned that if real performance benefits can be shown, this capability should be added to Netty's ChannelOutboundBuffer.
./qps_client --client_payload=20 --server_payload=40 --outstanding_rpcs=2000
--channels=1 --streaming_rpcs --directexecutor --address=localhost:8080
./qps_server --directexecutor --address=localhost:8080
Best out of 3 runs:
Before:
Channels:                       1
Outstanding RPCs per Channel:   2000
Server Payload Size:            40
Client Payload Size:            20
50%ile Latency (in micros):     9799
90%ile Latency (in micros):     11751
95%ile Latency (in micros):     12911
99%ile Latency (in micros):     14959
99.9%ile Latency (in micros):   23727
Maximum Latency (in micros):    145919
QPS:                            199364
After:
Channels:                       1
Outstanding RPCs per Channel:   2000
Server Payload Size:            40
Client Payload Size:            20
50%ile Latency (in micros):     9007
90%ile Latency (in micros):     10799
95%ile Latency (in micros):     11895
99%ile Latency (in micros):     13495
99.9%ile Latency (in micros):   22431
Maximum Latency (in micros):    107327
QPS:                            217794
Thoughts? @ejona86 @nmittler @carl-mastrangelo @louiscryan
You can view, comment on, or merge this pull request online at:
#1996
Commit Summary
netty: add handler to combine small writes into larger buffer
File Changes
M netty/src/main/java/io/grpc/netty/NettyClientHandler.java (6)
M netty/src/main/java/io/grpc/netty/NettyServerHandler.java (1)
A netty/src/main/java/io/grpc/netty/WriteCombiningHandler.java (82)
Patch Links:
https://github.com/grpc/grpc-java/pull/1996.patch
https://github.com/grpc/grpc-java/pull/1996.diff
â€”
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub, or mute the thread.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1997
Reduce default max message size to 4 MiB
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1998
core: Rename withCredentials to withCallCredentials on CallOptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/1999
netty: update to 4.1.2.Final and tcnative Fork18
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Throughput is up ~5% with this new Netty release. Guessing at HPACK changes. Thanks @normanmaurer and @Scottmitch! :)
Netty 4.1.1.Final
Outstanding RPCs per Channel:   10
Server Payload Size:            0
Client Payload Size:            0
50%ile Latency (in micros):     433
90%ile Latency (in micros):     468
95%ile Latency (in micros):     486
99%ile Latency (in micros):     658
99.9%ile Latency (in micros):   1378
Maximum Latency (in micros):    48927
QPS:                            90211

Netty 4.1.2.Final
Channels:                       4
Outstanding RPCs per Channel:   10
Server Payload Size:            0
Client Payload Size:            0
50%ile Latency (in micros):     412
90%ile Latency (in micros):     449
95%ile Latency (in micros):     466
99%ile Latency (in micros):     578
99.9%ile Latency (in micros):   1336
Maximum Latency (in micros):    24959
QPS:                            95105
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2000
netty: reduce allocations in write queue.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2001
benchmarks: fix typo in README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2002
netty: add logging to find cause of ClosedChannelException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2003
netty: undo commit 6a55e29 as netty's DefaultThreadFactory has been fixed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2004
Fixing error-prone warnings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2005
ManagedChannels and Servers should nag when not shutdown properly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Idea: add a finalizer to ManagedChannels and Servers, to make sure they are shutdown properly.  In the event that a user loses a reference to the object, the finalizer can check to see if it was shutdown properly and loudly nag about how it should be done correctly.  It may or may not decide to actually do the shutdown in addition.  It is not guaranteed to run, but would help point out where they are being lost.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2006
examples: Avoid deprecated generated class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2007
Start 1.0.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm.. I guess I should just instead bump this to 1.0 BECAUSE THERE MUST NOT BE A 0.16. WE WILL NOT DO THAT AGAIN
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2008
Release 0.15.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2009
Fix releasing doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, friendly ping. This will end up merge conflicting with the examples change I'm working on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2010
compiler: Add option to disable version output
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2011
core: add @GaurdedBy annotations for mutable state of ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2012
netty: prevent race between transportCreated and transportShutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2013
interop tests: fix race in Compression tests where MetadataEntry.getPâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2014
Race on NettyServer shutdown.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Even with 2292cbf it seems there is still a race with shutdown.  Initial guess is that the shutdown and close are happening in the Boss Event loop and the normal event loop.  Conflicting reads and writes:
WARNING: ThreadSanitizer: data race (pid=705947)
  Read of size 8 at 0x7fa79fc81808 by thread T28 (mutexes: write M109229):
    #0 io.netty.channel.AbstractChannel$AbstractUnsafe.outboundBuffer()Lio/netty/channel/ChannelOutboundBuffer; (AbstractChannel.java:434)  
    #1 io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.init(Lio/netty/channel/AbstractChannelHandlerContext$AbstractWriteTask;Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:1027)  
    #2 io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.newInstance(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/AbstractChannelHandlerContext$WriteAndFlushTask; (AbstractChannelHandlerContext.java:1101)  
    #3 io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.access$1600(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/AbstractChannelHandlerContext$WriteAndFlushTask; (AbstractChannelHandlerContext.java:1089)  
    #4 io.netty.channel.AbstractChannelHandlerContext.write(Ljava/lang/Object;ZLio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:807)  
    #5 io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:780)  
    #6 io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:817)  
    #7 io.netty.channel.DefaultChannelPipeline.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (DefaultChannelPipeline.java:1011)  
    #8 io.netty.channel.AbstractChannel.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (AbstractChannel.java:289)  
    #9 io.grpc.netty.NettyServerTransport.shutdownNow(Lio/grpc/Status;)V (NettyServerTransport.java:101)  
    #10 io.grpc.internal.ServerImpl$ServerListenerImpl.serverShutdown()V (ServerImpl.java:302)  
    #11 io.grpc.netty.NettyServer$2.operationComplete(Lio/netty/channel/ChannelFuture;)V (NettyServer.java:178)  
    #12 io.grpc.netty.NettyServer$2.operationComplete(Lio/netty/util/concurrent/Future;)V (NettyServer.java:171)  
    #13 io.netty.util.concurrent.DefaultPromise.notifyListener0(Lio/netty/util/concurrent/Future;Lio/netty/util/concurrent/GenericFutureListener;)V (DefaultPromise.java:518)  
    #14 io.netty.util.concurrent.DefaultPromise.notifyListenersNow()V (DefaultPromise.java:492)  
    #15 io.netty.util.concurrent.DefaultPromise.notifyListenersWithStackOverFlowProtection()V (DefaultPromise.java:431)  
    #16 io.netty.util.concurrent.DefaultPromise.notifyListeners()V (DefaultPromise.java:420)  
    #17 io.netty.util.concurrent.DefaultPromise.trySuccess(Ljava/lang/Object;)Z (DefaultPromise.java:108)  
    #18 io.netty.channel.DefaultChannelPromise.trySuccess()Z (DefaultChannelPromise.java:82)  
    #19 io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:884)  
    #20 io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:675)  
    #21 io.netty.channel.AbstractChannel$AbstractUnsafe.close(Lio/netty/channel/ChannelPromise;Ljava/lang/Throwable;Z)V (AbstractChannel.java:652)  
    #22 io.netty.channel.AbstractChannel$AbstractUnsafe.close(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:596)  
    #23 io.netty.channel.DefaultChannelPipeline$HeadContext.close(Lio/netty/channel/ChannelHandlerContext;Lio/netty/channel/ChannelPromise;)V (DefaultChannelPipeline.java:1256)  
    #24 io.netty.channel.AbstractChannelHandlerContext.invokeClose(Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:610)  
    #25 io.netty.channel.AbstractChannelHandlerContext.access$1100(Lio/netty/channel/AbstractChannelHandlerContext;Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:36)  
    #26 io.netty.channel.AbstractChannelHandlerContext$13.run()V (AbstractChannelHandlerContext.java:599)  
    #27 io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(J)Z (SingleThreadEventExecutor.java:339)  
    #28 io.netty.channel.nio.NioEventLoop.run()V (NioEventLoop.java:393)  
    #29 io.netty.util.concurrent.SingleThreadEventExecutor$5.run()V (SingleThreadEventExecutor.java:742)  
    #30 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run()V (DefaultThreadFactory.java:145)  
    #31 java.lang.Thread.run()V (Thread.java:745)  
    #32 (Generated Stub)  

  Previous write of size 8 at 0x7fa79fc81808 by thread T65:
    #0 io.netty.channel.AbstractChannel$AbstractUnsafe.close(Lio/netty/channel/ChannelPromise;Ljava/lang/Throwable;Z)V (AbstractChannel.java:626)  
    #1 io.netty.channel.AbstractChannel$AbstractUnsafe.close(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:596)  
    #2 io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.closeOnRead(Lio/netty/channel/ChannelPipeline;)V (AbstractNioByteChannel.java:76)  
    #3 io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read()V (AbstractNioByteChannel.java:131)  
    #4 io.netty.channel.nio.NioEventLoop.processSelectedKey(Ljava/nio/channels/SelectionKey;Lio/netty/channel/nio/AbstractNioChannel;)V (NioEventLoop.java:563)  
    #5 io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized([Ljava/nio/channels/SelectionKey;)V (NioEventLoop.java:504)  
    #6 io.netty.channel.nio.NioEventLoop.processSelectedKeys()V (NioEventLoop.java:418)  
    #7 io.netty.channel.nio.NioEventLoop.run()V (NioEventLoop.java:390)  
    #8 io.netty.util.concurrent.SingleThreadEventExecutor$5.run()V (SingleThreadEventExecutor.java:742)  
    #9 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run()V (DefaultThreadFactory.java:145)  
    #10 java.lang.Thread.run()V (Thread.java:745)  
    #11 (Generated Stub)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2015
Race on NettyClientTransport.start
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Bootstrap.connect seems to add a listener to a ChannelFuture that is concurrently modified by the NioEventLoop and the client provided executor in ConcurrencyTest
Conflicting accesses:
WARNING: ThreadSanitizer: data race (pid=734706)
  Write of size 8 at 0x7f4e49d10538 by thread T86 (mutexes: write M70410, write M82043):
    #0 io.netty.util.concurrent.DefaultPromise.addListener0(Lio/netty/util/concurrent/GenericFutureListener;)V (DefaultPromise.java:526)  
    #1 io.netty.util.concurrent.DefaultPromise.addListener(Lio/netty/util/concurrent/GenericFutureListener;)Lio/netty/util/concurrent/Promise; (DefaultPromise.java:163)  
    #2 io.netty.channel.DefaultChannelPromise.addListener(Lio/netty/util/concurrent/GenericFutureListener;)Lio/netty/channel/ChannelPromise; (DefaultChannelPromise.java:93)  
    #3 io.netty.channel.DefaultChannelPromise.addListener(Lio/netty/util/concurrent/GenericFutureListener;)Lio/netty/channel/ChannelFuture; (DefaultChannelPromise.java:28)  
    #4 io.netty.bootstrap.Bootstrap.doResolveAndConnect(Ljava/net/SocketAddress;Ljava/net/SocketAddress;)Lio/netty/channel/ChannelFuture; (Bootstrap.java:173)  
    #5 io.netty.bootstrap.Bootstrap.connect(Ljava/net/SocketAddress;)Lio/netty/channel/ChannelFuture; (Bootstrap.java:144)  
    #6 io.grpc.netty.NettyClientTransport.start(Lio/grpc/internal/ManagedClientTransport$Listener;)V (NettyClientTransport.java:156)  
    #7 io.grpc.internal.ForwardingConnectionClientTransport.start(Lio/grpc/internal/ManagedClientTransport$Listener;)V (ForwardingConnectionClientTransport.java:45)  
    #8 io.grpc.internal.TransportSet.startNewTransport(Lio/grpc/internal/DelayedClientTransport;)V (TransportSet.java:206)  
    #9 io.grpc.internal.TransportSet.obtainActiveTransport()Lio/grpc/internal/ClientTransport; (TransportSet.java:179)  
    #10 io.grpc.internal.ManagedChannelImpl$3.getTransport(Lio/grpc/EquivalentAddressGroup;)Lio/grpc/internal/ClientTransport; (ManagedChannelImpl.java:476)  
    #11 io.grpc.internal.ManagedChannelImpl$3.getTransport(Lio/grpc/EquivalentAddressGroup;)Ljava/lang/Object; (ManagedChannelImpl.java:432)  
    #12 io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer.pickTransport(Lio/grpc/Attributes;)Ljava/lang/Object; (DummyLoadBalancerFactory.java:105)  
    #13 io.grpc.internal.ManagedChannelImpl$1.get(Lio/grpc/CallOptions;)Lio/grpc/internal/ClientTransport; (ManagedChannelImpl.java:149)  
    #14 io.grpc.internal.ClientCallImpl.start(Lio/grpc/ClientCall$Listener;Lio/grpc/Metadata;)V (ClientCallImpl.java:201)  
    #15 io.grpc.stub.ClientCalls.startCall(Lio/grpc/ClientCall;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:248)  
    #16 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:227)  
    #17 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;Z)V (ClientCalls.java:215)  
    #18 io.grpc.stub.ClientCalls.asyncServerStreamingCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;)V (ClientCalls.java:87)  
    #19 io.grpc.testing.integration.TestServiceGrpc$TestServiceStub.streamingOutputCall(Lio/grpc/testing/integration/Messages$StreamingOutputCallRequest;Lio/grpc/stub/StreamObserver;)V (TestServiceGrpc.java:311)  
    #20 io.grpc.testing.integration.ConcurrencyTest$ClientWorker.run()V (ConcurrencyTest.java:138)  
    #21 java.util.concurrent.ThreadPoolExecutor.runWorker(Ljava/util/concurrent/ThreadPoolExecutor$Worker;)V (ThreadPoolExecutor.java:1142)  
    #22 java.util.concurrent.ThreadPoolExecutor$Worker.run()V (ThreadPoolExecutor.java:617)  
    #23 java.lang.Thread.run()V (Thread.java:745)  
    #24 (Generated Stub)  

  Previous read of size 8 at 0x7f4e49d10538 by thread T142:
    #0 io.netty.util.concurrent.DefaultPromise.notifyListeners()V (DefaultPromise.java:417)  
    #1 io.netty.util.concurrent.DefaultPromise.trySuccess(Ljava/lang/Object;)Z (DefaultPromise.java:108)  
    #2 io.netty.channel.DefaultChannelPromise.trySuccess()Z (DefaultChannelPromise.java:82)  
    #3 io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:884)  
    #4 io.netty.channel.AbstractChannel$AbstractUnsafe.register0(Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:497)  
    #5 io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(Lio/netty/channel/AbstractChannel$AbstractUnsafe;Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:412)  
    #6 io.netty.channel.AbstractChannel$AbstractUnsafe$1.run()V (AbstractChannel.java:471)  
    #7 io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(J)Z (SingleThreadEventExecutor.java:339)  
    #8 io.netty.channel.nio.NioEventLoop.run()V (NioEventLoop.java:393)  
    #9 io.netty.util.concurrent.SingleThreadEventExecutor$5.run()V (SingleThreadEventExecutor.java:742)  
    #10 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run()V (DefaultThreadFactory.java:145)  
    #11 java.lang.Thread.run()V (Thread.java:745)  
    #12 (Generated Stub)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2016
Custom HostnameVerifier for NettyChannelBuilder 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would it be possible to provide a customizable javax.net.ssl.HostnameVerifier on he client side?
The most http clients provide this feature in order to deal with "generic selfsigned certificates".
Currently I use netty's InsecureTrustManagerFactory, which trusts all certificates not just mine.
val sslContext = GrpcSslContexts.forClient()
    .trustManager(InsecureTrustManagerFactory.INSTANCE)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2017
Do not merge, just for code review. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2018
Issue compiling proto files using protobuf lite within android studio
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I followed android example to compile few existing proto files that we have in android studio. However i get following errors
Error:(146, 51) error: cannot find symbol method mutableCopy(ProtobufList)
Error:(327, 52) error: cannot find symbol method parseFrom(Resource,ByteString)
Error:(339, 52) error: cannot find symbol method parseFrom(Resource,byte[])
etc..
Following is how my module build.gradle looks like, Am i missing some config??
Thanks
apply plugin: 'com.android.application'
apply plugin: 'com.google.protobuf'
android {
compileSdkVersion 24
buildToolsVersion '24.0.0'
defaultConfig {
applicationId "com.luminatewireless.ops.installerapp"
minSdkVersion 19
targetSdkVersion 24
versionCode 1
versionName "1.0"
testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
}
buildTypes {
release {
minifyEnabled false
proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
}
}
configurations.all {
resolutionStrategy.force 'com.google.code.findbugs:jsr305:1.3.9'
}
lintOptions {
disable 'InvalidPackage', 'HardcodedText'
textReport true
textOutput "stdout"
}
}
protobuf {
protoc {
artifact = 'com.google.protobuf:protoc:3.0.0-beta-3'
}
plugins {
grpc {
artifact = 'io.grpc:protoc-gen-grpc-java:0.15.0-SNAPSHOT' // CURRENT_GRPC_VERSION
}
}
generateProtoTasks {
all().each { task ->
task.builtins {
// Javanano is installed by default, but needs to be removed to use protobuf lite..
remove javanano
java {
// Options added to --java_out
option 'lite'
}
}
        task.plugins {
            grpc {
                // Options added to --grpc_out
                option 'lite'
            }
        }
    }
}

}
dependencies {
compile 'javax.annotation:javax.annotation-api:1.2'
compile 'com.google.code.findbugs:jsr305:3.0.0'

//guava
compile 'com.google.guava:guava:19.0'

//grpc
compile 'io.grpc:grpc-okhttp:0.15.0-SNAPSHOT'
compile 'io.grpc:grpc-protobuf-lite:0.15.0-SNAPSHOT'
compile 'io.grpc:grpc-stub:0.15.0-SNAPSHOT'

compile fileTree(include: ['*.jar'], dir: 'libs')
androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
    exclude group: 'com.android.support', module: 'support-annotations'
})
compile 'com.android.support:appcompat-v7:24.0.0'
compile 'com.android.support.constraint:constraint-layout:1.0.0-alpha3'
testCompile 'junit:junit:4.12'

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2019
Fix wrong use of checkNotNull in WriteQueue.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2020
Is 0.15.0 out?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I see it in the release tab from a couple days ago, but it isn't in maven central, are you waiting to pull in more before publishing it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2021
examples: Provide Maven and Gradle build files
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Where did GreeterGrpc go?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2022
Make ManagedChannelBuilder.idleTimeout() non-experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2023
thrift integration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2024
Consider doing header processing on Application thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Profiling shows that about 10% of time on the network thread on a spinning benchmark is spent converting from Netty Headers to gRPC Metadata.  This has been optimized recently, and the profiling doesn't include recent Netty changes, but most of the time is actually in the gRPC code!
An idea to fix this would be to punt the conversion of Transport Headers to gRPC Headers onto an application thread, freeing up the network thread.  I don't imagine this would have big CPU savings, but could have a latency spike.
cc @buchgr  thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2025
core: Save accept encoding since Metadata is not thread-safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2026
netty: deduplicate javadoc accidentially introduced in e80b136495c
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2027
netty: Improve flusing behaviour in WriteQueue.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The discussion is in PR #1989 ... More investigation is needed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2028
travis,jenkins: Fail build if javac emits warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2029
Stop infinite loop
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I'm try to do some streaming service. I do something like this:
// Server-side
    @Override
    public void signalStream(StreamParams request, StreamObserver<Data> responseObserver) {
      final ServerCallStreamObserver callStreamObserver = (ServerCallStreamObserver) responseObserver;
      while (!callStreamObserver.isCancelled()) {
        // ... prepare data
        responseObserver.onNext(data);
      }
      responseObserver.onCompleted();
    }

But if client is goes away or (somehow) isCancelled() not changed either StreamObserver not started throwing.
protobuf 0.15.0
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
Microsoft Windows [Version 10.0.10586]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2030
core: Allow avoiding Provider loading, for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2031
grpc-netty on maven central depends on netty 4.1.2 but code assumes 4.1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I noticed that the grpc-netty v0.15 package on Maven Central suggests using netty-4.1.2Final. However, we get the following exception when we use it. The cause appears to be that the code uses a DefaultHttp2HeadersDecoder constructor that takes 3 parameters, as supplied by netty 4.1.1, but netty 4.1.2 added a 4th parameter, hence the NoSuchMethodError.
Everything appears to work fine for me with netty 4.1.1Final.
java.lang.RuntimeException: java.lang.NoSuchMethodError: io.netty.handler.codec.http2.DefaultHttp2HeadersDecoder.(IIZ)V
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:144)
at com.turn.platform.message.grpc.ExecutorGrpc$ExecutorBlockingStub.doExec(ExecutorGrpc.java:171)
....(our calling code)....
Caused by: java.lang.NoSuchMethodError: io.netty.handler.codec.http2.DefaultHttp2HeadersDecoder.(IIZ)V
at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:118)
at io.grpc.netty.NettyClientTransport.newHandler(NettyClientTransport.java:250)
at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:140)
at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:45)
at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:206)
at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:179)
at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:476)
at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:432)
at io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer.pickTransport(DummyLoadBalancerFactory.java:105)
at io.grpc.internal.ManagedChannelImpl$1.get(ManagedChannelImpl.java:149)
at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:201)
at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:248)
at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:227)
at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:186)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:132)
... 10 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2032
Fix issues found by static checkers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2033
interop: Bump maxMessageSize for Android testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2034
ServerImpl may use executor after it is released
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since 777e928, ServerImpl may reference executor and may schedule Runnables on executor after executor is released. The executor should be released on termination, not shutdown.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2035
Start 1.1.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2036
Metadata trailers are not passed to Status*Exception when using ClientCalls.blockingUnaryCall.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Trying to write a sample for #1295, but when calling unary rpc method on blocking stub, the trailers are not passed during ClientCalls.getUnchecked which is called from ClientCalls.blockingUnaryCall.
Is this by design or bug ?
Sample code is here, the blockingCall() fails but others are good.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2037
Optimize NameResolverProvider,ManagedChannelBuilder for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Class.getResource() is very expensive on Android, so we need to find an alternative for our Provider classes.
Since Android has little need for alternative name resolvers and the number of transport implementations is very limited, we're planning on swapping to a hard-coded list of well-known providers when we detect we are on Android.
We will most likely hard-code the string in call to check for the class, Class.forName("io.grpc.internal.DnsNameResolverProvider"), to also allow ProGuard to notice the reference.
Internal tracking: b/30158670
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2038
Absorb new Java import style
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/google/styleguide/pull/160/files
The rest of the changes are Java 8-specific.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2039
Revert "core: add @GaurdedBy annotations for mutable state of ServerIâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I figured out a short comment that I think will work instead. Closing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2040
core: Fix ErrorProne errors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2041
Specify ThreadGroup to Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Depending on the specifics of how netty/netty#5533 ends, it may break our users using ThreadGroups. We would need to re-apply the workaround removed in 2d7347f or add a workaround that specifies the ThreadGroup to Netty's DefaultThreadFactory.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2042
Improve thread safety docs for fields in ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Split out of #2032 (comment). usingSharedExecutor and executor aren't using GuardedBy semantics. It isn't clear to @carl-mastrangelo that the current code is valid. Improve the docs/code to correct/make the correctness more clear.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2043
interop: Add constant for necessary max message size
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2044
docs: Avoid using bindService()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I will backport this to the v1.0.x branch after LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2045
core: Fix doc to refer to ImplBase
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2046
Optimize for the normal case when we need to send keepalive pings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd rather not solve this problem by hacking KeepAliveManager. I'd rather just fix OkHttpClientTransport to call onDataReceived earlier. Could we instead make our own Okio Source that we place right after the socket (and ideally before the buffer), and have it call onDataReceived instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2047
netty: update to 4.1.3.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #2041, #2015, #2014
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2048
android-interop: Remove usage of deprecated generated interface
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2049
Fix selection of security Provider to conscruct SSLContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2050
ClientCall.cancel is not required to be implemented
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/ClientCall.java#L212
This is an oversight based on how we changed the arguments. We should remove the default implementation for 1.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2051
Consider adding UnimplementedChannel to testing project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An UnimplementedChannel is convenient over using a InProcessServer without any services since it does not need to be shut down. It seems reasonable to make it easier to create a stub that shouldn't be used.
/**
 * Implementation of {@link Channel} where every method responds {@link Status#UNIMPLEMENTED}.
 * Useful for testing to create a stub that should not be used. No verification of arguments
 * or call order is performed.
 */
public class UnimplementedChannel extends Channel {
  @Override
  public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(
      MethodDescriptor<ReqT, RespT> methodDescriptor, CallOptions callOptions) {
    return new ClientCall<ReqT, RespT>() {
      @Override
      public void start(Listener<RespT> responseListener, Metadata headers) {
        responseListener.onClose(Status.UNIMPLEMENTED, new Metadata());
      }

      @Override
      public void request(int numMessages) {}

      @Override
      public void cancel(@Nullable String message, @Nullable Throwable cause) {}

      @Override
      public void halfClose() {}

      @Override
      public void sendMessage(ReqT message) {}
    };
  }

  @Override
  public String authority() {
    return "localhost";
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2052
netty: reduce contention in WriteQueue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc: @louiscryan @buchgr
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2053
Fixed directory in README.md for output scripts.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2054
Log a warning in ClientCall.cancel if it has neither a message nor exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ClientCallImpl.java#L347
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2055
core: Add missing assert in CallOptionsTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2056
interop: Fix flake in cascading test due to sleeps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan friendly ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2057
Service is still running when client is killed.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My service queries lot of data by jdbc and sends to client using grpc stream. If I killed the client, the service cant catch a exception, and it still running the circle to query from jdbc and write to stream. I cant find a method to receive a notify that grpc completed. What should I do, please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2058
Remove usages of Guava's BaseEncoding and ByteStreams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Both are @Beta in Guava, and thus are not appropriate for use in a library. Usages within tests are fine.
$ git grep -E 'com.google.common.io.(ByteStreams|BaseEncoding)' | grep -v Test
auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java:import com.google.common.io.BaseEncoding;
core/src/main/java/io/grpc/internal/MessageFramer.java:import com.google.common.io.ByteStreams;
core/src/main/java/io/grpc/internal/TransportFrameUtil.java:import com.google.common.io.BaseEncoding;
core/src/test/java/io/grpc/StringMarshaller.java:import com.google.common.io.ByteStreams;
protobuf-lite/src/main/java/io/grpc/protobuf/lite/ProtoInputStream.java:import com.google.common.io.ByteStreams;
protobuf-nano/src/main/java/io/grpc/protobuf/nano/NanoUtils.java:import com.google.common.io.ByteStreams;
This should probably be back-ported to the v1.0.x branch.
Edit: BaseEncoding is used for base64, which be a bit painful to remove. If it turns out to be very painful, we should probably not backport it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2059
Ensure that trailers are not lost when making blocking calls.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2060
core: Reduce DeadlineTest flake
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2061
benchmarks: daemonize threads to reduce the number of stacktraces
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What is being referred to by "the number of stacktraces" isn't clear. You could just mention that the threads are preventing JMH from starting the next test.
And it appears that the reason for the speedup is that those event loops are never shut down.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2062
Benchmarks OOM
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Running FlowControlledMessagePerSecond benchmark with 4 forks creates out of memory exceptions.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2063
Deprecated method warning when upgrading to 0.15.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I got following warning messages in generated code.
Proto version is 3.0.0-beta-3.
mandatory_warning: writeRawVarint32(int) in com.google.protobuf.CodedOutputStream has been deprecated output.writeRawVarint32(10);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2064
Ensure that trailers are not lost when making blocking calls.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 PTAL .... this is the backport into v1.0.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2065
Revise security provider selection for android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2066
[Question] BlockingResponseStream.hasNext blocks forever
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I run into an issue that BlockingResponseStream.hasNext occasionally blocks forever while sending response for a streaming RPC. I haven't found any reliable way to reproduce this issue, but following code and comment in ClientCalls.java caught my attention:
try {
  // Will block here indefinitely waiting for content. RPC timeouts defend against permanent
  // hangs here as the call will become closed.
  last = waitForNext();
} catch (InterruptedException ie) {
  Thread.currentThread().interrupt();
  throw Status.CANCELLED.withCause(ie).asRuntimeException();
}

I am not vary familiar with GRPC codebase. Could someone tell me when is this call going to block and which thread usually unblocks it? What could cause the call being blocked forever?
It seems GRPC does not timeout by default. Should I specify RPC timeout (BTW is timeout the same thing as deadline)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2067
Flow control proxy and tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2068
TLS communication error between grpc-java client to golang server 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I get the following error when establishing a connection between a grpc-java client and a golang grpc server.
Jul 19, 2016 5:52:49 PM io.grpc.internal.TransportSet$1 call
INFO: Created transport io.grpc.netty.NettyClientTransport@7e72c234(/127.0.0.1:30303) for /127.0.0.1:30303
Jul 19, 2016 5:52:49 PM io.grpc.internal.TransportSet$TransportListener transportShutdown
INFO: Transport io.grpc.netty.NettyClientTransport@7e72c234(/127.0.0.1:30303) for /127.0.0.1:30303 is being shutdown
Jul 19, 2016 5:52:49 PM io.grpc.internal.TransportSet$TransportListener transportTerminated
INFO: Transport io.grpc.netty.NettyClientTransport@7e72c234(/127.0.0.1:30303) for /127.0.0.1:30303 is terminated
Jul 19, 2016 5:52:49 PM io.netty.handler.codec.http2.Http2ConnectionHandler processGoAwayWriteResult
WARNING: [id: 0x065e63d9, L:0.0.0.0/0.0.0.0:60630 ! R:/127.0.0.1:30303] Sending GOAWAY failed: lastStreamId '0', errorCode '1', debugData 'First received frame was not SETTINGS. Hex dump for first 5 bytes: 1503010002'. Forcing shutdown of the connection.
java.io.IOException: Broken pipe
    at sun.nio.ch.FileDispatcherImpl.writev0(Native Method)
    at sun.nio.ch.SocketDispatcher.writev(SocketDispatcher.java:51)
    at sun.nio.ch.IOUtil.write(IOUtil.java:148)
    at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:504)
    at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:305)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:839)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:311)
    at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:806)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1436)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:347)
    at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:395)
    at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:259)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.onError(Http2ConnectionHandler.java:546)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:216)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:392)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:387)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:245)
    at io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:83)
    at io.netty.channel.DefaultChannelHandlerInvoker.invokeChannelRead(DefaultChannelHandlerInvoker.java:154)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:354)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:145)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:1078)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:510)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:467)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:381)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:353)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2069
DO NOT MERGE Flush coalescing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Interesting idea. What do benchmarks show? I wonder if we should also bring in time as a factor to provide an upper bound for the time for when we do not flush?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2070
netty: always flush at least once, even if there were no writes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2071
core: Hard-code a list of providers for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2072
netty: Add test for AbstractHttp2Headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2073
Add an example for setting and reading error details
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2074
How to use load balancer in client side
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI. I am writing a client for a service, since this service has multiple instances, so I can get more than one addresses, and I just want to configure those addresses when I construct client. But after scan all the examples, I can't find such example. All examples use ManagedChannelBuilder.forAddress() like way to get a ChannelBuilder, I did notice that channel builder has a loadBalancerFactory method, but I am wondering how to implement a custom load balancer factory and where I can configure those addresses?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2075
compiler: add build option to enable deprecated generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2076
Force the immediate release of reference counted resources on AppEngine
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@louiscryan LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2077
compiler: make Stub final class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2078
compiler: Add FALLTHROUGH_INTENDED to appropriate cases
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2079
benchmarks: improve benchmarks recording and shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh yeah, this also speeds up the benchmarks significantly since there isn't a sleep for 5 seconds after each benchmark case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2080
compiler: flip enable_deprecated option default to false
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@dapengzhang0 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2081
core: remove extra allocation in MessageFramer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2082
benchmarks: avoid 2 copies in favor of one
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2083
update grpc version to 0.15.0 and protoc to 3.0.0-beta-3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2084
core: Remove default implementation for ClientCall.cancel.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2085
core: Log a warning in ClientCall.cancel if no detail is provided.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2086
Update to protobuf-3.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Upgrading to Protobuf-3.0.0-beta-4 breaks Lite, since there are no pre-compiled binaries for Lite at that version. GA will have pre-compiled libraries.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2087
android: Remove providers from ProGuard configuration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Based on #1817, right?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2088
HandlerRegistryBenchmark always fails
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HandlerRegistryBenchmark always fails to run because MethodDescriptor expects a non-null request marshaller:
java.lang.NullPointerException: requestMarshaller
    at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:228)
    at io.grpc.MethodDescriptor.<init>(MethodDescriptor.java:161)
    at io.grpc.MethodDescriptor.create(MethodDescriptor.java:151)
    at io.grpc.benchmarks.netty.HandlerRegistryBenchmark.setup(HandlerRegistryBenchmark.java:91)
    at io.grpc.benchmarks.netty.generated.HandlerRegistryBenchmark_lookupMethod_jmhTest._jmh_tryInit_f_handlerregistrybenchmark0_G(HandlerRegistryBenchmark_lookupMethod_jmhTest.java:395)
    at io.grpc.benchmarks.netty.generated.HandlerRegistryBenchmark_lookupMethod_jmhTest.lookupMethod_Throughput(HandlerRegistryBenchmark_lookupMethod_jmhTest.java:57)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:430)
    at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:412)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

Probably easy enough to fix by adding one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2089
Routeguide example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2090
Cherry picks for v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2091
Error zero_copy_stream.h file not found during  ../gradlew java_pluginExecutable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RUN ../gradlew java_pluginExecutable  got error:
Error zero_copy_stream.h file not found
I tried export CXXFLAGS="-I/usr/local/include" LDFLAGS="-L/usr/local/lib" , but did not work,
ENV as following:
OS: CentOS-7/Mac
protobuf: protoc-3.0.0-beta-4-linux-x86_64
grpc-java:grpc-java-0.15.0
jdk:1.8
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2092
core,netty: retain buffer in MessageFramer to reuse for subsequent messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, we can't merge this right now, right? Because otherwise we could leak buffers?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2093
Flow control (disabled by default) in netty and unit tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2094
Bump version to 1.0.0-pre1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2095
Fix examples README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zsurocking LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2096
doc: fix io.grpc package level java doc not showing up
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@dapengzhang0 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2097
Mobile Benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2098
Android has version "0.0" in user agent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should have the actual version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2099
Can we please call the thrift module & artifacts 'grift'
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@chedeti
@ejona86
Pretty please!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2100
Update protobuf to 3.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2101
Begin consuming protobuf-lite artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2102
Slightly encourage more use of lite, instead of nano
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2103
netty: update to 4.1.4.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@buchgr LGTM. I'd rather not update v1.0.x at this point though, since we won't have tested with that version of netty very much and there were the changes to the Recycler and WeakOrderQueue. There also weren't any correctness bug fixes that appeared to impact us. So I'd rather not rush it. It can always be in a v1.0.1 or similar (since I do expect we'll like the new version).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2104
Mobile Benchmark PR Template
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for your pull request. Before we can look at your contribution, we need to ensure all contributors are covered by a Contributor License Agreement.
After the following items are addressed, please respond with a new comment here, and the automated system will re-verify.

User @david-cao isn't covered by a CLA. They will need to complete the form at https://identity.linuxfoundation.org/projects/cncf

Regards,
CLA GitHub bot
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2105
Cherry-picks into v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2106
core: call newStream() and applyRequestMetadata() under context.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2107
Protobuf benchmarks for protolite_app added
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2108
inprocess: Avoid creating unnecessary threads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2109
DNS+SRV NameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I see that there is currently a dns name resolver and I'm wondering if a dns+srv resolver would make sense for the project:
So you would be able to resolve a target like:
"dns+srv:///_etcd-server._tcp.example.com"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2110
okhttp: Remove wrong status description
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2111
stub: Avoid double-wrapping status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2112
Server-side cancellation does not promptly inform server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Both context.isCancelled() and call.isCancelled() only begin returning true after ServerCallListener.onCancel() (in ServerCallImpl.ServerStreamListenerImpl, but that is already on application callback thread via ServerImpl.JumpToApplicationThreadServerStreamListener). That means callers must return from a listener event before the values can change and they will have already seen onCancel(), which makes them broken for the very case they are there to solve.
If !status.isOk(), both the context and the call should return true as soon as the transport notifies the server. How to do that seems it will be a bit awkward with the current code organization.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2113
RPC Benchmarks for proto lite app
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2114
Added Spark and Python servers for mobile benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2115
Protobuf benchmarks for protonano
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2116
build fails with exception v0.15.x :grpc-protobuf-lite:compileJava cannot find symbol
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, All;
I am forced to work on a Mac OS system and I am simply trying to build the grpc-java examples.
I keep getting a build failure with exception.
Here is the relevant output:
:grpc-protobuf-lite:compileJava
/Users/jmc3000/gocode/src/github.com/grpc-java/protobuf-lite/src/main/java/io/grpc/protobuf/lite/ProtoLiteUtils.java:80: error: cannot find symbol
    final Parser<T> parser = (Parser<T>) defaultInstance.getParserForType();
                                                        ^
  symbol:   method getParserForType()
  location: variable defaultInstance of type T
  where T is a type-variable:
    T extends MessageLite declared in method <T>marshaller(T)
/Users/jmc3000/gocode/src/github.com/grpc-java/protobuf-lite/src/main/java/io/grpc/protobuf/lite/ProtoLiteUtils.java:129: error: cannot find symbol
          e.setUnfinishedMessage(message);
           ^
  symbol:   method setUnfinishedMessage(T)
  location: variable e of type InvalidProtocolBufferException
  where T is a type-variable:
    T extends MessageLite declared in method <T>marshaller(T)
/Users/jmc3000/gocode/src/github.com/grpc-java/protobuf-lite/src/main/java/io/grpc/protobuf/lite/ProtoLiteUtils.java:151: error: cannot find symbol
          return (T) instance.getParserForType().parseFrom(serialized, globalRegistry);
                             ^
  symbol:   method getParserForType()
  location: variable instance of type T
  where T is a type-variable:
    T extends MessageLite declared in method <T>metadataMarshaller(T)
3 errors
:grpc-protobuf-lite:compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-protobuf-lite:compileJava'.
> Compilation failed; see the compiler error output for details.

Any advice would be welcome.
Thanks,
Jo3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2117
Cherry-picks for v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2118
Excess contention in ExecutorService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When profiling a client with 200K active RPCs, there is a point of contention on the Executor.  Each RPC gets its own SerializingExecutor, which executes work on an underlying executor.  Currently, that executor is ThreadPoolExecutor in almost all cases, which itself has a BlockingQueue.  That queue is heavily contended  showing up at minutes of wasted time:
141.17mins 79.41% 79.41% 141.22mins 79.44%  java.util.concurrent.LinkedBlockingQueue.offer LinkedBlockingQueue.java
 36.51mins 20.54% 99.95%  36.52mins 20.54%  java.util.concurrent.LinkedBlockingQueue.take LinkedBlockingQueue.java

An idea to fix this is to have some sort of striping executor in order to prevent this contention from happening.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2119
Excess contention in ManagedChannelImpl.exitIdleMode
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Each RPC needs a transport, and thus calls ManagedChannelImpl's transport provider.  This tries to make the transport wake up, but does so under a lock.  Profiling reveals a high amount of contention on this lock.  If possible we should look at eliding the lock and using a volatile read to get the loadbalancer out of it.
cc @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2120
Excess contention in ManagedChannelImpl getTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is major blocker for running at high qps
      flat  flat%   sum%        cum   cum%
   932.07s 24.46% 73.94%    932.07s 24.46%  io.grpc.internal.ManagedChannelImpl$3.getTransport ManagedChannelImpl.java:598
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2121
Excess contention in DummyLoadBalancer.pickTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
flat  flat%   sum%        cum   cum%
    27.54s  0.72% 97.66%    959.60s 25.18%  io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer.pickTransport DummyLoadBalancerFactory.java:90
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2122
Contention in SerializingExecutor$TaskRunner.run
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Not sure why there is much contention here, but there does appear to be some.  This is very tiny compared to the rest of the other contention points.
      flat  flat%   sum%        cum   cum%
     0.21s 0.0054% 97.67%   2853.93s 74.89%  io.grpc.internal.SerializingExecutor$TaskRunner.run SerializingExecutor.java:142
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2123
Reduce Thread count in default Event Loop Group
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
By default, ELGs use 2x the number of threads as the number of processors.  This appears to be for applications that do a lot of work on their net threads, which gRPC does not.  Consider reducing ELG threads down to the number of processors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2124
Release 1.0.0-pre2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Shouldn't there be a another commit going back to snapshot?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2125
Change routeguide example to use proto 3.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zsurocking LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2126
Flow Control integration tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2127
core: Remove usage of LogExceptionRunnable from Deadline
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2128
Update to Gradle 2.14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2129
benchmarks: update to using jmh 1.13
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2130
core: Avoid wrapping Errors in RuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Didn't compile, and now I can't re-open.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2131
core: Avoid wrapping Errors in RuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2132
Filter mechanism for server transport creation and deletion
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To support a per-connection throttling mechanism used inside google, gRPC needs to allow user to add filters to the server that:

Gets called when a server transport is created and handshake-completed, and has access to transport-specific attributes such as client address and identity.
Adds per-transport attributes to ServerCall attributes.
Gets called when a server transport is terminated.

I discussed a few options with @ejona86:
ServerInterceptor
The filter returns a ServerInterceptor when transport is created. The interceptor is transport-scoped, unlike ordinary interceptors that are service-scoped.
interface ServerTransportFilter {
  ServerInterceptor transportCreated(SomePublicServerTransportType transport);
  void transportTerminated(SomePublicServerTransportType transport);
}
Pros:

Doesn't touch transport API (ServerTransport, ServerStream) which are internal.
Re-uses ServerInterceptor for purposes that ServerInterceptor is designed for (modifying ServerCall attributes etc).

Cons:

Changes the scope of ServerInterceptor. @ejona86 thinks bonding ServerInterceptor to a transport is seemingly generic but actually an ad-hoc solution for a particular problem. I don't necessarily agree though.

Decorating transport
The filter returns a decorated ServerListener at registration. Through a few more layers of wrapping, the filter would be able to decorate ServerListener.transportCreated(),ServerTransportListener.transportTerminated() and ServerStream.attributes().
Pros:

Minimal API change

Cons:

Heavily coupled with transport API which is internal.
Duplicates the existing interceptor mechanism, but on ServerStream instead of ServerCall. It would be ideal to just decorate ServerCall, which is what ServerInterceptor does. ServerInterceptor currently is per-service, but our use case need it to be per-connection.
Even more layers of decoration than the interceptors. The filter can be annoying to write.

Ad-hoc
Just for our original requirements, the filter would return per-transport attributes that are to be merged into ServerCall attributes.
interface ServerTransportFilter {
  Attributes transportCreated(SomePublicServerTransportType transport);
  void transportTerminated(SomePublicServerTransportType transport);
}
It probably won't work in this form, because the attributes such as peer security identity may not be available immediately after the transport is created, if the security handshake has not completed yet. On the other hand, the first two options can work around this situation by reading the attributes only when the first stream is created.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2133
docs: Update README.md before tagging release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2134
Small doc improvements based on feedback
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2135
benchmarks: use a fork-join pool to reduce executor contention
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2136
benchmarks: add fork join pool executor to load server too
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2137
DNM: Sketch of removing Idle lock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2138
benchmarks: backport forkjoin pool
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you make those changes to master and then backport both commits?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2139
Zero-copy* write combining
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TL;DR;
I propose to defer the serialization of protobuf, thrift, ... from the MessageFramer to the WriteCombiningHandler.
PR #1996 shows that combining small buffers into one large buffer can substantially improve throughput. However, it's very hard to come up with a one-size-fits all algorithm that decides on when to combine buffers. It's probably safe to assume that all buffers (HTTP/2 frames) except for DATA frames are small enough to be combined (copied) without much overhead. HEADERS could be large, but probably aren't. Say we would expect headers to be in the 100 - 300 byte range.
For example, a RPC response will typically write 3 HTTP/2 frames
HEADERS + DATA + HEADERS (trailers)

In Netty's HTTP/2 codec that would typically translate to the following buffers being written
HEADERS(FrameHeader) + HEADERS(HeaderBlock) + DATA(FrameHeader) + 
DATA(Payload) + HEADERS(FrameHeader) + HEADERS(Payload)

When using write combining as proposed in #1996, then depending on the size of the DATA(Payload) buffer, we would either pass one buffer or 3 buffers to write/writev. As mentioned before, coming up with a "magic" number N bytes that for all machines and workloads tells us when to combine buffers is hard. It would be much easier if we would simply always combine all writes until flush, and I believe we can.
If we change the MessageFramer internals and the WritableBuffer API, so that instead of always copying the InputStream into a buffer, it's up to the WritableBuffer implementation of when that copy happens. We could then create a simple, internal ByteBuf implementation that effectively just wraps an InputStream. The copying into a "real" ByteBuf could then be done in the WriteCombiningHandler. So we would still only do one copy, but instead of copying in the MessageFramer we do it in the WriteCombiningHandler.
The logic of the WriteCombiningHandler would become very streamlined. It simply stores a list of ByteBufs and Promises, and on flush it allocates a large buffer with exactly the number of bytes it needs, copies all buffers from the list into the large buffer, and does a ctx.writeAndFlush(largeBuffer, combinedPromise).
A nice sideeffect of this change would be that buffering / piggy-backing messages would no longer be a concern of the MessageFramer, but be a responsibility of the transport only.
Some questions:

This moves the protobuf serialization from the application thread to the Netty thread, is this a problem?
Right now the InputStream is immediately consumed when passed to the MessageFramer. With this change it would be consumed at some later point in time on the Netty thread. Could that be a problem in terms of leaks or so?

Thoughts @louiscryan @ejona86 @nmittler @carl-mastrangelo ?
* Zero-copy for DATA frames only, but assuming most of the time DATA frames make up the majority of the bytes on the wire. Certainly true for streaming :-).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2140
core,netty: split stream state on client-side; AbstractStream2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2141
jenkins: Fix Windows build to specify Studio version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2142
withWaitForReady is missing from AbstractStub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's added to CallOptions but we don't have a convenience on the AbstractStub. We expect it to be called pretty frequently in normal usage, so the convenience seems very appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2143
Consider adding AbstractStub.withCallOptions()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would fully overwrite the current CallOptions. That could be considered "bad" because you don't know what you are overwriting, but it seems there are fine times to do so. Maybe it would be better to have a new generated method newStub(channel, callOptions) instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2144
core: propagate name resolution errors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2145
How to implement  logging in ClientInterceptorï¼Ÿ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to logging the content of request and response each call. As documentation saying :

Interface for intercepting outgoing calls before they are dispatched by aÂ Channel.Implementers use this mechanism to add cross-cutting behavior toÂ ChannelÂ and stub implementations.Â 

This is my code to add metadata and logging each all :
 public static ManagedChannel getChannel() {

        ClientInterceptor attachHeadersInterceptor = MetadataUtils.newAttachHeadersInterceptor(getMetadata());

        ClientInterceptor attachLogInterceptor = new ClientInterceptor() {
            @Override
            public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
                    MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {

                Log.i(TAG, "request Method: " + method.getFullMethodName() + "\n");
                Log.i(TAG, "request Content: ");
                return next.newCall(method, callOptions.withDeadlineAfter(10, TimeUnit.SECONDS));
            }
        };

        return ManagedChannelBuilder.forAddress(Config.HOST, Config.PORT)
                .intercept(attachHeadersInterceptor, attachLogInterceptor)
                .usePlaintext(true)
                .build();
    }

But I don`t know how to get the request and response content  from method  or some other object .
Does anyone know the answer ,thanks !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2146
netty: add handler to combine small writes into larger buffer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2147
Update README.md for both examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2148
Update README.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2149
No NameResolverProviders found via ServiceLoader, including for DNS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to execute a grpc client from Mathworks Matlab. Matlab should be able to execute Java code mostly unmodified. The client works well from plain Java, but fails from Matlab with error:
java.lang.IllegalStateException: No NameResolverProviders found via ServiceLoader, including for DNS. This is probably due to a broken build. If using
ProGuard, check your configuration
    at com.google.common.base.Preconditions.checkState(Preconditions.java:173)
    at io.grpc.NameResolverProvider$NameResolverFactory.checkForProviders(NameResolverProvider.java:200)
    at io.grpc.NameResolverProvider$NameResolverFactory.getDefaultScheme(NameResolverProvider.java:195)
    at io.grpc.internal.ManagedChannelImpl.getNameResolver(ManagedChannelImpl.java:384)
    at io.grpc.internal.ManagedChannelImpl.<init>(ManagedChannelImpl.java:316)
    at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:251)

I'm unable to find the error. My code fails here:
  String host = ...;
  int port = ...;
  ManagedChannel mChannel = OkHttpChannelBuilder.forAddress(host, port).usePlaintext(true).build();

I'm not using ProGuard. The same code used to work with grpc-java-0.14.0. This might be related to issue 1982 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2150
Cherry-picks for v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2151
Slowness with large payloads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When reading a proto off the wire, Netty Passes the chunks of data read up to the message deframer, which stores them in a composite byte buffer.  It passes this composite as an InputStream to CodedInputStream for decoding, which itself makes many copies.
It seems like it would be more efficient to pre allocate a buffer of the appropriate size (since we know the message length) and concat to it each chunk that netty passes up.  This would be a copy, but it would make it so that CIS doesn't have to copy in its inefficient manner.
This would also free up the buffers Netty uses to read chunks of data off of the wire more quickly.
Discovered when trying to max out a very high speed network link.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2152
Deadlock found in TransportSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running benchmarks where the client started up faster than the server, The first few calls failed as unavailable.  Our internal deadlock detector seems to think there is a deadlock around here:
Deadlock(s) found:
"grpc-client-net-1-32" daemon prio=5 Id=175 BLOCKED on java.lang.Object@7eeb2e6b owned by "grpc-client-app-5" Id=119
 io.grpc.internal.DelayedClientTransport.startBackoff(DelayedClientTransport.java:323)
 io.grpc.internal.TransportSet.scheduleBackoff(TransportSet.java:235)
 io.grpc.internal.TransportSet.access$1500(TransportSet.java:61)
 io.grpc.internal.TransportSet$TransportListener.transportShutdown(TransportSet.java:440)
 io.grpc.netty.ClientTransportLifecycleManager.notifyShutdown(ClientTransportLifecycleManager.java:68)
 io.grpc.netty.ClientTransportLifecycleManager.notifyTerminated(ClientTransportLifecycleManager.java:84)
 io.grpc.netty.NettyClientTransport$4.operationComplete(NettyClientTransport.java:181)
 io.grpc.netty.NettyClientTransport$4.operationComplete(NettyClientTransport.java:175)
 io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
 io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
 io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
 io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:120)
 io.netty.channel.DefaultChannelPromise.setFailure(DefaultChannelPromise.java:87)
 io.grpc.netty.ProtocolNegotiators$AbstractBufferingHandler.fail(ProtocolNegotiators.java:436)
 io.grpc.netty.ProtocolNegotiators$AbstractBufferingHandler.exceptionCaught(ProtocolNegotiators.java:376)
 io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:295)
 io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:274)
 io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught(AbstractChannelHandlerContext.java:266)
 io.grpc.netty.NettyClientTransport$3.operationComplete(NettyClientTransport.java:165)
 io.grpc.netty.NettyClientTransport$3.operationComplete(NettyClientTransport.java:156)
 io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
 io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:507)
 io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486)
 io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
 io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:129)
 io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
 io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
 io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:588)
 io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
 io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
 io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
 io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
 java.lang.Thread.run(Thread.java:745)


"grpc-client-app-5" daemon prio=5 Id=119 BLOCKED on java.lang.Object@17902cf5 owned by "grpc-client-net-1-32" Id=175
 io.grpc.internal.InUseStateAggregator.updateObjectInUse(InUseStateAggregator.java:51)
 io.grpc.internal.TransportSet$BaseTransportListener.transportInUse(TransportSet.java:345)
 io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:128)
 io.grpc.internal.DelayedClientTransport$PendingStream.createRealStream(DelayedClientTransport.java:382)
 io.grpc.internal.DelayedClientTransport$PendingStream.access$100(DelayedClientTransport.java:369)
 io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:261)
 java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)
 java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
 java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
 java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
 java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2153
Null pointer exception while setting a deadline on a stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I posted this on the grpc mailing list too, reposting here because I'm not sure what the right forum is.
I followed directions in this issue to add deadlines to a RPC. But I get a null pointer error.
java.lang.NullPointerException at io.grpc.stub.AbstractStub.withDeadlineAfter(AbstractStub.java:117)
My code is
blockingStub.withDeadlineAfter(10, TimeUnit.DAYS).doSomething()
Can the callOptions here be null by any chance?
   * Returns a new stub with a deadline that is after the given {@code duration} from now.
   *
   * @see CallOptions#withDeadlineAfter
   */
  public final S withDeadlineAfter(long duration, TimeUnit unit) {
    return build(channel, callOptions.withDeadlineAfter(duration, unit));
  }

I'm using the code generated by the protobuf java plugin and the constructor initializes callOptions to CallOptions.DEFAULT, so I'm not sure what's wrong here. Anyone else faced this issue? I'm using protobuf-gradle-plugin:0.7.6.
   * Constructor for use by subclasses, with the default {@code CallOptions}.
   *
   * @param channel the channel that this stub will use to do communications
   */
  protected AbstractStub(Channel channel) {
    this(channel, CallOptions.DEFAULT);
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2154
core: fix a deadlock in TransportSet.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2155
Support unary Future and Blocking service implementations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since we are now requiring all implementations to extend our base classes we can add streaming options later without breaking anyone (with the interfaces it would have). Even though we have server-streaming for blocking we may want to not support it yet on server-side.
This has a benefit for testing since blocking/future is much easier to mock with mocking frameworks than the async interface.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2156
all: add parameter name to checkNotNull
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
:-/ Non-static usage is much higher than the static usage.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2157
Flaky CompressionTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Found in https://travis-ci.org/grpc/grpc-java/jobs/151357545
io.grpc.testing.integration.CompressionTest > compression[23] FAILED
    io.grpc.StatusRuntimeException: INTERNAL: Exception deframing message
        at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:230)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:211)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:144)
        at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.unaryCall(TestServiceGrpc.java:369)
        at io.grpc.testing.integration.CompressionTest.compression(CompressionTest.java:217)
        Caused by:
        io.grpc.StatusRuntimeException: INTERNAL: Can't decode compressed frame as compression not configured.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2158
auth: Tests should end in Test, not Tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2159
protobuf: copy input data before decoding
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unexpectedly, there is a latency improvement on non-throughput bounded RPCs:
After:
Benchmark                         (direct)  (transport)    Mode     Cnt       Score     Error  Units
TransportBenchmark.unaryCall1024      true    INPROCESS  sample  843738    1636.493 Â±  25.616  ns/op
TransportBenchmark.unaryCall1024      true        NETTY  sample  261953  152453.549 Â± 410.259  ns/op
TransportBenchmark.unaryCall1024      true  NETTY_LOCAL  sample  358631  111337.198 Â± 383.789  ns/op
TransportBenchmark.unaryCall1024      true       OKHTTP  sample  275771  144798.488 Â± 444.639  ns/op
TransportBenchmark.unaryCall1024     false    INPROCESS  sample  997583   18374.480 Â±  67.945  ns/op
TransportBenchmark.unaryCall1024     false        NETTY  sample  196664  203092.272 Â± 599.238  ns/op
TransportBenchmark.unaryCall1024     false  NETTY_LOCAL  sample  243526  164007.563 Â± 524.886  ns/op
TransportBenchmark.unaryCall1024     false       OKHTTP  sample  207957  192037.259 Â± 666.798  ns/op

Before:
Benchmark                         (direct)  (transport)    Mode     Cnt       Score     Error  Units
TransportBenchmark.unaryCall1024      true    INPROCESS  sample  845992    1657.045 Â±  35.495  ns/op
TransportBenchmark.unaryCall1024      true        NETTY  sample  248463  160749.033 Â± 527.269  ns/op
TransportBenchmark.unaryCall1024      true  NETTY_LOCAL  sample  339227  117719.943 Â± 428.632  ns/op
TransportBenchmark.unaryCall1024      true       OKHTTP  sample  260116  153515.303 Â± 580.275  ns/op
TransportBenchmark.unaryCall1024     false    INPROCESS  sample  984239   18638.299 Â±  78.800  ns/op
TransportBenchmark.unaryCall1024     false        NETTY  sample  180027  221856.332 Â± 671.632  ns/op
TransportBenchmark.unaryCall1024     false  NETTY_LOCAL  sample  237268  168316.719 Â± 679.528  ns/op
TransportBenchmark.unaryCall1024     false       OKHTTP  sample  195578  204207.931 Â± 764.328  ns/op

More benchmarks to come.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2160
Stub classes shouldn't be final to allow mocking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#2077 Seems to have made stub classes final. As stubs do remote calls, it's usually important for them to be mockable to write unit tests, but mockito can't mock final classes. Previously users could use the interface I guess. While I understand the reasoning of dropping the interface for service classes in #1469, to allow stub upgrades without breaking service implementation code compile, does this apply to client stubs too?  It'd be nice for the stub classes to either be non-final or have interfaces to allow mocking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2161
Could not initialize class io.grpc.netty.Utils
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, All;
I have made it through the grpc-java build process (thanks for all the help!).
Now, when I run my application from a "fat jar" or uberjar, it succeeds.  However, when I incorporate that jar in another application, it get this error: Could not initialize class io.grpc.netty.Utils
I do not seem to be able to get any further details on the error because it does not occur when I run the code directly from the uberjar.
Where should I look to see why Netty Utils is failing?
Thanks,
Jo3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2162
Servers should send RST_STREAM(NO_ERROR) after trailers if client is not half-closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HTTP/2 spec calls out this case specifically saying that servers MAY send the RST_STREAM. For gRPC, we are going to consider it more of a SHOULD, although clients still have to assume it is a MAY because intermediaries may in be play.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2163
Clients should RST_STREAM(NO_ERROR) if not half-closed when receiving trailers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the client-side version of #2162, to handle the case when intermediaries are in play. Note that the RST_STREAM can be elided if the server sent a RST_STREAM after the EOS=true. But the client can't assume the server will send such a RST_STREAM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2164
point to correct 1.0 proto reference in readme
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our current maven and gradle techniques point to beta3. Change to 1.0?
artifact = "com.google.protobuf:protoc:3.0.0-beta-3"
com.google.protobuf:protoc:3.0.0-beta-3:exe:${os.detected.classifier}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2165
Add equals/hashCode to Attributes and ResolvedServerInfo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While Attributes is immutable, it's contents may not be. That could cause problems.
For naming/LB, it probably isn't a problem, but for the attributes returned from ServerCall.attributes() it may be. In either case it seems semi-easy to accidentally add an attribute that mutates over time. Although such a attribute would probably need to be thread-safe (although the threading guarantees there isn't 100% clear), so maybe we will notice them.
Thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2166
Excess garbage in Metadata 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Metadata today is a Hashmap of ArrayLists, and each arraylist has an object array.  This creates a lot of garbage since Metadata objects are short lived.
Some ideas on how to improve the situation:

Recycle the objects
Store headers as a flat array of an initial size, and swap to using a full map if slow.  (and avoid Strings when possible)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2167
Extra array copy in Metadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Metadata.storeAdd(), the code optimistically tries to allocate a single element array under the premise that most headers will only have a single value.
In DecompressorRegistry, it tries too to cache the "grpc-accept-encoding" header and builds it ahead of time.  In theory, there should only be one such header.
Sadly, ClientCallImpl.prepareHeaders() always adds the "identity" codec before adding the raw, cached  encodings, which makes the Arraylist in Meta data be too small, and have to reallocate larger, which copies the tiny array.  This happens on every single RPC and was noticed during profiling.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2168
cycle dependencies between grpc-core and other projects.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when use eclipse to import this project but get many warning:
"A cycle was detected in the build path of project 'grpc-core'. The cycle consists of projects {grpc-core, grpc-testing, grpc-stub} grpc-core       Build path  Build Path Problem" .
why and how to resove? thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2169
Provide hook for network availability notification on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I new a stub with a multiplexed channel like this:
ServiceGrpc.ServiceBlockingStub stub = ServiceGrpc.newBlockingStub(getChannel());
 public static ManagedChannel getChannel() {
        if (mChannel == null) {
            mChannel = ManagedChannelBuilder.forAddress(Config.HOST, Config.PORT)
                    .usePlaintext(true)
                    .build();
        }
        return mChannel;
    }
Launch the application when the network is close , then open the network . Invoking method of stub that is built with a multiplex  don`t work immediately. While invoking method of stub that built with new channel  can get response from server immediately . It will happen also when the network was unavailable long time .and then network turn available .
How does channel judge network state ï¼ŸHow to reconnect immediately with multiplexed channel ?
Build and platform infomation:
            compileSdkVersion: 23,
            buildToolsVersion: "23.0.2",
            minSdkVersion    : 14,
            targetSdkVersion : 19,

application is running in Android 5.1.1 and 6.0.1
Thanks !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2170
grift is experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tracking issue for tasks necessary before considering grift (thrift marshalling over grpc) API stable.

 hear about some usage, to make sure it is satisfactory to users familiar with thrift marshalling
 codegen'd method signatures should have multiple arguments instead of the single wrapping message (this is probably cross-language)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2171
Mark Thrift experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2172
Simplify commands in Android README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2173
Update android example.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zsurocking LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2174
CodedInputStream should have aliasing enabled.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Premise: Most Protobuf messages are either big (space) or complex (lots of different fields set), but not  usually both.  The expected use case for the first is sending raw data through, with large ByteStrings  dominating the majority of the encoded payload.  The expected use case for the second is a complicated message with lots of fields, some of which may be used and retained by the program after the request is complete.
In the wake of c47d948, it became clear that Proto is copying way more than it should, and meekly provides some methods to avoid copying too much.  In the specific case of byte strings (and no other type), it is possible to avoid copying from the input buffer when extracting a byte string field.  Instead, if the buffer is immutable, and "aliasing" is enabled, Proto will return a ByteString field which points into the interior of the buffer and avoids the copy.
The downside of this approach is that it keeps a reference to the entire outer buffer, even if the remaining data inside is not needed.  This means that if a large message was received, and a single ByteString is referenced but the outer proto not, the encoded data will remain in memory.  This is a garbage collection risk, since the buffer cannot be GC'd.
I feel that this is not a significant risk due to the premise of this issue.  Either the message is dominated by a single byte string, in which case retaining the whole buffer is not an issue.  On the other hand, the message could be large, but it is unlikely that the program would have a ByteString that would be retained for a long time after the rest of the message could be reclaimed.
The upside is removing yet another copy in the first use case.  A quick benchmark of enabling immutability and aliasing adds around 10-20 MB/s round trip throughput.  (so maybe a could hundred megabits)
Strings, repeated fields, and byte arrays are not affected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2175
core: Add equals/hashCode to ResolvedServerInfo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2176
io.grpc.testing.integration.ProxyTest.smallLatency is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://grpc-testing.appspot.com/job/gRPC-Java-master-windows/359/console
io.grpc.testing.integration.ProxyTest > smallLatency FAILED
    java.lang.AssertionError: expected:<1.0E7> but was:<2.65721E7>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:743)
        at org.junit.Assert.assertEquals(Assert.java:519)
        at org.junit.Assert.assertEquals(Assert.java:609)
        at io.grpc.testing.integration.ProxyTest.smallLatency(ProxyTest.java:94)

CC @mfcripps
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2177
build: upgrade to protobuf-gradle-plugin 0.8.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2178
Cherry-picks from master to v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2179
Flaky proxy test short term fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pretty sure this is fixed now - all threads are now managed using an executor, all threads are now daemon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2180
Release v1.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2181
core: add DoNotMock annotations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo That means if I use custom ClientInterceptor in my test, I can not mock a ClientInterceptor that returns a mock ClientCall?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2182
Remove Dummy LB, use RoundRobin by default
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Dummy is still useful for cases where NameResolver returns more than one address group, but you don't want load-balancing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2183
Update README to reference 1.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2184
Change NameResolver#onUpdate API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2185
docs: Android examples moved for sed in RELEASING.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2186
interop-testing: Remove hard-coded ports in ProxyTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2187
Sync load_balancer.proto to latest version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2188
Occasional IllegalStateException during shutdown after upgrading to 1.0.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, after upgrading from 0.15.0 to 1.0.0, I'm seeing occasional IllegalStateException during shutdown (makes my tests fail which is why I notice).  I had not seen this previously with 0.15.0.
java.lang.IllegalStateException: null
    at com.google.common.base.Preconditions.checkState(Preconditions.java:159)
    at io.grpc.internal.DelayedClientTransport.startBackoff(DelayedClientTransport.java:323)
    at io.grpc.internal.TransportSet$2.run(TransportSet.java:281)
    at io.grpc.internal.TransportSet$TransportListener.transportShutdown(TransportSet.java:461)
    at io.grpc.netty.ClientTransportLifecycleManager.notifyShutdown(ClientTransportLifecycleManager.java:68)
    at io.grpc.netty.ClientTransportLifecycleManager.notifyTerminated(ClientTransportLifecycleManager.java:84)
    at io.grpc.netty.NettyClientTransport$4.operationComplete(NettyClientTransport.java:181)
    at io.grpc.netty.NettyClientTransport$4.operationComplete(NettyClientTransport.java:175)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
    at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
    at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:120)
    at io.netty.channel.DefaultChannelPromise.setFailure(DefaultChannelPromise.java:87)
    at io.grpc.netty.ProtocolNegotiators$AbstractBufferingHandler.fail(ProtocolNegotiators.java:436)
    at io.grpc.netty.ProtocolNegotiators$AbstractBufferingHandler.exceptionCaught(ProtocolNegotiators.java:376)
    at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:295)
    at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:274)
    at io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught(AbstractChannelHandlerContext.java:266)
    at io.grpc.netty.NettyClientTransport$3.operationComplete(NettyClientTransport.java:165)
    at io.grpc.netty.NettyClientTransport$3.operationComplete(NettyClientTransport.java:156)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:507)
    at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
    at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:129)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:588)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)

I was able to capture under a debugger and the existing backoffStatus was
Status{code=UNAVAILABLE, description=Channel in TRANSIENT_FAILURE state, cause=io.grpc.StatusRuntimeException: UNAVAILABLE}

Let me know if there's additional info I can provide to help diagnose.
Thanks,
Trask
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2189
metadata is lost when server sends StatusRuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I would like to send a StatusRuntimeException to the client with some information saved in metadata. like this:
Metadata trailers = new Metadata();
 trailers.put(EXTENDED_STATUS_KEY, "10001");
StatusRuntimeException e = new StatusRuntimeException(Status.ABORTED, trailers);
 throw e;
But when I caught the exception in the client, I found that the metadata in the exception didn't contain this information. I checked the code and found that in class Server.JumpToApplicationThreadServerStreamListener:
    public void halfClosed() {
      callExecutor.execute(new ContextRunnable(context) {
        @Override
        public void runInContext() {
          try {
            getListener().halfClosed();
          } catch (RuntimeException e) {
            internalClose(Status.fromThrowable(e), new Metadata());
            throw e;
          } catch (Throwable t) {
            internalClose(Status.fromThrowable(t), new Metadata());
            throw new RuntimeException(t);
          }
        }
      });
    }
In this method, Status.fromThrowable(e) will convert this exception into Status instance, but it won't reuse the metadata saved in the exception. Instead, it create a new empty Metadata.
So in this way, all the data saved in the metadata of StatusRuntimeException is lost.
Yet in class Status I found there is a new method Metadata trailersFromThrowable(Throwable t) and it is used in class ServerCalls:
public void onError(Throwable t) {
      Metadata metadata = Status.trailersFromThrowable(t);
      if (metadata == null) {
        metadata = new Metadata();
      }
      call.close(Status.fromThrowable(t), metadata);
    }
I think this is the correct way to handle and pass metadata.
Please help to confirm it. If so, I would like to pull a request to fix it.
Thank you !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2190
fix bug that metadata is lost when throwing StatusException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2191
Rename Dummy to PickFirst load balancer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@lukaszx0 LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2192
core: Add lockless SingleProducerSerializingExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2193
Support forward proxies with CONNECT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to specify a proxy connection when specifying the host and port with the NettyChannelBuilder?
originChannel = NettyChannelBuilder.forAddress(host, port)
                          .sslContext(GrpcSslContexts.forClient().build())
                          .build();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2194
DeadlineTest.defaultTickerIsSystemTicker is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
trying to build grpc-java
following these instructions ...
https://github.com/grpc/grpc-java/blob/master/COMPILING.md
using the version recommended on the java quick start page:
http://www.grpc.io/docs/quickstart/java.html
$ git clone -b v1.0.0-pre2 https://github.com/grpc/grpc-java
building on the nvidia jetson tx1 platform.
64 bit arm chip
ubuntu 14
Here is the error that I get ...
ubuntu@tegra-ubuntu:~/grpc-java2/grpc-java$ ./gradlew build
*** Skipping the build of codegen and compilation of proto files because skipCodegen=true
:grpc-core:compileJava UP-TO-DATE
:grpc-core:animalSniffer
:grpc-core:processResources UP-TO-DATE
:grpc-core:classes
:grpc-core:jar UP-TO-DATE
:grpc-auth:compileJava UP-TO-DATE
:grpc-auth:animalSniffer
:grpc-auth:processResources UP-TO-DATE
:grpc-auth:classes
:grpc-auth:jar UP-TO-DATE
:grpc-netty:compileJava UP-TO-DATE
:grpc-netty:processResources UP-TO-DATE
:grpc-netty:classes UP-TO-DATE
:grpc-netty:jar UP-TO-DATE
:grpc-okhttp:compileJava UP-TO-DATE
:grpc-okhttp:animalSniffer
:grpc-okhttp:processResources UP-TO-DATE
:grpc-okhttp:classes
:grpc-okhttp:jar UP-TO-DATE
:grpc-protobuf-lite:extractIncludeProto UP-TO-DATE
:grpc-protobuf-lite:extractProto UP-TO-DATE
:grpc-protobuf-lite:generateProto UP-TO-DATE
:grpc-protobuf-lite:compileJava UP-TO-DATE
:grpc-protobuf-lite:animalSniffer
:grpc-protobuf-lite:processResources UP-TO-DATE
:grpc-protobuf-lite:classes
:grpc-protobuf-lite:jar UP-TO-DATE
:grpc-protobuf:compileJava UP-TO-DATE
:grpc-protobuf:animalSniffer
:grpc-protobuf:processResources UP-TO-DATE
:grpc-protobuf:classes
:grpc-protobuf:jar UP-TO-DATE
:grpc-protobuf-nano:compileJava UP-TO-DATE
:grpc-protobuf-nano:animalSniffer
:grpc-protobuf-nano:processResources UP-TO-DATE
:grpc-protobuf-nano:classes
:grpc-protobuf-nano:jar UP-TO-DATE
:grpc-stub:compileJava UP-TO-DATE
:grpc-stub:animalSniffer
:grpc-stub:processResources UP-TO-DATE
:grpc-stub:classes
:grpc-stub:jar UP-TO-DATE
:grpc-all:compileJava UP-TO-DATE
:grpc-all:processResources UP-TO-DATE
:grpc-all:classes UP-TO-DATE
:grpc-all:jar UP-TO-DATE
:grpc-core:javadoc UP-TO-DATE
:grpc-auth:javadoc UP-TO-DATE
:grpc-netty:javadoc UP-TO-DATE
:grpc-okhttp:javadoc UP-TO-DATE
:grpc-protobuf-lite:javadoc UP-TO-DATE
:grpc-protobuf:javadoc UP-TO-DATE
:grpc-protobuf-nano:javadoc UP-TO-DATE
:grpc-stub:javadoc UP-TO-DATE
:grpc-all:javadoc UP-TO-DATE
:grpc-all:javadocJar UP-TO-DATE
:grpc-all:sourcesJar UP-TO-DATE
:grpc-all:signArchives SKIPPED
:grpc-all:assemble UP-TO-DATE
:grpc-all:checkstyleMain UP-TO-DATE
:grpc-all:compileTestJava UP-TO-DATE
:grpc-all:processTestResources UP-TO-DATE
:grpc-all:testClasses UP-TO-DATE
:grpc-all:checkstyleTest UP-TO-DATE
:grpc-all:test UP-TO-DATE
:grpc-all:check UP-TO-DATE
:grpc-all:build UP-TO-DATE
:grpc-auth:javadocJar UP-TO-DATE
:grpc-auth:sourcesJar UP-TO-DATE
:grpc-auth:signArchives SKIPPED
:grpc-auth:assemble UP-TO-DATE
:grpc-auth:checkstyleMain UP-TO-DATE
:grpc-auth:compileTestJava UP-TO-DATE
:grpc-auth:processTestResources UP-TO-DATE
:grpc-auth:testClasses UP-TO-DATE
:grpc-auth:checkstyleTest UP-TO-DATE
:grpc-auth:test UP-TO-DATE
:grpc-auth:check UP-TO-DATE
:grpc-auth:build UP-TO-DATE
:grpc-testing:compileJava UP-TO-DATE
:grpc-testing:processResources UP-TO-DATE
:grpc-testing:classes UP-TO-DATE
:grpc-testing:jar UP-TO-DATE
:grpc-benchmarks:compileJava UP-TO-DATE
:grpc-benchmarks:processResources UP-TO-DATE
:grpc-benchmarks:classes UP-TO-DATE
:grpc-benchmarks:jar UP-TO-DATE
:grpc-benchmarks:benchmark_worker UP-TO-DATE
:grpc-benchmarks:openloop_client UP-TO-DATE
:grpc-benchmarks:qps_client UP-TO-DATE
:grpc-benchmarks:qps_server UP-TO-DATE
:grpc-benchmarks:startScripts SKIPPED
:grpc-benchmarks:distTar
:grpc-benchmarks:distZip
:grpc-testing:javadoc UP-TO-DATE
:grpc-benchmarks:javadoc UP-TO-DATE
:grpc-benchmarks:javadocJar UP-TO-DATE
:grpc-benchmarks:sourcesJar UP-TO-DATE
:grpc-benchmarks:signArchives SKIPPED
:grpc-benchmarks:assemble
:grpc-benchmarks:compileTestJava UP-TO-DATE
:grpc-benchmarks:processTestResources UP-TO-DATE
:grpc-benchmarks:testClasses UP-TO-DATE
:grpc-benchmarks:compileJmhJava UP-TO-DATE
:grpc-benchmarks:processJmhResources UP-TO-DATE
:grpc-benchmarks:jmhClasses UP-TO-DATE
:grpc-benchmarks:checkstyleJmh UP-TO-DATE
:grpc-benchmarks:checkstyleMain UP-TO-DATE
:grpc-benchmarks:checkstyleTest UP-TO-DATE
:grpc-benchmarks:test UP-TO-DATE
:grpc-benchmarks:check UP-TO-DATE
:grpc-benchmarks:build
:grpc-core:javadocJar UP-TO-DATE
:grpc-core:sourcesJar UP-TO-DATE
:grpc-core:signArchives SKIPPED
:grpc-core:assemble UP-TO-DATE
:grpc-core:checkstyleMain UP-TO-DATE
:grpc-core:compileTestJava UP-TO-DATE
:grpc-core:processTestResources UP-TO-DATE
:grpc-core:testClasses UP-TO-DATE
:grpc-core:checkstyleTest UP-TO-DATE
:grpc-core:test

io.grpc.DeadlineTest > defaultTickerIsSystemTicker[0] FAILED
    java.lang.AssertionError: <-22817159 ns from now> and <0 ns from now> should have been within <20000000ns> of each other
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
        at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
        at com.google.common.truth.Subject.failWithRawMessage(Subject.java:381)
        at io.grpc.testing.DeadlineSubject.access$400(DeadlineSubject.java:52)
        at io.grpc.testing.DeadlineSubject$1.of(DeadlineSubject.java:81)
        at io.grpc.DeadlineTest.defaultTickerIsSystemTicker(DeadlineTest.java:84)

621 tests completed, 1 failed
:grpc-core:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-core:test'.
> There were failing tests. See the report at: file:///home/ubuntu/grpc-java2/grpc-java/core/build/reports/tests/index.html

Here is the html ...
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=edge"/>
<title>Test results - Test Summary</title>
<link href="css/base-style.css" rel="stylesheet" type="text/css"/>
<link href="css/style.css" rel="stylesheet" type="text/css"/>
<script src="js/report.js" type="text/javascript"></script>
</head>
<body>
<div id="content">
<h1>Test Summary</h1>
<div id="summary">
<table>
<tr>
<td>
<div class="summaryGroup">
<table>
<tr>
<td>
<div class="infoBox" id="tests">
<div class="counter">621</div>
<p>tests</p>
</div>
</td>
<td>
<div class="infoBox" id="failures">
<div class="counter">1</div>
<p>failures</p>
</div>
</td>
<td>
<div class="infoBox" id="ignored">
<div class="counter">0</div>
<p>ignored</p>
</div>
</td>
<td>
<div class="infoBox" id="duration">
<div class="counter">10.431s</div>
<p>duration</p>
</div>
</td>
</tr>
</table>
</div>
</td>
<td>
<div class="infoBox failures" id="successRate">
<div class="percent">99%</div>
<p>successful</p>
</div>
</td>
</tr>
</table>
</div>
<div id="tabs">
<ul class="tabLinks">
<li>
<a href="#tab0">Failed tests</a>
</li>
<li>
<a href="#tab1">Packages</a>
</li>
<li>
<a href="#tab2">Classes</a>
</li>
</ul>
<div id="tab0" class="tab">
<h2>Failed tests</h2>
<ul class="linkList">
<li>
<a href="classes/io.grpc.DeadlineTest.html">DeadlineTest</a>.
<a href="classes/io.grpc.DeadlineTest.html#defaultTickerIsSystemTicker[0]">defaultTickerIsSystemTicker[0]</a>
</li>
</ul>
</div>
<div id="tab1" class="tab">
<h2>Packages</h2>
<table>
<thead>
<tr>
<th>Package</th>
<th>Tests</th>
<th>Failures</th>
<th>Ignored</th>
<th>Duration</th>
<th>Success rate</th>
</tr>
</thead>
<tbody>
<tr>
<td class="failures">
<a href="packages/io.grpc.html">io.grpc</a>
</td>
<td>249</td>
<td>1</td>
<td>0</td>
<td>6.749s</td>
<td class="failures">99%</td>
</tr>
<tr>
<td class="success">
<a href="packages/io.grpc.inprocess.html">io.grpc.inprocess</a>
</td>
<td>27</td>
<td>0</td>
<td>0</td>
<td>0.327s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success">
<a href="packages/io.grpc.internal.html">io.grpc.internal</a>
</td>
<td>329</td>
<td>0</td>
<td>0</td>
<td>2.627s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success">
<a href="packages/io.grpc.util.html">io.grpc.util</a>
</td>
<td>16</td>
<td>0</td>
<td>0</td>
<td>0.728s</td>
<td class="success">100%</td>
</tr>
</tbody>
</table>
</div>
<div id="tab2" class="tab">
<h2>Classes</h2>
<table>
<thead>
<tr>
<th>Class</th>
<th>Tests</th>
<th>Failures</th>
<th>Ignored</th>
<th>Duration</th>
<th>Success rate</th>
</tr>
</thead>
<tbody>
<tr>
<td class="success"/>
<a href="classes/io.grpc.AttributesTest.html">io.grpc.AttributesTest</a>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.CallOptionsTest.html">io.grpc.CallOptionsTest</a>
<td>15</td>
<td>0</td>
<td>0</td>
<td>0.011s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ClientInterceptorsTest.html">io.grpc.ClientInterceptorsTest</a>
<td>15</td>
<td>0</td>
<td>0</td>
<td>0.620s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ContextTest.html">io.grpc.ContextTest</a>
<td>36</td>
<td>0</td>
<td>0</td>
<td>4.375s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ContextsTest.html">io.grpc.ContextsTest</a>
<td>10</td>
<td>0</td>
<td>0</td>
<td>0.189s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="failures"/>
<a href="classes/io.grpc.DeadlineTest.html">io.grpc.DeadlineTest</a>
<td>84</td>
<td>1</td>
<td>0</td>
<td>1.284s</td>
<td class="failures">98%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.DecompressorRegistryTest.html">io.grpc.DecompressorRegistryTest</a>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0.005s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.DummyLoadBalancerTest.html">io.grpc.DummyLoadBalancerTest</a>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0.024s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ForwardingServerCallListenerTest.html">io.grpc.ForwardingServerCallListenerTest</a>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0.007s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ManagedChannelProviderTest.html">io.grpc.ManagedChannelProviderTest</a>
<td>6</td>
<td>0</td>
<td>0</td>
<td>0.019s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.MetadataTest.html">io.grpc.MetadataTest</a>
<td>16</td>
<td>0</td>
<td>0</td>
<td>0.012s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.MethodDescriptorTest.html">io.grpc.MethodDescriptorTest</a>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0.001s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.NameResolverProviderTest.html">io.grpc.NameResolverProviderTest</a>
<td>10</td>
<td>0</td>
<td>0</td>
<td>0.084s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ServerInterceptorsTest.html">io.grpc.ServerInterceptorsTest</a>
<td>11</td>
<td>0</td>
<td>0</td>
<td>0.096s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ServerProviderTest.html">io.grpc.ServerProviderTest</a>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0.012s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.ServerServiceDefinitionTest.html">io.grpc.ServerServiceDefinitionTest</a>
<td>8</td>
<td>0</td>
<td>0</td>
<td>0.007s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.StatusTest.html">io.grpc.StatusTest</a>
<td>16</td>
<td>0</td>
<td>0</td>
<td>0.003s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.inprocess.InProcessClientTransportFactoryTest.html">io.grpc.inprocess.InProcessClientTransportFactoryTest</a>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0.006s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.inprocess.InProcessServerTest.html">io.grpc.inprocess.InProcessServerTest</a>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0.002s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.inprocess.InProcessTransportTest.html">io.grpc.inprocess.InProcessTransportTest</a>
<td>24</td>
<td>0</td>
<td>0</td>
<td>0.319s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.AbstractClientStreamTest.html">io.grpc.internal.AbstractClientStreamTest</a>
<td>14</td>
<td>0</td>
<td>0</td>
<td>0.035s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.AbstractManagedChannelImplBuilderTest.html">io.grpc.internal.AbstractManagedChannelImplBuilderTest</a>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0.009s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.AbstractReadableBufferTest.html">io.grpc.internal.AbstractReadableBufferTest</a>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0.030s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.AbstractServerStreamTest.html">io.grpc.internal.AbstractServerStreamTest</a>
<td>15</td>
<td>0</td>
<td>0</td>
<td>0.024s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.AbstractStreamTest.html">io.grpc.internal.AbstractStreamTest</a>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0.171s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ByteWritableBufferTest.html">io.grpc.internal.ByteWritableBufferTest</a>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0.004s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.CallCredentialsApplyingTest.html">io.grpc.internal.CallCredentialsApplyingTest</a>
<td>8</td>
<td>0</td>
<td>0</td>
<td>0.053s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ClientCallImplTest.html">io.grpc.internal.ClientCallImplTest</a>
<td>23</td>
<td>0</td>
<td>0</td>
<td>0.279s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.CompositeReadableBufferTest.html">io.grpc.internal.CompositeReadableBufferTest</a>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0.040s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.DelayedClientTransportTest.html">io.grpc.internal.DelayedClientTransportTest</a>
<td>17</td>
<td>0</td>
<td>0</td>
<td>0.107s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.DelayedStreamTest.html">io.grpc.internal.DelayedStreamTest</a>
<td>21</td>
<td>0</td>
<td>0</td>
<td>0.089s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.DnsNameResolverProviderTest.html">io.grpc.internal.DnsNameResolverProviderTest</a>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0.001s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.DnsNameResolverTest.html">io.grpc.internal.DnsNameResolverTest</a>
<td>8</td>
<td>0</td>
<td>0</td>
<td>0.035s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ExponentialBackoffPolicyTest.html">io.grpc.internal.ExponentialBackoffPolicyTest</a>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0.003s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ForwardingReadableBufferTest.html">io.grpc.internal.ForwardingReadableBufferTest</a>
<td>14</td>
<td>0</td>
<td>0</td>
<td>0.015s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.GrpcUtilTest.html">io.grpc.internal.GrpcUtilTest</a>
<td>15</td>
<td>0</td>
<td>0</td>
<td>0.010s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.KeepAliveManagerTest.html">io.grpc.internal.KeepAliveManagerTest</a>
<td>10</td>
<td>0</td>
<td>0</td>
<td>0.073s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ManagedChannelImplGetNameResolverTest.html">io.grpc.internal.ManagedChannelImplGetNameResolverTest</a>
<td>11</td>
<td>0</td>
<td>0</td>
<td>0.009s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ManagedChannelImplIdlenessTest.html">io.grpc.internal.ManagedChannelImplIdlenessTest</a>
<td>6</td>
<td>0</td>
<td>0</td>
<td>0.285s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ManagedChannelImplTest.html">io.grpc.internal.ManagedChannelImplTest</a>
<td>17</td>
<td>0</td>
<td>0</td>
<td>0.238s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ManagedChannelImplTransportManagerTest.html">io.grpc.internal.ManagedChannelImplTransportManagerTest</a>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0.152s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.MessageDeframerTest.html">io.grpc.internal.MessageDeframerTest</a>
<td>21</td>
<td>0</td>
<td>0</td>
<td>0.037s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.MessageFramerTest.html">io.grpc.internal.MessageFramerTest</a>
<td>17</td>
<td>0</td>
<td>0</td>
<td>0.067s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ReadableBuffersArrayTest.html">io.grpc.internal.ReadableBuffersArrayTest</a>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0.130s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ReadableBuffersByteBufferTest.html">io.grpc.internal.ReadableBuffersByteBufferTest</a>
<td>8</td>
<td>0</td>
<td>0</td>
<td>0.109s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.SerializeReentrantCallsDirectExecutorTest.html">io.grpc.internal.SerializeReentrantCallsDirectExecutorTest</a>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0.027s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ServerCallImplTest.html">io.grpc.internal.ServerCallImplTest</a>
<td>19</td>
<td>0</td>
<td>0</td>
<td>0.289s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.ServerImplTest.html">io.grpc.internal.ServerImplTest</a>
<td>17</td>
<td>0</td>
<td>0</td>
<td>0.123s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.SharedResourceHolderTest.html">io.grpc.internal.SharedResourceHolderTest</a>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0.013s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.TransportFrameUtilTest.html">io.grpc.internal.TransportFrameUtilTest</a>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0.057s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.internal.TransportSetTest.html">io.grpc.internal.TransportSetTest</a>
<td>11</td>
<td>0</td>
<td>0</td>
<td>0.113s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.util.MutableHandlerRegistryTest.html">io.grpc.util.MutableHandlerRegistryTest</a>
<td>12</td>
<td>0</td>
<td>0</td>
<td>0.147s</td>
<td class="success">100%</td>
</tr>
<tr>
<td class="success"/>
<a href="classes/io.grpc.util.RoundRobinLoadBalancerTest.html">io.grpc.util.RoundRobinLoadBalancerTest</a>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0.581s</td>
<td class="success">100%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="footer">
<p>
<div>
<label class="hidden" id="label-for-line-wrapping-toggle" for="line-wrapping-toggle">Wrap lines
<input id="line-wrapping-toggle" type="checkbox" autocomplete="off"/>
</label>
</div>Generated by 
<a href="http://www.gradle.org">Gradle 2.13</a> at Aug 24, 2016 1:20:47 AM</p>
</div>
</div>
</body>
</html>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2195
gRPC code generator needs to handle reserved words in method names
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When defining an RPC like:
service Foo {
  rpc Import(ImportRequest) returns (ImportResponse) {};
}

The method Import gets translated to a java keyword.    When should adjust it by adding an underscore (prepended?)  to allow it to compile.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2196
Server should compressed responses if the client sent a compressed request
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the ServerCallImpl never implicitly turns on compression, and instead compression has to be enabled via an interceptor, e.g.:
  public static ServerServiceDefinition createWithCompressionEnabled() {
    return ServerInterceptors.intercept(new MyServer(), new ServerInterceptor() {
      @Override
      public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {
        call.setCompression("gzip");
        return next.startCall(call, headers);
      }
    });
  }

In theory, somewhere around here:
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ServerCallImpl.java#L85
If the client sent a compressed request, the server could default it's compressor to the same compression codec, and return a compressed response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2197
Consider replacing java.util.logging with SLF4J. Or a custom logger.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Very few libraries use java.util.logging these days because of all the problems. Netty uses their own logging facade into which you can plug your own implementation. It's not a bad approach, but it's easier to just use slf4j directly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2198
Failed to load any of the given libraries: [netty-tcnative-linux-aarch_64, netty-tcnative-linux-aarch_64-fedora, netty-tcnative]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
trying to build grpc-java on a 64 bit arm architecture.
NVIDIA 4-Plus-1â„¢ Quad-Core  ARMÂ® Cortexâ„¢-A15 CPU
specifically the nvidia jetson tk1 dev kit.
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ java -version
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)

ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ uname -a
Linux tegra-ubuntu 3.10.96-tegra #1 SMP PREEMPT Tue May 17 16:29:05 PDT 2016 aarch64 aarch64 aarch64 GNU/Linux

ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ lsb_release -d
Description:    Ubuntu 14.04.5 LTS
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ 

ultimate goal is to run tensorflow in this nvidia device, but we need to be grpc-java as a part of the tensorflow installation process.
using the latest version of the source code ...
ubuntu@tegra-ubuntu:~/grpc-java3$ git clone https://github.com/grpc/grpc-java.git
building with skipCodegen=true
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ cat gradle.properties 
skipCodegen=true
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ ./gradlew build
*** Skipping the build of codegen and compilation of proto files because skipCodegen=true
...

here is the error that I am getting ...
:grpc-interop-testing:test[jetty-alpn-agent] Using: alpn-boot-8.1.8.v20160420.jar


io.grpc.testing.integration.Http2NettyTest > classMethod FAILED
    java.lang.UnsatisfiedLinkError: failed to load the required native library
        at io.netty.handler.ssl.OpenSsl.ensureAvailability(OpenSsl.java:241)
        at io.netty.handler.ssl.OpenSslContext.<init>(OpenSslContext.java:169)
        at io.netty.handler.ssl.OpenSslServerContext.<init>(OpenSslServerContext.java:347)
        at io.netty.handler.ssl.OpenSslServerContext.<init>(OpenSslServerContext.java:337)
        at io.netty.handler.ssl.SslContext.newServerContextInternal(SslContext.java:413)
        at io.netty.handler.ssl.SslContextBuilder.build(SslContextBuilder.java:391)
        at io.grpc.testing.integration.Http2NettyTest.startServer(Http2NettyTest.java:70)

        Caused by:
        java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty-tcnative-linux-aarch_64, netty-tcnative-linux-aarch_64-fedora, netty-tcnative]
            at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:167)
            at io.netty.handler.ssl.OpenSsl.loadTcNative(OpenSsl.java:325)
            at io.netty.handler.ssl.OpenSsl.<clinit>(OpenSsl.java:90)
            at io.grpc.netty.GrpcSslContexts.defaultSslProvider(GrpcSslContexts.java:137)
            at io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:119)
            at io.grpc.netty.GrpcSslContexts.forServer(GrpcSslContexts.java:100)
            at io.grpc.testing.integration.Http2NettyTest.startServer(Http2NettyTest.java:65)

212 tests completed, 1 failed, 4 skipped
:grpc-interop-testing:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-interop-testing:test'.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2199
Provide base implementation for load balancer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Example:
private static class FoobarBalancer<T> extends AbstractLoadBalancer<T> {
  private FoobarBalancer(TransportManager<T> tm) {
    super(tm);
  }

  @Override
  protected TransportPicker<T> createTransportPicker(List<ResolvedServerInfoGroup> servers) {
    // Do something with `servers` and convert them to `EquivalentAddressGroup`
    final EquivalentAddressGroup equivalentAddressGroup = serversToEquivalentAddressGroup(servers);
    return new TransportPicker<T>() {
      @Override
      public T pickTransport(Attributes affinity) {
        return tm.getTransport(equivalentAddressGroup);
      }
    };
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2200
core: remove unused code path.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2201
Add tests for ResolvedServerInfo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@lukaszx0 LGTM. @zhangkun83, wanna take a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2202
   > Invalid NativePlatform: linux_aarch64
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to build on an arm 64 bit platform.
Following these instructions .
I have successfully built grpc-java
but only by adding skipCodegen=true to gradle.properties.
I have succesfully build protobuf on the platform as well
by following the instructions on the same page.
however, after building protobuf, when I go back I try to build grpc-java without the gradle properties file, I get this error ...
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ ./gradlew build
*** Building codegen requires Protobuf version 3.0.0
*** Please refer to https://github.com/grpc/grpc-java/blob/master/COMPILING.md#how-to-build-code-generation-plugin

FAILURE: Build failed with an exception.

* What went wrong:
A problem occurred configuring project ':grpc-compiler'.
> Exception thrown while executing model rule: NativeComponentModelPlugin.Rules#createBinaries(TargetedNativeComponentInternal, PlatformResolvers, BuildTypeContainer, FlavorContainer, ServiceRegistry)
   > Invalid NativePlatform: linux_aarch64

It appears that this code generation plugin is a necessary component to tensorflow.
I need to get tensorflow installed on this machine [nvidia jetson tk1], so I need to find a way to build this plugin.
Any suggestions?
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ java -version
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)

ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ uname -a
Linux tegra-ubuntu 3.10.96-tegra #1 SMP PREEMPT Tue May 17 16:29:05 PDT 2016 aarch64 aarch64 aarch64 GNU/Linux

ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ lsb_release -d
Description:    Ubuntu 14.04.5 LTS
ubuntu@tegra-ubuntu:~/grpc-java3/grpc-java$ 

the hardware is
nvidia jetson tk1 dev kit.
this has a GPU
but the CPU is one of these  ...
NVIDIA 4-Plus-1â„¢ Quad-Core  ARMÂ® Cortexâ„¢-A15 CPU
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2203
Add RunWith annotation to AutoWindowSizingOnTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2204
Add server-side example for compression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have a client-side example but no server. That's probably the best form of documentation for users to figure out how to use it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2205
core: clarify EOS dataframe error came from server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2206
stub: make more classes final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo  LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2207
Android HelloWorld example release build is broken
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When trying to send the RPC it crashes with:
08-26 12:45:47.761  6837  6837 E AndroidRuntime: java.lang.NullPointerException: Attempt to invoke virtual method 'io.grpc.l io.grpc.l.a()' on a null object reference
08-26 12:45:47.761  6837  6837 E AndroidRuntime:    at io.grpc.helloworldexample.b.a(Unknown Source)
08-26 12:45:47.761  6837  6837 E AndroidRuntime:    at io.grpc.helloworldexample.b.onPostExecute(Unknown Source)
08-26 12:45:47.761  6837  6837 E AndroidRuntime:    at android.os.AsyncTask.finish(AsyncTask.java:651)
...

After fixing the NPE (caused by calling shutdown() on a null ManagedChannel), then it gracefully fails with:
Failed... :
io.grpc.p: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact

okhttp is not included after ProGuard. However, android-interop-testing doesn't suffer from the same issue, and I don't understand how. For android-interop-testing, I do see OkHttpChannelBuilder in mapping.txt, but I don't see OkHttpChannelProvider. Maybe it is being inlined. But I don't know why it would be included for one application but not for the other. I do know that android-interop-testing includes a cast to OkHttpChannelBuilder, but it seems like the provider should still break. The only reference to OkHttpChannelProvider in a Class.forName() in ManagedChannelProvider.
CC @zsurocking
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2208
core: Remove com.google.common.collect usages for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Yay! Thanks for doing this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2209
LoadBalancer should not fail wait-for-ready requests when there is an errror
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently LoadBalancer would just call TransportManager.InterimTransport.closeWithError(), which fails all requests. We should instead add another method like enterTransientFailure(), which is reversible by exitTrasientFailure() and only kills current and further fail-fast requests.
closeWithError() shall be kept for shutdown, or be renamed to closeWithShutdown().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2210
core: simplify timeout header processing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2211
Improve LoadBalancer API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implementing LoadBalancer API at the moment is kinda hard and requires a lot of boiler plate to get you going. I proposed some changes in #2199 to improve this situation and we eventually come to the conclusion that this would you some reworking in core rather than simple wrappers and utility classes.
I'm coping @zhangkun83's and @ejona86 comments from the PR and let's continue design discussion here.
@zhangkun83's comment:
The problems SimpleLoadBalancer is set to solve are:

The handling of interim transports is repeated among all LoadBalancers
The error handling is repeated among most LoadBalancers.

What I would like to see, is a new LoadBalancer interface that solves those problems, instead of fragmenting the API. The idea is to move those common logic into ManagedChannelImpl.
Inspired by your proposal, @ejona86 and I have come up with a strawman design:
abstract class LoadBalancer {
  void shutdown();
  void handleResolvedAddresses();
  void handleNameResolutionError(Status error);
  interface LoadBalancerListener {
    void loadBalancerReady(TransportPicker picker)
    void loadBalancerPending()
    void loadBalancerError(Status error);
  }
  abstract class TransportPicker<T> {
    public T pickTransport(Attributes affinity);
  }
}
The most important part is LoadBalancerListener, which is implemented by ManagedChannelImpl. It technically defines three states in the LoadBalancer:

PENDING: this is the initial state. The channel holds requests in the interim transport.
READY: when entering this state, the channel will close the interim transport with the transport from the picker, and use the picker to serve further requests.
ERROR: the channel holds wait-for-ready requests in the interim transport, and fail fail-fast requests immediately. This is the behavior expected by #2209.
LoadBalancer may enter any state any time with the methods in LoadBalancerListener, and no longer needs to worry about managing interim transports and returning failing transports.

Caveat: in the case of sharded load-balancing, the LoadBalancer may be able to serve some requests, but have to fail or hold other requests, because for example, some shards may be unavailable temporarily, but come back online shortly. We either keep createInterimTransport() on TransportManager to let LoadBalancer handle this manually, or tweak the API somehow to make it as nice as the non-sharded case.
I look forward to landing with a new LoadBalancer API after a few iterations with you, before we do any implementation work. Comments and ideas are welcome :)
@ejona86's comment:
I'd just add that PENDING, READY, and ERROR, are analogous to CONNECTING, READY, and TRANSIENT_FAILURE, respectively, in the Channel connectivity semantics (and I might prefer we use those names, but I don't care much). This new LB API also makes the Channel state API (#28) much easier to design since the LB wouldn't need to directly participate (with caveat for the sharded LB case, but I think we punt on that for now).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2212
Will java grpc server close the idle connection in sometime later?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When client don't send any request over and established connection to server, will server close the connection in sometime later? How to configure java grpc server to enable this behavior? thank you very much!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2213
Will java grpc server close the idle connection in sometime later?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When client don't send any request over and established connection to server, will server close the connection in sometime later? How to configure java grpc server to enable this behavior? thank you very much!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2214
core/tests: add missing RunWith annotation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2215
auth/tests: unmock ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM. The class under test is also on the chopping block, once we are able to migrate enough people away.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2216
Add testing helpers for ClientCall, ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With DoNotMock being a thing, we should add some helper classes to the testing package to make them easier to use.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2217
Use a custom Http2HeadersDecoder to avoid copying
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the meeting today @carl-mastrangelo mentioned that reading headers from the wire and converting between metadata is a major contributor to our allocation profile.
Can't we just use our own Http2HeadersDecoder that instead of DefaultHttp2Headers uses our own Http2Headers implementation, which would just be an adapter for Metadata (wrap around Metadata)? We could thereby avoid copying between Metadata and Http2Headers, but HPACK would directly store to Metadata.
Am I missing something? ðŸ˜…
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2218
core: add ServerTransportFilter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Please review the PR as a whole.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2219
all/tests: add a ClientCall suitable for use in tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2220
Delete deprecated attributes in ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2221
core: fix race condition for TransportSet scheduleBackoff
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OS X failed. I wonder if it just reproduced the race.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2222
Stabilize reflection APIs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is jumping the gun a little bit, because we don't yet have reflection APIs, but such APIs can use this issue as they are introduced.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2223
Add a new option for caching support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
And please suggest better API names and comments
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2224
Update to netty 4.1.5.final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Long story short, there was a bug until 4.1.5.final that would cause issues when running inside Tomcat.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2225
all: update to netty 4.1.5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Netty bug has been fixed, PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2226
core: split Context into a separate grpc-context artifact.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2227
Running grpc server on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there an example or implementation of GRPC server (Java/C++) running on Android?
I am following grpc java server example to implement the server i
private class GrpcServerTask extends AsyncTask<Void, Void, String>{

    @Override
    protected void onPreExecute() {
    }
    @Override
    protected String doInBackground(Void... params) {
        int port = 50051;
        Server server;
        try {
            server = ServerBuilder.forPort(port)
                    .addService(new GreeterImpl())
                    .build()
                    .start();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}

private class GreeterImpl extends GreeterGrpc.GreeterImplBase {

    @Override
    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
        HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();
        responseObserver.onNext(reply);
        responseObserver.onCompleted();
    }
}

I keep getting the error io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact
on executing new GrpcServerTask().execute();
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2228
Support for server plaintext upgrade
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks like this is one of the supported protocol negotiators for clients but not for servers.
I've been trying to set up plaintext GRPC endpoints behind Amazon's new ALB (Application Load Balancer) and it looks like they require an upgradable connection on the backend (sadly, there is no way to configured ALB to assume HTTP/2).
I can try implementing a ProtocolNegotiator myself using Http2ServerUpgradeCodec but wanted to make sure this was feasible first.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2229
https://mvnrepository.com/artifact/io.grpc/grpc-all/1.0.0 dependencies issue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When i'm working with grpc-1.0.0 i get the following error:
The type io.netty.handler.ssl.SslContextBuilder cannot be resolved. It is indirectly referenced from required .class files
This problem did not occure when i used grpc-0.15.0
Any solutions ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2230
Jetty ALPN/NPN has not been properly configured with grpc-1.0.0 on windows only
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've upgraded grpc java from version 0.15.0 to 1.0.0. now my integration tests - connect real client and server - on windows complain with
Jetty ALPN/NPN has not been properly configured 

It works properly on Linux (fedora) but not on Windows.
With version 0.15.0 I was able to run client and server on Windows as well as on Linux and cross connect between Linux and Windows and vice versa.
My Gradle dependencies are:
'io.grpc:grpc-all:1.0.0'
'io.netty:netty-tcnative-boringssl-static:1.1.33.Fork19'
I start the server like so:
val scb = SslContextBuilder.forServer(keyCertChainInputStream, keyInputStream)
GrpcSslContexts.configure(scb)
  .build()

Is there something else I need to consider for this migration?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2231
core: avoid allocating Iterators in EquivalentAddressGroup, which is â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2232
OOM after a bunch of "thread-local buffers freed"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I occasionally observe Java runs out of heap space after a sequence of log lines looks like
...
DEBUG [2016-08-30 20:20:19,188] io.netty.buffer.PoolThreadCache: Freed 1 thread-local buffer(s) from thread: grpc-default-executor-3519 [req=null firm=null cred=null ip=null]
DEBUG [2016-08-30 20:20:19,188] io.netty.buffer.PoolThreadCache: Freed 1 thread-local buffer(s) from thread: grpc-default-executor-3534 [req=null firm=null cred=null ip=null]
DEBUG [2016-08-30 20:20:19,189] io.netty.buffer.PoolThreadCache: Freed 1 thread-local buffer(s) from thread: grpc-default-executor-3518 [req=null firm=null cred=null ip=null]
DEBUG [2016-08-30 20:21:13,472] io.netty.buffer.PoolThreadCache: Freed 1 thread-local buffer(s) from thread: grpc-default-executor-3516 [req=null firm=null cred=null ip=null]
DEBUG [2016-08-30 20:21:13,474] io.netty.buffer.PoolThreadCache: Freed 1 thread-local buffer(s) from thread: grpc-default-executor-3526 [req=null firm=null cred=null ip=null]
WARN  [2016-08-30 22:25:26,932] io.grpc.netty.NettyServerHandler: Exception in onHeadersRead() [req=null firm=null cred=null ip=null]
! java.lang.OutOfMemoryError: Java heap space

I think the server is under heavy load when this happens.
It seems like the grpc-default-executor created thousands of threads. Is it normal?
Does anyone know what is going on?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2233
netty: cache method path conversion
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Alternatives considered:

Cache the transformation inside MethodDescriptor.   This is difficult to expose to the transport layer, since it would be giving access to the mutable byte[].  It would also still cost the allocation of an AsciiString
Use a single static synchronized map in Netty to cache transformation.  This adds synchronization even though it saves memory.
Use a netty fast thread local.  Since Users provide their own thread factory, it doesn't seem possible to assume we are using the necessary thread factory needed.  FastThreadLocal says that it needs this.

Option 1 is the best, but I am wary of putting a public accessor method on the API even if marked as Internal.  We are already finding places where users are abusing our API quirks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2234
Tracking Issue for NoopClientCall and NoopServerCall being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2235
netty: use custom http2 headers for decoding.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2236
core: add Metadata.discardAll()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2237
Possible bug in Status code parser
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public static Status fromCodeValue(int codeValue) {
    if (codeValue < 0 || codeValue > STATUS_LIST.size()) {
      return UNKNOWN.withDescription("Unknown code " + codeValue);
    } else {
      return STATUS_LIST.get(codeValue);
    }
  }

It seems that a codeValue of 17 would not be greater than the list size of 17, and would explode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2238
core: speed up Status code and message parsing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2239
core: fix indentation in MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2240
netty: Recycle command objects on the WriteQueue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nmittler FYI
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2241
sequential reading is guaranteeï¼Ÿ when is using client stream service. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
service ProfileData {
    rpc store (ProfileDataRequest) returns (ServiceResponse) {}
}

Server reads list of ProfileDataRequest, it's the same sequence of server and client? When client use only one thread to send ProfileDataRequest.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2242
core,protobuf: Add simple argument introspection for methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2243
Detect zero-message response to unary request on server-side
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It appears that a server can respond OK to a unary RPC without any detection on the server-side. It'd be nice to throw an exception if close(OK) is called without first sending a message for a UNARY response, although that may be against our API stability. At the very least, we should convert the OK into a Status saying the server is broken.
As reported in grpc/grpc#8010.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2244
core/internal: replace make Stream id a primitive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2245
protobuf: fast path zero sized messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What a cheat. Nice :-).
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2246
Deadlock with TransportSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I was testing Grpc with RoundRobinLB and a custom NameResolver when this deadlock happened:

Found one Java-level deadlock:
"grpc-timer-0":
waiting to lock monitor 0x00007fa1b00062c8 (object 0x00000007397d7f88, a java.lang.Object),
which is held by "main"
"main":
waiting to lock monitor 0x00007fa1800087f8 (object 0x00000007397d7e00, a java.lang.Object),
which is held by "grpc-timer-0"
"grpc-timer-0":
at io.grpc.internal.DelayedClientTransport.hasPendingStreams(DelayedClientTransport.java:284)

waiting to lock <0x00000007397d7f88> (a java.lang.Object)
at io.grpc.internal.TransportSet$1EndOfCurrentBackoff.run(TransportSet.java:246)
locked <0x00000007397d7e00> (a java.lang.Object)
at io.grpc.internal.LogExceptionRunnable.run(LogExceptionRunnable.java:56)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)

"main":
at io.grpc.internal.InUseStateAggregator.updateObjectInUse(InUseStateAggregator.java:50)

waiting to lock <0x00000007397d7e00> (a java.lang.Object)
at io.grpc.internal.TransportSet$BaseTransportListener.transportInUse(TransportSet.java:357)
at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:128)
locked <0x00000007397d7f88> (a java.lang.Object)
at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:135)
at [...]remote.TestGrpc$TestBlockingStub.sayHello(TestGrpc.java:156)


I don't know if it may relate to my own code or if the issue is on grpc side.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2247
OutOfDirectMemoryError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Copied from the C based grpc repository
grpc/grpc#7938
Basically it seems that grpc will throw OutOfDirectMemoryError if you send enough messages over  a single stream. I am probably just using it wrong or it was not meant for such use case. If anyone could explain this, that'd be great.
The code to reproduce the error: https://github.com/lploom/grpc-OutOfDirectMemoryError
To execute, run GameServer and then GameClient, when the client connects the server attemps to send 3M messages, but eventually crashes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2248
benchmarks: upgrade to jmh 1.14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2249
core: fix a javadoc bug in ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2250
core: Make getTransport's fast path lock-free
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2251
core: Make PickFirst.pick's fast path lock-free
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2252
core: Use grace period to avoid exitIdleMode in fast path
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2253
services: Implement Server Reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Another implementation got merged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2254
Ping implementation in Netty doesn't handle all error cases.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The field NettyClientHandler.ping is used to determine whether a PING acknowledgement is outstanding, as we only allow one PING at a time.
The logic to reset NettyClientHandler.ping handles the case where the write of the frame fails, we receive a PING ack or the channel gets closed.
We need to additionally handle the case in which the write of the PING frame succeeds, the channel remains active and we don't get any valid PING acknowledgement back. This error case may happen for example due to a buggy implementation of the remote endpoint or even packet corruption.  I think we should ensure users that the PingCallback is called eventually.
A possible solution may be an automatic re-send of PINGs that don't receive a matching PING ack within some timeout period.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2255
netty: Fix receipt of ClosedChannelException instead of actual error.â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2256
compile grpc-java is terrible, can you release a binary zip?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2257
Cache higher order objects in HPACK's dynamic table.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In #2217, @carl-mastrangelo had the idea to cache high order objects in HPACK's dynamic table. Carl mentioned the example of instead of parsing a jwt token on every request, we could cache an object that already contains the parsed representation, reducing garbage creation and parsing overhead.
Additionally, since Metadata uses String for names, we could for header names cache the String representation.
This would mostly require changes to Netty's HPACK implementation. We need some way to attach additional headers. I suggested to modify the StaticTable, Decoder and HuffmanDecoder to take a HeaderLiteralFactory as an optional ctor argument.
interface HeaderLiteralFactory {
  CharSequence newKey(byte[] bytes);
  CharSequence newValue(CharSequence key, byte[] bytes);
}
Netty's default implementation would simply return AsciiString objects. The gRPC implementation, could use String objects for keys. For values, we could special case certain header names and return holder objects e.g.
class JwtHolder implements CharSequence {
  JwtObject jwt;
  byte[] bytes;
}
Risks
The decoder has no power over what gets cached and what doesn't - it's up to the encoder. We might introduce overhead for headers that don't get cached. Also, a (name, value) is treated as one header entry in HPACK's dynamic table. Say if a users use custom headers, with lots of different values, then caching in the dynamic table might not be very effective, as entries might get evicted before they can be reused (if ever).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2258
Fix a deadlock in TransportSet.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2259
core: Remove com.google.common.collect usages, again
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2260
Many tcp ports opened by client and by server on Windows
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Starting my grpc-server or grpc-client on Windows causes netstat to show lots of established tcp connections. Both endpoints of those connections are in the same process. This is true for the server and for the client.
I've created an isolated grpc echo client/server program which doesn't do anything else than send an echo request/response via grpc-java. It behaves the same. The effected versions are
grpc-all-0.15.0; netty-tcnative-boringssl-static-1.1.33.Fork18
grpc-all-1.0.0; netty-tcnative-boringssl-static-1.1.33.Fork19

There seems to be no difference between TLS or insecure mode.
I see this behavior only on Windows (version: Server 2008 R2 Standard). On Linux everything is ok.
I use the same distribution on both platforms built by gradle.
Is Grpc though fully functional or does this cause any harm?
The integration test suite passes successfully but I'm uncertain if this would cause any trouble.
Is there some way to avoid this behavior?
Netstat trace:
C:\Users\jpork\projects\grpc-demo\bin>netstat -taonb

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    127.0.0.1:57651        127.0.0.1:57650        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57652        127.0.0.1:57649        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57653        127.0.0.1:57654        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57654        127.0.0.1:57653        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57655        127.0.0.1:57656        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57656        127.0.0.1:57655        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57657        127.0.0.1:57658        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57658        127.0.0.1:57657        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57659        127.0.0.1:57660        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57660        127.0.0.1:57659        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57661        127.0.0.1:57662        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57662        127.0.0.1:57661        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57663        127.0.0.1:57664        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57664        127.0.0.1:57663        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57665        127.0.0.1:57666        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57666        127.0.0.1:57665        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57667        127.0.0.1:57668        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57668        127.0.0.1:57667        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57669        127.0.0.1:57670        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57670        127.0.0.1:57669        ESTABLISHED     65764
 [javaw.exe]
  TCP    127.0.0.1:57671        127.0.0.1:2255         ESTABLISHED     65764
 [javaw.exe]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2261
netty: complete promise when RequestMessagesCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hehe. That's actually the message we should kill. But LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2262
core: Census integration for stats
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2263
Update examples to use Executor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our hello world examples don't show the right way to create a server.   Fix them
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2264
Implement HTTPâ†’gRPC status code mapping
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As defined in grpc/grpc#4955. Please wait until PR is in before merging the code changes, although the PR has received general agreement ("but it's not official until it's official").
This is important to return useful gRPC status codes when proxies generate errors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2265
Backport PRs with "backport" label from master to v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2266
Error opening zip file or JAR manifest missing when using qps_client / openloop_client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to reproduce:
# wget http://repo1.maven.org/maven2/io/grpc/grpc-benchmarks/1.0.0/grpc-benchmarks-1.0.0.tar
# tar xf grpc-benchmarks-1.0.0.tar
# grpc-benchmarks-1.0.0/bin/qps_client

Error opening zip file or JAR manifest missing : /root/.gradle/caches/modules-2/files-2.1/org.mortbay.jetty.alpn/jetty-alpn-agent/2.0.3/89e34338e9214ca753b33f23ccf80a4b5b861bb7/jetty-alpn-agent-2.0.3.jar
Error occurred during initialization of VM
agent library failed to init: instrument

Basically I think you should just comment the DEFAULT_JVM_OPTS.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2267
An exception occurred when I use maven plugin, Why?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
maven logs:
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: osx
[INFO] os.detected.arch: x86_64
[INFO] os.detected.classifier: osx-x86_64
[WARNING] Failed to inject repository session properties.
java.lang.NoSuchMethodError: org.apache.maven.execution.MavenSession.getRepositorySession()Lorg/eclipse/aether/RepositorySystemSession;
    at kr.motd.maven.os.RepositorySessionInjector.injectRepositorySession(RepositorySessionInjector.java:22)
    at kr.motd.maven.os.DetectExtension.injectSession(DetectExtension.java:148)
    at kr.motd.maven.os.DetectExtension.afterProjectsRead(DetectExtension.java:107)
    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:274)
    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
    at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
    at org.codehaus.classworlds.Launcher.main(Launcher.java:47)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:483)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
[INFO]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2268
When I use grpc 1.0.0, why javax/annotation package is in my jar?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My dependencies like this:
    <dependencies>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>1.0.0</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
And I use maven-shade-plugin to package my project, like this
<properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <shade.com.google.source>com.google</shade.com.google.source>
        <shade.com.google.target>com.a.eye.skywalking.protocol.dependencies.com.google</shade.com.google.target>
        <shade.io.netty.source>io.netty</shade.io.netty.source>
        <shade.io.netty.target>com.a.eye.skywalking.protocol.dependencies.io.netty</shade.io.netty.target>
        <shade.io.grpc.source>io.grpc</shade.io.grpc.source>
        <shade.io.grpc.target>com.a.eye.skywalking.protocol.dependencies.io.grpc</shade.io.grpc.target>
    </properties>

<plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.4.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <shadedArtifactAttached>false</shadedArtifactAttached>
                            <createDependencyReducedPom>true</createDependencyReducedPom>
                            <createSourcesJar>true</createSourcesJar>
                            <shadeSourcesContent>true</shadeSourcesContent>
                            <relocations>
                                <relocation>
                                    <pattern>${shade.com.google.source}</pattern>
                                    <shadedPattern>${shade.com.google.target}</shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>${shade.io.netty.source}</pattern>
                                    <shadedPattern>${shade.io.netty.target}</shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>${shade.io.grpc.source}</pattern>
                                    <shadedPattern>${shade.io.grpc.target}</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
And my jar in target directory has package javax/annotation? Why is this happending?
I provides my pom.xml and jar as attach files for you.
And as my pom define, I relocation io.netty, io.goole, io.grpc. Is this OK? Will Grpc works?
Attach files:
skywalking-network-2.0-2016.jar.zip
pom.xml.zip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2269
Fix bugs discovered while importing into google
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2270
OutOfMemoryError getting swallowed by SerializingExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My application throws OutOfMemoryError and got swallowed by following code,
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/SerializingExecutor.java#L156
I hope to handle OutOfMemoryError in my default uncaught exception handler, but it is not happening.
Is this a bug?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2271
interop-testing: skip large memory tests on constrained JVMs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2272
Release 1.0.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2273
Investigate if Netty can be used as a server on Android 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Warning: Running a server on android is not officially supported on Android by the gRPC Java team!
It may be possible to run a gRPC Java server on android in a limited sense, but we don't do anything to restrict the possibility.  There appears to be a small number of users who do want to run a server for reasons that may be valid.  This issue is to track both interest from the community, as well as possibly being a list of known issues.
Netty has not been optimized for Android.  gRPC has not been optimized to be a server on android.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2274
core: reimplement Metadata to avoid allocation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Initial numbers:
Before:
Benchmark                                            (headerCount)    Mode     Cnt        Score    Error  Units
InboundHeadersBenchmark.defaultHeaders_clientHandler           N/A    avgt      10      240.879 Â±  4.903  ns/op
InboundHeadersBenchmark.defaultHeaders_serverHandler           N/A    avgt      10      882.354 Â± 16.177  ns/op
InboundHeadersBenchmark.grpcHeaders_clientHandler              N/A    avgt      10      208.068 Â±  5.380  ns/op
InboundHeadersBenchmark.grpcHeaders_serverHandler              N/A    avgt      10      477.604 Â±  8.200  ns/op
OutboundHeadersBenchmark.convertClientHeaders                    1  sample  234233      125.232 Â± 11.903  ns/op
OutboundHeadersBenchmark.convertClientHeaders                    5  sample  344367      264.343 Â± 18.318  ns/op
OutboundHeadersBenchmark.convertClientHeaders                   10  sample  392273      439.640 Â±  2.589  ns/op
OutboundHeadersBenchmark.convertClientHeaders                   20  sample  221506      855.115 Â± 38.899  ns/op
OutboundHeadersBenchmark.convertServerHeaders                    1  sample  253676      111.941 Â±  2.742  ns/op
OutboundHeadersBenchmark.convertServerHeaders                    5  sample  368499      248.255 Â±  2.601  ns/op
OutboundHeadersBenchmark.convertServerHeaders                   10  sample  390015      439.651 Â± 11.040  ns/op
OutboundHeadersBenchmark.convertServerHeaders                   20  sample  221807      840.435 Â± 21.667  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                     1  sample  230139      432.866 Â± 25.503  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                     5  sample  226901      765.095 Â± 19.969  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                    10  sample  260495     1268.239 Â± 21.850  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                    20  sample  311526     2059.973 Â± 23.503  ns/op


After:

Benchmark                                            (headerCount)    Mode     Cnt        Score    Error  Units
InboundHeadersBenchmark.defaultHeaders_clientHandler           N/A    avgt      10      104.317 Â±  1.973  ns/op
InboundHeadersBenchmark.defaultHeaders_serverHandler           N/A    avgt      10      395.666 Â± 11.056  ns/op
InboundHeadersBenchmark.grpcHeaders_clientHandler              N/A    avgt      10       64.147 Â±  4.076  ns/op
InboundHeadersBenchmark.grpcHeaders_serverHandler              N/A    avgt      10      228.299 Â±  2.874  ns/op
OutboundHeadersBenchmark.convertClientHeaders                    1  sample  252451      102.718 Â±  2.714  ns/op
OutboundHeadersBenchmark.convertClientHeaders                    5  sample  239976      225.812 Â± 38.824  ns/op
OutboundHeadersBenchmark.convertClientHeaders                   10  sample  258119      364.475 Â± 57.217  ns/op
OutboundHeadersBenchmark.convertClientHeaders                   20  sample  260138      676.950 Â± 36.243  ns/op
OutboundHeadersBenchmark.convertServerHeaders                    1  sample  276064      105.371 Â±  1.859  ns/op
OutboundHeadersBenchmark.convertServerHeaders                    5  sample  255128      190.970 Â± 16.475  ns/op
OutboundHeadersBenchmark.convertServerHeaders                   10  sample  272923      366.769 Â± 28.204  ns/op
OutboundHeadersBenchmark.convertServerHeaders                   20  sample  264797      641.961 Â± 18.879  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                     1  sample  226078      425.262 Â±  3.481  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                     5  sample  253606      675.488 Â± 26.001  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                    10  sample  286556     1157.014 Â± 12.923  ns/op
OutboundHeadersBenchmark.encodeClientHeaders                    20  sample  345649     1874.806 Â± 36.227  ns/op
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2275
netty: use void promises and improve error handling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2276
TransportSet garbage collection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today we only have logic for creating TransportSets. A TransportSet may be no longer used if NameResolver or LoadBalancer has decided to switch away from that address, and ManagedChannelImpl should clean it up.
Probably TransportSet should just shutdown and move itself to ManagedChannelImpl.decommissionedTransports when it's IDLE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2277
examples: fix bound method not same instance as that in service descriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2278
QPS client using much more memory than server.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I did some benchmarking using the qps_client and qps_server. Zero bytes payload. I enabled verbose:gc.
When running with 8 channels and 250 concurrent RPCs. On the client, after a young GC our live heap is ~290MiB. The GC logs have a very low volatility +/- 1MiB.
Doubling the concurrent streams to 500, on the client, the live heap more than doubles to 560MiB.
On the server it increases to ~140MiB. Doubling the concurrent streams to 1000, on the client, the live heap again doubles to ~1.1GB and on the server it increases to ~170MB.
I then thought it might be due to the client having to keep stream state  around much longer (until the server responds) and so I enabled streaming rpcs (with 8 channels, 1000 concurrent). Live heap on the client stays the same, on the server it drops to ~30MiB. The used heap on the client is about 2.3GiB before the GC, and 1.1GiB after. The used heap on the server is about 1.3GB before the GC and 30MiB after. So it seems like we keep an additional GiB of data around on the client (or 130KiB per stream).
That data seems to be allocated at the beginning. The first 3 GCs and the last GC on the client
(before GC -> after GC)
1GB -> 800.67MB
1.78GB -> 1.08GB
2.08GB -> 1.09GB
...
2.4GB -> 1.09GB

The first 3 GCs and the last GC on the server
(before GC -> after GC)
1.31GB -> 14.95MB
1.32GB -> 13.53MB
1.31GB -> 12.25MB
...
1.35GB -> 31.30MB

The increased memory usage on the client is not due to histograms, cause I commented out the line recording latencies.
I wonder why that is? Is it possibly a small memory leak per RPC? Is that specific to the QPS client or gRPC? Any ideas?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2279
Http2ChannelClosedException instead of actual failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is similar to #1330, but for when the stream was never actually sent because of MAX_CONCURRENT_STREAMS.
In this case, we do know more information: the stream was never sent, so it is safe to retry. While that information is useful internally, the user probably would like to know the cause of connection closure. (In this case, I think it was a TCP timeout, because the network was flaky.) We should probably just swap out the exception in the same way we do with ClosedChannelException. At the very least, it should be UNAVAILABLE instead of INTERNAL.
This was seen in grpc-java v1.0.0:
Status{code=INTERNAL, description=null, cause=io.netty.handler.codec.http2.StreamBufferingEncoder$Http2ChannelClosedException: Connection closed}
io.netty.handler.codec.http2.StreamBufferingEncoder$Http2ChannelClosedException: Connection closed
    at io.netty.handler.codec.http2.StreamBufferingEncoder.close(StreamBufferingEncoder.java:224)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder.channelInactive(Http2ConnectionHandler.java:176)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:372)
    at io.grpc.netty.NettyClientHandler.channelInactive(NettyClientHandler.java:298)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:234)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:360)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:325)
    at io.netty.handler.ssl.SslHandler.channelInactive(SslHandler.java:723)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:234)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1329)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:908)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:744)
    at io.netty.util.concurrent.SingleThreadEventExecutor.safeExecute(SingleThreadEventExecutor.java:451)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:401)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
    at java.lang.Thread.run(Thread.java:745)

CC @buchgr, any thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2280
Per request logging params in GRPC server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We use a logging framework that uses thread local map to store parameters for logging templates like request id, client ip etc.
Params are usually set and reset in some request filter (interceptor), with the assumption that the same thread is going to be used to handle the request.
From what I observe, GRPC server thread that handles request might be different from the thread that runs interceptor.
Is there any way to implement per-request logging parameter in GRPC server?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2281
Add injection points to generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Protobuf has a concept of injection points that make it possible to extend generated classes with additional methods, implements interfaces, and others.  This has been useful for example to generate setters which take an Optional Java 8 in addition to the standard methods generated when a user uses google.protobuf.StringValue or Int64Value.
A similar feature would be very useful in the generated gRPC code to allow for extension to add interaction models for clients and servers which are not appropriate in core.  For example, I would like to generate RxJava interfaces for client and server, and I'd like them to live in the same area as the other clients.
An example of the type of line in protoc generated files now that allows for this is
 //@@protoc_insertion_point(builder_scope:com.google.protobuf.Int64Value)

It would be helpful if there was a class scope insertion point for adding additional client and server interactions models.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2282
client  set   RoundRobinLoadBalancer fail
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
code
that  client is
    managedChannel = NettyChannelBuilder
                .forTarget("server://127.0.0.1:9999,127.0.0.1:8888")
                .nameResolverFactory(new ServerNameResolverProvider())
                .loadBalancerFactory(RoundRobinLoadBalancerFactory.getInstance())
                .usePlaintext(true).build();

that  RoundRobinLoadBalancerFactory is fail .
debug   the  code  ,discover  class TransportSet method obtainActiveTransport have a problem
final ClientTransport obtainActiveTransport() {
    ClientTransport savedTransport = activeTransport;
    if (savedTransport != null) {
      return savedTransport;
    }
    synchronized (lock) {
      // Check again, since it could have changed before acquiring the lock
      if (activeTransport == null) {
        if (shutdown) {
          return SHUTDOWN_TRANSPORT;
        }
        // Transition to CONNECTING
        DelayedClientTransport delayedTransport = new DelayedClientTransport(appExecutor);
        transports.add(delayedTransport);
        delayedTransport.start(new BaseTransportListener(delayedTransport));
        activeTransport = delayedTransport;
        startNewTransport(delayedTransport);
      }
      return activeTransport;
    }
}

the savedTransport  frist is null ,  the second time  is not null ,no execute  find  activeTransport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2283
CanÂ´t build HelloWorld Android project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After installing java-gRPC as ReadMe states, I tried to build the android project HelloWord but the build fails:
FAILURE: Build failed with an exception.

* What went wrong:
Could not resolve all dependencies for configuration ':app:protobufToolsLocator_grpc'.

 Could not find io.grpc:protoc-gen-grpc-java:1.1.0-SNAPSHOT.
  Searched in the following locations
      https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/maven-metadata.xml
      https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT.pom
      https://jcenter.bintray.com/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT-windows-x86_64.exe
      file:/C:/Users/javier.silva/.m2/repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/maven-metadata.xml
      file:/C:/Users/javier.silva/.m2/repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT.pom
      file:/C:/Users/javier.silva/.m2/repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT-windows-x86_64.exe
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/maven-metadata.xml
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT.pom
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/android/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT-windows-x86_64.exe
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/maven-metadata.xml
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT.pom
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/google/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT-windows-x86_64.exe
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/maven-metadata.xml
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT.pom
      file:/C:/Users/javier.silva/Documents/software/android-sdk-windows/extras/m2repository/io/grpc/protoc-gen-grpc-java/1.1.0-SNAPSHOT/protoc-gen-grpc-java-1.1.0-SNAPSHOT-windows-x86_64.exe
  Required by:
      helloworld:app:unspecified

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2284
Census stats recording with InProcessTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Message sizes are counted in MessageFramer and MessageDeframer, which InProcessTransport doesn't use. Right now we simply do not record metrics for InProcessTransport at all. This may turn out to be needed, so I use this issue to track this missing feature.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2285
Stats for UNIMPLEMENTED methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The way that gRPC uses Census to collect metrics, is that each RPC creates a record, which is tagged with the method name and the Status.
If Census keeps an in-memory store that maps (Method, Status) to metrics (counts, message sizes etc), which is useful for on-line querying, the key space on the server could be blown up by misbehaving (or malicious) clients that sends a lot of distinct unimplemented method names to the server.
If this is a valid concern, we should probably treat UNIMPLEMENTED status in a special way.
cc @dinooliva
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2286
core: channel connectivity state API and implementation by TransportSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2287
Updated README
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2288
PoC: Reduce allocations & copies deserializing protobuf.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2289
Grpc server uses more memory than -Xmx
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes Grpc server can use (couple of Gb) more memory than JVM max heap size. Does anyone know how could that happen? What is the recommended Jvm heap size configuration for Grpc servers?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2290
protobuf: cache temp buffers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Setting the transport benchmark to use megabyte messages sees the following results:
Before:
TransportBenchmark.unaryCall1024                                       true        NETTY  sample  4564   2188854.745 Â±  71456.423   ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.00                   true        NETTY  sample         1875968.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.50                   true        NETTY  sample         2105344.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.90                   true        NETTY  sample         2396160.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.95                   true        NETTY  sample         2535424.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.99                   true        NETTY  sample         3011993.600                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.999                  true        NETTY  sample         7471595.520                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.9999                 true        NETTY  sample        99090432.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p1.00                   true        NETTY  sample        99090432.000                ns/op
TransportBenchmark.unaryCall1024:Â·gc.alloc.rate                        true        NETTY  sample    10      2787.784 Â±    169.945  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.alloc.rate.norm                   true        NETTY  sample    10   6415272.837 Â±    262.046    B/op
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Eden_Space               true        NETTY  sample    10      2815.863 Â±    429.465  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Eden_Space.norm          true        NETTY  sample    10   6483440.294 Â± 947355.959    B/op
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Survivor_Space           true        NETTY  sample    10         2.143 Â±      1.623  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Survivor_Space.norm      true        NETTY  sample    10      4873.798 Â±   3679.598    B/op
TransportBenchmark.unaryCall1024:Â·gc.count                             true        NETTY  sample    10        42.000               counts
TransportBenchmark.unaryCall1024:Â·gc.time                              true        NETTY  sample    10       155.000                   ms


After:
Benchmark                                                          (direct)  (transport)    Mode   Cnt         Score        Error   Units
TransportBenchmark.unaryCall1024                                       true        NETTY  sample  5037   1982881.569 Â±  16738.841   ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.00                   true        NETTY  sample         1683456.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.50                   true        NETTY  sample         1918976.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.90                   true        NETTY  sample         2232320.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.95                   true        NETTY  sample         2330624.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.99                   true        NETTY  sample         2729574.400                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.999                  true        NETTY  sample         6127304.704                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p0.9999                 true        NETTY  sample        15515648.000                ns/op
TransportBenchmark.unaryCall1024:unaryCall1024Â·p1.00                   true        NETTY  sample        15515648.000                ns/op
TransportBenchmark.unaryCall1024:Â·gc.alloc.rate                        true        NETTY  sample    10      2071.435 Â±    141.669  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.alloc.rate.norm                   true        NETTY  sample    10   4318096.849 Â±    269.655    B/op
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Eden_Space               true        NETTY  sample    10      2076.282 Â±    323.504  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Eden_Space.norm          true        NETTY  sample    10   4335884.918 Â± 729189.378    B/op
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Survivor_Space           true        NETTY  sample    10         1.567 Â±      1.238  MB/sec
TransportBenchmark.unaryCall1024:Â·gc.churn.PS_Survivor_Space.norm      true        NETTY  sample    10      3274.883 Â±   2640.345    B/op
TransportBenchmark.unaryCall1024:Â·gc.count                             true        NETTY  sample    10        31.000               counts
TransportBenchmark.unaryCall1024:Â·gc.time                              true        NETTY  sample    10        51.000                   ms
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2291
core: fix a discrepency in state transition.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2292
Implement channel-state API in ManagedChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The API is added by #2286, but is implemented (will throw exception) in ManagedChannelImpl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2293
protobuf: make buffer cache even weaker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm. Interesting. When under memory pressure should we allow the GC to free that object, so that allocating a new one will create even more memory pressure? ðŸ˜…
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2294
examples: fix dependencies
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2295
Refactor passing down ssl session
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The ProtocolHandler.Listener seemed more lightweight. I not sure if we'll add more stuff in GrpcHttp2ConnectionHandler but I guess it's likely to be beneficial in the future.
@zhangkun83 I've pushed update. PTAL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2296
Client side NPE when sending large number of concurrent requests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Both server and client use GRPC 1.0.
Client log:
Exception in thread "grpc-default-executor-95" java.lang.NullPointerException: channel
        at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:228)
        at io.grpc.netty.WriteQueue.<init>(WriteQueue.java:76)
        at io.grpc.netty.NettyClientHandler.startWriteQueue(NettyClientHandler.java:223)
        at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:172)
        at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:45)
        at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:215)
        at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:188)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:637)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:579)
        at 
......

Server log:
WARN  [2016-09-22 21:28:41,870] io.netty.channel.DefaultChannelPipeline: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. [client=null]
! java.io.IOException: Too many open files in system
! at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method) ~[na:1.8.0_60]
! at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422) ~[na:1.8.0_60]
! at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250) ~[na:1.8.0_60]
! at io.netty.channel.socket.nio.NioServerSocketChannel.doReadMessages(NioServerSocketChannel.java:140) ~[netty.jar:4.1.5.Final]
! at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:75) ~[netty.jar:4.1.5.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:610) [netty.jar:4.1.5.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:551) [netty.jar:4.1.5.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:465) [netty.jar:4.1.5.Final]
! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:437) [netty.jar:4.1.5.Final]
! at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873) [netty.jar:4.1.5.Final]
! at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [netty.jar:4.1.5.Final]
! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_60]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2297
NettyFlowControlTest is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Happened few times for me, in CI as well as locally:
io.grpc.testing.integration.NettyFlowControlTest > verySmallWindowMakesProgress FAILED
    java.lang.AssertionError: Window was 655492 expecting 314570
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.assertTrue(Assert.java:41)
        at io.grpc.testing.integration.NettyFlowControlTest.doTest(NettyFlowControlTest.java:171)
        at io.grpc.testing.integration.NettyFlowControlTest.verySmallWindowMakesProgress(NettyFlowControlTest.java:141)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2298
grpc-all on Maven repository does not contain anything
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since version 0.14 the grpc-all JAR on Maven.org only contains a Manifest but no actual code. 0.13.2 is the last version still OK.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2299
More logs in channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have insufficient logging in the channel layer. In particular:

Name resolution success and failures. Although failures are plumbed to application when it makes a call.
ManagedChannelImpl goes into and out of idleness

Whether they should be INFO or FINE are not clear, but at least they should start as FINE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2300
Generated OuterClass has a lot of incompatibilities !
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi , I am new to gRPC / protobuf , and facing a first step problem...
This is my first .proto file :
syntax = "proto3";
option java_package = "destiny.identity.services.grpc";

service EchoService {
    rpc echo (EchoRequest) returns (EchoReply) {}
}

message EchoRequest {
    string name=1;
}

message EchoReply {
    string message = 1;
}

It is simple , but the generated EchoServiceOuterClass.java has a lot of incompatibilities :
~/destiny-identity/target/generated-sources/protobuf/java/destiny/identity/services/grpc/EchoServiceOuterClass.java
Error:(83, 13) java: incompatible types: java.io.IOException cannot be converted to java.lang.String
Error:(152, 18) java: memoizedSize has private access in com.google.protobuf.AbstractMessage
Error:(159, 7) java: memoizedSize has private access in com.google.protobuf.AbstractMessage
Error:(394, 18) java: cannot find symbol
  symbol:   method unwrapIOException()
  location: variable e of type com.google.protobuf.InvalidProtocolBufferException
Error:(586, 13) java: incompatible types: java.io.IOException cannot be converted to java.lang.String
Error:(655, 18) java: memoizedSize has private access in com.google.protobuf.AbstractMessage
Error:(662, 7) java: memoizedSize has private access in com.google.protobuf.AbstractMessage
Error:(897, 18) java: cannot find symbol
  symbol:   method unwrapIOException()
  location: variable e of type com.google.protobuf.InvalidProtocolBufferException

For example :

This is my [ partial ] pom.xml
<dependencies>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-netty</artifactId>
      <version>${grpc.version}</version>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-protobuf</artifactId>
      <version>${grpc.version}</version>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-stub</artifactId>
      <version>${grpc.version}</version>
    </dependency>
   ... other skipped ...
</dependencies>

// the related plugin :
<plugin>
  <groupId>org.xolstice.maven.plugins</groupId>
  <artifactId>protobuf-maven-plugin</artifactId>
  <version>0.5.0</version>
  <configuration>
    <!--
      The version of protoc must match protobuf-java. If you don't depend on
      protobuf-java directly, you will be transitively depending on the
      protobuf-java version that grpc depends on.
    -->
    <protocArtifact>com.google.protobuf:protoc:3.0.0:exe:${os.detected.classifier}</protocArtifact>
    <pluginId>grpc-java</pluginId>
    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.0.0:exe:${os.detected.classifier}</pluginArtifact>
  </configuration>
  <executions>
    <execution>
      <goals>
        <goal>compile</goal>
        <goal>compile-custom</goal>
      </goals>
    </execution>
  </executions>
</plugin>


The grpc-netty , grpc-protobuf , grpc-stub are all of version of 1.0.0
Where goes wrong here ?
Thanks.
I am new to gRPC / protobuf , sorry I don't know whether the problem is related to grpc-java project or not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2301
Define the API for LoadBalancer to add headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GRPCLB needs this to add the per-client LB token to every RPC.
Metadata injection is usually done in interceptors, but LoadBalancer cannot use interceptor, because it returns transports, not channels. Since LoadBalancer doesn't need the full power of interceptor anyway, we may just figure out an API that allows LoadBalancer to change headers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2302
LoasdBalancer: the affinity keys are not used when completing the delayed (interim) transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
InterimTransport {
  void closeWithRealTransports(Supplier<T> realTransports);
}
Although DelayedClientTransport saves the affinity keys for the delayed streams (in CallOptions), there is no way for it to pass those keys to Supplier<T>. This can be addressed by changing this method into:
TransportPicker<T> {
  T pickTransport(Attributes affinity);
}

InterimTransport {
  void closeWithTransportPicker(TransportPicker<T> picker);
}
Similarly:
DelayedClientTransport {
  void setTransportPicker(TransportPicker<T> picker);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2303
all: Bump protobuf to 3.0.2, to fix protoc in CI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2304
all: add findbugs annotations to check return values
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2305
Exception thrown from OnReadyHandler sometimes does not close stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems like there should be a try-catch block around this line:
https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ServerImpl.java#L559
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2306
netty: server support extension content types
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 is it okay to merge? travis seems to be broken? (also seen on other PRs)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2307
ManagedChannelBuilder doesn't have maxMessageSize
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This makes it more annoying to override the maxMessageSize, because you have to know which implementation you are using.
Note that if you specify the actual implementation, this is easy, but the problem is needing to specify the implementation.
Instead of:
ManagedChannelBuilder.forTarget(...)
   .maxMessageSize(SIZE)
   .build();

You are forced to do:
NettyChannelBuilder.forTarget(...)
   .maxMessageSize(SIZE)
   .build();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2308
all: fix minor bugs discovered on import
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2309
interop-testing: limit the amount of noise from failing tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2310
android-interop-testing: skip integration tests if there is not enough memory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2311
docs: Suggest using Fork19 of tcnative
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2312
all: Bump protobuf to 3.0.2, to fix protoc in CI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2313
Guarantees around using responseObserver in multiple threads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was writing a service which takes a stream of Events, and returns a stream of Acks.  In doing so, the Acks can trigger from multiple threads after I've done work and published them to downstream systems.  After sending a bit of load I would get errors that sendHeaders had already been called, and I realized that ServerCalls here https://github.com/grpc/grpc-java/blob/master/stub/src/main/java/io/grpc/stub/ServerCalls.java#L284 is performing a check to see if headers are sent that is not thread safe.
I wanted to get a bit more insight into the expectations for a service which is sending back responses on multiple threads.  Should I just do
synchronized(responseObserver) {
  responseObserver.onNext(ack);
}

or should there be more synchronization in the ServerCalls code?  I suspect this was a deliberate choice not to support multi-threaded usage since cancelled is volatile while sentHeaders isn't.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2314
docs: Suggest using Fork19 of tcnative
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2315
Update README to reference 1.0.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2316
Bump protobuf to 3.1.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/google/protobuf/releases/tag/v3.1.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2317
Tracking Issue for FakeClock APIs being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FakeClock
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2318
core/test: sanitize FakeClock 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2319
Update OAuth section in SECURITY.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2320
Client certificate not sent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm trying to use gRPC from Java (as a client) to communicate with a gRPC Node.js server.
I am trying to get TLS mutual auth between the two, but I can't seem to get the Java client to send its client cert. I've verified via packet capture that the Node server is requesting a client cert.
ManagedChannelBuilder<?> mcb = NettyChannelBuilder.forAddress("127.0.0.1", 50051)
  .sslContext(GrpcSslContexts.forClient()
    .keyManager(client_leaf.key, client_ca.cert, client_leaf.cert)
    .trustManager(server_ca.cert)
    .build()
  )
  .negotiationType(NegotiationType.TLS);

mcb.overrideAuthority("localhost");
I am dynamically generating CA certs and leaf certs under them to bind the communication.
Due to this, I'm using the keyManager(PrivateKey,X509Certificate...) overload, and the private key is generated from a KeyPairGenerator.getInstance("RSA") object. I'm currently generating two chains (one for the server's cert, and one for the client cert) and verification of the server cert works fine (connections work when I disable the client cert requirement on the Node server).
My relevant dependencies are below:
compile group: 'io.grpc', name: 'grpc-netty', version: '1.0.1'
compile group: 'io.grpc', name: 'grpc-protobuf', version: '1.0.1'
compile group: 'io.grpc', name: 'grpc-stub', version: '1.0.1'
compile group: 'io.netty', name: 'netty-tcnative-boringssl-static', version: '+'//'1.1.33.Fork19'
The + currently resolves to 1.1.33.Fork23. I've found that the 1.1.33.Fork19 version specified in the documentation results in an exception on Linux (and OS X) caused by:
Caused by: javax.net.ssl.SSLHandshakeException: error:00000000:invalid library (0):OPENSSL_internal:invalid library (0)

As per CONTRIBUTING.md, my setup is as follows:
$ java -version
openjdk version "1.8.0_91"
OpenJDK Runtime Environment (build 1.8.0_91-8u91-b14-0ubuntu4~14.04-b14)
OpenJDK 64-Bit Server VM (build 25.91-b14, mixed mode)
$ uname -a
Linux ubuntu 3.13.0-85-generic #129-Ubuntu SMP Thu Mar 17 20:50:15 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux

Any ideas on what might be causing this behavior or what I'm doing wrong?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2321
SO_BACKLOG 128 enough?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In NettyServer there is a hardcode
if (NioServerSocketChannel.class.isAssignableFrom(channelType)) {
      b.option(SO_BACKLOG, 128);
      b.childOption(SO_KEEPALIVE, true);
    }

SO_BACKLOG = 128 is enough for every situation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2322
all: fix minor JavaStyle errors found in code sync
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Are you synced to head?  I fixed some of these in f5f9ca5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2323
ErrorProne compile failure on v1.0.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
core/src/main/java/io/grpc/internal/ManagedChannelImpl.java:266: error: [GuardedByChecker] This access should be guarded by 'ManagedChannelImpl.this.lock'; instead found: 'this.lock'
idleModeTimer.cancelled = true;
^
(see http://errorprone.info/bugpattern/GuardedByChecker)
1 error
This is for tag v1.0.1 -- it may or may not be fixed @Head
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2324
parseDelimitedFrom behavior has changed between 2.5 and 3.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
parseDelimitedFrom didn't check limit in 2.5. In 3.1 it does throwing InvalidProtocolBufferException if we exceed the hard-coded max of 64MB.
This is issue is a bit like "Remove proto size restriction when parsing protos. #836" but parseDelimitedFrom only takes InputStream so we can't set max size.
64MB is large but previous there was no limit. There is a sort of a workaround by doing parsePartialFrom and creating a CodedInputStream probably set to this method but means creating a new object every time (or reading to see if > 64MB and then making new CIS...)
Let us know how you think best to address and we can put up a patch.
Thanks.
org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException: Protocol message was too large.  May be malicious.  Use CodedInputStream.setSizeLimit() to increase the size limit.
at org.apache.hadoop.hbase.shaded.com.google.protobuf.InvalidProtocolBufferException.sizeLimitExceeded(InvalidProtocolBufferException.java:134)
at org.apache.hadoop.hbase.shaded.com.google.protobuf.CodedInputStream$StreamDecoder.readRawBytesSlowPath(CodedInputStream.java:2768)
at org.apache.hadoop.hbase.shaded.com.google.protobuf.CodedInputStream$StreamDecoder.readBytes(CodedInputStream.java:2335)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$Procedure.<init>(ProcedureProtos.java:564)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$Procedure.<init>(ProcedureProtos.java:423)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$Procedure$1.parsePartialFrom(ProcedureProtos.java:2498)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$Procedure$1.parsePartialFrom(ProcedureProtos.java:2493)
at org.apache.hadoop.hbase.shaded.com.google.protobuf.CodedInputStream$StreamDecoder.readMessage(CodedInputStream.java:2314)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$ProcedureWALEntry.<init>(ProcedureProtos.java:6565)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$ProcedureWALEntry.<init>(ProcedureProtos.java:6505)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$ProcedureWALEntry$1.parsePartialFrom(ProcedureProtos.java:7660)
at org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos$ProcedureWALEntry$1.parsePartialFrom(ProcedureProtos.java:7655)
at org.apache.hadoop.hbase.shaded.com.google.protobuf.AbstractParser.parsePartialFrom(AbstractParser.java:197)
at org.apache.hadoop.hbase.shaded.com.google.protobuf.AbstractParser.parsePartialDelimitedFrom(AbstractParser.java:238)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2325
Power support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2326
Build grpc-java from a new arch---mips64el
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to build bazel, which has dependencies protoc and protoc-gen-grpc-java. So, I need to build grpc-java. I got grpc-java from github and the reference README.md run the following command.
COMMANS: ./gradlew build
My error as follows, Any one can tell me how to work around? I will port to a new platform --mips64el
ERRORS:
Detecting the operating system and CPU architecture
os.detected.name=linux
os.detected.arch=unknown
FAILURE: Build failed with an exception.


Where:
Build file '/usr/local/TenFlow/grpc-java/build.gradle' line: 60


What went wrong:
A problem occurred evaluating root project 'grpc'.

unknown os.arch: mips64el



Try:
Run with --stacktrace option to get the stack trace. Run with --debug option to get more log output.


BUILD FAILED
Total time: 49.999 secs
Stopped 0 compiler daemon(s).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2327
Error on run example step "./gradlew installDist"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to documentation  http://www.grpc.io/docs/quickstart/java.html

clone git repo
run command line ./gradlew installDist

step number 2 does not work for me, get a compile errors about illegal characters... like RouteGuideServer.java line 299 this line has greece characters.
to resolve this issue I had to add set DEFAULT_JVM_OPTS="-Dfile.encoding=utf-8"
into gradlew.bat file and execute command ./gradlew installDist againe. Can it be resolve in git?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2328
io.grpc.okhttp.OkHttpTransportTest > newStream_duringShutdown is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are working on  s390x platform and facing below test failure while building gRPC-java master.
We are using protoc v3.0.2 and v3.0.0-javalite.
:grpc-okhttp:checkstyleTest UP-TO-DATE
:grpc-okhttp:test

io.grpc.okhttp.OkHttpTransportTest > newStream_duringShutdown FAILED
    java.lang.AssertionError: Timed out waiting for server stream

129 tests completed, 1 failed, 1 skipped
:grpc-okhttp:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-okhttp:test'.

BUILD FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2329
Implement connection attempt timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
trying to resolve #1943
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2330
interop-testing: No census asserts for standalone client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2331
all: Style, unused, and errorprone fixes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2332
netty: Port client and server handler to frame codec.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I updated this to current Netty and reduced the diff size in https://github.com/ejona86/grpc-java/tree/netty_http2_framecodec . Grep for FIXMEs. It currently will leak all streams, as it keeps them in a map and never removes them (since managedState isn't available). To remove them, it looks like we should override Abstract{Server,Client}Stream.TransportState.deframerClosed() but that's not available at the version of gRPC being modified here. It could be added fairly easily to this without upgrading grpc (see a446b53 where it was added), but meh.
I looked through the conflicts to update to grpc master, and there didn't appear to be anything too hard in the non-test code to merge such that we would want to go with a different approach. There were some non-trivial conflicts in the Handlers, but they also seems pretty self-contained and mostly clear what is going on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2333
netty: Remove RequestMessagesCommand
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2334
netty: Special case Http2ChannelClosedException. Fixes #2279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2335
AbstractTransportTest.openStreamPreventsTermination is flaky on Windows
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seen in https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/2337/console
io.grpc.netty.NettyTransportTest > openStreamPreventsTermination FAILED
    java.io.IOException: Failed to bind

        Caused by:
        java.net.BindException: Address already in use: bind

    java.lang.AssertionError

187 tests completed, 1 failed, 3 skipped
:grpc-netty:test FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2336
core: Fix a bug for exception handling at messageRead
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
resolves #2337
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2337
Client-streaming call is hanging if service impl throws unexpected runtime exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Client-streaming call is hanging if service implementation for the requestStreamObserver#onNext callback throws an unexpected runtime exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2338
Grpc-Java best practices
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Developers may run into similar issues when started using Grpc. Solutions to most of the issue are  scattered around the mailing list and github issues, like custom server executor, stream rcp flow control, server/client request intercepting, error handling, ssl, testing, etc.
I think it would be valuable to document the best practices for Grpc-Java.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2339
core: Call onSentBytes only if future is successfull.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm... I think I'd prefer to try to fix the tests. Allocated is very helpful for determining whether to call onReady().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2340
interop-testing: -PskipCodegen requires =true
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ctiller, friendly ping. This is an easy review :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2341
GrpcHttp2RequestHeaders and GrpcHttp2OutboundHeaders don't support toString
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This causes a regression in debugging. Instead of seeing headers when enabling the Http2 logging in Netty, you get something like:
[id: 0x8afe7481, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:57543] HEADERS: streamId=1, headers=io.grpc.netty.GrpcHttp2HeadersDecoder$GrpcHttp2RequestHeaders@3fe6fa38, padding=0, endStream=true

Note the io.grpc.netty.GrpcHttp2HeadersDecoder$GrpcHttp2RequestHeaders@3fe6fa38.
It looks like Itr has toString, but not the headers itself. The wrong class probably got the toString method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2342
netty: Add toString() to GrpcHttp2InboundHeaders. Fixes #2341.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #2341
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2343
benchmarks: Reduce excessive memory usage of histograms. Fixes #2278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We discussed point-to-point. Basically, precision doesn't mean what this PR was seeming to imply. The precision is of values (in scientific notation), not of the bucket percentages. But a precision of 3 was a bit much. We see C using a precision of 2, which sounds reasonable. Unfortunately, that's not enough of a memory savings by itself, so there will need to be some other work.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2344
io.grpc.okhttp.OkHttpTransportTest > serverNotListening FAILED
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc.okhttp.OkHttpTransportTest > serverNotListening FAILED
    Wanted but not invoked:
    listener.transportTerminated();
    -> at io.grpc.internal.testing.AbstractTransportTest.serverNotListening(AbstractTransportTest.java:242)
    Actually, there were zero interactions with this mock.

Seen at https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/2345/console
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2345
ManagedChannelBuilder and URI path routing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This may be a silly question but I'm having a hard time figuring out what's going on. I have a couple of gRPC servers sitting behind a load balancer and I have rules set up to route requests based on the path. i.e. myloadbalancerIPaddress:8000/service/serviceA would route to a particular backend server. And on the client side this is what I'm doing:
ManagedChannel channel = ManagedChannelBuilder
    .forTarget("ipaddress:8000/service/test-service").usePlaintext(true).build()

It seems like the request is always made against ipaddress:8000 without the specified path. Am I doing something wrong here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2346
issue with progaurd minifyEnabled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
First of all, thank you guys for awesome work. Currently, I am using grpc on my android app and it crashes with below trace when minifyEnabled is true in gradle configuration. Is there any specific progaurd rule/ config for this ?
E: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
       at io.grpc.ManagedChannelProvider.provider(ManagedChannelProvider.java:127)
       at io.grpc.ManagedChannelBuilder.forAddress(ManagedChannelBuilder.java:45)
       at com.nishant.starterkit.helloWorld.HelloWorldActivity$GrpcTask.doInBackground(HelloWorldActivity.java:78)
       at com.nishant.starterkit.helloWorld.HelloWorldActivity$GrpcTask.doInBackground(HelloWorldActivity.java:62)
       at android.os.AsyncTask$2.call(AsyncTask.java:292)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:818)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2347
Factoring out RefreshingNameResolver from DnsNameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2348
add support Stetho's interceptor for OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2349
netty: Upgrade to 4.1.6 and tcnative Fork23
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2350
Include SETTINGS_MAX_HEADER_LIST_SIZE in initial SETTINGS.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We currently don't send SETTINGS_MAX_HEADER_LIST_SIZE as part of the initial SETTINGS frame, although we enforce it on the decoder. This is valid as of the H2 spec

For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited.

However, we would argue that we should still include it in the initial SETTINGS frame, cause why not? If both endpoints are gRPC Java, it would also give us better error messages, as then the local encoder would enforce the remote decode limit [1]. However, we can't currently do that cause it seems like a bug in Netty that the encoder throws a connection error and not a stream error [1], bringing down the whole connection, while only the stream should fail. I ll open a issue/PR in Netty.
[1] https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java#L126
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2351
compiler: lazily generate ServiceDescriptors, and define equality
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2352
How to generate .java files from .proto files in command line using protoc.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Here is my problem, I'm trying to compile my .proto files into .java files to implement it into some android projects. I don't want to compile it using gradle or maven because I don't want to compile my .proto file with my whole projects. I just want to compile it using protoc like how I'm doing for objective-c or nodeJS, but I didn't find the Javalite plugin for grpc.
Do you know any ways to do it ?
Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2353
examples: unit test examples for users
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2354
generated java stub is not mockable 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when we upgrade to grpc 1.0.0, the generated java stub is a static final class without implement any interface. as a result it's impossible to use mockito to mock the stub in unit test to verify the business logic without communicating with the real grpc server.
protobuf {
    protoc {
        // The version of protoc must match protobuf-java. If you don't depend on
        // protobuf-java directly, you will be transitively depending on the
        // protobuf-java version that grpc depends on.
        artifact = "com.google.protobuf:protoc:3.0.2"
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0'
        }
    }

    generateProtoTasks.generatedFilesBaseDir = "${projectDir}/src/generated"

    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
    }
}

/**
   */
  public static final class FilterManagerServiceStub extends io.grpc.stub.AbstractStub<FilterManagerServiceStub> {
    private FilterManagerServiceStub(io.grpc.Channel channel) {
      super(channel);
    }

    private FilterManagerServiceStub(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      super(channel, callOptions);
    }

    @java.lang.Override
    protected FilterManagerServiceStub build(io.grpc.Channel channel,
        io.grpc.CallOptions callOptions) {
      return new FilterManagerServiceStub(channel, callOptions);
    }

    /**
     */
    public void create(io.practiceinsight.licensingalert.filtermanager.generated.CreateFilterRequest request,
        io.grpc.stub.StreamObserver<io.practiceinsight.licensingalert.filtermanager.generated.FilterCreated> responseObserver) {
      asyncUnaryCall(
          getChannel().newCall(METHOD_CREATE, getCallOptions()), request, responseObserver);
    }

    /**
     */
    public void findForUser(io.practiceinsight.licensingalert.filtermanager.generated.FindFiltersForUserRequest request,
        io.grpc.stub.StreamObserver<io.practiceinsight.licensingalert.filtermanager.generated.FindFiltersResult> responseObserver) {
      asyncUnaryCall(
          getChannel().newCall(METHOD_FIND_FOR_USER, getCallOptions()), request, responseObserver);
    }

    /**
     */
    public void delete(io.practiceinsight.licensingalert.filtermanager.generated.DeleteFilterRequest request,
        io.grpc.stub.StreamObserver<io.practiceinsight.licensingalert.filtermanager.generated.FilterDeleted> responseObserver) {
      asyncUnaryCall(
          getChannel().newCall(METHOD_DELETE, getCallOptions()), request, responseObserver);
    }

    /**
     */
    public void findAllUsers(io.practiceinsight.licensingalert.filtermanager.generated.FindAllUsersRequest request,
        io.grpc.stub.StreamObserver<io.practiceinsight.licensingalert.filtermanager.generated.AllUsersResponse> responseObserver) {
      asyncUnaryCall(
          getChannel().newCall(METHOD_FIND_ALL_USERS, getCallOptions()), request, responseObserver);
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2355
Update http to grpc mappings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh, look, something I've forgotten about.
So I actually have this mostly implemented (now at ejona86@84d4165), but it isn't as easy as it looks, because of the handling of OK in Http2ClientStream. I was considering whether it was better to just leave 200 == OK, or whether I could wrestle the logic into something sane.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2356
netty: use memory efficient slice in Buffer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2357
ServiceDescriptor lacks validation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ServerServiceDefinition has validation, but it seems that should actually be in ServiceDescriptor (moved or copied). The method names should match the service name, and there shouldn't be two methods with the same name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2358
ServerBuilder defaults affected by Netty memory leak
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GRPC 1.0.0 and 1.0.1 are both based on Netty 4.1.3.Final. This version of Netty is affected by a memory leak bug referenced and fixed in the following commit:
netty/netty@94d7557
The vanilla GRPC ServerBuilder uses a Executors.newCachedThreadPool() executor that expands and contracts based on the load. Any thread that is cleaned up leaks a whole lot of Netty cached data. The workaround is to specify your own Executor that reuses the threads and doesn't recycle them, something like:
ServerBuilder
    .forPort(port)
    .executor(Executors.newFixedThreadPool(8))
    .addService(myService)
    .build()
    .start();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2359
The type io.grpc.Deadline cannot be resolved. It is indirectly referenced from required .class files
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-all-1.0.0 and grpc-all-1.0.1 are build as blank jars hence it could not resolve to its reference.
Any pointers how to resolve this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2360
Proto reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2361
bindService and cglib
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
aService is a cglib proxy class, then I add the service:
serverBuilder.addService(aService.bindService()).
aService.bindService(),the returned ServerServiceDefinition is not what I want because of "this"
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop-understanding-aop-proxies
what should I do?
use grpc v1.0.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2362
core: Update HTTP status to gRPC status mapping
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2363
Handle java.lang.IllegalStateException properly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm currently using gRPC on Android, and it crashes due to the following exceptions:
Case 1:
Fatal Exception: java.lang.IllegalStateException: activeTransport still points to the delayedTransport. Seems transportShutdown() was not called.
       at com.google.common.base.Preconditions.checkState(Preconditions.java:174)
       at io.grpc.internal.TransportSet$TransportListener.transportTerminated(TransportSet.java:495)
       at io.grpc.okhttp.OkHttpClientTransport$ClientFrameHandler.run(OkHttpClientTransport.java:759)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)
       at java.lang.Thread.run(Thread.java:818)

Case 2:
Fatal Exception: java.lang.IllegalStateException
       at com.google.common.base.Preconditions.checkState(Preconditions.java:159)
       at io.grpc.internal.DelayedClientTransport.startBackoff(DelayedClientTransport.java:324)
       at io.grpc.internal.TransportSet$2.run(TransportSet.java:297)
       at io.grpc.internal.TransportSet$TransportListener.transportShutdown(TransportSet.java:477)
       at io.grpc.okhttp.OkHttpClientTransport.startGoAway(OkHttpClientTransport.java:568)
       at io.grpc.okhttp.OkHttpClientTransport.access$1400(OkHttpClientTransport.java:98)
       at io.grpc.okhttp.OkHttpClientTransport$ClientFrameHandler.run(OkHttpClientTransport.java:752)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)
       at java.lang.Thread.run(Thread.java:818)

Is there any way to handle these exceptions before crashing?
Thanks in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2364
NettyTransportTest.frameAfterRstStreamShouldNotBreakClientChannel flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Failed on Travis-CI for OS X (https://travis-ci.org/grpc/grpc-java/jobs/169511662):
io.grpc.netty.NettyTransportTest > frameAfterRstStreamShouldNotBreakClientChannel FAILED
    java.lang.AssertionError: Timed out waiting for server stream
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2365
Add support for http forward proxy with CONNECT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's missing tests, but I think it's ready for first pass.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2366
Add support for keepalive in netty transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 I took a first stab at injecting keepAliveManager logic in netty stack. Please have a quick look and let me know if this is correct.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2367
Bump protobuf to 3.1.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2368
Interop test cases: Unimplemented method and unimplemented service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2369
cherry pick: core: fix race condition for TransportSet scheduleBackoff
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a cherry pick to v1.0.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2370
Provide channel pooling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The client libraries generated by https://github.com/googleapis/toolkit currently create a new channel for every API wrapper object, which is expensive and wasteful. For the benefit of users, we need channel pooling support so that startup time and resource usage is minimized, regardless of how many API wrapper objects are created. The alternatives require more work for users (which is undesirable) or implementing pooling support in the API wrapper layer, which doesn't make sense if grpc is a better place to implement it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2371
How to use load balancer in gRPC V1.0?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I see on the gRPC home page said, V 1.0 already has load balancing capabilities,but did not find any relevant examples.Will be in gRPC V1.0 of how to use load balancing?
Where are the loac balancing examples?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2372
Java QpsWorker produces many exceptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We've recently enabled printing output from QPS workers in the benchmark suite, but the logs are 93MB big, which makes them completely useless.
It seems that it's mostly because java worker is super chatty (tons of exceptions get printed to the console)
https://grpc-testing.appspot.com/view/Performance/job/gRPC_performance_experiment/3192/consoleFull
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2373
How can I config timeout
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I config to let server timeout when a  invoked take a long time, just like HTTP 504?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2374
netty: add channel options in NettyChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seems setting TOS is not allowed in both Jenkins and Travis...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2375
Use provider's class loader instead of context class loader
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In a multi classloader application it may easily turn out Thread#contextClassloader contains something unrelated to a classloader that indeed loads grpc classes.
@Internal
public abstract class ServerProvider {
  private static final ServerProvider provider =
      load(Thread.currentThread().getContextClassLoader());
...
It's better to check current classloader for ServerProvider.class too.
I use JRE 1.8.0_66, macos 10.12
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2376
benchmarks: Avoid sending a message after half close
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, I pushed a cleaner version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2377
Census Race
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Read of size 4 at 0x7f00465dfbcc by thread T123:
    #0 java.nio.Buffer.remaining()I (Buffer.java:391)  
    #1 io.grpc.internal.StatsTraceContext$1.toBytes(Lcom/google/census/CensusContext;)[B (StatsTraceContext.java:151)  
    #2 io.grpc.internal.StatsTraceContext$1.toBytes(Ljava/lang/Object;)[B (StatsTraceContext.java:145)  
    #3 io.grpc.Metadata$BinaryKey.toBytes(Ljava/lang/Object;)[B (Metadata.java:730)  
    #4 io.grpc.Metadata.put(Lio/grpc/Metadata$Key;Ljava/lang/Object;)V (Metadata.java:314)  
    #5 io.grpc.internal.StatsTraceContext.propagateToHeaders(Lio/grpc/Metadata;)V (StatsTraceContext.java:130)  
    #6 io.grpc.internal.ClientCallImpl.prepareHeaders(Lio/grpc/Metadata;Lio/grpc/DecompressorRegistry;Lio/grpc/Compressor;Lio/grpc/internal/StatsTraceContext;)V (ClientCallImpl.java:156)  
    #7 io.grpc.internal.ClientCallImpl.start(Lio/grpc/ClientCall$Listener;Lio/grpc/Metadata;)V (ClientCallImpl.java:211)  
    #8 io.grpc.stub.ClientCalls.startCall(Lio/grpc/ClientCall;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:273)  
    #9 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:252)  
    #10 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;Z)V (ClientCalls.java:240)  
    #11 io.grpc.stub.ClientCalls.asyncUnaryCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;)V (ClientCalls.java:80)  

  Previous write of size 4 at 0x7f00465dfbcc by thread T7 (mutexes: write M771099600033694440, write M323554386926150112):
    #0 java.nio.Buffer.position(I)Ljava/nio/Buffer; (Buffer.java:245)  
    #1 java.nio.HeapByteBuffer.get([BII)Ljava/nio/ByteBuffer; (HeapByteBuffer.java:153)  
    #2 java.nio.ByteBuffer.get([B)Ljava/nio/ByteBuffer; (ByteBuffer.java:715)  
    #3 io.grpc.internal.StatsTraceContext$1.toBytes(Lcom/google/census/CensusContext;)[B (StatsTraceContext.java:152)  
    #4 io.grpc.internal.StatsTraceContext$1.toBytes(Ljava/lang/Object;)[B (StatsTraceContext.java:145)  
    #5 io.grpc.Metadata$BinaryKey.toBytes(Ljava/lang/Object;)[B (Metadata.java:730)  
    #6 io.grpc.Metadata.put(Lio/grpc/Metadata$Key;Ljava/lang/Object;)V (Metadata.java:314)  
    #7 io.grpc.internal.StatsTraceContext.propagateToHeaders(Lio/grpc/Metadata;)V (StatsTraceContext.java:130)  
    #8 io.grpc.internal.ClientCallImpl.prepareHeaders(Lio/grpc/Metadata;Lio/grpc/DecompressorRegistry;Lio/grpc/Compressor;Lio/grpc/internal/StatsTraceContext;)V (ClientCallImpl.java:156)  
    #9 io.grpc.internal.ClientCallImpl.start(Lio/grpc/ClientCall$Listener;Lio/grpc/Metadata;)V (ClientCallImpl.java:211)  
    #10 io.grpc.stub.ClientCalls.startCall(Lio/grpc/ClientCall;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:273)  
    #11 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/ClientCall$Listener;Z)V (ClientCalls.java:252)  
    #12 io.grpc.stub.ClientCalls.asyncUnaryRequestCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;Z)V (ClientCalls.java:240)  
    #13 io.grpc.stub.ClientCalls.asyncUnaryCall(Lio/grpc/ClientCall;Ljava/lang/Object;Lio/grpc/stub/StreamObserver;)V (ClientCalls.java:80)  

cc: @adriancole @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2378
netty: fix static data race on handler settings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2379
OutOfDirectMemoryError in fast stream objects generation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I send a message to a bidi-stream method from a server to a client.
Each message contains 1kb of bytes + several fields.
Server implementation sends 2GB of such messages from a loop without delay
Client consumes messages without delay too.
Currently it fails on the server with a netty error
INFO: [ManagedChannelImpl@39b43d60] Created with target 127.0.0.1:5656
java.lang.RuntimeException: io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 3808428319, max: 3817865216)
    at io.grpc.internal.ServerCallImpl.sendMessage(ServerCallImpl.java:153)
    at io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onNext(ServerCalls.java:287)
    at jetbrains.vcs.server.hosting.rpc.MockSSHServer$ssh$1$onNext$1.run(test.kt:152)
    at jetbrains.vcs.server.test.util.ThreadsUtil.lambda$catchAllAsRunnable$3(ThreadsUtil.java:77)
    at java.lang.Thread.run(Thread.java:745)
Caused by: io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 3808428319, max: 3817865216)
    at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:613)
    at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:567)
    at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:686)
    at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:675)
    at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:237)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:213)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:141)
    at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:262)
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:179)
    at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115)
    at io.grpc.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:66)
    at io.grpc.internal.MessageFramer.writeKnownLength(MessageFramer.java:190)
    at io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:149)
    at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:126)
    at io.grpc.internal.AbstractStream2.writeMessage(AbstractStream2.java:70)
    at io.grpc.internal.ServerCallImpl.sendMessage(ServerCallImpl.java:146)
    ... 4 more

Quickly checked the code. Not sure if it is able to limit sending buffer by blocking a StreamObserver#onNext calls once sending buffer is full.
macos 10.12, java 1.8.0_66, 16GB RAM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2380
Proto reflection - compiler and core changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This CL is still too big.  Can you split the compiler changes apart from the rest of this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2381
core: support sending request message using GET verb for server caching
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I changed mind. Now I only modify the ClientStream.start to take an additional Metadata parameter instead of adding a new API.
It's much easier and all we needed to do is to delay starting a stream in ClientCallImpl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2382
core: make max message size part of the public API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2383
android-interop-testing: use new channel builder size limit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2384
interop-testing: fix lint errors found on import
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2385
testing: make all of StreamRecorder threadsafe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2386
Proto reflection API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo @ejona86  - fyi, I updated this to match the merged PR for the compiler changes #2380
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2387
client can not connect to server when server has more than 61000 connections.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to test grpc performance, and I have 4 centos6.5, and update configure to allow 2000000 tcp connections.
And i use example of "route_guide" to test, just change logic of "func (s *routeGuideServer) ListFeatures" make it not return and send message to stream each 10 seconds on server side.
It's works well when connect 60000 clients, and all clients can receive message from server.
But i got error like: "2016/10/28 10:50:08 &{0xc8648f4b40}.ListFeatures(_) = _, rpc error: code = 14 desc = grpc: the connection is unavailable".
and some of others client got error like: "2016/10/28 10:50:08 grpc: addrConn.resetTransport failed to create client transport: connection error: desc = "transport: dial tcp 10.204.10.36:10000: getsockopt: connection timed out"; Reconnecting to {10.204.10.36:10000 }"
I want to know is this a system configure problem or just a bug?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2388
New deadlock in TransportSet and GrpcTimer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have encountered a new deadlock in TransportSet. I'm running under v1.0 with #2258 cherry-picked.

Found one Java-level deadlock:
"consumer-63":
waiting to lock monitor 0x00007f7ea408ca78 (object 0x0000000733ee5700, a java.lang.Object),
which is held by "consumer-35"
"consumer-35":
waiting to lock monitor 0x00007f7e9052a3c8 (object 0x000000070c6272f0, a java.lang.Object),
which is held by "grpc-timer-0"
"grpc-timer-0":
waiting to lock monitor 0x00007f7ea408ca78 (object 0x0000000733ee5700, a java.lang.Object),
which is held by "consumer-35"
Java stack information for the threads listed above:
"consumer-63":
at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:118)

waiting to lock <0x0000000733ee5700> (a java.lang.Object)
at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
at //.GrpcService$1$1.start(GrpcService.java:190)
at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:135)

"consumer-35":
at io.grpc.internal.InUseStateAggregator.updateObjectInUse(InUseStateAggregator.java:50)

waiting to lock <0x000000070c6272f0> (a java.lang.Object)
at io.grpc.internal.TransportSet$BaseTransportListener.transportInUse(TransportSet.java:357)
at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:128)
locked <0x0000000733ee5700> (a java.lang.Object)
at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
at //.GrpcService$1$1.start(GrpcService.java:190)
at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:135)

"grpc-timer-0":
at io.grpc.internal.DelayedClientTransport.hasPendingStreams(DelayedClientTransport.java:283)

waiting to lock <0x0000000733ee5700> (a java.lang.Object)
at io.grpc.internal.TransportSet$1EndOfCurrentBackoff.run(TransportSet.java:246)
locked <0x000000070c6272f0> (a java.lang.Object)
at io.grpc.internal.LogExceptionRunnable.run(LogExceptionRunnable.java:56)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2389
switch to a logging library from JUL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently JUL logger is used. It cannot be controlled well in multi-classloader applications. For example Servlet API containers.
From a web application point of view it's a hacky to configure JUL explicitly from there. The best way to configure logging in that case is to isolate if from container logging (and possible other applications).
Isolation is implemented as easy as including logger libraries into application package. This makes a container to load logger classes along with the app, and thus all logger configuration that is done on application level is not shared to the whole JVM.
This trick does not work well with java.util.logging (JUL). It is a part of JVM, so one cannot load those classes on application-level classloader. So any attempt to configure JUL from application will make this visible to the whole JVM and vice versa.
Switching to any Logging library (which in not a part of JRE) will solve the issue and adds more flexibility for library users. Moreover, it's likely such library is already in classpath of most apps.
For example, slf4j-api is the minimalistic logging library that allows to use any logging backend
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2390
Does gRPC-java supports http2-stream-priority?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If yes, How to use it? Is there an example?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2391
Service account to JWT token upgrade fails when no scopes provided
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Apologies for the poor wording - I don't know enough about the details to term this properly.
Here's a small piece of code using the Monitoring library at https://github.com/GoogleCloudPlatform/google-cloud-java
package monitoringbug;

import com.google.api.MetricDescriptor;
import com.google.cloud.monitoring.spi.v3.MetricServiceApi;

public class App 
{
    public static void main( String[] args ) throws Exception
    {
        System.out.println("Environment: " + System.getenv("GOOGLE_APPLICATION_CREDENTIALS"));
        MetricServiceApi api = MetricServiceApi.create();
        System.out.println("Created API");
        for (MetricDescriptor descriptor : api.listMetricDescriptors("projects/jonskeet-uberproject", "").iterateAllElements()) {
            System.out.println(descriptor);
        }
        System.out.println("Done");
    }
}
Without GOOGLE_APPLICATION_CREDENTIALS set, this runs and outputs some metric descriptors. With the environment variable set to my service account JSON file, I get:
Exception in thread "main" com.google.api.gax.grpc.ApiException: io.grpc.StatusRuntimeException: UNAUTHENTICATED
	at com.google.api.gax.grpc.ExceptionTransformingCallable$1.onFailure(ExceptionTransformingCallable.java:91)
	at com.google.common.util.concurrent.Futures$6.run(Futures.java:1764)
	at com.google.common.util.concurrent.MoreExecutors$DirectExecutor.execute(MoreExecutors.java:456)
	at com.google.common.util.concurrent.AbstractFuture.executeListener(AbstractFuture.java:817)
	at com.google.common.util.concurrent.AbstractFuture.addListener(AbstractFuture.java:595)
	at com.google.common.util.concurrent.Futures.addCallback(Futures.java:1776)
	at com.google.common.util.concurrent.Futures.addCallback(Futures.java:1713)
	at com.google.api.gax.grpc.ExceptionTransformingCallable.futureCall(ExceptionTransformingCallable.java:66)
	at com.google.api.gax.grpc.RetryingCallable$Retryer.run(RetryingCallable.java:129)
	at com.google.api.gax.grpc.RetryingCallable.futureCall(RetryingCallable.java:85)
	at com.google.api.gax.grpc.ChannelBindingCallable.futureCall(ChannelBindingCallable.java:64)
	at com.google.api.gax.grpc.PageImpl.<init>(PageImpl.java:63)
	at com.google.api.gax.grpc.PagedListResponseImpl.<init>(PagedListResponseImpl.java:57)
	at com.google.api.gax.grpc.PageStreamingCallable.futureCall(PageStreamingCallable.java:64)
	at com.google.api.gax.grpc.ApiCallable.futureCall(ApiCallable.java:237)
	at com.google.api.gax.grpc.ApiCallable.futureCall(ApiCallable.java:248)
	at com.google.api.gax.grpc.ApiCallable.call(ApiCallable.java:285)
	at com.google.cloud.monitoring.spi.v3.MetricServiceApi.listMetricDescriptors(MetricServiceApi.java:563)
	at com.google.cloud.monitoring.spi.v3.MetricServiceApi.listMetricDescriptors(MetricServiceApi.java:535)
	at mavendemo.monitoring.App.main(App.java:13)
Caused by: io.grpc.StatusRuntimeException: UNAUTHENTICATED
	at io.grpc.Status.asRuntimeException(Status.java:545)
	at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:442)
	at io.grpc.ClientInterceptors$CheckedForwardingClientCall.start(ClientInterceptors.java:203)
	at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
	at com.google.api.gax.grpc.HeaderInterceptor$1.start(HeaderInterceptor.java:64)
	at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
	at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
	at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
	at com.google.api.gax.grpc.DirectCallable.futureCall(DirectCallable.java:58)
	at com.google.api.gax.grpc.ExceptionTransformingCallable.futureCall(ExceptionTransformingCallable.java:65)
	... 12 more
Caused by: java.io.IOException: Scopes not configured for service account. Scoped should be specifed by calling createScoped or passing scopes to constructor.
	at com.google.auth.oauth2.ServiceAccountCredentials.refreshAccessToken(ServiceAccountCredentials.java:186)
	at com.google.auth.oauth2.OAuth2Credentials.refresh(OAuth2Credentials.java:97)
	at com.google.auth.oauth2.OAuth2Credentials.getRequestMetadata(OAuth2Credentials.java:74)
	at io.grpc.auth.ClientAuthInterceptor.getRequestMetadata(ClientAuthInterceptor.java:150)
	at io.grpc.auth.ClientAuthInterceptor.access$100(ClientAuthInterceptor.java:64)
	at io.grpc.auth.ClientAuthInterceptor$1.checkedStart(ClientAuthInterceptor.java:96)
	at io.grpc.ClientInterceptors$CheckedForwardingClientCall.start(ClientInterceptors.java:195)
	... 19 more

This is due to the scopes not being configured in the generated code - we're fixing that side of things, but we gather that gRPC design should allow service accounts to work without scopes being configured, as part of using JWT tokens.
The same failure occurs in C#, which is obviously a separate implementation - I'll be filing a separate bug for that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2392
Restricted App Engine auth workaround
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2393
Create issue template
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should probably ask for version, JVM, stack trace, error details, etc. It can probably just move part of CONTRIBUTING into it.
To avoid polluting root folder even more, probably want to use the .github/ISSUE_TEMPLATE variety.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2394
Error on gradlew build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting the attached error on building the examples. I have gradle.properties file in grpc-java\examples folder that has one property , which is skipCodegen=true
C:\gRPC\grpc-java\examples>gradlew build --stacktrace
:extractIncludeProto UP-TO-DATE
:extractProto UP-TO-DATE
:generateProto UP-TO-DATE
:compileJava
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:299: error: illegal character: '\u2020'
      double â•§Ã¥1 = toRadians(lat1);
              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:300: error: illegal character: '\u2020'
      double â•§Ã¥2 = toRadians(lat2);
              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:301: error: illegal character: '\u201d'
      double â•¬Ã¶â•§Ã¥ = toRadians(lat2 - lat1);
              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:301: error: illegal character: '\u2020'
      double â•¬Ã¶â•§Ã¥ = toRadians(lat2 - lat1);
                ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:301: error: not a statement
      double â•¬Ã¶â•§Ã¥ = toRadians(lat2 - lat1);
               ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:302: error: illegal character: '\u201d'
      double â•¬Ã¶â•¬â•— = toRadians(lon2 - lon1);
              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:302: error: illegal character: '\u00bb'
      double â•¬Ã¶â•¬â•— = toRadians(lon2 - lon1);
                ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:302: error: not a statement
      double â•¬Ã¶â•¬â•— = toRadians(lon2 - lon1);
               ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u201d'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                      ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u2020'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                        ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                       ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u201d'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                      ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u2020'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                        ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                       ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u2020'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                      ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                       ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: ';' expected
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                        ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u2020'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                 ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                  ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: ';' expected
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                   ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u201d'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                            ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u00bb'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                             ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u201d'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                                            ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: illegal character: '\u00bb'
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                                              ^
C:\gRPC\grpc-java\examples\src\main\java\io\grpc\examples\routeguide\RouteGuideServer.java:304: error: not a statement
      double a = sin(â•¬Ã¶â•§Ã¥ / 2) * sin(â•¬Ã¶â•§Ã¥ / 2) + cos(â•§Ã¥1) * cos(â•§Ã¥2) * sin(â•¬Ã¶â•¬â•— / 2) * sin(â•¬Ã¶â•¬â•— / 2);
                                                                                             ^
26 errors
:compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --info or --debug option to get more log output.

* Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':compileJava'.
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:69)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
        at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:68)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:203)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:185)
        at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:66)
        at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:50)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:25)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:110)
        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:37)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
        at org.gradle.execution.DefaultBuildExecuter.access$000(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$1.proceed(DefaultBuildExecuter.java:43)
        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:30)
        at org.gradle.initialization.DefaultGradleLauncher$4.run(DefaultGradleLauncher.java:154)
        at org.gradle.internal.Factories$1.create(Factories.java:22)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:52)
        at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:151)
        at org.gradle.initialization.DefaultGradleLauncher.access$200(DefaultGradleLauncher.java:32)
        at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:99)
        at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:93)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:62)
        at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:93)
        at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:82)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:94)
        at org.gradle.tooling.internal.provider.ExecuteBuildActionRunner.run(ExecuteBuildActionRunner.java:28)
        at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:43)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:28)
        at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:81)
        at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:46)
        at org.gradle.launcher.exec.DaemonUsageSuggestingBuildActionExecuter.execute(DaemonUsageSuggestingBuildActionExecuter.java:51)
        at org.gradle.launcher.exec.DaemonUsageSuggestingBuildActionExecuter.execute(DaemonUsageSuggestingBuildActionExecuter.java:28)
        at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:43)
        at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:173)
        at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:241)
        at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:214)
        at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35)
        at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24)
        at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:207)
        at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169)
        at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
        at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
        at org.gradle.launcher.Main.doAction(Main.java:33)
        at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
        at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:55)
        at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:36)
        at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
        at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30)
        at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:129)
        at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)
Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output for details.
        at org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:48)
        at org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:33)
        at org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.delegateAndHandleErrors(NormalizingJavaCompiler.java:104)
        at org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:53)
        at org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:38)
        at org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:35)
        at org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:25)
        at org.gradle.api.tasks.compile.JavaCompile.performCompilation(JavaCompile.java:163)
        at org.gradle.api.tasks.compile.JavaCompile.compile(JavaCompile.java:145)
        at org.gradle.api.tasks.compile.JavaCompile.compile(JavaCompile.java:93)
        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute(AnnotationProcessingTaskFactory.java:245)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:221)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute(AnnotationProcessingTaskFactory.java:232)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:210)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
        ... 60 more


BUILD FAILED

Total time: 7.853 secs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2395
Avoiding unbalanced backends with server-side load balancing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One of our use cases is a server-side application which must connect to a pool of backends through a layer 4 load balancer.  By default grpc-java opens only a single, long-lived channel to the backend.  So if we have 4 clients with 4 backends, the best distribution is a single connection from each client to each backend.
There are two problems with this: 1) each client directly determines the load placed on its backend, and 2) during rolling backend deployments, the connections are redistributed to all backends except the last one deployed.
To work around these issues, I attempted to add client-side load balancing with a list of identical backend endpoints.  After a lot of poking (and finally understanding the existing DnsNameResolver, etc), I realized this wasn't going to work.  Finally I settled on a custom pool of client channels that I use in a round-robin fashion.
Unfortunately even this is imperfect because I need must limit the lifetime of a channel to avoid backends becoming unbalanced for extended periods after backend re-deployment.  Is an interceptor the best (only?) way to achieve a maximum channel lifetime?
@zhangkun83  (I mentioned this issue briefly on IRC a couple of months ago).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2396
ProtoUtil.jsonMarshaller can be supplied a JsonFormat Parser and Printer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2397
Error converting bytecode to dex: Cause: Dex cannot parse version 52 byte code.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I'm trying to build an APK for my project, I encountered the following error.
Error: Error converting bytecode to dex:
Cause: Dex cannot parse version 52 byte code.
This is caused by library dependencies that have been compiled using Java 8 or above.
If you are using the 'java' gradle plugin in a library submodule add 
targetCompatibility = '1.7'
sourceCompatibility = '1.7'
to that submodule's build.gradle file.

Seems that some of the libraries are getting compiled into Java 8 bytecode, which won't be compatible with current javac. I had to use jack with the new bytecode which takes minutes on a debug build and it is very annoying.
My app/build.gradle is set up according to the one in protobuf-gradle-plugin:
apply plugin: 'com.android.application'

def gitSha1 = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()

apply from: '../signing.gradle'

android {
    compileSdkVersion 25
    buildToolsVersion "25"
    defaultConfig {
        applicationId "<some.application.id>"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 2
        versionName "1.0.0"
        buildConfigField "String", "GIT_SHA1", "\"${gitSha1}\""
        resValue 'string', 'application_id', applicationId
        jackOptions {
            enabled false
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_7
        targetCompatibility = JavaVersion.VERSION_1_7
    }
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
    }
}
apply plugin: 'com.google.protobuf'
protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.0.2'
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.1'
        }
        javalite {
            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'
        }
    }
    generateProtoTasks {
        all()*.plugins {
                grpc {
                    option 'lite'
                }
                javalite {}
        }
    }
}

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
    }
}
apply plugin: 'android-apt'

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])

    compile 'com.android.support:appcompat-v7:25.0.0'
    compile 'com.android.support:design:25.0.0'

    compile 'com.google.android.gms:play-services-auth:9.8.0'

    compile 'com.google.protobuf:protobuf-lite:3.0.0'
    compile 'com.squareup.okhttp:okhttp:2.7.5'
    compile 'io.grpc:grpc-core:1.0.1'
    compile 'io.grpc:grpc-okhttp:1.0.1'
    compile ('io.grpc:grpc-protobuf-lite:1.0.1') {
        // Otherwise Android compile will complain "Multiple dex files define ..."
        exclude module: 'protobuf-lite'
    }
    compile 'io.grpc:grpc-stub:1.0.1'
    compile 'javax.annotation:javax.annotation-api:1.3'

    compile "com.andkulikov:transitionseverywhere:1.6.9"
    compile 'com.github.bumptech.glide:glide:3.7.0'
    compile 'com.github.bumptech.glide:okhttp-integration:1.4.0@aar'
    compile 'com.jakewharton:butterknife:8.4.0'
    compile 'com.jakewharton.threetenabp:threetenabp:1.0.4'
    apt 'com.jakewharton:butterknife-compiler:8.4.0'
    compile 'com.squareup.okhttp3:okhttp:3.4.1'
    compile 'org.greenrobot:eventbus:3.0.0'
    compile 'me.zhanghai.android.materialedittext:library:1.0.5'
    compile 'me.zhanghai.android.materialprogressbar:library:1.3.0'
}
$ uname -a
Linux ZH-Laptop 4.8.4-1-ARCH #1 SMP PREEMPT Sat Oct 22 18:26:57 CEST 2016 x86_64 GNU/Linux
$ java -version
openjdk version "1.8.0_112"
OpenJDK Runtime Environment (build 1.8.0_112-b15)
OpenJDK 64-Bit Server VM (build 25.112-b15, mixed mode)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2398
Re-introduce service interfaces
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Stub interfaces were generated prior to gRPC 1.0. It was since removed and now we are forced to extend a base class.
Interface is the contract for the service - it'd be great to generate the interface as well. If keeping the base abstract class, the base abstract class should implement the interface as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2399
benchmarks: check shutdown after acquiring a token, and weak error messages on shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2400
Run a grpc application not working
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According to link http://www.grpc.io/docs/quickstart/java.html#run-a-grpc-application , I must follow the below steps to execute a hello world sample client and server.
From the examples directory:
$ ./gradlew installDist
$ ./build/install/examples/bin/hello-world-server
$ ./build/install/examples/bin/hello-world-client

I am using Windows machine , so gradlew installDist command works for me. But after that, there is no build/install/examples/bin folder structure to execute hello-world-server.
There is a hello-world-server in examples\build\tmp folder, but that too gives following error
Error: Could not find or load main class io.grpc.examples.helloworld.HelloWorldServer
Please help
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2401
all: update to gradle 2.14.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2402
github: add an issue template
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2403
benchmarks: print gc detail and vm flags for benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2404
Typo in version number
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2405
core: MutableHandlerRegistry#addService with BindableService arg
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2406
benchmarks spend lots of time parking and unparking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Running the benchmarks with profiling turned on shows that ForkJoinPool is spending a lot of time parking and unparking itself.
      flat  flat%   sum%        cum   cum%
 12.42mins 77.35% 77.35%  12.59mins 78.39%  pthread_cond_wait@@GLIBC_2.3.2 ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
  0.99mins  6.17% 83.52%   1.06mins  6.59%  pthread_cond_timedwait@@GLIBC_2.3.2 ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
  0.89mins  5.56% 89.07%   0.89mins  5.56%  GC
  0.38mins  2.38% 91.45%   0.38mins  2.38%  __epoll_wait_nocancel ../sysdeps/unix/syscall-template.S
  0.25mins  1.53% 92.98%   0.25mins  1.53%  __lll_lock_wait ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
  0.23mins  1.40% 94.38%   0.23mins  1.40%  pthread_cond_signal@@GLIBC_2.3.2 ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
  0.17mins  1.04% 95.42%   0.17mins  1.04%  Native
  0.14mins  0.85% 96.28%   0.14mins  0.85%  __lll_unlock_wake ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
  0.12mins  0.73% 97.01%   0.14mins  0.85%  [libnetty-tcnative-linux-x86_642288772925992928556.so]
  0.02mins  0.12% 97.13%  14.37mins 89.50%  <unknown>
  0.02mins  0.12% 97.25%   0.14mins  0.85%  io.netty.handler.ssl.SslHandler.wrap SslHandler.java
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2407
core: fix bug when stream listener not set before stream closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2408
Jetty ALPN/NPN has not been properly configured
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc0.14.0
jdk 1.8
netty-tcnative-boringssl-static 1.1.33.Fork14
when I start server on windows,it prints "Jetty ALPN/NPN has not been properly configured",But it works properly on Linux and MacOs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2409
BlockingStub returns iterator that cannot be closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use a blocking sub for a method that returns a stream of messages. The return type of it is Iterator<T>. It turns out I cannot make grpc client to end the request (e.g. because of client failure). There are a number of cases where an open connection may stuck in client because of that
The implementation uses
io.grpc.stub.ClientCalls#blockingServerStreamingCall(io.grpc.Channel, io.grpc.MethodDescriptor<ReqT,RespT>, io.grpc.CallOptions, ReqT)
call, which in turn uses BlockingResponseStream. There is no way to reach the io.grpc.ClientCall#cancel method form the Iterator. Could be nice to wrap an Iterator or make it implement an interface in the similar way as done with ServerStreamObserver/ClientStreamObserver
The other approach could be to implement AutoCloseable from Java with this iterator
There is also a comment on the Iterator implementation class
  // TODO(ejona86): determine how to allow ClientCall.cancel() in case of application error.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2410
benchmarks: reuse executor between channels
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
oh wow. good catch carl!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2411
how to use serverIntercepter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc1.0.1
how to use serverIntercepter,I want to intercept some of the methods of a service
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2412
Does gRPC support push notifications from the server to the client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does gRPC support push notifications from the server to the client? Client to establish a connection, registration, if the server has to trigger events to the client, through the channel to find the client to send the connection, and then push the message to the specified client.
the example of a stream response: StreamObserver, if I do not call onCompleted method, whether this link can continue to push the message? How to get the designated client channel?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2413
interop-testing: new stress test client command line options
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This modifies the stress test client to accept the same --use_tls, --use_test_ca, and --server_host_override arguments as the interop client.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2414
OkHttpChannelBuilder doesn't work 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in android high level platform ,OkHttpChannelBuilder works fine, but in android level 17 platform   , it logs out ï¼š
E/GrpcService: java.lang.NoClassDefFoundError: io.grpc.okhttp.OkHttpChannelBuilder
is the everyone meet the same problem ? if you know that, please tell me , thank you guys !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2415
using java.util.logging.Logger may cause ClassNotFound in javaagent for JBoss
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
3.0.0
What JVM are you using (java -version)?
java version "1.7.0_67"
Java(TM) SE Runtime Environment (build 1.7.0_67-b01)
Java HotSpot(TM) 64-Bit Server VM (build 24.65-b04, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
ClassNotFoundException
What did you expect to see?
What did you see instead?

I am developing a javaagent project, as a instrument of JBoss 8.0 .
I use protobuf 3.0.0, the manifest info is following:
Manifest-Version: 1.0
Bnd-LastModified: 1469731108499
Build-Jdk: 1.8.0_45
Built-By: root
Bundle-Description: Core Protocol Buffers library. Protocol Buffers are 
 a way of encoding structured data in an    efficient yet extensible for
 mat.
Bundle-DocURL: https://developers.google.com/protocol-buffers/
Bundle-License: http://www.opensource.org/licenses/bsd-license.php
Bundle-ManifestVersion: 2
Bundle-Name: Protocol Buffers [Core]
Bundle-SymbolicName: com.google.protobuf
Bundle-Vendor: Google
Bundle-Version: 3.0.0
Created-By: Apache Maven Bundle Plugin
Export-Package: com.google.protobuf;version="3.0.0"
Import-Package: com.google.protobuf;version="[3.0,4)",sun.misc
Require-Capability: osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.6))"
Tool: Bnd-3.0.0.201509101326
When I use map<int32,string> defined a field, and use putAll method. Somehow, class Descriptors is loaded by classloader. And this trigger Logger.getLogger(Descriptors.class.getName()).
As we known, LogManager is necessary for java.util.logging.* . The static block of LogManager is using System.getProperty("java.util.logging.manager") to init.
In JBOSS, it will set java.util.logging.manager to a JBOSS class. So, when I run code in premain, I can't access to the LogManager, it trigger ClassNotFound.
I recommend not to use java.util.logging directly. I think the better way to create a LogResolver in grpc-java. LogResolver will only choose java.util.logging as default logger, and provide api to set other implements.
And the most important, LogResolver should not trigger ClassLoader to load java.util.logging.
Does this seem good to you?
If you are agree with me, I want to send a pull request to fix this problem. And we discuss further in that rp?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2416
Remove UTF-8 symbols in example to simplify compilation for most people.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2417
README - note for protobuf-maven-plugin in Eclipse
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2418
error: incompatible types: ServiceDescriptor cannot be converted to String
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8.0_102
What did you do?
If possible, provide a recipe for reproducing the error.
build app with gradle
What did you expect to see?
build app
What did you see instead?
For all grpc protos:
error: incompatible types: ServiceDescriptor cannot be converted to String
      return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())

Here is my build.gradle:
dependencies {
    compile 'com.google.protobuf:protobuf-java:3.1.0'
    compile 'io.grpc:grpc-netty:1.0.1'
    compile 'io.grpc:grpc-protobuf:1.0.1'
    compile 'io.grpc:grpc-stub:1.0.1'
...
}

protobuf {
    protoc {
        // The artifact spec for the Protobuf Compiler.
        artifact = 'com.google.protobuf:protoc:3.1.0'
    }
    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.0.1'
        }
    }
    generateProtoTasks {
        all()*.plugins {
            grpc {
                option 'enable_deprecated=false'
            }
        }
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2419
core,netty: quick patch for setListener regression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2420
doc: link to IDE-specific docs for os-maven-plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Big thanks, that will save time for other users
and me (not having to keep it in mind)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2421
core: fix a benign data race in NoopCensusContextFactory.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for taking care of this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2422
all: cleanup - errorprone, unused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2423
Provide access to Method options in ServerInterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like to be able to see the options on the method being called in a ServerInterceptor interceptCall method.
Is this currently possible, or are there plans to provide this?
Currently, a io.grpc.MethodDescriptor is available from the ServerCall.  This doesn't have the option data though.  I need a com.google.protobuf.Descriptors.MethodDescriptor, which I can't seem to easily access.
My use case:  I am writing an interceptor that provides user authentication.  I would like to add a custom option to the rpc methods in the proto files to indicate if a method requires authentication or not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2424
gRPC stream client OutOfDirectMemoryError, when send ton of data
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
Netty OutOfDirectMemoryError
What did you expect to see?
send data as quickly as possible
What did you see instead?
not to trigger OutOfDirectMemoryError
ref issue: #2247
test case:
for (int i = 0; i < 1000000; i++) {
            StreamObserver<RequestSpan> requestSpanStreamObserver =
                    spanStorageServiceStub.storageRequestSpan(new StreamObserver<SendResult>() {
                        @Override
                        public void onNext(SendResult sendResult) {

                        }

                        @Override
                        public void onError(Throwable throwable) {
                            throwable.printStackTrace();
                        }

                        @Override
                        public void onCompleted() {
                            endTime2 = System.currentTimeMillis();
                        }
                    });
            for (int j = 0; j < 10; j++) {
                requestSpanStreamObserver.onNext(requestSpan);
            }

            ClientCallStreamObserver<RequestSpan> newRequestSpanStreamObserver =
                    (ClientCallStreamObserver<RequestSpan>) requestSpanStreamObserver;

            while (!newRequestSpanStreamObserver.isReady()) {
                Thread.sleep(1);
            }

            ackSpanStreamObserver.onCompleted();
            requestSpanStreamObserver.onCompleted();
This single thread code send ton of data to server,  casue OutOfDirectMemoryError. more discussion detail, see the ref issue #2247
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2425
Android examples don't obey Min API level
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.../git/grpc-java/examples/android/helloworld/app/src/main/java/io/grpc/helloworldexample/HelloworldActivity.java:112: Error: Call requires API level 19 (current min is 9): java.lang.System#lineSeparator [NewApi]
                return "Failed... : " + System.lineSeparator() + sw;
                                               ~~~~~~~~~~~~~

Either the min level needs to be raised, or the usage removed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2426
examples: don't use System.lineSeparator if unsupported
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2427
core: InternalSubchannel: the new TransportSet.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc @kkaneda
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2428
Problem with interceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
openjdk version "1.8.0_111"
What did you do?
If possible, provide a recipe for reproducing the error.
Adding an interceptor on the server side of the app gives me:
java.lang.NoClassDefFoundError: io/netty/handler/codec/Headers
If I add the dependency: io.netty:nett-codec:4.1.3-Final to my app, then this happens on the client side after the remote procedure is called:
Exception in thread "grpc-default-executor-1" java.lang.IllegalAccessError: tried to access method io.netty.handler.logging.LogLevel.toInternalLevel()Lio/netty/util/internal/logging/InternalLogLevel; from class io.netty.handler.codec.http2.Http2FrameLogger
	at io.netty.handler.codec.http2.Http2FrameLogger.<init>(Http2FrameLogger.java:54)
	at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:140)
	at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:123)
	at io.grpc.netty.NettyClientTransport.newHandler(NettyClientTransport.java:251)
	at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:140)
	at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:45)
	at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:222)
	at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:192)
	at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:637)
	at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:579)
	at io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer$1.get(DummyLoadBalancerFactory.java:135)
	at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:262)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
What did you expect to see?
Nothing.
What did you see instead?
A Stacktrace.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2429
Proper handling of server stubs that throw?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
throw new RuntimeException() in any server implementation of an rpc defined in your proto
What did you expect to see?
client gets UNKNOWN, close or cancel to eventually be called in the interceptor chain on the server
What did you see instead?
client gets UNKNOWN, and my interceptor chain stops executing in the halfClose (for Unary requests/responses).
I'm wondering, if some interceptors want/need to do cleanup to do things like emit metrics, modify logging MDC in thread locals and such, what should I expect here and be doing?  Is it reasonable to have an exception mapping interceptor that is the last one called right before the actual implementation and if it catches any exception translate it into a close(Status.UNKNOWN, new Metadata()) ?  Should I instead have every interceptor catch exceptions in onHalfClose and onMessage and then bubble it after they do their personal cleanup?  We had up to this point kept our cleanup logic isolated to close(...) and onCancel().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2430
interop-testing: apply --server_host_override regardless of flag order
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2431
netty: call the client ssl negotiation handler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
User visible changes to follow in another PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2432
a better way to convert to a Plain Ordinary Java Object
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
commisson is a model from orm framework,  when provide grpc service like query,I always code like this:
Commisson commission = commissionDao.query(params);
ProductProfit.Builder productProfitBuilder = ProductProfit.newBuilder();
productProfitBuilder.setId(commission.getId());
productProfitBuilder.setProdId(commission.getProductId());
productProfitBuilderÂ .setProdName(commission.getProductName());
........
responseObserver.onValue(productProfitBuilder.build());
then the client get the response,and get the commision againï¼Œbecause the response is a complicated dataï¼Œbut sometimes we want json or a Plain Ordinary Java Object.
commission.setId(response.getId());
commission.setProdId(response.getProductId())
.........
it is a little boring,is there any better way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2433
examples: address ErrorProne and warnings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 FYI, build is broken
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2434
V1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We found a Contributor License Agreement for you (the sender of this pull request) and all commit authors, but as best as we can tell these commits were authored by someone else.  If that's the case,  please add them to this pull request and have them confirm that they're okay with these commits being contributed to Google.  If we're mistaken and you did author these commits, just reply here to confirm.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2435
examples: really fix the loss of precision error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My understanding of the code is that the loss of precision was intentional.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2436
error:  UNAVAILABLE  StatusRuntimeException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I add grpc to my android project , But I meet some UNAVAILABLE problems.  I got some Message from the Excepiton  :   statusCode=14  , and  msg : "Channel shutdownNow invoked"  or  "End of stream or IOException".  It is  a bug  or  something would cause this  problem ? This Exception  is  not alway happen.  Looking forward to your reply.   Thank you.
grpc-java 1.0.1
java -version, 1.8
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2437
ServerServiceDefinition.addMethod fails incorrectly 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
public class MyBindableService implements BindableService {

    @Override
    public ServerServiceDefinition bindService() {

        MethodDescriptor<String, String> myMethodDescriptor = MethodDescriptor.create(
                MethodDescriptor.MethodType.UNARY,
                "/mypage",
                new MyRequestMarshaller<>(),
                new MyResponseMarshaller<>());
        ServiceDescriptor myServiceDescriptor = new ServiceDescriptor(
                "/mypage",
                myMethodDescriptor);
        ServerMethodDefinition<String, String> serverMethodDefinition =
                ServerMethodDefinition.create(myMethodDescriptor,
                new MyServerCallHandler());
        return ServerServiceDefinition.builder(myServiceDescriptor).
                addMethod(serverMethodDefinition).build();
    }
}

What did you expect to see?
This works without problem, the server starts up
What did you see instead?
An error that says the following:
Exception in thread "main" java.lang.IllegalArgumentException: Service name mismatch. Expected service name: '/mypage'. Actual method name: '/mypage'. 
The reason for this is rather interesting, here is the code that generates this in addMethod:
 /** Add a method to be supported by the service. */
    public <ReqT, RespT> Builder addMethod(ServerMethodDefinition<ReqT, RespT> def) {
      MethodDescriptor<ReqT, RespT> method = def.getMethodDescriptor();
      checkArgument(
          serviceName.equals(MethodDescriptor.extractFullServiceName(method.getFullMethodName())),
          "Service name mismatch. Expected service name: '%s'. Actual method name: '%s'.",
          serviceName, method.getFullMethodName());
      String name = method.getFullMethodName();
      checkState(!methods.containsKey(name), "Method by same name already registered: %s", name);
      methods.put(name, def);
      return this;
    }

The problem is that what your outputting as the comparison is not what is actually being compared.  The "extractFullServiceName" method performs the following operation:
  public static String extractFullServiceName(String fullMethodName) {
    int index = fullMethodName.lastIndexOf('/');
    if (index == -1) {
      return null;
    }
    return fullMethodName.substring(0, index);
  }

Which normalizes in some weird way the method name, but this only happens in the above code to the MethodDescriptor, but not to the serviceName, this leads to a mismatch, and then you print out a wrong mismatch as well.  This is broken.  The other problem, is that even if you passed in just "mypage" for both values, the noramalization results in an empty string while the other one has a full string, and thus the test fails again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2438
travis: Use default OS X image (xcode7.3)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2439
travis: Remove old comment for broken OS X caching
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2440
Remove RoundRobinLoadBalancerFactory access to RoundRobinServerList
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.grpc has been removing references to io.grpc.internal for some time now.  The last of these appears to be RoundRobinLoadBalancerFactory which imports from io.grpc.internal.RoundRobinServerList
This makes it hard to separate internal details from public interface.  We should remove it.
cc: @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2441
core: reverse dependency from core/internal classes, so that it is now one directional.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2442
Create point release, then bump.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2443
core: LoadBalancer2 and DelayedClientTransport.reprocess().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2444
Non-determinism when using InProcessTransport with direct executors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8.0_101
What did you do?
I am attempting to write unit tests for RPC systems without mocking stubs, which would be lovely if it worked. Recent discussions (e.g. here, 1.0.1 release notes, this example) suggest this is the new done thing and is supposed to work. To this end I am running an InProcessServer and calling it over an InProcessChannel with both ends using a DirectExecutor.
What did you expect to see?
The 1.0.1 release notes imply that this is now deterministic (after the removal of the grpc-ready thread pool, which was causing issues for me before), so I expected to see determinism in my unit test, and for the server handler to be called on the same thread that made the stub method call. The RPC method is a client-side streaming RPC, but I don't know if that is relevant.
What did you see instead?
The unit test is not deterministic, since the service handler seems to end up being called on a grpc-timer thread provided by the ScheduledExecutorService created by GrpcUtil.TIMER_SERVICE. The task that causes the call is  the NameResolverStartTask in ManagedChannelImpl, and there appears to be no way to provide an alternative timer service.
See ManagedChannelImpl.java line 307.
For reference, the stack trace that I see on the handler side is as follows:
        ...
	at foo.bar.FooServiceImpl$1.onNext(FooServiceImpl.java:33)
	at io.grpc.stub.ServerCalls$2$1.onMessage(ServerCalls.java:206)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messageRead(ServerCallImpl.java:237)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1.runInContext(ServerImpl.java:485)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializeReentrantCallsDirectExecutor.execute(SerializeReentrantCallsDirectExecutor.java:65)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener.messageRead(ServerImpl.java:481)
	at io.grpc.inprocess.InProcessTransport$InProcessStream$InProcessClientStream.writeMessage(InProcessTransport.java:475)
	at io.grpc.internal.DelayedStream$3.run(DelayedStream.java:201)
	at io.grpc.internal.DelayedStream.drainPendingCalls(DelayedStream.java:121)
	at io.grpc.internal.DelayedStream.setStream(DelayedStream.java:90)
	at io.grpc.internal.DelayedClientTransport$PendingStream.createRealStream(DelayedClientTransport.java:383)
	at io.grpc.internal.DelayedClientTransport$PendingStream.access$100(DelayedClientTransport.java:370)
	at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:262)
	at com.google.common.util.concurrent.MoreExecutors$DirectExecutor.execute(MoreExecutors.java:456)
	at io.grpc.internal.DelayedClientTransport.setTransportSupplier(DelayedClientTransport.java:259)
	at io.grpc.internal.ManagedChannelImpl$InterimTransportImpl.closeWithRealTransports(ManagedChannelImpl.java:740)
	at io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer.handleResolvedAddresses(DummyLoadBalancerFactory.java:133)
	at io.grpc.internal.ManagedChannelImpl$NameResolverListenerImpl.onUpdate(ManagedChannelImpl.java:681)
	at io.grpc.internal.AbstractManagedChannelImplBuilder$DirectAddressNameResolverFactory$1.start(AbstractManagedChannelImplBuilder.java:323)
	at io.grpc.internal.ManagedChannelImpl$1NameResolverStartTask.run(ManagedChannelImpl.java:254)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

Am I doing something wrong? Is there a workaround? It seems like doing the name resolution work on the ManagedChannelImpl's user-provided executor rather than its scheduledExecutor might fix it, but I don't know if there's some reason it's not done that way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2445
A memory leak of Recycler$WeakOrderQueue
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.0 and 1.0.1
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
A huge data send from client, use gprc-java async service. Service define is like this:
service AgentData {
    rpc store (stream AgentDataRequest) returns (ServiceResponse) {}
}

What did you expect to see?
run and send with high performance.
What did you see instead?
A memory leak of Recycler$WeakOrderQueue
@ejona86, a memory leak occurs in my app, a memory analysis is following:

The leak point is very obvious. At the same time, I found too many grpc-default-executors is running, thousands of it.

And I have found #2358 seems to match my issue. But the solution is not very useful, you said should update netty to 4.1.6 and the release is in grpc 1.1 or next 1.0.x , which is not available now.
Is their any solutions? Or can you release hotfix version for 1.0.1, such as 1.0.1.1?
It's a very urgent and mortal issue in my product env.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2446
Generate interface for every service action
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The generated service stubs evolved quite a lot in past few months and I've noticed that we removed service interface in favor of having just an abstract base class, it was indeed redundant and probably not very useful (I don't know if it was solve factor that led to removing it, if not please correct me).
While the per-service interface in the presence of equivalent abstract class might not provide a lot of value (in the context of generated services) I'd like to propose generating per-action interfaces which would be implemented by the base abstract service.
The value of per-action interfaces is that it would allow users to easily build custom service definitions which then would allow custom integrations for frameworks where single action is represented by class (as opposed to one class implementing all actions). This approach is used in many custom frameworks which relay heavily on dependency injection and the main benefit it provides is that in order to test single action, you don't need to provide dependencies for every action of a given service.
I'm open to work on implementation if we reach consensus. The change will be additive and won't break any existing APIs or implementations.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2447
Add Attributes#withKey(Key<T>, T)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmmm... With Context, creating a new instance is cheap (not a full copy). Forcing users to use the builder helps them realize that they should batch any changes. Granted, CallOptions does a full copy while using with*; but we also had decided a while back that we could change to Context-style chaining if we wanted.
Attributes is being used many more places compared to its original design, so maybe a convenience method like this makes sense (or even considering eventually changing its internals).
@zhangkun83, what do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2448
Run NameResolverStartupTask on user-provided executor. Fixes #2444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2449
core: add javadocs to internal methods in MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2450
stub: add withWaitForReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
resolves #2142
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2451
stub: make NoopStreamObserver public
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
languishing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2452
internal/test: make FakeClock more thread-safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would it be easier to use PriorityBlockingQueue instead? It can be unbounded, which means you can use it without ever blocking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2453
Threading of StatsTraceContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
StatsTraceContext assumes non-thread-safety, which is fine as long as the RPC is closed by the application through the ClientCall/ServerCall interface, which are also not thread-safe.
However, if the RPC is not closed by the application, but either cancelled by the other side, or closed by transport due to errors, which will call callEnded() from the transport thread which is not synchronized with  the application thread. As the application may not be notified about the closure in time, it may still trying to send messages, resulting in wireBytesSent() etc being called after callEnded(), which would trigger a check failure. There is also a data race on the counter fields as wireBytesSent() etc write them and callEnded() reads them from different threads without synchronization.
We will remove the preconditions checks from writeBytesSent() etc. For the data race, some kind of synchronization would be required, maybe atomics? @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2454
core: address data race in StatsTraceContext.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2455
compiler: whitelist USER32.DLL.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2456
testing: added junit rule for in-process servers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2457
Http2NettyTest.exchangeMetadataStreamingCall is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://travis-ci.org/grpc/grpc-java/jobs/179640919 (since re-run):
io.grpc.testing.integration.Http2NettyTest > exchangeMetadataStreamingCall FAILED
    java.lang.Exception: test timed out after 10000 milliseconds
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2458
Build with Bazel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would be great to be able to build grpc-java with Bazel.  It looks like there may some ongoing internal efforts to do this.  Any comment on the scope/challenge of this?  Any help needed from the community?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2459
core: Only use scheduled executor for timer tasks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2460
core: improve error message for adding method issue: grpc/grpc-java/issues/â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2461
context: pluggable Storage mechanism.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2462
Context.Storage is experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the tracking issue that will be closed once Context.Storage API exits experimental status.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2463
How can I use OpenTracing api in grpc?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am a member of OpenTracing org. I have known gRPC has supported OT spec.
Where is the doc, provide how I can set tracer to gRPC, or other ways?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2464
a
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2465
Netty  proxy request grpc service error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use  netty  proxy request grpc service  , there  is  error
åä¸€æœˆ 30, 2016 7:19:41 ä¸‹åˆ io.grpc.netty.NettyServerHandler onStreamError
è­¦å‘Š: Stream Error
io.netty.handler.codec.http2.Http2Exception$StreamException: Received HEADERS frame for an unknown stream 3
	at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:127)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.shouldIgnoreHeadersOrDataFrame(DefaultHttp2ConnectionDecoder.java:567)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:299)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:65)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader$1.processFragment(DefaultHttp2FrameReader.java:442)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:449)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:247)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:155)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:113)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:333)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:393)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:571)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)

why?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2466
core: Make tiny fixes to InUseStateAggregator2 and InternalSubchannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2467
core: make Status reference the correct internal Marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2468
core,netty: add onConnection() to ClientStreamListener; add getAttrs() to ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm a bit confused by this. I thought we realized the only use case we had for the Attributes needed a getter, because it would see the Calls after they have already connected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2469
stub: remove a reference to internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Added another file
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2470
reverse proxy
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
imagine there are 10k grpc-clients, they established 10k http2 connections(TCP-connections) with the http2 reverse proxy; then http2 reverse proxy create 10k http2 connections(TCP-connections) to the origin(backend) server.
Is it possible to reduce the 10k connections between proxy and origin(backend) server?
for example, can a connection pool be used in reverse proxy to reduce connections with backend server?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2471
What is the correct way to confirm send is complete? 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
onCompleted means server have proccessed, correct?
My stub is like this
this.spanStorageStub = SpanStorageServiceGrpc.newStub(channel);
Will onError be called when network unconnected? And when unconnected occurs, wil stub reconnect?
I can not found this demo call to show these features for GRPC.
Can anyone confirm for me?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2472
Add toString to descriptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MethodDescriptor, specifically, but it could be helpful for others as well, like ServiceDescriptor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2473
compiler: Explicitly specify std::
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2474
when will gRPC server create a new stream to client?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when will gRPC server create a new stream to client?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2475
core: Fix typos in GrpcUtil
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Loks Gud 2 Mee
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2476
internal: mark internal subchannel methods for override
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2477
all: use a proper log id which can reference channels, subchannels, aâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2478
error: UNAVAILABLE StatusRuntimeException:"End of stream or IOException"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2479
Port PickFirst & RoundRobin LBs to v2 API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2480
Proto reflection service: Optimize handling of dynamic services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The initial proto reflection service (#2386) reloads all proto file descriptors for every request. This was done to avoid checking for any service changes within a mutable fallback registry, but should be optimized to avoid re-processing unchanged services.
This likely requires a minor modification in core to enable the reflection service to distinguish between dynamic and static services.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2481
Remove deadcode
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2482
core,netty: add a log id to the server and server transports
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc: @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2483
Flaky OkHttpTransportTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Build: https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/2587/ (failure)

Error Message: java.io.IOException: Failed to bind
Stacktrace
java.io.IOException: Failed to bind
at io.grpc.netty.NettyServer.start(NettyServer.java:160)
at io.grpc.internal.testing.AbstractTransportTest.openStreamPreventsTermination(AbstractTransportTest.java:324)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:168)
at org.junit.rules.RunRules.evaluate(RunRules.java:20)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.net.BindException: Address already in use: bind
at sun.nio.ch.Net.bind0(Native Method)
at sun.nio.ch.Net.bind(Net.java:433)
at sun.nio.ch.Net.bind(Net.java:425)
at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)
at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:127)
at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:554)
at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1258)
at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:512)
at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:497)
at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:980)
at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:250)
at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:363)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:454)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
... 1 more
Standard Error
Dec 03, 2016 11:31:53 PM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
java.io.IOException: An established connection was aborted by the software in your host machine
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:366)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Dec 03, 2016 11:31:53 PM io.grpc.netty.NettyServerTransport notifyTerminated
SEVERE: Transport failed
java.io.IOException: An established connection was aborted by the software in your host machine
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:366)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Dec 03, 2016 11:31:55 PM io.grpc.okhttp.AsyncFrameWriter$14 run
WARNING: Failed closing connection
java.net.SocketException: Socket closed
at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:116)
at java.net.SocketOutputStream.write(SocketOutputStream.java:153)
at okio.Okio$1.write(Okio.java:80)
at okio.AsyncTimeout$1.write(AsyncTimeout.java:155)
at okio.RealBufferedSink.close(RealBufferedSink.java:234)
at io.grpc.okhttp.internal.framed.Http2$Writer.close(Http2.java:568)
at io.grpc.okhttp.AsyncFrameWriter$14.run(AsyncFrameWriter.java:221)
at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Dec 03, 2016 11:31:56 PM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
java.io.IOException: An established connection was aborted by the software in your host machine
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:366)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Dec 03, 2016 11:31:56 PM io.grpc.netty.NettyServerTransport notifyTerminated
SEVERE: Transport failed
java.io.IOException: An established connection was aborted by the software in your host machine
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:366)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2484
Listen to channel state changes on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's more of a question than an issue. I can't find any methods to listen to connection state changes. Is there any way to do this on the client side? I'm using protobuf-lite on Android. It'd be nice to listen to channel state changes, e.g. if the Internet connection is lost, the channel should signal the error. I have a persistent connection (full-duplex) to the server with a StreamObserver, but neither the onError(...) nor onCompleted() gets called if I just turn off the WiFi to test it.
TL;DR: How can I know on Android whether the channel is still operational (so the connection is not down)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2485
Shade Netty transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So this means that gRPC netty will no longer have a chance to conflict with other Netty versions I'm using?  If so, +1, we were thinking of doing this ourselves when we imported and used gRPC anyways.  The http2 changes between 4.1.5.Final and 4.1.6.Final were frustrating and it happens often enough to cause issues in a big organization.
How will this play with shared things like worker groups and whatnot?  If I have normal Netty plus grpc Netty, can I use the same worker group between them, or will I likely be stuck with 2 worker groups due to the relocation of classes?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2486
core: handle a race in DelayedClientTransport.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I may need to make an additional change which is invasive enough to justify a fork. Please don't review it for now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2487
Building grpc-java on POWER8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
v0.15.0
What JVM are you using (java -version)?
openjdk version "1.8.0_65"
OpenJDK Runtime Environment (build 1.8.0_65-b17)
OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode)
What did you do?
Install protoc to /opt/share
If possible, provide a recipe for reproducing the error.
cd /tmp
git clone https://github.com/google/protobuf.git && cd protobuf
git checkout v3.1.0
./autogen.sh
./configure --prefix=/opt/share/protobuf/ppc64le/
make && make install
export PATH=/opt/share/protobuf/ppc64le/bin/:$PATH
export LD_LIBRARY_PATH=/opt/share/protobuf/ppc64le/lib/:$LD_LIBRARY_PATH
Install grpc-java
cd tmp
git clone https://github.com/grpc/grpc-java.git && cd grpc-java
export CXXFLAGS="-I/opt/share/protobuf/ppc64le/include"
./gradlew build
What did you expect to see?
Build Successful
What did you see instead?
:grpc-compiler:compileJava_pluginExecutableJava_pluginCpp/tmp/src/grpc-java/compiler/src/java_plugin/cpp/java_generator.cpp:7:54: fatal error: google/protobuf/compiler/java/java_names.h: No such file or directory
#include <c>

even though
ls -la /opt/share/protobuf/ppc64le/include/google/protobuf/compiler/java/
total 12
drwxr-xr-x  2 bmbelgod users   48 Dec  1 22:06 .
drwxr-xr-x 11 bmbelgod users 4096 Dec  1 22:06 ..
-rw-r--r--  1 bmbelgod users 2945 Dec  1 22:06 java_generator.h
-rw-r--r--  1 bmbelgod users 2931 Dec  1 22:06 java_names.h
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2488
GrpcServerRule is Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a tracking issue that will be closed once GrpcServerRule exits experimental status.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2489
docs: Place all badges together
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2490
Migrate example unit tests to GrpcServerRule
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GrpcServerRule from #2456 simplifies the boilerplate necessary to unit test gRPC clients and services. We should update the example unit tests to make use of it (as appropriate).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2491
Update param name for saving histograms
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
ðŸ“ Please visit https://cla.developers.google.com/ to sign.
Once you've signed, please reply here (e.g. I signed it!) and we'll verify.  Thanks.


If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check your existing CLA data and verify that your email is set on your git commits.
If you signed the CLA as a corporation, please let us know the company's name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2492
Export Javadocs for 1.0.2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
http://www.grpc.io/grpc-java/javadoc/overview-summary.html is still on 1.0.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2493
core: thread-less ChannelExecutor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2494
all: Add more projects to the all super-project
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This still needs a bit more love; both the javadoc and code coverage need tweaking to remove generated code.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2495
core: Fix ErrorProne failure for ForOverride
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2496
core: Add @Nullable to Metadata#get
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2497
StatusRuntimeException with client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2 (but also tried with 0.15.0, 1.0.0, 1.0.1)
What JVM are you using (java -version)?
Java(TM) SE Runtime Environment (build 1.8.0_73-b02)
What did you do?
I am creating a PredictClient to make a gRPC call to an inception model of Tenserflow serving. I am providing url and port of our environment, where it's being hosted.
What did you expect to see?
I expect to see PredictResponse output for the image I am sending.
What did you see instead?
io.grpc.StatusRuntimeException: INTERNAL: Connection closed with unknown cause
at io.grpc.Status.asRuntimeException(Status.java:536)
at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
at tensorflow.serving.PredictionServiceGrpc$PredictionServiceBlockingStub.predict(PredictionServiceGrpc.java:144)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2498
context: Fix ErrorProne ClassNewInstance
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2499
How to determine different streams are based on the same channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpc-java-1.0.2
What JVM are you using (java -version)?
java version "1.7.0_79"
OpenJDK Runtime Environment (rhel-2.5.5.4.el6-x86_64 u79-b14)
OpenJDK 64-Bit Server VM (build 24.79-b02, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
I have a persistent connection (full-duplex) to the server with a StreamObserver (for login and push notification). And I have various unary calls based on the other streams. So if there is a api to judge whether these unary streams and the full-duplex stream are based on the same channel ?
Purpose: refuse unary calls if the full-duplex stream dose not exists.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2500
Implement setListener in AbstractServerStream.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2501
doc: more guidelines for LoadBalancer2 implementations.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks! Looks good to me!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2502
interop-testing: Observe --use_tls to disable TLS with OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2503
core: InternalSubchannel uses ChannelExecutor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2504
core: make forTarget(String) non-experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2505
core: two changes on DelayedClientTransport2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry for having two unrelated changes in the same commit. I just copied the HEAD version of the two files from my working branch, which doesn't maintain a useful commit history that would allow me to extract the two changes as separate commits. The changes are straightforward enough so I think it may not worth the effort trying to split them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2506
context: add the four-value withValues().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2507
Remove maxMessageSize on NettyChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since #2382 has been committed, there is no longer a valid use for NettyChannelBuilder.maxMessageSize.   It has been marked as deprecated and should be removed for the 1.1 release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2508
netty: move internal channel builder code to a special accessor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2509
services: Flow control for protobuf reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2510
google flatbuffer java support feature request
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While it has been discussed, I don't think there is an explicit feature request for grpc-java support of google flatbuffers, maintained by @gwvo, as a replacement for protobuf messages, initially integrated into the grpc c at grpc/grpc#5438 and google/flatbuffers@48f37f9.
Use cases in grpc-java have also been mentioned in #2139 and #1403.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2511
No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.

When building release app, the error is coming: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2512
Caused by: java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNAVAILABLE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
Caused by: java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNAVAILABLE
What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2513
interop-testing: New client for HTTP/2 "negative" interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2514
Periodical refresh of DnsNameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
Original discussion:
https://groups.google.com/forum/#!topic/grpc-io/wxgLgjzkR30
Currently DnsNameResolver soles relies on refresh() being called to re-resolve. refresh() currently is called only when there is a connection failure, but there are cases where refreshing is needed without connection failure, e.g., rolling deploys, or simply adding a server.  We could introduce periodic refresh to DnsNameResolver.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2515
Deadlock in grpc due to recursive grpc call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
openjdk version "1.8.0_102"
OpenJDK Runtime Environment (build 1.8.0_102)
OpenJDK 64-Bit Server VM (build 25.102-b01, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.

Turned on FINE logging
Used the Logging client in google-cloud-java

What did you expect to see?
Not what I saw below...
What did you see instead?
Deadlock.
Found one Java-level deadlock:
=============================
"grpc-default-worker-ELG-1-1":
  waiting to lock monitor 0x00007fe628006318 (object 0x00000005cf4cead0, a java.lang.Object),
  which is held by "main"
"main":
  waiting to lock monitor 0x00007fe628002d78 (object 0x00000005ce107468, a java.lang.Object),
  which is held by "pool-1-thread-1"
"pool-1-thread-1":
  waiting to lock monitor 0x00007fe628006318 (object 0x00000005cf4cead0, a java.lang.Object),
  which is held by "main"

Java stack information for the threads listed above:
===================================================
"grpc-default-worker-ELG-1-1":
        at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:121)
        - waiting to lock <0x00000005cf4cead0> (a java.lang.Object)
        at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
        at io.grpc.auth.ClientAuthInterceptor$1.checkedStart(ClientAuthInterceptor.java:104)
        at io.grpc.ClientInterceptors$CheckedForwardingClientCall.start(ClientInterceptors.java:195)
        at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
        at com.google.api.gax.grpc.HeaderInterceptor$1.start(HeaderInterceptor.java:62)
        at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
        at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
        at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
        at com.google.api.gax.grpc.DirectCallable.futureCall(DirectCallable.java:60)
        at com.google.api.gax.grpc.ReentranceDetectingCallable.futureCall(ReentranceDetectingCallable.java:56)
        at com.google.api.gax.grpc.ExceptionTransformingCallable.futureCall(ExceptionTransformingCallable.java:64)
        at com.google.api.gax.grpc.RetryingCallable$RetryingResultFuture.issueCall(RetryingCallable.java:220)
        - locked <0x00000005cf8472e8> (a java.lang.Object)
        at com.google.api.gax.grpc.RetryingCallable.futureCall(RetryingCallable.java:88)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:238)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:249)
        at com.google.cloud.logging.spi.DefaultLoggingRpc.write(DefaultLoggingRpc.java:202)
        at com.google.cloud.logging.LoggingImpl.writeAsync(LoggingImpl.java:504)
        at com.google.cloud.logging.LoggingImpl.write(LoggingImpl.java:499)
        at com.google.cloud.logging.LoggingHandler.write(LoggingHandler.java:382)
        at com.google.cloud.logging.LoggingHandler.flush(LoggingHandler.java:407)
        at com.google.cloud.logging.LoggingHandler.publish(LoggingHandler.java:318)
        at java.util.logging.Logger.log(Logger.java:738)
        at io.netty.util.internal.logging.JdkLogger.log(JdkLogger.java:606)
        at io.netty.util.internal.logging.JdkLogger.debug(JdkLogger.java:186)
        at io.netty.util.internal.logging.AbstractInternalLogger.log(AbstractInternalLogger.java:147)
        at io.netty.handler.codec.http2.Http2FrameLogger.log(Http2FrameLogger.java:183)
        at io.netty.handler.codec.http2.Http2FrameLogger.logSettings(Http2FrameLogger.java:111)
        at io.netty.handler.codec.http2.Http2OutboundFrameLogger.writeSettings(Http2OutboundFrameLogger.java:81)
        at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettings(DefaultHttp2ConnectionEncoder.java:246)
        at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettings(DecoratingHttp2FrameWriter.java:70)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.sendPreface(Http2ConnectionHandler.java:324)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.channelActive(Http2ConnectionHandler.java:224)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.channelActive(Http2ConnectionHandler.java:363)
        at io.grpc.netty.AbstractNettyHandler.channelActive(AbstractNettyHandler.java:78)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:202)
        at io.netty.handler.ssl.SslHandler.channelActive(SslHandler.java:1398)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:202)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(DefaultChannelPipeline.java:1322)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.DefaultChannelPipeline.fireChannelActive(DefaultChannelPipeline.java:902)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:305)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:335)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:588)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)
"main":
        at io.grpc.internal.InUseStateAggregator.updateObjectInUse(InUseStateAggregator.java:51)
        - waiting to lock <0x00000005ce107468> (a java.lang.Object)
        at io.grpc.internal.TransportSet$BaseTransportListener.transportInUse(TransportSet.java:373)
        at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:129)
        - locked <0x00000005cf4cead0> (a java.lang.Object)
        at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
        at io.grpc.auth.ClientAuthInterceptor$1.checkedStart(ClientAuthInterceptor.java:104)
        at io.grpc.ClientInterceptors$CheckedForwardingClientCall.start(ClientInterceptors.java:195)
        at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
        at com.google.api.gax.grpc.HeaderInterceptor$1.start(HeaderInterceptor.java:62)
        at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
        at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
        at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
        at com.google.api.gax.grpc.DirectCallable.futureCall(DirectCallable.java:60)
        at com.google.api.gax.grpc.ReentranceDetectingCallable.futureCall(ReentranceDetectingCallable.java:56)
        at com.google.api.gax.grpc.ExceptionTransformingCallable.futureCall(ExceptionTransformingCallable.java:64)
        at com.google.api.gax.grpc.RetryingCallable$RetryingResultFuture.issueCall(RetryingCallable.java:220)
        - locked <0x00000005cd8b7740> (a java.lang.Object)
        at com.google.api.gax.grpc.RetryingCallable.futureCall(RetryingCallable.java:88)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:238)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:249)
        at com.google.cloud.logging.spi.DefaultLoggingRpc.write(DefaultLoggingRpc.java:202)
        at com.google.cloud.logging.LoggingImpl.writeAsync(LoggingImpl.java:504)
        at com.google.cloud.logging.LoggingImpl.write(LoggingImpl.java:499)
        at com.google.cloud.logging.LoggingHandler.write(LoggingHandler.java:382)
        at com.google.cloud.logging.LoggingHandler.flush(LoggingHandler.java:407)
        at com.google.cloud.logging.LoggingHandler.publish(LoggingHandler.java:318)
        at java.util.logging.Logger.log(Logger.java:738)
        at java.util.logging.Logger.doLog(Logger.java:765)
        at java.util.logging.Logger.log(Logger.java:788)
        at java.util.logging.Logger.info(Logger.java:1490)
        at com.google.cloud.runtimes.jetty9.StackDriverLogging.init(StackDriverLogging.java:37)
        at com.google.cloud.runtimes.jetty9.StackDriverLogging.main(StackDriverLogging.java:64)
"pool-1-thread-1":
        at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:121)
        - waiting to lock <0x00000005cf4cead0> (a java.lang.Object)
        at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:214)
        at io.grpc.auth.ClientAuthInterceptor$1.checkedStart(ClientAuthInterceptor.java:104)
        at io.grpc.ClientInterceptors$CheckedForwardingClientCall.start(ClientInterceptors.java:195)
        at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
        at com.google.api.gax.grpc.HeaderInterceptor$1.start(HeaderInterceptor.java:62)
        at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:273)
        at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
        at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:189)
        at com.google.api.gax.grpc.DirectCallable.futureCall(DirectCallable.java:60)
        at com.google.api.gax.grpc.ReentranceDetectingCallable.futureCall(ReentranceDetectingCallable.java:56)
        at com.google.api.gax.grpc.ExceptionTransformingCallable.futureCall(ExceptionTransformingCallable.java:64)
        at com.google.api.gax.grpc.RetryingCallable$RetryingResultFuture.issueCall(RetryingCallable.java:220)
        - locked <0x00000005cfbce9e0> (a java.lang.Object)
        at com.google.api.gax.grpc.RetryingCallable.futureCall(RetryingCallable.java:88)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:238)
        at com.google.api.gax.grpc.UnaryCallable.futureCall(UnaryCallable.java:249)
        at com.google.cloud.logging.spi.DefaultLoggingRpc.write(DefaultLoggingRpc.java:202)
        at com.google.cloud.logging.LoggingImpl.writeAsync(LoggingImpl.java:504)
        at com.google.cloud.logging.LoggingImpl.write(LoggingImpl.java:499)
        at com.google.cloud.logging.LoggingHandler.write(LoggingHandler.java:382)
        at com.google.cloud.logging.LoggingHandler.flush(LoggingHandler.java:407)
        at com.google.cloud.logging.LoggingHandler.publish(LoggingHandler.java:318)
        at java.util.logging.Logger.log(Logger.java:738)
        at java.util.logging.Logger.doLog(Logger.java:765)
        at java.util.logging.Logger.log(Logger.java:851)
        at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:217)
        at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:192)
        - locked <0x00000005ce107468> (a java.lang.Object)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:637)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:579)
        at io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer$1.get(DummyLoadBalancerFactory.java:135)
        at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:262)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:295)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)

Background: I have been trying various strategies to resolve googleapis/google-cloud-java#1386 , where using the Logging service at level FINE results in grpc logging to the Logging service in a recursive way. I tried using a ThreadLocal to prevent this, but this doesn't work with grpc because the actual call is executed on a worker thread. Essentially I think I need some way to bail out of the LoggingHandler.publish call if I can detect that this is in the scope of a grpc worker thread sending a request to the Logging service.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2516
netty-tcnative-boringssl-static and version 1.1.33.Fork19 need which glibc verson
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
netty-tcnative-boringssl-static and version 1.1.33.Fork19 need which glibc verson?
What JVM are you using (java -version)?
JDK1.7
What did you do?
If possible, provide a recipe for reproducing the error.
What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2517
How to cause Invalid protobuf byte sequence?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
com.blueware.deps.io.grpc.StatusRuntimeException: INTERNAL: Invalid protobuf byte sequence
	at com.blueware.deps.io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java) ~[oneapm.jar:2.0]
	at com.blueware.deps.io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java) ~[oneapm.jar:2.0]
	at com.blueware.deps.io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java) ~[oneapm.jar:2.0]

io.grpc is renamed by me. How does this exception happen? It happen in only one environment, but I can't tell the diff between this one and others.
Can you give me some tips? How to know, what cause this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2518
Review experimental annotations for 1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should check all experimental tags, and see if we feel comfortable graduating them to the supported status.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2519
core: add full stack trace in Status.toString
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm not sure how I feel about this. After all, Throwable.toString() doesn't include the stack trace. But it is really annoying when we don't have the backtrace. @zhangkun83, what are your thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2520
What does setting  GRPC  once request  read  time out ? 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In a production environment ,we should setting once request   time,avoid  cascading failures,so  what does setting  GRPC  once request  read  time out ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2521
Some javadocs in DelayedClientTransport2 are obsolete
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/**
   * Prevents creating any new streams until {@link #setTransport} is called. Buffered streams are
   * not failed, so if {@link #shutdown} is called when {@link #setTransport} has not been called,
   * you still need to call {@link #setTransport} to make this transport terminated.
   */
  @Override
  public final void shutdown()

/**
   * Use the picker to try picking a transport for every pending stream, proceed the stream if the
   * pick is successful, otherwise keep it pending.
   *
   * <p>This method may be called concurrently with {@code newStream()}, and it's safe.  All pending
   * streams will be served by the latest picker (if a same picker is given more than once, they are
   * considered different pickers) as soon as possible.
   *
   * <p>This method <strong>must not</strong> be called concurrently, with itself or with {@link
   * #setTransportSupplier}/{@link #setTransport}.
   */
  final void reprocess(SubchannelPicker picker)

Here {@link #setTransport} and {@link #setTransportSupplier} are no longer valid.
Please answer these questions before submitting your issue.
What version of gRPC are you using?
master head
What JVM are you using (java -version)?
N/A
What did you do?
If possible, provide a recipe for reproducing the error.
N/A
What did you expect to see?
N/A
What did you see instead?
N/A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2522
doc: update javadocs in DelayedClientTransport2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2523
codehealth: errorprone, unused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2524
netty: refactor how internal netty channel works
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2525
ManagedChannelImpl leaves grpc theads unreleased after shudown or shutdownNow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using grpc-1.0.2 & netty-4.1.6-Final with
Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)
Fedora 25 - Linux 64
When using shutdown or shutdownNow on the client channel ManagedChannelImpl grpc threads are not released. This is in my production system as well as in the minimal example I've stripped down, see below. The server is not available and no actual call is done. The code is invoked from scala-2.11.8 but this should not matter.
If I do the code in a loop more and more threads pile up without going away after some time.
 val sslContext = GrpcSslContexts.forClient()
    .trustManager(InsecureTrustManagerFactory.INSTANCE)
    .build()
 
  //one additional threadDeathWatcher-1-1

  val channel = NettyChannelBuilder
    .forAddress(MyServer.address, MyServer.port)
    .sslContext(sslContext)
    .build()

  //no additional thread

  val client = MyServerGrpc.newStub(channel)

  //no additional thread    

  channel.shutdownNow();

  //eleven additional grpc-* threads

  channel.awaitTermination(5, TimeUnit.MINUTES)

  //succeeds instantly, all grpc-* threads are still there.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2526
core,netty: add getAttributes to ClientStream and ClientCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2527
Introduce a grpc-exp ALPN protocol identifier.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2528
all: update to guava 20
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Done
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2529
netty: no add_dep io.netty.handler.ssl.SslContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2530
core: ManagedChannelImpl2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2531
Make Deadline test-friendly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In its current form, io.grpc.Deadline is not suitable for testing.  It is not possible to create a deadline with an absolute offset, making it impossible to reliably create two relative deadlines.  The only public constructor is after() which is actually a timeout!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2532
services: More efficient pre-processing in proto reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is a file missing?  I don't see any callers of getMutableService
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2533
Acess services from Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I would like to access all registered services from a build server, in my case the name is enough.
Therefore I need access to the handlerRegistry of the Server here and also an added entry in the interface.
Do you think that is a good idea?
I am currently writing an etcd service discovery on top of grpc and want to register all services from a server, so I need to access the services.
It would also be a good approach for me if I could add an interceptor/listener to the server that will be called when the server started where I can access those information.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2534
CompositeChannelCredentials for OkHttpChannelBuilder channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C++ has composite credentials for the channel, as well as CallCredentials for individual stubs.
Does grpc-java have something similar?
So far all i've managed to find is the call credentials that can be applied to each stub, but that means I have to manually add it each time I create a stub, rather than just letting the channel handle it.
Is there a better way to do this?
Will something similar to CompositeChannelCredentials  be added to OkHttpChannelBuilder?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2535
Context Key not set in gRPC worker thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.01
What JVM are you using (java -version)?
openjdk version "1.8.0_102"
OpenJDK Runtime Environment (build 1.8.0_102)
OpenJDK 64-Bit Server VM (build 25.102-b01, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.

Turned on FINE logging
Used the Logging client in google-cloud-java
Used the code recommended in #2515 to set a Context Key in my main thread

What did you expect to see?
I expected to see the Context Key set in the gRPC worker thread.
What did you see instead?
The key was not set.
Here are the stack traces where I expected it to be set, but it wasn't:
java.lang.Exception
        at com.google.cloud.logging.LoggingHandler.publish(LoggingHandler.java:315)
        at java.util.logging.Logger.log(Logger.java:738)
        at io.netty.util.internal.logging.JdkLogger.log(JdkLogger.java:606)
        at io.netty.util.internal.logging.JdkLogger.debug(JdkLogger.java:186)
        at io.netty.util.internal.logging.AbstractInternalLogger.log(AbstractInternalLogger.java:147)
        at io.netty.handler.codec.http2.Http2FrameLogger.log(Http2FrameLogger.java:183)
        at io.netty.handler.codec.http2.Http2FrameLogger.logSettings(Http2FrameLogger.java:111)
        at io.netty.handler.codec.http2.Http2OutboundFrameLogger.writeSettings(Http2OutboundFrameLogger.java:81)
        at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettings(DefaultHttp2ConnectionEncoder.java:246)
        at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettings(DecoratingHttp2FrameWriter.java:70)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.sendPreface(Http2ConnectionHandler.java:324)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.channelActive(Http2ConnectionHandler.java:224)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.channelActive(Http2ConnectionHandler.java:363)
        at io.grpc.netty.AbstractNettyHandler.channelActive(AbstractNettyHandler.java:78)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:202)
        at io.netty.handler.ssl.SslHandler.channelActive(SslHandler.java:1398)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:202)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(DefaultChannelPipeline.java:1322)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:223)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:209)
        at io.netty.channel.DefaultChannelPipeline.fireChannelActive(DefaultChannelPipeline.java:902)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:305)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:335)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:588)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)

second:
java.lang.Exception
        at com.google.cloud.logging.LoggingHandler.publish(LoggingHandler.java:315)
        at java.util.logging.Logger.log(Logger.java:738)
        at java.util.logging.Logger.doLog(Logger.java:765)
        at java.util.logging.Logger.log(Logger.java:851)
        at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:217)
        at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:192)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:637)
        at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:579)
        at io.grpc.DummyLoadBalancerFactory$DummyLoadBalancer$1.get(DummyLoadBalancerFactory.java:135)
        at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:262)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:295)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2536
okhttp: catch Throwable to avoid breaking preconditions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM, but could you also add a test?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2537
benchmarks: update to jmh 1.17.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2538
interop-testing: Add status_code_and_message interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2539
compiler: reduce synchronzed invocation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2540
interop-testing: Add custom_metadata interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2541
Network is unreachable: pubsub.googleapis.com/2607:f8b0:4001:c02:0:0:0:5f:443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
openjdk version "1.8.0_102"
OpenJDK Runtime Environment (build 1.8.0_102)
OpenJDK 64-Bit Server VM (build 25.102-b01, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
Tried to connect to the gRPC Pub/Sub service.
What did you expect to see?
A successful connection.
What did you see instead?
Caused by: java.net.SocketException: Network is unreachable: pubsub.googleapis.com/2607:f8b0:4001:c02:0:0:0:5f:443
Other info:

Running in a docker image in Google Compute Engine
From what I understand, GCE does not support IPv6. But, when using gRPC (through Netty), for some reason it's trying to use IPv6 instead of IPv4.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2542
compiler: Use public headers instead of pb.h
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2543
context: fix race condition in Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This seems to be a benign race. These are writes and reads to an object reference, which are guaranteed to be atomic, so there won't be any tearing. If T1 writes first and T2 still reads the stale null, it won't harm for T2 to write again.
I am not sure adding the volatile here will add overhead for Android. This field is read on a per-message base. @ejona86, opinions?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2544
all: add max message size to client calls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2545
netty,okhttp: CONNECT proxy support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So there's good news and bad news.
ðŸ‘ The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
ðŸ˜• The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
Note to project maintainer: This is a terminal state, meaning the cla/google commit status will not change from this state. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2546
core: remove a benign data race.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2547
Add support for http forward proxy with CONNECT (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This commit has been modified to reduce its size to substantially reduce
risk of it breaking Netty error handling. But that also means proxy
error handling just provides a useless "there was an error" sort of
message.

At least the user can tell proxy errors from backend connection errors, right?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2548
 The version of okhttp is not up-to-date
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpc-1.0.2
What JVM are you using (java -version)?
1.8.0_51
What did you do?
If possible, provide a recipe for reproducing the error.
We also need the latest okhttp of our application
but now okhttp is 2.5.0
What did you expect to see?
Use the latest okhttp
What did you see instead?
okhttp 3.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2549
 The version of okhttp is not up-to-date
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8.0_51
What did you do?
If possible, provide a recipe for reproducing the error.
grpc used the old version of okhttp 2.5.0
What did you expect to see?
Update the version of okhttp to the latest version
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2550
Release v1.0.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2551
Update README to reference 1.0.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2552
bindService() should be final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We just found out a method in the generated code
The method is "bindService()" on the generated server interface is supposed to be "final", but is currently not.
For example
public abstract class RouteGuideImplBase {
  // Empty implementations, to be overridden by the application
  public StreamObserver routeSingle(StreamObserver) {
    failWithUnimplemented();
  }
  public StreamObserver routeMultiple(StreamObserver) {
    failWithUnimplemented();
  }

  // Glue code called by gRPC server to register the service.
  // Not supposed to be overridden.
  public bindService() {
    ...
  }
}
Why is it an issue
The non-final bindService() adds difficulty for users who want to mock the server interface in their tests. Mockito by default overrides all non-final methods with its no-op and null-returning impl. When a Mockito user creates a mock for RouteGuideImplBase, it can't be correctly registered to the server. It can be worked around by explicitly telling Mockito to use the original bindService(), but it's still a friction in the user experience.
What should we do
bindService() should have been defined as "final" in the first place. It was an oversight that we didn't make it so.  This should be considered as a bug and be fixed.
We will make the change in master, which will be in 1.1.0.
Risk
This is technically an incompatible API change. Anyone overrides bindService() on the generated interface will be broken. However, I don't find anyone doing so in google3, or any legitimate reason for it in general. The chance of breaking anyone is very low.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2553
compiler: final bindService() in generated code.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It was not set as final at the time of 0.15.0 mostly because the json marshaller example overrides it.
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2554
large memory usage in io.grpc.netty.NettyClientTransport$2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported in googleapis/google-cloud-java#1449 , io.grpc.netty.NettyClientTransport$2 (I don't know which anonymous class it is) consumes a large amount of memory. Detailed memory analysis is contained in the linked issue. (This is blocking google-cloud-logging GA).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2555
SECURITY.md mutual TLS code snippet out of date
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI the code snippet in the mutual TLS section seems out of date, the method signature of the given ServerInterceptor still references MethodDescriptor

public <ReqT, RespT> ServerCall.Listener interceptCall(MethodDescriptor<ReqT, RespT> method,    ServerCall call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2556
Can a name resolver handle multiple schemes?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a name resolver which itself is backed by a gRPC service which accepts the full URI string and allows for a handful of schemes(think something like eureka:// or eurekas://).  getDefaultScheme can only return a single string, but the newNameResolver call is capable of returning a name resolver for multiple schemes.  What is the proper way to go about doing this?  Should I make two different factories so they each return the defaultScheme appropriately, or can I have a single Factory that returns the insecure or secure scheme only?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2557
grpclb: re-implement GrpclbLoadBalancer in v2 API.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2558
errors when doing bench-marking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8
What did you do?
the benck-marking code is from "https://github.com/grpc/grpc-java/tree/master/benchmarks".
bench-mark client is:

https://github.com/grpc/grpc-java/blob/master/benchmarks/src/main/java/io/grpc/benchmarks/qps/AsyncClient.java

bench-mark server is:

https://github.com/grpc/grpc-java/blob/master/benchmarks/src/main/java/io/grpc/benchmarks/qps/AsyncServer.java
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2559
nginx proxy
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8
What did you do?
i want to using nginx to proxy grpc server, but it got error
nginx version
[root@s168 ~]# nginx -v
nginx version: nginx/1.10.2

nginx config
[root@s168 ~]# cat /etc/nginx/sites-enabled/grpctest.conf
upstream grpc {
        server 127.0.0.1:50051;
}

server {
        listen       50055 http2;
        location / {
                proxy_pass http://grpc;
        }
}

run grpc server
grpc server start successfully, but it got error when the client connect.
[root@s168 examples]# mvn exec:java -Dexec.mainClass=io.grpc.examples.helloworld.HelloWorldServer
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: linux
[INFO] os.detected.arch: x86_64
[INFO] os.detected.release: centos
[INFO] os.detected.release.version: 7
[INFO] os.detected.release.like.centos: true
[INFO] os.detected.release.like.rhel: true
[INFO] os.detected.release.like.fedora: true
[INFO] os.detected.classifier: linux-x86_64
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building examples 1.0.2
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- exec-maven-plugin:1.5.0:java (default-cli) @ examples ---
Dec 28, 2016 11:33:01 PM io.grpc.examples.helloworld.HelloWorldServer start
INFO: Server started, listening on 50051
Dec 28, 2016 11:40:33 PM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.handler.codec.http2.Http2Exception: HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 504f5354202f68656c6c6f776f726c642e47726565746572
        at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.readClientPrefaceString(Http2ConnectionHandler.java:271)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:211)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:395)
        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)

Dec 28, 2016 11:40:33 PM io.grpc.netty.NettyServerTransport notifyTerminated
SEVERE: Transport failed
io.netty.handler.codec.http2.Http2Exception: HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 504f5354202f68656c6c6f776f726c642e47726565746572
        at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.readClientPrefaceString(Http2ConnectionHandler.java:271)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:211)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:395)
        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)


grpc client
[root@s168 examples]# mvn exec:java -Dexec.mainClass=io.grpc.examples.helloworld.HelloWorldClient
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: linux
[INFO] os.detected.arch: x86_64
[INFO] os.detected.release: centos
[INFO] os.detected.release.version: 7
[INFO] os.detected.release.like.centos: true
[INFO] os.detected.release.like.rhel: true
[INFO] os.detected.release.like.fedora: true
[INFO] os.detected.classifier: linux-x86_64
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building examples 1.0.2
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- exec-maven-plugin:1.5.0:java (default-cli) @ examples ---
Dec 28, 2016 11:54:25 PM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@32033ad8] Created with target localhost:50055
Dec 28, 2016 11:54:25 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Will try to greet world ...
Dec 28, 2016 11:54:26 PM io.grpc.examples.helloworld.HelloWorldClient greet
WARNING: RPC failed: Status{code=UNKNOWN, description=invalid content-type: null
headers: Metadata({:status=[000], server=[nginx/1.10.2], date=[Thu, 29 Dec 2016 07:54:26 GMT]})
DATA-----------------------------

ï¿½ï¿½ï¿½HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 504f5354202f68656c6c6f776f726c642e47726565746572, cause=null}
Dec 28, 2016 11:54:26 PM io.grpc.internal.ManagedChannelImpl maybeTerminateChannel
INFO: [ManagedChannelImpl@32033ad8] Terminated
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.303 s
[INFO] Finished at: 2016-12-28T23:54:29-08:00
[INFO] Final Memory: 12M/138M
[INFO] ------------------------------------------------------------------------

but it worked correctly without nginx proxy
[root@s168 examples]# mvn exec:java -Dexec.mainClass=io.grpc.examples.helloworld.HelloWorldClient
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: linux
[INFO] os.detected.arch: x86_64
[INFO] os.detected.release: centos
[INFO] os.detected.release.version: 7
[INFO] os.detected.release.like.centos: true
[INFO] os.detected.release.like.rhel: true
[INFO] os.detected.release.like.fedora: true
[INFO] os.detected.classifier: linux-x86_64
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building examples 1.0.2
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- exec-maven-plugin:1.5.0:java (default-cli) @ examples ---
Dec 28, 2016 11:52:45 PM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@59f2ffb7] Created with target localhost:50051
Dec 28, 2016 11:52:45 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Will try to greet world ...
Dec 28, 2016 11:52:46 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Greeting: Hello world
Dec 28, 2016 11:52:46 PM io.grpc.internal.ManagedChannelImpl maybeTerminateChannel
INFO: [ManagedChannelImpl@59f2ffb7] Terminated
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.921 s
[INFO] Finished at: 2016-12-28T23:52:48-08:00
[INFO] Final Memory: 13M/169M
[INFO] ------------------------------------------------------------------------

What did you expect to see?
is it possible using nginx proxy for grpc?
if can, what i should do ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2560
style: fix styles and error-prones
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2561
Which version of android sdk/ios sdk support gRPC.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, which version of android/ios sdk support gRPC, I am sorry I can't find any information in the website.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2562
Race between pick and transport shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now they are done in two steps:

A transport that is in READY state is selected
newStream() is called on the selected transport.

If transport is shutdown (by LoadBalancer or channel idle mode) between the two steps, Step 2 will fail spuriously. Currently we work around this by adding a delay between stopping selecting a subchannel (which owns the transport) and shutting it down. As long as the delay is longer than the time between Step 1 and Step 2, the race won't happen.
This is not ideal because it relies on timing to work correctly, and will still fail in extreme cases where the time between the two steps are longer than the pre-set delay.
It would be a better solution to differentiate the racy shutdown and the intended shutdown (Channel is shutdown for good). In response to racy shutdown, transport selection will be retried. The clientTransportProvider in ManagedChannelImpl is in the best position to do this, because it knows whether the Channel has shutdown. clientTransportProvider would have to call newStream() and start the stream, and return the started stream to ClientCallImpl instead of a transport.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2563
Tracking Issue for maxInboundMessageSize being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2564
benchmarks: Do not set done to true when HistogramFuture#get
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2565
core: upgrade census (now named instrumentation) to 0.3.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2566
weekly cleanup: errorprone, javastyle, unused
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 , I'm not sure about the semantics of the tests, just removed the unused, so probably my change is wrong.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2567
releasing: Document bumping version on grpc.io
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2568
core: fix API breakage in ServerBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2569
core: add default implementation to ServerBuilder.addTransportFilter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2570
context: put ContextStorageOverride in io.grpc.override.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2571
context: expose Ticker interface and testing method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also, incase not obvious, the name DeadlineTicker was picked as to not conflict with the Guava Ticker class, which I expect to be the preferred implementation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2572
all: update styleguide XML to canonical one on github
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2573
testing: Remove accidental cast to char in file IO
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2574
grpc-testing maven package broken
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
1.8.0_77
What did you do?
I want to use the GrpcServerRule in my junit tests.
What did you expect to see?
When I include testCompile "io.grpc:grpc-testing:1.0.3" in my dependencies, I can use GrpcServerRule and all other classes currently available in the main github repo.
What did you see instead?
When I include testCompile "io.grpc:grpc-testing:1.0.3" in my dependencies, the GrpcServerRule and other classes are not there.
The grpc-testing-1.0.3-sources.jar file on bintray indeed does not contain those classes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2575
What's the default value of TCP_NODELAY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What's the default value of TCP_NODELAY in gRPC-java and is there's a way to set this option?
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
open jdk 1.8
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2576
testing: Move echo interceptors out of TestUtils
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2577
ServerTransportFilter is experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Added in #2132
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2578
com.google.protobuf:protoc:3.1.0 generates unusable stubs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
Java(TM) SE Runtime Environment (build 1.8.0_112-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)
What did you do?

Create a new gRPC project latest instruction from gRPC 1.0.3 from master branch https://github.com/grpc/grpc-java
Create a .proto file with a message field map<string, string>
Generate the stubs

What did you expect to see?
Expected to see successful stub generating
What did you see instead?
Error message indicating serializeStringToMap method is not found:
symbol:   method serializeStringMapTo(com.google.protobuf.CodedOutputStream,com.google.protobuf.MapField<java.lang.String,java.lang.String>,com.google.protobuf.MapEntry<java.lang.String,java.lang.String>,int)
  location: class com.google.protobuf.GeneratedMessageV3

More Information
After much troubleshooting, the README in 1.0.3 tag seem to have the correct combination of protoc version (3.0.2) and gRPC version (1.0.3)
https://github.com/grpc/grpc-java/tree/v1.0.3
However, the master branch has the incorrect combination of protoc version (3.1.0) and gRPC version (1.0.3).  protoc 3.1.0 would generate the incorrect stub source.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2579
Distinct status for client channel shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-1.0.3
I've a long running server availability monitoring rpc method implemented. The server just sends status messages if it is still alive. This is wrapped into an rxObservable so I can reconnect from client under the hood. But I should do so only if the client (channel) wasn't shutdown.
Unfortunately I get the same status (UNAVAILABLE) - as StatusRuntimeException - in the monitoring stream observer for server is unavailable and for client channel shutdown. The difference is only the description where I get a message like:
"channel shutdownnow invoked"

Currently I test the status description if it contains 'channel' && 'shutdown' in order to decide for reconnect or not.
Is there a better way to decide whether the channel is shutdown or the server is just unavailable? Or is there an distinct status planned for both events?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2580
readme: Downgrade protoc to 3.0.2 to match grpc-protobuf
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2581
context: don't log to logger in static initialization.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2582
Investigate Appengine Thread Partitioning
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, using gRPC on AppEngine requires a new channel to be created for each request.  Sharing channels across requests would have substantial performance benefit, but would require per-request threading.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2583
core: abstract channel builder to accept LoadBalancer2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2584
core,stub: remove deprecated deadline methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These methods have been deprecated in 1.0, so they are subject for removal.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2585
proto: remove deprecated methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2586
Clarify best practices for sending credentials in ClientAuthInterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The replacement for ClientAuthInterceptor, a deprecated but useful class, is GoogleAuthLibraryCallCredentials.  ClientAuthInterceptor has much wider usage, presumably because GoogleAuthLibraryCallCredentials is difficult to use, with no clear examples.
Some better Javadoc needs to be added to GoogleAuthLibraryCallCredentials, as well, as some extremely easy to read example code.  It should make a convincing argument for why it should be used over ClientAuthInterceptor.
ClientAuthInterceptor has been deprecated in 1.0.x, and is subject to removal.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2587
interop-testing: script for running http2 client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@makdharma fyi
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2588
core,testing: make MethodDescriptor final and add Test helper
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2589
core: make Contexts, ResolvedServerInfoGroup, and ServerInterceptors â€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2590
Any ETA on 1.1.0 Release?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.1.0-SNAPSHOT
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
N/A
What did you expect to see?
N/A
What did you see instead?
N/A
Question
Is there any ETA for 1.1.0 gprc-java release?
Thanks
Tim
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2591
core: remove thisT() from API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2592
Tracking Issue for MethodDescriptor.getRequestMarshaller being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2593
core: make getResponseMarshaller experimental in MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2594
core: promote experimental methods in MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For extractFullServiceName, util reference isn't a big deal, because util is part of core. Auth is a bit more interesting. We haven't stated that you are permitted to mix-and-match grpc artifacts, but we do try to version-pin when there are usages of internal by other artifacts. We could just say that it was a bug that util didn't version-pin (which I'd completely believe; I wouldn't be surprised if it wasn't the only such artifact with such a bug).
But I'm fine with it being non-experimental anyway.
@zhangkun83, you feel comfortable making extractFullServiceName non-experimental?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2595
Maybe add a builder to MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After talking about this briefly, it seems that a Builder for MD might be a good idea.  One complication comes up: MD is generic, but the Builder may not be.  If the marshaller is not the first this passed to the the builder the types will be wrong.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2596
the benchmark example gives a 2 times better QPS result after add spring-boot to dependency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
1.8
What did you do?
I use the bench mark code from https://github.com/grpc/grpc-java/tree/master/benchmarks
I download the code and convert it to a maven project, then run the bench mark with command:

sudo java -jar benchmark-client.jar --address=10.200.10.17:1024 --duration=10 --channels=10 --outstanding_rpcs=40

the benchmark result is:

Channels:                       10
Outstanding RPCs per Channel:   40
Server Payload Size:            0
Client Payload Size:            0
50%ile Latency (in micros):     6431
90%ile Latency (in micros):     12991
95%ile Latency (in micros):     16191
99%ile Latency (in micros):     23551
99.9%ile Latency (in micros):   33023
Maximum Latency (in micros):    50175
QPS:                            52874

then I add the spring-boot-starter-web dependency to the benchmark project, and re-run the bench mark:

sudo java -jar benchmark-client-with-springboot.jar --address=10.200.10.17:1024 --duration=10 --channels=10 --outstanding_rpcs=40

the benchmark result is:

Channels:                       10
Outstanding RPCs per Channel:   40
Server Payload Size:            0
Client Payload Size:            0
50%ile Latency (in micros):     2239
90%ile Latency (in micros):     4351
95%ile Latency (in micros):     5695
99%ile Latency (in micros):     10175
99.9%ile Latency (in micros):   16511
Maximum Latency (in micros):    28671
QPS:                            149371

What did you expect to see?
the  QPS results of two benchmarking should be same.
What did you see instead?
after add spring-boot dependency, it gives a 2 times better QPS result.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2597
documentation fix #2555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2598
core: fix bug with Metadata merging
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2599
Don't hang RPC when netty-tcnative .so fails to load due to (musl) linking errors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
openjdk version "1.8.0_102"
OpenJDK Runtime Environment (build 1.8.0_102)
OpenJDK 64-Bit Server VM (build 25.102-b01, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
https://github.com/garrettjonesgoogle/gcloud-java/tree/deadline-exceeded-issue/google-cloud-example-docker-gradle-alpine

./gradlew jar shadowJar
docker build .

Then deploy to a GCE instance and run it.

sudo docker run -it YOUR_DOCKER_BUILD_ID_HERE sh
java -Djava.util.logging.config.file=logging.properties -cp google-cloud-example-docker-gradle-alpine-all.jar com.google.cloud.pubsub.spi.v1.PublisherSmokeTest --project_id YOUR_PROJECT_ID_HERE

What did you expect to see?
An exception indicating that the netty dependency was unsatisfied
What did you see instead?
After the call times out, DEADLINE_EXCEEDED
Notes
If a user has a high timeout, it can take a long time for them to discover something is wrong. Then when they receive DEADLINE_EXCEEDED, they have no idea why - it doesn't guide them to the problem with the dependency. They have to know to turn on FINE logging and go log spelunking to fine the root cause. Example user-filed issue: googleapis/google-cloud-java#1430
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2600
Tracking issue for TestMethodDescriptors being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2601
Java GRPC Client (1.0.3) not able to send requests with metadata larger than ~500KB.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
Java: 1.0.3
Python: 1.0.4
What JVM are you using (java -version)?
java version "1.8.0_112"
Java(TM) SE Runtime Environment (build 1.8.0_112-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.


Start a Python Greeter server.


Modify the Python Greeter client to have the following run() method:


def run():
  channel = grpc.insecure_channel('localhost:50051', options=[('grpc.max_metadata_size', 10*1024*1024)])
  stub = helloworld_pb2.GreeterStub(channel)
  response = stub.SayHello(helloworld_pb2.HelloRequest(name='you'), metadata=[('request-metadata', 'x'*20000)])

Run the python client. With the standard package for grpc 1.0.4 for python, the metadata is larger than the default metadata size (16K) and we get (as expected):


grpc._channel._Rendezvous: <_Rendezvous of RPC that terminated with (StatusCode.RESOURCE_EXHAUSTED, {"created":"@1484199373.574894000","description":"RST_STREAM","file":"src/core/ext/transport/chttp2/transport/frame_rst_stream.c","file_line":107,"http2_error":11})>


Now patch this line on the python grpc server init code (we don't yet have the ability to set options :/) with:

server = cygrpc.Server(cygrpc.ChannelArgs([
        cygrpc.ChannelArg(_common.encode('grpc.max_metadata_size'), 10*1024*1024)])) 


Rerun the server and client:
âž¤ python greeter_client.py
Greeter client received: Hello, you!


Change the client to send 4MB of metadata instead:
metadata=[('request-metadata', 'x'*(4*1024*1024))]
âž¤ python greeter_client.py
Greeter client received: Hello, you!


Keep the python server running and run the Java client:


Jan 11, 2017 9:56:34 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Greeting: Hello, world!


Modify the Java client to add metadata:

  public HelloWorldClient(String host, int port) {
    channel = ManagedChannelBuilder.forAddress(host, port)
        // Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid
        // needing certificates.
        .usePlaintext(true)
        .build();

    Metadata metadata = new Metadata();
    Metadata.Key<String> key = Metadata.Key.of("request-metadata", Metadata.ASCII_STRING_MARSHALLER);

    char[] chars = new char[10*1024];
    Arrays.fill(chars, 'x');
    metadata.put(key, new String(chars));

    blockingStub = MetadataUtils.attachHeaders(GreeterGrpc.newBlockingStub(channel), metadata);
  }
Jan 11, 2017 10:07:28 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Greeting: Hello, world!


Modify the Java client to send 4MB of metadata:

 char[] chars = new char[4*1024*1024];
âž¤ ./build/install/examples/bin/hello-world-client
Jan 11, 2017 10:09:40 PM io.grpc.internal.ManagedChannelImpl <init>
INFO: [ManagedChannelImpl@96532d6] Created with target localhost:50052
Jan 11, 2017 10:09:40 PM io.grpc.examples.helloworld.HelloWorldClient greet
INFO: Will try to greet world ...
Jan 11, 2017 10:09:40 PM io.grpc.examples.helloworld.HelloWorldClient greet
**WARNING: RPC failed: Status{code=INTERNAL, description=Connection closed with unknown cause, cause=null}**
Jan 11, 2017 10:09:40 PM io.grpc.internal.ManagedChannelImpl maybeTerminateChannel
INFO: [ManagedChannelImpl@96532d6] Terminated

As a side note, creating the channel with
NettyChannelBuilder.forAddress(host, port)
        .maxHeaderListSize(10*1024*1024))
        .maxMessageSize(10*1024*1024)
        .usePlaintext(true)
        .build()
does not change the outcome (kind of expected, since apparently those options are only for receiving metadata, which is quite confusing).
What did you expect to see?
I expected the Java client to be able to send  as much metadata as the server supports. The python client seems to do it just fine.
What did you see instead?
Starting at around 500KB the Java GRPC client is not able to send the request and the connection errors with WARNING: RPC failed: Status{code=INTERNAL, description=Connection closed with unknown cause, cause=null}.
I'm guessing this behavior is not expected? Are there any workarounds?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2602
BUILD FAILED
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
What JVM are you using (java -version)?
What did you do?
If possible, provide a recipe for reproducing the error.
What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2603
all: bump to netty 4.1.7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins test this please.
jenkins retest this please.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2604
GRPC is logging NOT_FOUND errors as SEVERE and spamming the logs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
gRPC = 1.0.3
We are using NOT FOUND to indicate that a resource is missing on the server. This is an ok response. However, this is getting logged as a SEVERE error on the client side and we can't find a way to control how to turn off logging for this particular error or reduce its severity to INFO.
Can someone help fix this/explain why NOT_FOUND is severe?
cc: @jacob-tock
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2605
	core: ServerImpl returns shared resources at termination
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2606
core: more logs in ManagedChannelImpl.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2607
Tracking Issue for ClientCall getAttributes being Experimental.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specific usages:

ClientCall.getAttributes()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2608
Limit Cipher Suites Available
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
What did you do?
n/a
What did you expect to see?
n/a
What did you see instead?
n/a
I'm using  statically linked tcnative via "netty-tcnative-boringssl-static" in my dependencies.  With ServerBuilder as below....
ServerBuilder.forPort(config.getPort())
        .addService(healthManager.getHealthService())
        .useTransportSecurity(new File(config.getServerCertPemFile()), 
                                       new File(config.getServerCertPemKeyFile()))
        .addService(authenticationService);

How would I limit the cipher suites available to the TLS negotiation to a very specific subset?.  I know I can provide an SSL context to NettyChannelBuilder and NettyServerBuilder but i'm not sure I can limit the available ciphers in there (or if openSSL would even care)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2609
the JVM never exit after added sleep(2000)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8
What did you do?
code is from: https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/helloworld/HelloWorldClient.java
I added  sleep(2000) in the finally block of main:

public static void main(String[] args) throws Exception {
HelloWorldClient client = new HelloWorldClient("localhost", 50051);
try {
/* Access a service running on the local machine on port 50051 /
String user = "world";
if (args.length > 0) {
user = args[0]; / Use the arg as the name to greet if provided */
}
client.greet(user);
} finally {
Thread.sleep(2000);  //added sleep code
client.shutdown();
}
}

What did you expect to see?
the JVM should terminate after client.shutdown();
What did you see instead?
the JVM never terminate
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2610
does one streamId(>=3) represents one RPC call in the same TCP connection?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.1
What JVM are you using (java -version)?
1.8
What did you do?
Does one streamId(>=3) represents one RPC call in the same TCP connection? I mean:
one streamId only can be used for 1 time RPC call
OR
one streamId could be used for multiple times RPC calls?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2611
RoundRobinLoadBalancer minor cleanups
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2612
compile: add std:: to all stl types
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2613
Put server address in ClientCall#attributes()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be very helpful to put the target address into ClientCall#attributes(). One of the use cases is the ability to access it in interceptors.
Without first class support for retries, we're using RetryingInterceptor. We want to be able to write LB logic which in the case of failed attempt, would pick different backed on next call. There's currently no way to achieve that and ability to get information about which address is targeted in given call would solve it (the RetryingInterceptor would then append target address to BACKENDS_TRIED key in affinity attributes, on every attempt).
/cc @dapengzhang0 @zhangkun83  @kkaneda
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2614
docs: add links to examples and tutorials.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2615
Rename attributes() to getAttributes() to make it consistent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2616
core: rename attributes() -> getAttributes()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 resolved conflict, should build green now
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2617
core: rename getAttr() and use standard getAttributes()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I saw this test failure:
io.grpc.okhttp.OkHttpTransportTest > clientCancel FAILED
    java.lang.AssertionError

That strikes me as very strange. I'm very disappointed it didn't give more backtrace information. Probably a flake, but it'd be nice to know what assertion failed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2618
core: DelayedStream cancels provided stream if not using it.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you look at this, it is blocking 1.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2619
core: pass down addr to which client is connected
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is first stab at conveying target address down to ClientCall. It's not fully functional yet, @zhangkun83 let me know if this is the way how you would like it to be implemented?
cc @kkaneda
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2620
all: ErrorProne fixes and avoid @Beta in Guava
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2621
docs: fix deprecation reference in ClientAuthInterceptor.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2622
core: add debug information in MessageDeframer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was meant to refer to #2157 in the commit message, but it was wrapped at the beginning of a line and treated as comment.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2623
thrift: disable export of artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2624
Client Error: io.grpc.StatusRuntimeException: UNKNOWN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.2
What JVM are you using (java -version)?
1.8
What did you do?
I am running a gRPC-java server with multiple grpc services defined.
When running multiple stubs and their multiple rpc calls simultaneously I am seeing this exception below thrown.
io.grpc.StatusRuntimeException: UNKNOWN
	at io.grpc.Status.asRuntimeException(Status.java:545)
	at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:395)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:481)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$600(ClientCallImpl.java:398)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:513)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

This happens only when I have multiple stubs with their own channel defined and the occurrence of the exception seems to be more frequent when increasing the number of stubs/rpc calls. This looks to me like some sort of resource issue either client or server side. I have increased the thread count and seen no measurable improvements. Not sure where to go from here?
My server setup is as follows:
private final NettyServerBuilder builder;
private final NioEventLoopGroup workerGroup;
...
...

// The options are currently set to the defualt grpc settings. So in effect these should not change the default environment.
// NioEventLoopGroup( 2 * Runtime.getRuntime().availableProcessors() )
builder.workerEventLoopGroup( workerGroup )
                              // 1048576
				.flowControlWindow( options.getFlowControlWindow() ) 
                              // Integer.MAX_VALUE
				.maxConcurrentCallsPerConnection( options.getMaxConcurrentCallsPerConnection() )
                              // 8192
				.maxHeaderListSize( options.getMaxHeaderListSize() )
                              // 4 * 1024 * 1024
				.maxMessageSize( options.getMaxMessageSize() )
                              //ProtocolNegotiators.serverPlaintext()
				.protocolNegotiator( options.getProtocolNegotiator() ) 
                              // Executors.newFixedThreadPool(20)
				.executor( executor )
                              // CompressorRegistry.getDefaultInstance()
				.compressorRegistry( options.getCompressorRegistry() )
                               // DecompressorRegistry.getDefaultInstance()
				.decompressorRegistry( options.getDecompressorRegistry() );

My Client setup:
ManagedChannel channel = NettyChannelBuilder.forAddress( remote_host, remote_port )
				.usePlaintext( true )
				.build();

Runtime.getRuntime().addShutdownHook( new Thread( new Runnable() {
			@Override
			public void run() {
				channel.shutdown();
				try {
					channel.awaitTermination( 120, TimeUnit.SECONDS );
				} catch ( InterruptedException e ) {
					Thread.currentThread().interrupt();
				}
			}
		} ) );

CallOptions callOptions = CallOptions.DEFAULT.withCompression( "gzip" );
// Where stubClazz would be the grpc-proto stub
Constructor<Stub> constructor = stubClazz.getDeclaredConstructor( Channel.class,
				CallOptions.class );
constructor.setAccessible( true );
return constructor.newInstance( channel, callOptions );

What did you expect to see?
I expect to get back the response object.
What did you see instead?
Instead I received a io.grpc.StatusRuntimeException: UNKNOWN
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2625
core: change method descriptor to be builder based
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
I feel much better for this than the current mixture of create() and with(). Unfortunately it's too late to remove create(). Should with()es be marked as deprecated?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2626
AbstractInteropTest.maxInboundSize_exact is too picky of the precise protobuf encoding
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If the client encodes protos ever-so-slightly differently than the server, the size the server sends won't match the computed size the client generates. If the server uses a more verbose encoding, it results in an error like:
io.grpc.StatusRuntimeException: INTERNAL: Frame size 7 exceeds maximum: 5. 
	at io.grpc.Status.asRuntimeException(Status.java:542)
	at io.grpc.stub.ClientCalls$BlockingResponseStream.hasNext(ClientCalls.java:529)
	at io.grpc.stub.ClientCalls$BlockingResponseStream.next(ClientCalls.java:536)
	at io.grpc.testing.integration.AbstractInteropTest.maxInboundSize_exact(AbstractInteropTest.java:800)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2627
all: make some api non-experimental for 1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm okay with ServerCalls, and the wait for ready changes, don't know about the Options changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2628
core: Fix a minor typo in the javadoc of MethodDescriptor#withSafe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2629
core: cancel RPC when exception in server onReady
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2630
docs: clarify requirements of detach().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2631
ClientCalls drops cause
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ClientCalls.toStatusRuntimeException drops the original cause of the Status when converting a Throwable to an SRE.  This results in somewhat useless stack traces, as the original stack trace is lost.  (or at least not printed).  This also happens in BlockingResponseStream.hasNext
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2632
core: mark Server.getPort non experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is it identical to part of #2627?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2633
Do not pass ClassLoader to Class.forName, for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #2207. An easy workaround for #2207 was to specify -keep in ProGuard configuration. However, everyone would be happier if such configuration was unnecessary. Using forName() without passing ClassLoader should remove the need for configuration, as originally intended.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2634
core: make StatsContextFactory setters protected
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2635
android: Fix ProGuard rules in Android apps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2636
ServiceDescriptor constructor is error prone
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The ServiceDescriptor(String, Collection<MethodDescriptor<?, ?>) constructor is error prone.  Getting the generics slightly wrong results in ServiceDescriptor(String, Object, MethodDescriptor<?, ? ...) being invoked instead.  This can happen if the second arg is List<MethodDescriptor<Void, Void>> for example.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2637
core: make ServiceDescriptor check input values
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2638
Unable to build 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
Downloaded a master copy of https://github.com/grpc/grpc-java.git on 21st Jan 2017.
What JVM are you using (java -version)?
javac 1.8.0_101
I am facing a similar issue described in
#1189
I am unable to build.
Build log  says
linking protoc-gen-grpc-java failed.
/usr/bin/ld: cannot find -lstdc++
collect2: error: ld returned 1 exit status
I am using Cent OS 7
I have libStd packages installed
[aditya@centos grpc-java]$ yum list libstdc++*
Loaded plugins: fastestmirror, langpacks
Determining fastest mirrors

base: centos-hcm.viettelidc.com.vn
epel: epel.mirror.net.in
extras: centos.excellmedia.net
updates: centos.excellmedia.net
WandiscoSVN                                                                                                                                             55/55
Installed Packages
libstdc++.x86_64                                                                4.8.5-4.el7                                                          @anaconda
libstdc++-devel.x86_64                                                          4.8.5-4.el7                                                          @anaconda
Available Packages
libstdc++.i686                                                                  4.8.5-11.el7                                                         base
libstdc++.x86_64                                                                4.8.5-11.el7                                                         base
libstdc++-devel.i686                                                            4.8.5-11.el7                                                         base
libstdc++-devel.x86_64                                                          4.8.5-11.el7                                                         base
libstdc++-docs.x86_64                                                           4.8.5-11.el7                                                         base
libstdc++-static.i686                                                           4.8.5-11.el7                                                         base
libstdc++-static.x86_64                                                         4.8.5-11.el7                                                         base

And
protoc version is "libprotoc 3.1.0"
Please help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2639
Replace Mockito with StreamObserver for several interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reassiging to ejona, who said he would be removing StreamRecorder
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2640
core: Only use scheduled executor for timer tasks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2641
Tracking Issue for MethodDescriptor.Builder being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2642
all: avoid DNS with GRPC_PROXY_EXP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2643
Add Since javadoc annotations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if we could quickly tell when methods / APIs were added.  Javadoc has the @since annotation for this purpose.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2644
services: Remove no-op call in reflection service test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2645
core: remove with* methods from MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2646
Provide Attribute for i.n.c.unix.PeerCredentials when using EpollDomainSocketChannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpc 1.0.3
What JVM are you using (java -version)?
java version "1.8.0_111"
Feature Request
We'd like to get access to the EpollDomainSocketChannel to access method peerCredentials() (new in Netty release 4.1.7) from within a gRPC server's BindableService call.
We're using gRPC with Unix Domain Sockets (Netty's EpollServerDomainSocketChannel) on a server to manage a hardware resource.  We allow a single user (but multiple processes) to open the resource more than once, but we need to reserve the resource while that user has it open and not allow any other users access to the device.  Our server needs to be resilient and detect that the client program has potentially crashed and allow the resource to be cleaned up and made available for another user.
We can add a ServerInterceptor but still I haven't figured out to get the Channel.
Can we get access from a ServerCall object to the Channel (understanding that it may be null for an Inprocess server)?  Or other alternatives?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2647
why my grpc-java client on version 1.0.3 threw io.netty.util.internal.OutOfDirectMemoryError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm testing the latest version of grpc-java which version is 1.0.3. The client always throws io.netty.util.internal.OutOfDirectMemoryError. why....
====================client code ======================
    public static void main(String[] args) throws InterruptedException{
        ManagedChannelImpl channel = NettyChannelBuilder.forAddress("localhost", 10000)
                .negotiationType(NegotiationType.PLAINTEXT)
//                .eventLoopGroup(new NioEventLoopGroup())
                .executor(new ThreadPoolExecutor(128,1024,60,TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),(r)->{
                    Thread t=new Thread(r);
                    t.setUncaughtExceptionHandler((Thread th,Throwable e)->{
                        e.printStackTrace();
                    });
                    return t;
                },new ThreadPoolExecutor.AbortPolicy()))
//                .idleTimeout(60,TimeUnit.SECONDS)
                .loadBalancerFactory(RoundRobinLoadBalancerFactory.getInstance())
                .build();
        Message msg=Message.newBuilder().addApid(1).addApid(2).addApid(3).setAge(23).setName("test").setTest(true).build();
        EchoStub stub=EchoGrpc.newStub(channel);
        
        long start=System.currentTimeMillis();
        int c=100_0000;
        CountDownLatch latch=new CountDownLatch(c);
        for(int i=0;i<c;i++){
            stub.echo(msg,new StreamObserver<Message>(){
                public void onCompleted(){
                    latch.countDown();
                }
                public void onError(Throwable t){
                    
                }
                public void onNext(Message m){
                }
            });
        }
        System.out.println("FFFFFFFFFFF");
        latch.await();
        System.out.println(System.currentTimeMillis()-start);
        channel.shutdownNow();
    }
====================exception stack=====================
io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 520093983, max: 536870912)
	at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:624)
	at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:578)
	at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:709)
	at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:698)
	at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:237)
	at io.netty.buffer.PoolArena.allocate(PoolArena.java:213)
	at io.netty.buffer.PoolArena.allocate(PoolArena.java:141)
	at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:262)
	at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:179)
	at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115)
	at io.grpc.netty.NettyWritableBufferAllocator.allocate(NettyWritableBufferAllocator.java:66)
	at io.grpc.internal.MessageFramer.writeKnownLength(MessageFramer.java:190)
	at io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:149)
	at io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:126)
	at io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:172)
	at io.grpc.internal.DelayedStream$3.run(DelayedStream.java:201)
	at io.grpc.internal.DelayedStream.drainPendingCalls(DelayedStream.java:121)
	at io.grpc.internal.DelayedStream.setStream(DelayedStream.java:90)
	at io.grpc.internal.DelayedClientTransport$PendingStream.createRealStream(DelayedClientTransport.java:392)
	at io.grpc.internal.DelayedClientTransport$PendingStream.access$100(DelayedClientTransport.java:379)
	at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:262)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "Thread-48"

Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "Thread-50"

Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "Thread-58"

Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2648
ForwardingClientCall.getAttributes() should call delegate().getAttributes()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2649
NameResolver can be NotThreadSafe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With ManagedChannelImpl2, NameResolver is always called from Channel Executor, except for getAuthority(). After ManagedChannelImpl2 is promoted, NameResolver can get rid of @ThreadSafe.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2650
Decide whether LBv2 should be kept in 1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If we do, we could provide a better (non-atomic) migration path for people (implementors) implementing LoadBalancer.
During 1.1, we keep the old API intact, and include the v2 API as LoadBalancer2. Implementors re-write their LBs with the v2 API, and migrate their customers to their v2 LB. The two versions of LB impls can coexist.
In 1.2, we replace LoadBalancer with LoadBalancer2, and keep LoadBalancer2 as an alias to LoadBalancer by extending it. The old LB impls stop working. Before switching to 1.2, the implementors must have switched all their customers to the v2 API. During 1.2, they can migrate their customers to the proper LoadBalancer name.
In 1.3, we delete LoadBalancer2.
The caveat is that it increases the size of Android packages in 1.1. It shouldn't be a significant amount compared with the existing code size. We should at least calculate the exact size and note it in release notes.
If we are going to do this, we should also change the @Internal annotations to @ExeprimentalApi on the v2 APIs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2651
AbstractInteropTest should not depend on TestUtils
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PR #2634 accidentally added a dep from src/tests to another src/test directory, which is uncommon.  Shared test library code needs to be under a /testing/ directory in the src/java which can be reused by multiple test suites.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2652
core: stop "testing" from depending on "core"'s test.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2653
Create GrpclbLoadBalancerFactory2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If #2650 is resolved by keeping LBv2 in 1.1, we should also add GrpclbLoadBalancerFactory2 for 1.1, otherwise GrpclbLoadBalancer2 will not be accessible to users.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2654
core: allow LBv2 impls to be stripped out by ProGuard.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2655
about Netty initChannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
1.7.0_80
What did you do?
If possible, provide a recipe for reproducing the error.
no error
What did you expect to see?
What did you see instead?
when netty client connect netty server,  exec initChannel, and new NettyServerTransport, and new NettyServerHandler...
so in server:
1 conn -----> 1 new NettyServerTransport, and new NettyServerHandler...
2 conn -----> 2 new NettyServerTransport, and new NettyServerHandler...
......
n conn -----> n new NettyServerTransport, and new NettyServerHandler...
in mem, too many new new new ......
Do you understand what I mean?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2656
Switch to LBv2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LBv2 (design doc) consists of LoadBalancer2 and its supporting channel implementation ManagedChannelImpl2. Here we outline the transition path from the current LoadBalancer and ManagedChannelImpl (a.k.a LBv1) to LBv2.
The transition is transparent to users who only use the default or stock LoadBalancers that are shipped with gRPC. The following transition plan should only concern advanced users who implement or use custom LoadBalanacer(s).
Also note all changes happen on master first. The changes scheduled for gRPC 1.2 will happen on master soon after 1.1 is released.
During gRPC 1.1
LBv1 and LBv2 coexist. LBv1 is the default one. Both can be set to the channel builder, while LBv2 is used only if a LoadBalancer2 implementation is set to the channel builder.
During this period, implementors re-write their LBs with the v2 API, and migrate their customers to their v2 LBs.
For example, FooBalancerFactory is the current LB, while Foo2BalancerFactory is the new one that uses LBv2.
class FooBalancerFactory extends LoadBalancer.Factory {
}

class Foo2BalancerFactory extends LoadBalancer2.Factory {
}
While the v1 version continues working:
NettyChannelBuilder.forTarget(...).loadBalancerFactory(new FooBalancerFactory()).build();
Customers should be migrated to use the v2 version:
NettyChannelBuilder.forTarget(...).loadBalancerFactory(new Foo2BalancerFactory()).build();
During gRPC 1.2
We replace LoadBalancer with LoadBalancer2, and keep LoadBalancer2 as an alias to LoadBalancer by extending it. LBv1 interfaces and codepath are deleted. All v1-based LBs stop working with gRPC.
Prior to switching to 1.2, the implementors must have switched all their customers to the v2-based LoadBalancer2. During 1.2, they should rebase their v2-based implementations to the proper LoadBalancer interface.
For example, this continues working because LoadBalancer2 extends LoadBalancer:
class Foo2BalancerFactory extends LoadBalancer2.Factory {
}
.., but it should be updated to this to prevent breakage with gRPC 1.3:
class Foo2BalancerFactory extends LoadBalancer.Factory {
}
gRPC 1.3
We delete the alias LoadBalancer2.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2657
services: make reflection test able to re-root proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2658
core: open up LBv2 APIs for early adopters
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2659
all: update to latest import ordering
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2660
all: fix linter found on import
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2661
documentation: new server reflection tutorial
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2662
[WIP] core: Allow LoadBalancer2 to use a different authority per SubChannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We can workaround this, but I can imagine other people having similar issues in the future.
@ejona86 @zhangkun83 thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2663
netty: call transportReady in handleProtocolNegotiationCompleted
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CC @lukaszx0, @kkaneda
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2664
CONNECT forward port
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2665
docs: security requirement of NameResolver.getServiceAuthority()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc @kkaneda @lukaszx0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2666
Tracking issue for ServiceDescriptor.Builder being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2667
core: make ServiceDescriptor use the Builder pattern
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2668
Catch Throwable instead Exception or RuntimeException&Error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While debugging my code problems I spot several places in the library code that might lead to uncatched/unreported exceptions being thrown through catch blocks.
In SerializingExcutor.TaskRunner#run there is try { .. } catch (RuntimeException e) { .. } block. It could easily happen any other Exception or Error can be thrown. (since checked exceptions are not necessarily on bytecode level, an Exception types are also possible, no matter they are not declared in Java code).
In the ServerImpl I see slightly incorrect check, that catches RuntimeException and Error only. I suppose a bit correct is to catch Throwable there too.  In messageRead, streamCreated, halfClosed methods.
There are a few more places I found, e.g. in RouteGuideActivity, RouteGuideClient, AsyncFrameWriter.WriteRunnable#run, GRPCUtil#TIMER_SERVICE,  MessageFramer,
ManagedChannelProvider#isAndroid, ClientInterceptors.CheckedForwardingClientCall#start, NameResolverProvider#isAndroid,
In internal/Util it is not clear if Throwable should be checked
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2669
testing: change names of noopMarshaller to void marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's not clear: are you planning to delete noopMarshaller? "change names" would seem to imply so, but your commit description seems to imply not so.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2670
all: upgrade to netty 4.1.8 and tcnative Fork26
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2671
netty: work around netty bug when RPCs may be reset early
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also, I manually confirmed this test works with 100 runs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2672
netty: fix race in server channel startup and shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2673
core: record server_elapsed_time on client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2674
Start 1.2.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2675
Release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2676
releasing: Add docs for creating new Jenkins job
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2677
gRPC 1.1.0 uses wrong Protoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For posterity:
Protobuf team released 3.1.0, which was accidentally built on a developer machine.  This caused the artifacts that were uploaded to Maven central to require glibc 2.14 or later.  This was not noticed at the time, and gRPC Java was changed to depend on 3.1.0.  Later it was found out  that this prevented users from using it since they use an older version of glibc.
Maven central prevents removing or modifying an artifact once released, so Protobuf team uploaded a new version, built from the protoc-artifacts/Dockerfile, which does have the correct dependencies.  This was uploaded as 3.1.0-build2.  Unfortunately, none of the other artifacts of (like the java libraries) were uploaded.
Meanwhile gRPC was unaware of this rename (it happened during the 1.1 release cycle), and was using 3.1.0 successfully since all gRPC developers machines are using a later glibc.  1.1 was cut, but now doesn't build using the docker image, since Protobufs own docker image doesn't contain the dependencies of the artifact.  There are a couple ways forward:

Revert v1.1.0, and rewrite the v1.1.x branch to use the proper protoc artifact.  This will break anyone who depended on the branch or tag in the brief window that it existed.    Once the correct protoc artifact is used, the branch will be rereleased and retagged.  This is probably okay, since the gRPC artifacts have not be released.  One downside is that the protoc and proto java libraries will not match, and will have an inconsistent  protobufVersion in the gradle file.
Like 1, it would be possible to just upgrade to 3.2.0.  3.2.0 hasn't been as well tested, but solves the protoc version not matching the proto libraries.  It would also have to be fixed in master
Don't rewrite history, dump the 1.1.0 tag, and move immediately to 1.1.1.  The errors of the past will be set in stone, and 1.1.0 will never exist as an artifact.
Some sort of hack to use the 3.1.0-build2 proto artifact when building the grpc plugin, but keeping the dependencies the same in the gradle file.  This lets us keep the version, but anyone using grpc plugin will be force to use a later glibc.  (2.14 came out in 2011).  This might be okay, assuming that 1.2 will be released soon anyways and have this fixed.

@ejona86 @zhangkun83 thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2678
core: clean up code deprecated in 1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What's the deprecation policy then? (ie. when we're free to clean up stuff?) Also, ClientAuthInterceptor seems like the one which is very easily "backportable" - just copy it into your repo internally, even leaving original package name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2679
Add 1.1.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2680
The JWT cloud-to-prod auth interop test is failing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://grpc-testing.appspot.com/job/gRPC_interop_master/10740/testReport/(root)/tests/cloud_to_prod_auth_default_java_jwt_token_creds/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2681
grpc-thrift 1.1.1 has not been published to maven repo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.1.1
What did you do?
Included grpc-all 1.1.1 as a dependency in a maven project
What did you expect to see?
grpc-all and all dependencies download from maven central
What did you see instead?
Could not find io.grpc:grpc-thrift:1.1.1.
Searched in the following locations:
https://repo1.maven.org/maven2/io/grpc/grpc-thrift/1.1.1/grpc-thrift-1.1.1.pom
https://repo1.maven.org/maven2/io/grpc/grpc-thrift/1.1.1/grpc-thrift-1.1.1.jar
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2682
overrideAuthority does not impact authority for JWT in jwt_token_creds
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
65e4d9f#diff-850c920bd69ac031d7e98cab9459dec8 caused grpc/grpc#9497
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2683
interop-testing: overrideAuthority breaks JWT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2684
Remove excessive logging in ManagedChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
master
What JVM are you using (java -version)?
Java8
What did you do?
If possible, provide a recipe for reproducing the error.
This was discovered in the internal stress test.
What did you expect to see?
What did you see instead?
Tons of
INFO: [io.grpc.internal.ManagedChannelImpl-277] Created with target directaddress:///foo.test.google.fr/[ip:port]
Jan 31, 2017 5:30:18 PM io.grpc.internal.ManagedChannelImpl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2685
docs: Remove annoying diff section heading
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2686
testing: fix StreamRecorder error not thread safe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is this different than #2385 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2687
Http2OkHttpTest.deadlineExceededServerStreaming is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://travis-ci.org/grpc/grpc-java/jobs/197410836

io.grpc.testing.integration.Http2OkHttpTest > deadlineExceededServerStreaming FAILED
java.lang.NullPointerException: t
tests completed, 1 failed
:grpc-interop-testing:test FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2688
Would it be possible to shade guava?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3 and 1.1.1
What JVM are you using (java -version)?
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)
What did you do?
GRPC 1.1+ uses Guava 20.0.   We have a very large codebase that uses both internal and external libraries that depend on older version of guava.  These libraries are not compatible with Guava 20.0.  As a result we are unable to upgrade to GRPC 1.1.+.   From what I can tell the only Guava class exposed by GRPC is ListenableFutures, via ClientCalls in grpc-stub.  Would it be possible to shade all other uses of Guava in GRPC.
There would still be an issue with the GRPC code generator that does expose Guava's ListenableFuture.  For that use case would it be possible to make generating those stubs optional and perhaps even add an option to generate a CompletableFuture stub?
What did you expect to see?
Newer versions of GRPC to not break other libraries depending on older version of Guava.
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2689
Reflection service can return inconsistent results
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The service currently calls serverReflectionIndex.updateMutableIndexIfNecessary() after receiving each request in the stream. This is not only needless processing, but actually against the point. The reflection API is streaming so that each stream can be independently consistent. This is normally important when a load balancer may direct each request to a different backend. However, in this case it could also handle the mutable nature of the services.
Although serverReflectionIndex is volatile, it is not assigned in a thread-unsafe way; it could be non-volatile. However, I would suggest making ServerReflectionIndex immutable and create a new/derivative each time the mutable index is detected to change (probably using locking instead of volatile). I would then suggest checking for updates to the mutable index at the beginning of each RPC (serverReflectionInfo()) and then copying the current ServerReflectionIndex reference to the ProtoReflectionStreamObserver.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2690
services: add monitoring proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2691
ManagedClientTransport.start should be better defined
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Calling  ManagedClientTransport.start returns a Runnable, but it isn't clear what to do with it, or when it should be called.  While the code is annotated @CheckReturnValue, the annotation doesn't get inherited across class boundaries, leading to places where the value is ignored.  NettyClientTransportTest contains several invocations of start, but ignores the return value due to NettyClientTransport currently returning null.
The difficulty of describing when and how the Runnable should be used feels indicative of shaky API.  It would be nice to modify InternalSubchannel to not need to acquire locks to alleviate the need to run code outside of locks.  This is not urgent.
@zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2692
netty: add return value errorprone annotations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc: @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2693
compiler: add some missing final modifiers on generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2694
interop-testing: fix flakes in Http2Client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2695
core: expose #ping in Subchannel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Long-term, I question if the transports should just keep track of their latency. They know the latency initially via SETTINGS ack and then later via flow control pinging.
But we may open this up in the short-term, since people were already using it in the previous LB setup.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2696
core: replace EquivalentAddressGroup with ResolvedServerInfo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I just pushed a proof of concept to illustrate my proposal. It doesn't work at all and I didn't bother to change var names etc. mostly just changed types everywhere and did few minor code adjustments as I wanted to discuss it first (if we'll go with it, we probably want to consider renaming ResolvedServerInfo to maybe something more generic, too).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2697
core: un-abstract the LBv2 setter in ManagedChannelBuilder.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Backported in #2702
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2698
Memory allocation not decreasing as load decreases or moves to zero
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I started down this path because I found the memory leak in 1.0.1 (fixed in 1.0.3) through load testing, but I see something that doesn't appear to behave as it should in 1.0.3.  The memory footprint increases relative to the amount of concurrent requests, but it doesn't appear to ever decrease when load decreases or goes to zero.  This may be expected, but I thought I would bring it up here.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
1.8.0_60-b27
What did you do?
If possible, provide a recipe for reproducing the error.
Many goroutines (hundreds, thousands) to create concurrent requests in a streaming server.

clone the example 1.0.3 branch git clone -b v1.0.3 https://github.com/grpc/grpc-java.git
navigate to the examples dir
build it ./gradlew installDist
run routeguide server ./build/install/examples/bin/route-guide-server
Load test it with 1000 concurrent requests, 5 loops each, for 1 minute. repeat 5 times.

I built a small go utility to do exactly this, just build and run with -c 1000


wait 3-5 minutes for JVM garbage cleanup.
Memory usage will stay around 2GB.

What did you expect to see?
Memory usage increases relative to the number of concurrent requests, and decreases (eventually)  as the load goes to zero, or is completely zero.
What did you see instead?
Memory usage goes up as expected when handling thousands of concurrent requests, but never decreases as load moves to zero.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2699
all: update to protobuf 3.2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2700
all: drop thrift from grpc-all deps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For #2681
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2701
all: remove thrift from grpc-all export
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2702
core: un-abstract the LBv2 setter in ManagedChannelBuilder.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2703
AssertionError in OkHttpClientTransport from older Android devices
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using gRPC on HTC M7 (2013), a crash occurs (AssertionError) that seems to be from the protocol negotiation in OkHttp transport.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
HTC M7 (2013) - Android 4.3 (HTC Sense 5.0)
FATAL EXCEPTION: grpc-okhttp-0
                                                          java.lang.AssertionError: Method getAlpnSelectedProtocol not supported for object SSL socket over Socket[address=suggestions-api.invi.im/104.197.200.100,port=80,localPort=37661]
                                                              at io.grpc.okhttp.internal.OptionalMethod.invoke(OptionalMethod.java:114)
                                                              at io.grpc.okhttp.internal.OptionalMethod.invokeWithoutCheckedException(OptionalMethod.java:135)
                                                              at io.grpc.okhttp.OkHttpProtocolNegotiator$AndroidNegotiator.getSelectedProtocol(OkHttpProtocolNegotiator.java:208)
                                                              at io.grpc.okhttp.OkHttpProtocolNegotiator$AndroidNegotiator.negotiate(OkHttpProtocolNegotiator.java:170)
                                                              at io.grpc.okhttp.OkHttpTlsUpgrader.upgrade(OkHttpTlsUpgrader.java:74)
                                                              at io.grpc.okhttp.OkHttpClientTransport$1.run(OkHttpClientTransport.java:425)
                                                              at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
                                                              at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)
                                                              at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)
                                                              at java.lang.Thread.run(Thread.java:849)

Seems like if the catch clause here was catching Throwable (rather than Exception) it would not crash and return null: https://github.com/grpc/grpc-java/blob/master/okhttp/src/main/java/io/grpc/okhttp/OkHttpProtocolNegotiator.java#L205
Not sure how gRPC behaves in this case but comments in the method seem to suggest that's a scenario that can be expected
Stock Web browser

Chrome browser
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2704
Implement missing authority API for HandlerRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2705
all: swap to newer animalsniffer plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2706
Update to 1.1.2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2707
core: switch to LBv2 as the default.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2708
core: Tweak getAttributes() JavaDoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2709
Implement missing authority API for HandlerRegistry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2710
gRPC memory leak? when send ton of data
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
java version "1.7.0_80"
Java(TM) SE Runtime Environment (build 1.7.0_80-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
Client side just a simple for loop to invoke rpc method.
Server side , i also set the maxConcurrentCallsPerConnection to 5.
What did you expect to see?
send at least 1M message frequently.
What did you see instead?
There are two doubt I don't understand.

Within log file , i see lots of OutOfDirectMemoryError, show as following:
Feb 08, 2017 12:41:13 AM io.grpc.netty.NettyServerTransport notifyTerminated
SEVERE: Transport failed
io.netty.handler.codec.DecoderException: io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 251658527, max: 255066112)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:252)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Caused by: io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 251658527, max: 255066112)
at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:624)
at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:578)
at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:709)
at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:698)
at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:237)
at io.netty.buffer.PoolArena.allocate(PoolArena.java:221)
at io.netty.buffer.PoolArena.allocate(PoolArena.java:141)
at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:262)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:179)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:170)
at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:107)
at io.netty.handler.codec.ByteToMessageDecoder.expandCumulation(ByteToMessageDecoder.java:475)
at io.netty.handler.codec.ByteToMessageDecoder$1.cumulate(ByteToMessageDecoder.java:88)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:246)
... 15 more

Feb 08, 2017 12:41:13 AM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16777216 byte(s) of direct memory (used: 251658527, max: 255066112)
at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:624)
at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:578)
at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:709)
at io.netty.buffer.PoolArena$DirectArena.newChunk(PoolArena.java:698)
at io.netty.buffer.PoolArena.allocateNormal(PoolArena.java:237)
at io.netty.buffer.PoolArena.allocate(PoolArena.java:221)

when I using linux Top command to see the java process. I found that the RES memory size is much bigger than the jvm heap size plus the off-heap size. see as following,
PID     USER      PR  NI    VIRT      RES       SHR  S %CPU  %MEM     TIME+        COMMAND
53709 hadoop    20   0 1470520 714356   5524  S  0.3        70.8         35:36.90         java

and java jvm configuration show as following,
-Xms256M -Xmx256M -XX:-HeapDumpOnOutOfMemoryError -Xmn128M -Djava.net.preferIPv4Stack=true -Dio.netty.leakDetectionLevel=advanced -verbose:gc -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:logs/gc.log -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads=2 -Djetty.logs=/home/hadoop/gp-service-bitmap/jetty-9.2.20/logs -Djetty.home=/home/hadoop/gp-service-bitmap/jetty-9.2.20 -Djetty.base=/home/hadoop/gp-service-bitmap/jetty-9.2.20 -Djava.io.tmpdir=/tmp
and the max direct memory size is 243.25 MB which is figured out by using PlatformDependent.maxDirectMemory().
thank you, can you make any suggestion ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2711
netty: Fix CheckReturnValue failure in test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2712
core: DelayedStream getAttributes to throw IllegalStateExeption if not passThrough
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2713
Protoc throws error=7, Argument list too long
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
1.8.0_66, vendor: Oracle Corporation
What did you do?
I tried to compile 1886 proto files using maven.
Getting the following exception
[ERROR] Failed to execute goal org.xolstice.maven.plugins:protobuf-maven-plugin:0.5.0:compile (default) on project i3grpc-client: An error occurred while invoking protoc. Error while executing process. Cannot run program "target/protoc-plugins/protoc-3.0.2-osx-x86_64.exe": error=7, Argument list too long -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.xolstice.maven.plugins:protobuf-maven-plugin:0.5.0:compile (default) on project i3grpc-client: An error occurred while invoking protoc.
Caused by: java.io.IOException: Cannot run program "/target/protoc-plugins/protoc-3.0.2-osx-x86_64.exe": error=7, Argument list too long
at java.lang.ProcessBuilder.start(ProcessBuilder.java:1048)
at java.lang.Runtime.exec(Runtime.java:620)
at org.codehaus.plexus.util.cli.Commandline.execute(Commandline.java:655)
... 27 more
Caused by: java.io.IOException: error=7, Argument list too long
at java.lang.UNIXProcess.forkAndExec(Native Method)
at java.lang.UNIXProcess.(UNIXProcess.java:248)
at java.lang.ProcessImpl.start(ProcessImpl.java:134)
at java.lang.ProcessBuilder.start(ProcessBuilder.java:1029)
... 29 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2714
Enable NettyChannelBuilder to set default call credentials
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I spoke with @ejona86 regarding this issue.  Currently, there's no straightforward way to set a default call credentials using io.grpc.netty.NettyChannelBuilder to allow all calls using this channel to have a default credential.  Right now one approach is to pass an interceptor, such as ClientAuthInterceptor, to ChannelBuilder. (here's an example: https://github.com/googleapis/gax-java/blob/master/src/main/java/com/google/api/gax/grpc/InstantiatingChannelProvider.java#L116)
However, ClientAuthInterceptor is deprecated.  Therefore, it would be great if ChannelBuilder could provide a method, say "callCredentials",  such that one can do something like NettyChannelBuilder.forAddress(addr, port).callCredentials(creds).build()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2715
java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've been grappling all day with java.lang.NoSuchMethodError issues, presumably due to Guava conflicts and some strange interaction with maven. I've also tried with different version of grpc-* and the protoc plugin, to no avail.
Relevant parts of my pom.xml:
> <dependency>
>       <groupId>io.grpc</groupId>
>       <artifactId>grpc-netty</artifactId>
>       <version>1.0.3</version>
>     </dependency>
>     <dependency>
>       <groupId>io.grpc</groupId>
>       <artifactId>grpc-protobuf</artifactId>
>       <version>1.0.3</version>
>     </dependency>
>     <dependency>
>       <groupId>io.grpc</groupId>
>       <artifactId>grpc-stub</artifactId>
>       <version>1.0.3</version>
>     </dependency>

> <plugins>
>         <plugin>
>         <groupId>org.xolstice.maven.plugins</groupId>
>         <artifactId>protobuf-maven-plugin</artifactId>
>         <version>0.5.0</version>
>         <configuration>
>           <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>
>           <pluginId>grpc-java</pluginId>
>           <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.0.3:exe:${os.detected.classifier}</pluginArtifact>
>           <checkStaleness>true</checkStaleness>
>         </configuration>
>         <executions>
>           <execution>
>             <goals>
>               <goal>compile</goal>
>               <goal>compile-custom</goal>
>             </goals>
>           </execution>
>         </executions>
>       </plugin>
>       <plugin>
> 

Here is also the relevant output of mvn dependency:tree -X:
[INFO] +- junit:junit:jar:4.12:test
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] +- org.checkerframework:checker-qual:jar:2.1.6:compile
[INFO] +- org.checkerframework:checker:jar:2.1.6:compile
[INFO] +- org.checkerframework:compiler:jar:2.1.6:compile
[INFO] +- org.checkerframework:jdk8:jar:2.1.6:compile
[INFO] +- io.grpc:grpc-netty:jar:1.0.3:compile
[INFO] |  +- io.grpc:grpc-core:jar:1.0.3:compile (version selected from constraint [1.0.3,1.0.3])
[INFO] |  |  +- io.grpc:grpc-context:jar:1.0.3:compile
[INFO] |  |  \- com.google.code.findbugs:jsr305:jar:3.0.0:compile
[INFO] |  +- io.netty:netty-handler-proxy:jar:4.1.6.Final:compile
[INFO] |  |  +- io.netty:netty-transport:jar:4.1.6.Final:compile
[INFO] |  |  |  +- io.netty:netty-buffer:jar:4.1.6.Final:compile
[INFO] |  |  |  |  \- io.netty:netty-common:jar:4.1.6.Final:compile
[INFO] |  |  |  \- io.netty:netty-resolver:jar:4.1.6.Final:compile
[INFO] |  |  +- io.netty:netty-codec-socks:jar:4.1.6.Final:compile
[INFO] |  |  |  \- io.netty:netty-codec:jar:4.1.6.Final:compile
[INFO] |  |  \- io.netty:netty-codec-http:jar:4.1.6.Final:compile
[INFO] |  \- io.netty:netty-codec-http2:jar:4.1.6.Final:compile (version selected from constraint [4.1.6.Final,4.1.6.Final])
[INFO] |     \- io.netty:netty-handler:jar:4.1.6.Final:compile
[INFO] +- io.grpc:grpc-protobuf:jar:1.0.3:compile
[INFO] |  +- com.google.guava:guava:jar:19.0:compile
[INFO] |  +- com.google.protobuf:protobuf-java-util:jar:3.0.2:compile
[INFO] |  |  \- com.google.code.gson:gson:jar:2.3:compile
[INFO] |  +- com.google.protobuf:protobuf-java:jar:3.0.2:compile
[INFO] |  \- io.grpc:grpc-protobuf-lite:jar:1.0.3:compile
[INFO] \- io.grpc:grpc-stub:jar:1.0.3:compile


Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.3 (also tried 1.1.2)
What JVM are you using (java -version)?
java version "1.8.0_101"
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
(See above for pom.xml)
I then followed the HelloWorld example to build a client and a server. In a Junit test case, the client simply invokes the rpc via a blockingStub.
What did you expect to see?
No errors.
What did you see instead?
With 1.0.3
 java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.directExecutor()Ljava/util/concurrent/Executor;
 	at io.grpc.internal.ClientCallImpl.<init>(ClientCallImpl.java:103)
 	at io.grpc.internal.ManagedChannelImpl$RealChannel.newCall(ManagedChannelImpl.java:556)
 	at io.grpc.internal.ManagedChannelImpl.newCall(ManagedChannelImpl.java:535)
 	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:133)

With 1.1.2
java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V

	at io.grpc.ServiceDescriptor.validateMethodNames(ServiceDescriptor.java:129)
	at io.grpc.ServiceDescriptor.<init>(ServiceDescriptor.java:83)
	at io.grpc.ServiceDescriptor.<init>(ServiceDescriptor.java:78)
	at io.grpc.ServiceDescriptor.<init>(ServiceDescriptor.java:66)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2716
Unify usage of EAG and ResolvedServer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 wrote:

The equality of EquivalentAddressGroup, which only counts the addresses but not the attributes, was needed by the v1 ManagedChannelImpl for de-duplicating TransportSets. Even though ManagedChannelImpl2 doesn't forbid duplicating InternalSubchannel for the same EquivalentAddressGroup, the equality is still needed by most LoadBalancer2 implementors, e.g., Map<EquivalentAddressGroup, Subchannel> subchannels in the round-robin LB, to determine which InternalSubchannels to close and which to keep, when the NR result is updated.
I agree that there are too many address wrappers and it has become very confusing, sometimes even to myself. I prefer to keep the EquivalentAddressGroup name, because it indicates how these addresses are used by the channel. So instead of deleting EquivalentAddressGroup, I suggest deleting ResolvedServerInfo, and adding attributes to EquivalentAddressGroup. To address the equality requirement I mentioned earlier, we could add a withoutAttributes() method which can be used in cases where attributes should not be counted for equality.
ResolvedServerInfoGroup was intended to be the attribute-ful counter-part of EquivalentAddressGroup. Since you are proposing to replace EquivalentAddressGroup with ResolvedServerInfo, I would expect ResolvedServerInfoGroup to go away instead of building yet another level on top of ResolvedServerInfo.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2717
Keep track of transport latency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 wrote:

Long-term, I question if the transports should just keep track of their latency. They know the latency initially via SETTINGS ack and then later via flow control pinging.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2718
netty: include SETTINGS_MAX_HEADER_LIST_SIZE in SETTINGS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tests are currently failing. It seems they are related.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2719
API Review
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Make sure that no new APIs were accidentally introduced (that is, APIs were made stable on purpose). Make sure we are happy with the APIs. Can consider removing ExperimentalApi from APIs, if we haven't already.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2720
TLS handshake failures on android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
grpc-java 1.1.2
grpc c++ build against OpenSSL 1.0.2k
What JVM are you using
Android
What did you do?
I'm creating a channel using the following code:
OkHttpChannelBuilder.forAddress(host, port)
        .connectionSpec(ConnectionSpec.MODERN_TLS)
        .sslSocketFactory(context.getSocketFactory())
        .build();
where context is generated by:
KeyStore trust_store = KeyStore.getInstance(KeyStore.getDefaultType());
trust_store.load(null);

InputStream input_stream = Cloud.class.getResourceAsStream("resources/EC_CA.crt");

CertificateFactory cert_factory = CertificateFactory.getInstance("X.509");
Certificate cert = cert_factory.generateCertificate(input_stream);
trust_store.setCertificateEntry("cert", cert);

TrustManagerFactory trust_manager_factory = TrustManagerFactory.getInstance(
        TrustManagerFactory.getDefaultAlgorithm());
trust_manager_factory.init(trust_store);
TrustManager[] trust_manager = trust_manager_factory.getTrustManagers();

SSLContext tlsContext = SSLContext.getInstance("TLSv1.2");
tlsContext.init(null, trust_manager, null);

return tlsContext;
Where "resources/EC_CA.crt" is packaged with our application, and is successfully used successfully for our current internal library.
When the client performs the TLS handshake with the c++ server, it gets up to the point where it sends the TLS client key exchange/change cipher spec, then the server complains with the line:
Handshaking failed: {"created":"@1486967107.222496318","description":"Cannot check peer: missing selected ALPN property.","file":"src/core/lib/security/transport/security_connector.c","file_line":491}

Interestingly, this only occurs on android devices after running com.google.android.gms.security.ProviderInstaller.installIfNeeded(getApplicationContext());. If we don't use play services we see different behaviour depending on API version. Our level 19 and below devices fail out since they lack the devices. The level 21 and above devices successfully connect and communicate with the server, though.
The python grpc implementation does not cause the above issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2721
Issue while running helloworld example on ubuntu 14.04
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting the following error from here while running the HelloWorldServer.java on my local.
I am using openjdk version "1.8.0_91" on ubuntu 14.04.
Exception in thread "main" java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V
    at io.grpc.ServiceDescriptor.validateMethodNames(ServiceDescriptor.java:129)
    at io.grpc.ServiceDescriptor.<init>(ServiceDescriptor.java:83)
    at io.grpc.ServiceDescriptor.<init>(ServiceDescriptor.java:51)
    at io.grpc.ServiceDescriptor$Builder.build(ServiceDescriptor.java:219)
    at io.grpc.examples.helloworld.GreeterGrpc.getServiceDescriptor(GreeterGrpc.java:251)
    at io.grpc.examples.helloworld.GreeterGrpc$GreeterImplBase.bindService(GreeterGrpc.java:84)
    at io.grpc.internal.AbstractServerImplBuilder.addService(AbstractServerImplBuilder.java:125)
    at io.grpc.internal.AbstractServerImplBuilder.addService(AbstractServerImplBuilder.java:63)
    at com.cw.predictive.HelloWorldServer.start(HelloWorldServer.java:56)
    at com.cw.predictive.HelloWorldServer.main(HelloWorldServer.java:92)

My pom.xml looks like :
<dependency>
   <groupId>io.grpc</groupId>
   <artifactId>grpc-netty</artifactId>
   <version>1.1.2</version>
 </dependency>
 
<dependency>
 <groupId>io.grpc</groupId>
 <artifactId>grpc-protobuf</artifactId>
 <version>1.1.2</version>
</dependency>

<dependency>
 <groupId>io.grpc</groupId>
 <artifactId>grpc-stub</artifactId>
 <version>1.1.2</version>
</dependency>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2722
netty: remove unused code in a test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2723
all: Enable ErrorProne during compilation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2724
How do I call grpc-java server from golang client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have generated the following method from the given proto file. As it is mentioned here it uses the combination of LowerCase of PackageName and ServiceName defined in the proto file.
    io.grpc.MethodDescriptor.MethodType.UNARY,
                      generateFullMethodName(
                          "helloworld.Greeter", "SayHello") 

to generate the full method name. Now the problem is the same file is being used to generate the client code in GoLang. Which take the package name as it is. And it throws the following exception while calling the same method from client :
**Error from GoLang client :**

    2017/02/14 19:16:44 Error occurend : %!(EXTRA *grpc.rpcError=rpc error: code = 12 desc = Method not found: HelloWorld.Greeter/SayHello) <nil>

So, how to generate the full method name as it is in grpc-java  as mentioned in proto file?
public static final io.grpc.MethodDescriptor<io.grpc.examples.helloworld.HelloRequest,
           io.grpc.examples.helloworld.HelloReply> METHOD_SAY_HELLO =
           io.grpc.MethodDescriptor.create(
               io.grpc.MethodDescriptor.MethodType.UNARY,
               generateFullMethodName(
                   "helloworld.Greeter", "SayHello"),
               io.grpc.protobuf.ProtoUtils.marshaller(io.grpc.examples.helloworld.HelloRequest.getDefaultInstance()),
               io.grpc.protobuf.ProtoUtils.marshaller(io.grpc.examples.helloworld.HelloReply.getDefaultInstance()));

Proto file :
 syntax = "proto3";

option java_package = "io.grpc.examples.helloworld";

package HelloWorld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2725
all: prepare for ErrorProne's FutureReturnValueIgnored
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2726
NPE during NettyClientTransport.start() if keepAlive is enabled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
GRPC 1.1.2
What JVM are you using (java -version)?
1.8.0_112
What did you do?
Just simply call io.grpc.netty.NettyChannelBuilder#enableKeepAlive(boolean) during channel build. and the grpc always throw NPE exception.
java.lang.NullPointerException: null
	at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:169)
	at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:44)
	at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:233)
	at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:203)
	at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:739)
	at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:677)
	at io.grpc.PickFirstBalancerFactory$PickFirstBalancer$1.get(PickFirstBalancerFactory.java:129)
	at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:271)
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)

and inspect the code(io.grpc.netty.NettyClientTransport#start):
 @SuppressWarnings("unchecked")
  @Override
  public Runnable start(Listener transportListener) {
    lifecycleManager = new ClientTransportLifecycleManager(
        Preconditions.checkNotNull(transportListener, "listener"));

    if (enableKeepAlive) {
      keepAliveManager = new KeepAliveManager(this, channel.eventLoop(), keepAliveDelayNanos,
          keepAliveTimeoutNanos);
    }
    ....
}
i believe the field channel is never initialized right now, so NPE is throw by field call channel.eventLoop().
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2727
grpc-core and grpc-context jars exporting the same package doesnt go well with OSGI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
GRPC version 1.1.2
What JVM are you using (java -version)?
1.8
What did you do?
I am trying to add a GRPC Server into Karaf OSGI Container as a feature. To this library, grpc-core and grpc-context libraries are dependencies.
Because these jars are not OSGI bundles, the osgi wrap is performed. While running the application, we get an error that io.grpc.Context could not be found in bundle grpc-core.jar (NoClassDefFoundError)
For information please refer to the OSGI bundle definitions.
karaf@root()> la |grep -i grpc-core
83 | Active   |  80 | 0                     | wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-core_1.1.2_grpc-core-1.1.2.jar
karaf@root()> bundle:headers 83
wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-core_1.1.2_grpc-core-1.1.2.jar (83)
Bnd-LastModified = 1486762343975
Built-By = root
Built-JDK = 1.8.0_45
Created-By = 1.8.0_121 (Oracle Corporation)
Generated-By-Ops4j-Pax-From = wrap:file:/home/apache-karaf-4.0.8/data/kar/mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT/io/grpc/grpc-core/1.1.2/grpc-core-1.1.2.jar
Implementation-Title = grpc-core
Implementation-Version = 1.1.2
Manifest-Version = 1.0
Source-Compatibility = 1.6
Target-Compatibility = 1.6
Tool = Bnd-2.3.0.201405100607
Bundle-ManifestVersion = 2
Bundle-Name = wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-core_1.1.2_grpc-core-1.1.2.jar
Bundle-SymbolicName = wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-core_1.1.2_grpc-core-1.1.2.jar
Bundle-Version = 0
Require-Capability =
osgi.ee;filter:=(&(osgi.ee=JavaSE)(version=1.6))
Export-Package =
io.grpc;uses:="com.google.common.base,com.google.errorprone.annotations,javax.annotation,javax.net.ssl",
io.grpc.inprocess;uses:="com.google.instrumentation.stats,io.grpc,io.grpc.internal",
io.grpc.internal;uses:="com.google.common.base,com.google.instrumentation.stats,
io.grpc,javax.annotation",
io.grpc.util;uses:="io.grpc,javax.annotation"
Import-Package =
com.google.common.base;resolution:=optional,
com.google.common.io;resolution:=optional,
com.google.common.util.concurrent;resolution:=optional,
com.google.errorprone.annotations;resolution:=optional,
com.google.instrumentation.stats;resolution:=optional,
javax.annotation;resolution:=optional,
javax.net.ssl;resolution:=optional
karaf@root()> la |grep -i grpc-context
82 | Active   |  80 | 0                     | wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-context_1.1.2_grpc-context-1.1.2.jar
karaf@root()> bundle:headers 82
wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-context_1.1.2_grpc-context-1.1.2.jar (82)
Bnd-LastModified = 1486762343849
Built-By = root
Built-JDK = 1.8.0_45
Created-By = 1.8.0_121 (Oracle Corporation)
Generated-By-Ops4j-Pax-From = wrap:file:/home/apache-karaf-4.0.8/data/kar/mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT/io/grpc/grpc-context/1.1.2/grpc-context-1.1.2.jar
Implementation-Title = grpc-context
Implementation-Version = 1.1.2
Manifest-Version = 1.0
Source-Compatibility = 1.6
Target-Compatibility = 1.6
Tool = Bnd-2.3.0.201405100607
Bundle-ManifestVersion = 2
Bundle-Name = wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-context_1.1.2_grpc-context-1.1.2.jar
Bundle-SymbolicName = wrap_file__home_apache-karaf-4.0.8_data_kar_mvm-core-grpcapi-17.6.0-rel.3-SNAPSHOT_io_grpc_grpc-context_1.1.2_grpc-context-1.1.2.jar
Bundle-Version = 0
Require-Capability =
osgi.ee;filter:=(&(osgi.ee=JavaSE)(version=1.6))
Export-Package =
io.grpc
As you can notice, the problem seems to be because of the same export-packages defined in grpc-core and grpc-context which doesnt seem to go well with OSGI.
I reverted my GRPC version to 1.0.0 in which the jars were broken down to core and context and it worked well.
So the requests are as below:
a) A single jar which includes both core and context
b) If context is intended to be separate, i suggest different packages be used in context so that there wont be a collision on the export-packages.
Is there a plan to create a OSGI bundle for these jars?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2728
dev: Jetty ALPN/NPN has not been properly configured when running tests in IntelliJ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some of the tests depend on jetty alpn agent for TLS stuff which is loaded by gradle for whole test suite but not if you're running a single test in for example an IDE.
I figured out how to hack it:

Go to Edit Configurations for your test in IJ
Add -ea -javaagent:/Users/lukasz/.gradle/caches/modules-2/files-2.1/org.mortbay.jetty.alpn/jetty-alpn-agent/2.0.3/89e34338e9214ca753b33f23ccf80a4b5b861bb7/jetty-alpn-agent-2.0.3.jar in VM options field (this assumes jetty-alpn-agent is already cached by gradle).

@ejona86 I wonder if there's more sane and straightforward way to do this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2729
netty: Fix NPE in NettyClientTransport when keepalive is enabled
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2730
Propagate trailers in runtime status exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2731
What happen when received many reset frame from grpc server!
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpc v1.0.1
What JVM are you using (java -version)?
jdk8
What did you do?
If possible, provide a recipe for reproducing the error.
We developed a grpc proxy based on netty.  In grpc proxy, we adapt long connection for connect proxy to grpc server. After Gprc prxoy run some time, we received many reset frame(errorCode=8) from grpc server and have no date frame(endStream=true),  then the proxy dose no work any way.
What did you expect to see?
We expect to reveived header frame(endStream=false), data frame(endStream=false), header frame(endStream=true)
What did you see instead?
But we really reveived header frame(endStream=false), reset frame(errorCode=8)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2732
interop-testing: Remove useless Threads in test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2733
Stub are not generated
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.1.2
What version of protoc are you using?
3.2.0
What JVM are you using (java -version)?
1.8.0_111
I don't get any stub generated.
Many thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2734
core: report error count metrics.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2735
netty: Fix NPE in NettyClientTransport (v1.1 backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2736
services: add monitoring service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2737
Pass "args" object to LoadBalancer2.SubchannelPicker.pickSubchannel()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now the method looks like:
public abstract PickResult pickSubchannel(Attributes affinity, Metadata headers);
Neither affinity nor headers feels inherent to the method. A bit "random." That is a symptom that we may need to add additional arguments in the future. For example, MethodDescriptor. To avoid overload troubles, we should probably just make it an object today. Say, something like:
public abstract class PickSubchannelArgs {
  public Attributes getAffinity() { return Attributes.EMPTY; }
  public abstract Metadata getMetadata();

  // And an example of how we would add things in the future
  public CallOptions getCallOptions() {
    return CallOptions.DEFAULT;
  }
  public MethodDescriptor getMethodDescriptor() {
    return null;
    // or
    // throw new UnsupportedOperationException();
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2738
Use CallOptions.withOptions instead of withAffinity
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
withAffinity is a full Attributes to be type-safe, but it will generally only have one entry and sometimes two. In more recent times we've added withOptions. This seems it could just use it instead. This would mean the LoadBalancer would be passed CallOptions instead of Attributes affinity, but that doesn't seem too bad.
Probably want to do #2737 at the same time as fixing this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2739
doc: fix link to class in java doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2740
core: introduce PickSubchannelArgs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2741
Add instructions about running tests in IJ w/ alpn agent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2742
gradle build failure in proxy environment
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using? : 1.2.0-SNAPSHOT
What JVM are you using (java -version)? : java version "1.8.0_72"
Forked the master branch and then tried to build some example codes using instructions given in quick start guide. I am not sure whether I have to install protobuf or any other thing to the local machine.
I am using windows 7 machine under corporate proxy. Navigated to grpc-java\examples>
then
gradlew.bat installDist
Expected: Build success
Found: FAILURE: Build failed with an exception.

What went wrong:
Could not resolve all dependencies for configuration ':compile'.


Could not find io.grpc:grpc-netty:1.2.0-SNAPSHOT.
Searched in the following locations:
https://repo1.maven.org/maven2/io/grpc/grpc-netty/1.2.0-SNAPSHOT/maven-metadata.xml
https://repo1.maven.org/maven2/io/grpc/grpc-netty/1.2.0-SNAPSHOT/grpc-netty-1.2.0-SNAPSHOT.pom
https://repo1.maven.org/maven2/io/grpc/grpc-netty/1.2.0-SNAPSHOT/grpc-netty-1.2.0-SNAPSHOT.jar
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-netty/1.2.0-SNAPSHOT/maven-metadata.xml
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-netty/1.2.0-SNAPSHOT/grpc-netty-1.2.0-SNAPSHOT.pom
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-netty/1.2.0-SNAPSHOT/grpc-netty-1.2.0-SNAPSHOT.jar
Required by:
project :
Could not find io.grpc:grpc-protobuf:1.2.0-SNAPSHOT.
Searched in the following locations:
https://repo1.maven.org/maven2/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/maven-metadata.xml
https://repo1.maven.org/maven2/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/grpc-protobuf-1.2.0-SNAPSHOT.pom
https://repo1.maven.org/maven2/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/grpc-protobuf-1.2.0-SNAPSHOT.jar
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/maven-metadata.xml
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/grpc-protobuf-1.2.0-SNAPSHOT.pom
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-protobuf/1.2.0-SNAPSHOT/grpc-protobuf-1.2.0-SNAPSHOT.jar
Required by:
project :
Could not find io.grpc:grpc-stub:1.2.0-SNAPSHOT.
Searched in the following locations:
https://repo1.maven.org/maven2/io/grpc/grpc-stub/1.2.0-SNAPSHOT/maven-metadata.xml
https://repo1.maven.org/maven2/io/grpc/grpc-stub/1.2.0-SNAPSHOT/grpc-stub-1.2.0-SNAPSHOT.pom
https://repo1.maven.org/maven2/io/grpc/grpc-stub/1.2.0-SNAPSHOT/grpc-stub-1.2.0-SNAPSHOT.jar
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-stub/1.2.0-SNAPSHOT/maven-metadata.xml
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-stub/1.2.0-SNAPSHOT/grpc-stub-1.2.0-SNAPSHOT.pom
file:/C:/Users/nayaksu/.m2/repository/io/grpc/grpc-stub/1.2.0-SNAPSHOT/grpc-stub-1.2.0-SNAPSHOT.jar
Required by:
project :


Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
Need assistance for this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2743
core: delete LBv1 and promote LBv2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Contrary to what I said in today's meeting, I am not going to rename the old classes to *1 and wait one more week after it's imported before deleting them, because I would like to have them deleted before we cut the 1.2 branch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2744
context: declare that context should not be mocked
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please make the comment in the JavaDoc instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2745
Steps for changing license
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Issue to track the following changes

 change LICENSE file to Apache v2.
 change license text in all source files.
 change license type in BUILD files.
 change copyright text from "Google Inc" to "gRPC Authors" in all files.
 Add a AUTHORS file
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2746
map types can't compile in Linux using gradle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpcVersion = '1.0.3'
What JVM are you using (java -version)?
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)

------------------------------------------------------------
Gradle 3.3
------------------------------------------------------------

Build time:   2017-01-03 15:31:04 UTC
Revision:     075893a3d0798c0c1f322899b41ceca82e4e134b

Groovy:       2.4.7
Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
JVM:          1.8.0_121 (Oracle Corporation 25.121-b13)
OS:           Linux 4.8.0-38-generic amd64

What did you do?
If possible, provide a recipe for reproducing the error.
syntax = "proto3";

package com.example.grpc;

option java_multiple_files = true;

enum Sentiment {
    HAPPY = 0;
    SLEEPY = 1;
    ANGRY = 2;
}

message HelloRequest {
    string name = 1;
    int32 age = 2;
    repeated string hobbies = 3;
    map<string, string> bagOfTricks = 4;
    Sentiment sentiment = 5;
}

message HelloResponse {
    string greeting = 1;
}

// 4. service, unary request/response
service GreetingService {
    rpc greeting(HelloRequest) returns (HelloResponse);
}

What did you expect to see?
I expected to compile
What did you see instead?
 magg@bodhidharma î‚° ~/Desktop/server î‚° gradle build
:extractIncludeProto
:extractProto UP-TO-DATE
:generateProto
:compileJava
/home/magg/Desktop/server/src/main/java/com/example/grpc/HelloRequest.java:312: error: cannot find symbol
      .serializeStringMapTo(
      ^
  symbol:   method serializeStringMapTo(CodedOutputStream,MapField<String,String>,MapEntry<String,String>,int)
  location: class GeneratedMessageV3
Note: /home/magg/Desktop/server/src/main/java/com/example/grpc/HelloRequest.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
1 error
:compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 2.05 secs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2747
all: recommend the latest gRPC version on master
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2748
compiler: update path to protoc plugin in README.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.  Please update the commit message to be in the "package: reason why grpc is better" format.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2749
examples: Split thrift from the multi-project build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2750
android-interop-testing: Fix checkstyle violations (imports)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2751
all: Downgrade to Guava 19
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2752
netty: Use tcnative in tests instead of Jetty ALPN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2753
interop-testing: Remove useless tcnative configuration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2754
grpclb: fix a bug in handling server address updates.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I remember I had a comment on this before in #2557 and you replied

Duplicate EAGs from the balancer are intentionally preserved. They are used to distribute load unevenly across backends, a.k.a. weighted round-robin.

Was that the same concern as this PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2755
 core: unify EquivalentAddressGroup and its immitators.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2756
Provide a java_grpc_library() Skylark extension
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Bazel users can now build protos using the built-in proto_library and {cc,java,javalite}_proto_library rules.
These rules do not include gRPC support intentionally; this FR is about providing a Skylark extension to allow users to build gRPC bindings.
@ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2757
Changing license to Apache v2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why were the various gradle-wrapper.properties files changed? That breaks the build.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2758
core: remove SingleTransportChannel, not used
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2759
doc: fix @link to cancel in java doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The travis failures appear to be flakes. I've filed notes about the flakes in appropriate issues and restarted the jobs. But I feel fine with merging it as-is.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2760
doc: there's no type param anymore
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please (a note for Jenkins)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2761
Failed to load any of the given libraries: [netty-tcnative-windows-x86_64, netty-tcnative]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.1.2
What JVM are you using (java -version)?
8
What did you do?
If possible, provide a recipe for reproducing the error.
Trying the SSL on server side
here is my pom.xml
..... <dependency> <groupId>io.netty</groupId> <artifactId>netty-tcnative-boringssl-static</artifactId> <version>1.1.33.Fork16</version> <classifier>${os.detected.classifier}</classifier> <scope>compile</scope> </dependency> ..... 
What did you expect to see?
SSL should work fine
What did you see instead?
Exception in thread "main" java.lang.UnsatisfiedLinkError: failed to load the required native library
at io.netty.handler.ssl.OpenSsl.ensureAvailability(OpenSsl.java:324)
at io.netty.handler.ssl.ReferenceCountedOpenSslContext.(ReferenceCountedOpenSslContext.java:216)
at io.netty.handler.ssl.OpenSslContext.(OpenSslContext.java:42)
at io.netty.handler.ssl.OpenSslServerContext.(OpenSslServerContext.java:344)
at io.netty.handler.ssl.OpenSslServerContext.(OpenSslServerContext.java:334)
at io.netty.handler.ssl.SslContext.newServerContextInternal(SslContext.java:414)
at io.netty.handler.ssl.SslContextBuilder.build(SslContextBuilder.java:402)
at com.nokia.nas.registration.main.Service.start(Service.java:49)
at com.nokia.nas.registration.main.Bootstrap.main(Bootstrap.java:45)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty-tcnative-windows-x86_64, netty-tcnative]
at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:177)
at io.netty.handler.ssl.OpenSsl.loadTcNative(OpenSsl.java:412)
at io.netty.handler.ssl.OpenSsl.(OpenSsl.java:90)
... 13 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2762
NettyClientTransportTest.maxHeaderListSizeShouldBeEnforcedOnServer is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seen at https://travis-ci.org/grpc/grpc-java/jobs/205610718 (since rebuilt)
io.grpc.netty.NettyClientTransportTest > maxHeaderListSizeShouldBeEnforcedOnServer FAILED
    java.lang.ClassCastException: io.netty.handler.codec.http2.Http2Exception$HeaderListSizeException cannot be cast to io.grpc.StatusException
        at io.grpc.netty.NettyClientTransportTest.maxHeaderListSizeShouldBeEnforcedOnServer(NettyClientTransportTest.java:313)

It looks like the problem is getRootCause() is over-eager and skips over the StatusException. So this is a bug in the test, which should be easy to fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2763
Need non-experimental way to raise maxInboundMessageSize
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As per googleapis/google-cloud-java#1499 , users of Pub/Sub see errors when their messages exceed 4MB, even though Pub/Sub's limit is 20 MB. Ideally we'd like to call maxInboundMessageSize to raise this maximum, but it turns out that maxInboundMessageSize is experimental. I don't see an open issue for making it non-experimental - when will this be done?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2764
doc: remove irrelevant java doc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2765
core: add @nullable annotation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2766
core: cache Accept-Encoding headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually, hold off on reviewing, my git has failed me, and I need to resurrect the actual commit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2767
services: don't update reflection index mid-stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2768
core: implement state API for ManagedChannel 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83 this is very rough proof of concept. It doesn't fully compile is missing tests, docs etc. but illustrates general idea. Let me know if this is a good direction and what do you think. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2769
travis: Add thrift example; it was split out in 5ca4ea7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2770
Server does not send initial metadata on a stream with no messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The gRPC wire spec says:

Most responses are expected to have both headers and trailers but Trailers-Only is permitted for calls that produce an immediate error.

However, the only time that headers are sent by a Java server is in when onNext() is called (see ServerCalls.java#L282). This means that a stream where the server's behavior should be to send initial and trailing metadata (i.e., close the stream with no outbound messages), instead gRPC sends out a Trailers-Only response, skipping any initial metadata.
This popped up on the existing interop tests when PHP and Node were not setting the response_parameters field in the custom_metadata interop test. See grpc/grpc@ced8702. These tests are now passing since the test spec says to set the response_parameters field, and so the interop server calls onNext() to send the appropriate response(s).
But, if the wire spec's statement should be interpreted as Trailers-Only should only be sent for calls with an immediate error, this is a bug in Java's implementation. Even if Trailers-Only is a legal response even without errors, it seems like the Trailers-Only message should include any header metadata.
It seems to fix things to add the following check to ServerCalls$ServerCallStreamObserverImpl#onCompleted(), but I haven't tested this extensively enough to be sure this doesn't cause problems elsewhere:
    @Override
    public void onCompleted() {
       if (cancelled) {
         throw Status.CANCELLED.asRuntimeException();
       } else {
+        if (!sentHeaders) {
+          call.sendHeaders(new Metadata());
+          sentHeaders = true;
+        }
         call.close(Status.OK, new Metadata());
       }
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2771
services: move proto services to io.grpc.protobuf.services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Dropping newInstance() from the old API is fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2772
Tracking GrpclbLoadBalancerTest unit tests should be more unitary
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some unit tests in GrpclbLoadBalancerTest are too long and testing multiple things in one test method.
It's hard to read and maintain. Better to split apart.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2773
core: fix keepalivemanager bug on handling IDLE_AND_PING_SENT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2774
core: make timeout marshalling less verbose
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2775
SSL error, pls help
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
Grpc version 1.0.1
What JVM are you using (java -version)?
JVM: Oracle Jdk jdk-8u121
What did you do?
 private SslContext buildServerSslContext() {
        try {
            InputStream certs = SslUtil.loadInputStreamCert("server.pem");
            InputStream keys = SslUtil.loadInputStreamCert("server_pkcs8.key");
            return GrpcSslContexts.configure(SslContextBuilder.forServer(certs, keys)).build();
        } catch (SSLException e) {
            throw new RpcFrameworkException(e);
        }
    }

 private SslContext buildClientSslContext() {
        try {
            InputStream certs = SslUtil.loadInputStreamCert("server.pem");
            return GrpcSslContexts.configure(SslContextBuilder.forClient()//
                                                              .trustManager(certs))//
                                  .build();
        } catch (SSLException e) {
            throw new RpcFrameworkException(e);
        }
    }

In client,use jetty alpn
-javaagent:/Users/shimingliu/.m2/repository/org/mortbay/jetty/alpn/jetty-alpn-agent/2.0.6/jetty-alpn-agent-2.0.6.jar

In server, use netty boringssl
             <dependency>
			<groupId>io.netty</groupId>
			<artifactId>netty-tcnative-boringssl-static</artifactId>
			<version>${netty-tcnative.version}</version>
			<classifier>${os.detected.classifier}</classifier>
		</dependency>

What did you expect to see?
There is no error
What did you see instead?
[jetty-alpn-agent] Replacing: sun/security/ssl/ClientHandshaker
[jetty-alpn-agent] Replacing: sun/security/ssl/HelloExtensions
[jetty-alpn-agent] Replacing: sun/security/ssl/ClientHandshaker$2
io.grpc.StatusRuntimeException: UNKNOWN
	at io.grpc.Status.asRuntimeException(Status.java:536)
	at com.quancheng.saluki.core.grpc.client.async.AbstractRetryingRpcListener.onClose(AbstractRetryingRpcListener.java:86)
	at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:56)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:481)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$600(ClientCallImpl.java:398)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:513)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.Exception: Failed ALPN negotiation: Unable to find compatible protocol.
	at io.grpc.netty.ProtocolNegotiators$BufferUntilTlsNegotiatedHandler.userEventTriggered(ProtocolNegotiators.java:508)
	at io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:339)
	at io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:325)
	at io.netty.channel.AbstractChannelHandlerContext.fireUserEventTriggered(AbstractChannelHandlerContext.java:317)
	at io.netty.channel.ChannelInboundHandlerAdapter.userEventTriggered(ChannelInboundHandlerAdapter.java:108)
	at io.netty.handler.codec.ByteToMessageDecoder.userEventTriggered(ByteToMessageDecoder.java:336)
	at io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:339)
	at io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:325)
	at io.netty.channel.AbstractChannelHandlerContext.fireUserEventTriggered(AbstractChannelHandlerContext.java:317)
	at io.netty.handler.ssl.SslHandler.setHandshakeSuccess(SslHandler.java:1193)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1008)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:900)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:571)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at com.quancheng.saluki.core.common.NamedThreadFactory$DefaultRunnableDecorator.run(NamedThreadFactory.java:127)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2776
Tracking issue for Monitoring Service being Experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2777
Fix shared subchannel state in RoundRobin LB
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2778
core/netty/okhttp: KeepAliveManager with Pinger
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I will split the PR into smaller parts @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2779
netty/test: be less agreesive on checking cause
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2780
core: update contributing guidelines w/ pr/commit conventions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2781
examples: Always pass an executor to Futures.addCallback()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2782
examples: Update imports to new-style
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2783
Test historic generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should check in generated code for each minor version of grpc, and at least makes sure it compiles. If it compiles, it is highly likely to work.
Ideally we'd run some simple sanity tests, although it is hard to force all the code to run. Maybe we create a noop-ImplBase service and call bindService(). That would at least load all the MethodDescriptors... I don't think a literal test is necessary before closing this. The compilation itself can count as a "test." But it should at least be briefly investigated before closing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2784
Max concurrent global streams (on the server) so applications don't have to implement it:
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Request coming from Mixpanel team
Seems like C has a lot of it but Java doesnt.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2785
Inconsistent INTERNAL errors for message-less RPCs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
java version "1.8.0_121"
What did you do?
Create a unary rpc, on the server have it immediately call responseObserver.onCompleted() with no previous onNext().  With a java gRPC client call this rpc with blocking and future stubs, they'll both throw an INTERNAL error from here 
  
    
      grpc-java/stub/src/main/java/io/grpc/stub/ClientCalls.java
    
    
         Line 434
      in
      89bc2cd
    
  
  
    

        
          
           Status.INTERNAL.withDescription("No value received for unary call") 
        
    
  

 .  Using the async client stubs will work(no onNext, just onCompleted with trailers).
If I switched to a streaming response and called onComplete() on with no previous onNext() the future stub is no longer available(expected) and now the Iterable for the blocking stub returns false for hasNext() as expected, but doesn't break.  The async stub continues working as before.
What did you expect to see?
I guess I wanted the "defaultInstance" of the response type for the blocking and future based stubs rather than an exception.  That, or an onError to trigger on the async stub with the same INTERNAL status and message.
I have not checked what the c-core will do in this case, or if there is a spec for this behavior.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2786
core: fix keepalivemanager bug on handling IDLE_AND_PING_SENT (backport 1.0.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You're backporting to 1.0. Should it be to 1.1 instead? Or will there be another PR for 1.1?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2787
core: fix keepalivemanager bug on handling IDLE_AND_PING_SENT (backport v1.1.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2788
android-interop-testing: fix lint
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2789
Java benchmark driver spams logs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at a recent run: https://grpc-testing.appspot.com/view/Performance/job/gRPC_performance_experiment/3856/consoleText
By lines of output, Java is causing 79% just with PrintFlagsFinal. It seems we should remove the argument or figure out a less spammy solution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2790
all: fix errorprones
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2791
core: use withOptions instead of withAffinity
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The build fails due to a deprecation warning.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2792
core: fix '@link: can't find...' build noise
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2793
services: Remove unused variables
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I fixed the checkstyle failure. It was caused by my change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2794
all: start 1.3.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2795
okhttp: Add restricted AppEngine SSL setup
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If I do some hacky stuff to make IS_RESTRICTED_APPENGINE=true for a unit test, it still seems the JDK used for unit tests doesn't support the SHA1PRNG.
io.grpc.okhttp.OkHttpChannelBuilderTest > restrictedAppEngineSocketFactory FAILED
    java.lang.RuntimeException: TLS Provider failure
        at io.grpc.okhttp.OkHttpChannelBuilder.createSocketFactory(OkHttpChannelBuilder.java:284)
        at io.grpc.okhttp.OkHttpChannelBuilderTest.restrictedAppEngineSocketFactory(OkHttpChannelBuilderTest.java:140)

        Caused by:
        java.security.NoSuchAlgorithmException: no such algorithm: SHA1PRNG for provider SunJSSE
            at sun.security.jca.GetInstance.getService(GetInstance.java:101)
            at sun.security.jca.GetInstance.getInstance(GetInstance.java:218)
            at java.security.SecureRandom.getInstance(SecureRandom.java:383)
            at io.grpc.okhttp.OkHttpChannelBuilder.createSocketFactory(OkHttpChannelBuilder.java:276)
            ... 1 more

This code path gets exercised in an AppEngine end to end test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2796
stub: document withChannel and document method history
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2797
CompletableFuture stubs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I'd like to start a discussion about adding a CompletableFuture-based stub implementations to gRPC. I understand that generated gRPC code must be backwards compatible with Java 6, so here are some alternative implementation strategies to consider.

Implement CompletableFuture-based stubs in a stand-alone class generated by a stand-alone protoc plugin. The CF stub class would reference the public MethodDescriptors of the stock generated client. This option is easiest to implement, but presents a fragmented programming model.
Implement CompletableFuture-based stubs inline with the existing generated stubs by adding @@protoc_insertion_points to the stock c++ generator. A protoc plugin would be used to populate the insertion points. This option has the benefit of presenting a homogenous programming model for this, and all future plugin-based stub extensions, but requires a coordinated one time change with the protoc project.
Extend the c++ generator with optional support for CompletableFuture. Use a protoc flag to turn it on and off. Not a great option, but possible.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2798
Cut 1.2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since 1.2 is still weeks away, we should keep the current versions, and only bump it when we tag 1.2.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2799
protobuf: utility methods for com.google.rpc.Status
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo any estimate for when this will get reviewed?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2800
Run examples without console and dependencies
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can i use gRPC without some grandle dependencies, and how?
I just want to see how work server and client from https://github.com/grpc/grpc-java/tree/master/examples/src/test/java/io/grpc/examples/helloworld but i can not do it, because i can not find some class-files (import io.grpc.stub.StreamObserver; - for example)
May be is there some description for run examples without consoles?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2801
Netty improperly delays sending SETTINGS ACK
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen in grpc/grpc#9956:
... it appears Java/Netty is doing the wrong thing. encoder.remoteSettings() is called before writeSettingsAck(). encoder.remoteSettings() calls flowController().initialWindowSize() which results in the flow controller writing pending bytes.
Two immediate changes should probably be made: 1) Send the settings ack immediately before processing the settings frame in the decoder. Any failure in processing would probably result in the connection being closed, so this doesn't seem dangerous. 2) Stop triggering writePendingBytes() in the flow controller and instead wait for the flush() like normal.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2802
Bump error-prone to v2.0.18 or later
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There's new checks, and we want to stay up-to-date.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2803
Bump gradle version to v3.4.1 or later
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
3.4 has much nicer incremental rebuild, able to avoid recompilation when APIs don't change. It also has native library support, which would be nice. For this issue, we probably won't change to use the library support, but we can open a new issue once we are on 3.4.1+.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2804
Cache .m2 on Travis-CI
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
maven verify performance varies widely on Travis, from 20 seconds to over 5 minutes. It seems this is primarily dictated by the download of artifacts. Caching .m2/repository would probably speed that up. We do need to make sure to avoid caching .m2/repository/io/grpc/ (probably by just deleting it before the cache is created).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2805
core: annotate keys with Immutable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2806
test: bump junit to 4.12
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can't be done, as it won't match the internal version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2807
testing: fix flaky okhttp test newStream_duringShutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2808
Inner class unit tests in GrpcServerRuleTest look so weird
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should make the inner classes top level classes, and also add @RunWith(Junit4.class)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2809
Do not merge: test flakiness on travis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On travis linux env, ran the test for 30000 times, all passed, not able to reproduce the flake  #2328 with this approach.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2810
documentation: monitoring service tutorial
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2811
documentation: update path/method for reflection
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2812
grpclb: set LB tokens to headers.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2813
It might be a mistake returning type of ManagedChannelBuilder<?>.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.1.2
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
when I use grpc-java in scala,
for example
val channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext(true).asInstanceOf[ManagedChannelBuilder[_]].build

the method forAddress returns ManagedChannelBuilder<?>,
so I have to add asInstanceOf[ManagedChannelBuilder[_]].
otherwise, i can't call build of a object with Any type .
What did you expect to see?
I think that forAddress might return ManagedChannelBuilder<? extends ManagedChannelBuilder<?>>.
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2814
How to terminate a service call in ServerInterceptor.interceptCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What is the correct way to terminate a call to a service's method once ServerInterceptor.interceptCall finds that the request is invalid (ex. the client's authentication fails) and wants to stop proceeding with executing the method and return an error to the client?
Should interceptCall return some special listener? or it should throw some sort of Exception indicating an Unauthenticated access?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2815
Capture more information on error for debugging
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When an error is propagated to the application, it would be useful to have things like server IP address[1], the timeout of the call (deadline - now), and whether the error was generated on the server.
There is other information that gRPC doesn't have direct knowledge of being useful, like tracing ids. Either Metadata would need to be included in full (doesn't sound great to me, since that could include auth tokens) or we could allow interceptors to cheaply supplement the data.

Note that retries/hedging make "address" a bit more interesting.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2816
all: Bump Jetty ALPN agent version, for new JREs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is it tested with the new JRE? An issue was reported #2775
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2817
testing: temporarily increased newStream_duringShutdown test timeout to 20s
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2818
Backport SETTINGS ACK sequencing fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have manually tested this fixes interop with C#. Since Netty added a test and we're going to revert to using their code once we upgrade, I didn't feel like it was worth-while to add a test in grpc.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2819
[backport-1.1] Backport SETTINGS ACK sequencing fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2820
[backport-1.2] Backport SETTINGS ACK sequencing fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2821
Move okhttp to AbstractStream2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2822
core: keepaliveManager not to use Ping.onSuccess and ragard onDataReceive as ping Ack
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2823
core: add missing @ThreadSafe annotation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2824
okhttp: revert okhttp: Add restricted AppEngine SSL setup (#2795)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this jenkins
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2825
core: Support keepalive even when transport is idle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2826
core,netty,okhttp: KeepAliveManager with Pinger
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2827
ContextStorageOverride unnecessary stacktrace logging
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(minor)
IMO the printStackTrace during init of io.grpc.Context when no ContextStorageOverride class is found is not really adding anything useful and could be removed. (moreover it jumpscares me each time i start my app in intellij :-)
 try {
      Class<?> clazz = Class.forName("io.grpc.override.ContextStorageOverride");
      newStorage = (Storage) clazz.getConstructor().newInstance();
    } catch (ClassNotFoundException e) {
      if (log.isLoggable(Level.FINE)) {
        // Avoid writing to logger because custom log handlers may try to use Context, which is
        // problemantic (e.g., NullPointerException) because the Context class has not done loading
        // at this point.  The caveat is that in environments stderr may be disabled, thus this
        // message would go nowhere.
        System.err.println("io.grpc.Context: Storage override doesn't exist. Using default.");
        e.printStackTrace();
      }
      newStorage = new ThreadLocalContextStorage();
    } catch (Exception e) {
      error = e;
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2828
KeepAliveManager is not apply to ConnectionHandler in netty transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
GRPC 1.2.0
What JVM are you using (java -version)?
1.8.0_112
What did you do?
I am try to make KeepAlive work with netty transport just now(grpc-java 1.2.0), and after some function test, i think the KeepAlive feature still not work functionally.
Debugging the code(io.grpc.netty.NettyClientTransport#start):

So, we known the KeepAliveManager only make effective in io.grpc.netty.NettyClientHandler instance. But the code showing the creation of io.grpc.netty.NettyClientHandler always receive a null keepAliveManager.

Probably because the keepAliveManager field is assigning in the end of io.grpc.netty.NettyClientTransport#start() call.
Associated commit: #2729: the commit resolve the problem of NPE(#2726)
cc @lukaszx0 @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2829
Define Context semantics on client-side
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context's semantics is quite clear on the server-side. For each call:

ServerImpl creates the base Context.
ServerInterceptors can create new Contexts, which can be based on the base Context. The last created Context is what the server application sees.
Server application access the Context from thread-local. And if it initiates outgoing calls, by default they inherit the Context.

For the client-side, currently the Context semantics is:

The current Context when Channel.newCall() is called is the base Context.
ClientInterceptors create new Contexts, which can be based on the base Context. The last created Context is what ClientCallImpl uses
ClientCall.Listener is called under the ClientCallImpl's Context.

This is problematic. If a new call is made from the ClientCall.Listener, it will inherit the previous call's Context. If this chain of calls is unbounded, and every call goes through interceptor(s) that create Context based off the current Context, this will create an unbounded inheritance chain of Contexts. Because Context always keeps a reference to the parent Context, this will lead to memory leak.
Context is designed to work like a stack. The expectation is that a Context (except the background one) should eventually be popped out of the "stack". Infinite pushing without popping, like the case from previous paragraph, should not happen. IMO, this means Context should only be passed in one direction. On the client-side, the direction should be application -> interceptors -> gRPC core. Since ClientCall.Listener is the other direction, it should not be called under the top-most Context, but rather the Context that application sees, which is the pre-interceptors one. This will prevent the unbounded-Context-chain issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2830
all: include analytics in releasing notes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2831
netty: fix KeepAliveManager not apply to ConnectionHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As discussed with @ejona86, there are some alternative solutions:

pass the attributes transport/pinger, enableKeepAlive, keepAliveDelayNanos, and keepAliveTimeoutNanos to the constructor of NettyClientHandler, and instantiate keepAliveManager at handlerAdded(). Passing transport as an attribute of NettyClientHandler is really ugly.
not to pass executorService to the constructor of KeepAliveManager, instead, pass it to onTransportStarted(); and call onTransportStarted(executor) at handlerAdded(). But this introduces a responsibility for all consumers (okhttp client, netty server, etc) of KeepAliveManager: make sure no race between onTransportStarted(executor) and onTransportActive().
there might be more alternatives but need dig deeper under the surface of netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2832
Possibly infinite loop
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have some grpc instance, after several days running, one cpu may running into full load at unperdicate time.
Usually one, and may be then grow to two or more.

What version of gRPC are you using?
1.0.3
What JVM are you using (java -version)?
java version "1.8.0_51"
Java(TM) SE Runtime Environment (build 1.8.0_51-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)
JvmTop result seems caused by netty.
JvmTop 0.8.0 alpha - 11:29:39,  amd64,  4 cpus, Linux 2.6.32-57, load avg 2.71
 http://code.google.com/p/jvmtop

 Profiling PID 32200:    xx.xx.SomeServer 

  99.97% (     0.90s) ...netty.handler.codec.http2.DefaultHttp2RemoteFlowContr()
   0.03% (     0.00s) net.spy.memcached.MemcachedConnection.handleIO()
   0.01% (     0.00s) io.netty.channel.nio.NioEventLoop.select()
   0.00% (     0.00s) im.cu.framework.thrift.ThriftBasedServiceServer$1.run()

and stack
"grpc-default-worker-ELG-3-4" #199 daemon prio=5 os_prio=0 tid=0x00007f4628015000 nid=0x7e9f runnable [0x00007f45ad90a000]
   java.lang.Thread.State: RUNNABLE
        at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.writeAllocatedBytes(DefaultHttp2RemoteFlo
wController.java:360)
        at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor$1.write(DefaultHttp2RemoteFlowCo
ntroller.java:550)
        at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State.write(WeightedFairQueueByteDistributor.java:2
48)
        at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor.distribute(WeightedFairQueueByteDistributor.java:15
1)
        at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor.distributeToChildren(WeightedFairQueueByteDistribut
or.java:183)
        at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor.distribute(WeightedFairQueueByteDistributor.java:13
0)
        at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$WritabilityMonitor.writePendingBytes(DefaultHttp2Re
moteFlowController.java:631)
        at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.writePendingBytes(DefaultHttp2RemoteFlowController.java:255)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:161)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:787)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:779)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:760)
        at io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:974)
        at io.netty.channel.AbstractChannel.flush(AbstractChannel.java:244)
        at io.grpc.netty.WriteQueue.flush(WriteQueue.java:139)
        at io.grpc.netty.WriteQueue.access$000(WriteQueue.java:49)
        at io.grpc.netty.WriteQueue$1.run(WriteQueue.java:61)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:454)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2833
core: use nanos more consistently
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2834
netty: move startWriteQueue right after channel is constructed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does this solve any problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2835
all: update to latest version of errorprone
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2836
Okhttp: keepAlivedManager#onTransportShutdown moved from shutdown to stopIfNecessary and refactored
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2837
all: bump recommended version to 1.2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2838
doc: suggest against overriding Context in ClientInterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2839
support GET verb in AbstractClientStream2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2840
tcp connection do not close, ChannelOutboundBuffer and NettyServerHandler still hold memory 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
java version "1.8.0_112"
Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)
What did you do?
I run stress test to hit grpc endpoint a lot and use VisualVM for memory leak detection.
debug message looks fine.
2017-03-17 18:55:12,552 DEBUG [NettyServerHandler]
----------------INBOUND--------------------
[id: 0x52781f4a, L:/127.0.0.1:8650 - R:/127.0.0.1:64571] SETTINGS: ack=true
2017-03-17 18:55:12,573 DEBUG [NettyServerHandler]
----------------OUTBOUND--------------------
[id: 0x52781f4a, L:/127.0.0.1:8650 - R:/127.0.0.1:64571] HEADERS: streamId=3, headers=GrpcHttp2OutboundHeaders[grpc-status: 0], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=true
After a while I terminate the test and check tcp connection and memory usage.
What did you see instead?
After I terminate the stress test, I saw those class still hold memory(not releasing any memory after I terminate the test).
io.netty.util.AsciiString
io.netty.handler.codec.http2.internal.hpack.HeaderField
io.netty.handler.codec.http2.internal.hpack.Encoder$HeaderEntry
io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultPropertyKey
io.netty.channel.ChannelOutboundBuffer
io.grpc.netty.WriteQueue
io.grpc.netty.NettyServerHandler
io.grpc.netty.NettyServerTransport
io.grpc.netty.FixedHttp2ConnectionDecoder
io.grpc.netty.NettyServerHandler
I also run the netstat to check the tcp connection.
I notice that even after I terminate the test, the number of tcp connection remained the same, the status are all ESTABLISHED.
What did you expect to see?
expect to see the tcp connection drop after test terminate.
expect to see io.grpc and io.netty class release memory.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2841
io.netty.handler.codec.http2.internal.hpack.Decoder removed in netty 4.1.9 Fina
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.1.2 / 1.2.0
What JVM are you using (java -version)?
java version "1.8.0_111"
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
io.netty.handler.codec.http2.internal.hpack.Decoder been removed in the Netty 4.1.9 fina
What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2842
services: update monitoring.proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2843
Version 1.0.x and >= 1.1.0 are binary incompatible
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried using google-cloud-spanner which uses 1.0.3 in a project that uses 1.2.0. So gradle resolves this version conflict in favor of 1.2.0. Running the project then fails with a NoSuchMethodError.
Exception in thread "main" java.lang.NoSuchMethodError: io.grpc.netty.NettyChannelBuilder.build()Lio/grpc/internal/ManagedChannelImpl;
        at com.google.cloud.spanner.SpannerOptions$NettyRpcChannelFactory.newChannel(SpannerOptions.java:278)
Notice how it tries to call NettyChannelBuilder.build() with ManagedChannelImpl as a return type. However, in 1.1.0 the return type changed to ManagedChannel [1] and in Java Byte Code the return type is also part of the method signature.
I also opened an issue at Cloud Spanner googleapis/google-cloud-java#1776 (comment)
I understand that NettyChannelBuilder is marked experimental and thus it's technically fine to break this. Although I am not exactly sure if experimental also includes ABI compatibility.
@ejona86 @zhangkun83
[1] d17a7b5#diff-34c34e0485cd6a3ebabb1f46de341a1aL269
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2844
version compatibility: grpc java vs grpc go
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What's the compatibility of  grpc-java and  grpc-go in term of version?
Suppose that the our service is using grpc-go 1.0.4,  can we upgrade the client to use grpc-java 1.12 without any issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2845
okhttp: Add restricted AppEngine SSL setup
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2846
core: delete defunct TransportManager.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2847
Context in its own package?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Although io.grpc.Context is shipped in its own artifact, and non-gRPC users can also depend on it, the package name still causes branding issue (census-instrumentation/opencensus-java/issues/162), and a practical issue with OSGI (#2727). We may consider moving it into its own package and splitting it completely from gRPC.
We have two questions to answer:

What should the new package name be? Probably something starting with com.google, but probably not com.google.common.context because it collides with a Google's proprietary context class.
How to bridge the old Context and Deadline to the new ones.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2848
Delete ResolvedServerInfoGroup and ResolvedServerInfo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This should be done after the release that deprecates them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2849
core: delete deprecated pickSubchannel()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2850
benchmarks: Fix broken building of ServerServiceDefinition
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2851
doc: performance implication of Metadata.containsKey()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2852
all: fix gradle nag for deprecated leftshift operator
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2853
core,benchmarks: use Atomics for StatsTraceContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2854
netty: Server side keep alive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2855
core: add @since annotations to MethodDescriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2856
Incorrect ClassLoader (need ability to select/configure)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In ManagedChannelProvider there is the function below to determine which classloader to use for loading the channel providers:
private static ClassLoader getCorrectClassLoader() {
    if (isAndroid()) {
      return ManagedChannelProvider.class.getClassLoader();
    }
    return Thread.currentThread().getContextClassLoader();
  }
Because this is all setup in the static initializers, there is no ability to change the classloader used. When using custom classloading (URLClassLoader for example), I don't want the threads classloader -- I want the classloader that loaded this class (essentially I want the isAndroid() logic when not in an android app).
Not sure what the community's preferred solution would be, but a few options are: offer a configuration parameter to change the selected classloader, don't set the classloader in the static initializer section to allow overriding, expose the ClassLoader as a parameter of the builder so the correct ClassLoader can be passed in.
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
1.8.0_51
What did you do?
The Thread's context classloader is always used (non-Android)
What did you expect to see?
Ability to override classloader used for providers
What did you see instead?
ClassLoader is pinned in the static initializers, preventing any override or configuration ability
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2857
core: Do not call startDeadlineTimer when is deadlineCancellationExecutor is null
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2858
core: make SerializingExecutor lockless
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2859
core: Remove internal comment referencing compression frames
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2860
core: Fix User-Agent Javadoc in ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2861
Tracking issue for StreamTracer APIs being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2862
Don't block for settings frame
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using gRPC 1.0.5. We server is implemented in Go and we use Java client. We are trying to use the wonderful https://github.com/soheilhy/cmux library to run both the grpc server and grpc gateway server on the same port. The issue is since Java gRPC client blocks until it receives a SETTINGS frame from the server, cmux has to do additional processing which results in very high cpu usage.
soheilhy/cmux#40 (comment)
My question is can Java clients can not block for SETTINGS frame and be more like go clients?
cc: @soheilhy, @sadlil
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2863
core: StreamTracer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reviewers: sorry for this large PR. It is an intrusive change and I had to make sure it works for all cases, thus I couldn't do it more incrementally. Here is the recommended order to review:

The public APIs


StreamTracer, ClientStreamTracer, ServerStreamTracer.
CallOptions
ServerBuilder


The core implementations


AbstractManagedChannelImplBuilder, AbstractServerImplBuilder
StatsTraceContext, CensusStreamTracerModule
ManagedChannelImpl, ClientCallImpl, ServerImpl, ServerCallImpl
AbstractClientStream, AbstractClientStream2, AbstractServerStream.


The transport implementations


Netty*, OkHttp*, InProcess*


The tests
The remaining files are just trivial mechanical changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2864
netty: expose server side keepalive API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2865
Rare race condition in Client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While more prominent when using compression, this race occurs without it as well.  The typical race looks something like:

Client starts and RPC
The transport to the server is not yet available, so a DelayedClientTransport is used.
The server handles the RPC and sends back headers and a compressed message.
The client sees there are headers, and begins executing the queued stream callbacks, on the channel executor threads instead of the transport thread
The client sees the Data frame, and tries to decompress it on the network thread.  *This fails since the headers from 4 have not yet been processed.
The stream has already failed, but the queued callback for onHeaders() is finally executed on the app thread.

This is the root cause of #2157.  As mentioned, this isn't just for compression.  ClientInterceptors will see headers after data has been received.   The solution (temporary?) seems to be to move OkHttp to used AbstractClientStream2 in #2821, and then move decompression from ClientCallImpl to the stream.  That will fix the decompression, but not interceptors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2866
core: Wrap keepalive runnables with exception logging
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2867
benchmarks: use JMH 1.18
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2868
KeepAliveManagerTest should use FakeClock.ScheduledExecutorService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current tests in KeepAliveManagerTest are using mocked Future and run scheduled task manually, which is not a correct way to test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2869
netty: Add server keepalive enforcement
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2870
core: Clarify misleading idleTimeout documentation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm... so this doc update isn't quite right. The problem is it was talking about "idle mode", not the "IDLE state". The IDLE state doesn't shut down the NR and LB, whereas idle mode does. That's far too subtle for our users.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2871
netty: Fix client keepalive initialization (again)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2872
core/grpclb: Ignore equivalent pickers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Never mind... It may not be so bad to achieve the same inside the LoadBalancer, and the API may bring more confusion than usefulness.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2873
InternalSubChannel doesn't comply with the connectivity state spec
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When receiving a GOAWAY (transportShutdown() callback), InternalSubChannel unconditionally transitions to IDLE. However, the spec says

READY transitions to TRANSIENT_FAILURE on "any failure encountered while expecting successful communication on established channel."
"Channels that receive a GOAWAY when there are no active or pending RPCs should also switch to IDLE".

InternalSubchannel needs to look at the status passed to transportShutdown():

If it's not OK, according to Rule 1 above, the new state should be TRANSIENT_FAILURE
If it's OK, then it's a GOAWAY.

If the in-use state of the subchannel is false, according to Rule 2 above, the new state should be IDLE.
Otherwise, the spec doesn't say what the new state should be. Apparently it cannot stay in READY. It cannot go to TRANSIENT_FAILURE either because it's a GOAWAY, not an error. This part of the spec should be revisited.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2874
netty: refactor NettyChannelBuilder keepalive API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2875
netty: Handle channel creation failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2876
grpclb: skip picker updates that have no effect
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2877
netty: Add config for server keepalive enforcement
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2878
Reset connection by peer 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.0
What JVM are you using (java -version)?
1.8.0_40
What did you do?
If possible, provide a recipe for reproducing the error.
add log in my web application, and deploy it to production sever.
always get error message as below. we cannot know which/where method throw out.
after a lots of error message throwing out, we can get "out for memory" error message and server is down, need to restart to to recover it.
error message is
Transport failed
java.io.IOException: Connection reset by peer
at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:349)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:112)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:571)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:512)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:426)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:398)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)

What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2879
all: Update to gradle 3.4.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2880
netty: implement server max connection age
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
rebased.
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2881
Permissive client keepalive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2882
core: allow SubchannelPicker to return a StreamTracer factory.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2883
Unimplemented channel state API is not documented as such
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Until #2292 is resolved, getState() and notifyWhenStateChanged() always throw UnsupportedOperationException. The documentation should call out that it isn't implemented, especially since not even LoadBalancer is using the API at this point.
I had thought this was already done, but I couldn't find where.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2884
Dns rr balancing does not refresh after dns change
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc-all 1.2.0
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
Hi. I use grpc RoundRobinLoadBalancerFactory and DnsNameResolverProvider. As well I use docker swarm. When i do replica of my service, I see that dns has second entry of my service, but grpc client to this service does not see it and not balancing. I has networkaddress.cache.ttl=10 in jvm for this service and -Dsun.net.inetaddr.ttl=10. But if I kill all my instances and start it again with two nodes at the same time, then client will see 2 dns entry and rr well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2885
Many TCPIP connectons in established state
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2.0 The latest I think.
What JVM are you using (java -version)?
java version "1.8.0_65"
Java(TM) SE Runtime Environment (build 1.8.0_65-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)
Linux Fedora 25 client.
Going to server in docker that is GOLANG
What did you do?
On the client I have 9 different types of connections. On 8 of them I reuse the respective  channel for all request (8 different ports/ 8 channels created) Never shutdown. One I do a shutdownNow on the channel after each request, create a new channel for the next request.  The code for the channelBuilder is identical for each except the forAddress/port part.  On all of these there are many requests.  If I stop my client before it terminates and using lsof MANY connections established with the 8 I reuse the channel on. I'm guessing there is one connections per each request.  The one where I shutdown there are none listed
.
What did you expect to see?
I expected to see 8 at most TCPIP connections established.  I waited for 10 minutes and not one of the connections were dropped.
What did you see instead?
From this link https://justpaste.it/15cj4
As said, MANY connections  established  to the same endpoint
All the connections are working just fine sending and receiving back the data as expected.
So the issue here is just why all these connections ? When and how will they get reclaimed ? Do I need to shutdown the channel after each request and create a new one like the one that's not seeing this issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2886
compiler: move over to method descriptor builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Generated code can't call anything that is @ExperimentalApi. This has to wait until after #2641. Although it also seemed like that is just a formality.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2887
core: deprecate MethodDescriptor.create
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there much of a pushing factor for deprecating create()? It handles the common case easily and we can trivially emulate it with the builder if it became the least bit of burden. It also seems to have a cleaner creation pattern in the common case (not needing to mess with the generics; that can be avoided in the builder, but then you have indentation problems).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2888
Changing CXXFLAGS and LDFLAGS is ignored due to Gradle daemon
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Apologies for the length, I've tried to provide as much detail as possible.  I'm trying to natively compile this on an nVidia Jetson TX2 board (aarch64)
What version of gRPC are you using?
nvidia@tegra-ubuntu:~/grpc-java$ git show --oneline -s
903197b core: StreamTracer (#2863)

What JVM are you using (java -version)?
nvidia@tegra-ubuntu:~/grpc-java$ java -version
openjdk version "1.8.0_121"
OpenJDK Runtime Environment (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
OpenJDK 64-Bit Server VM (build 25.121-b13, mixed mode)

What did you do?
nvidia@tegra-ubuntu:~$ git clone https://github.com/google/protobuf.git && cd protobuf
nvidia@tegra-ubuntu:~/protobuf$ git checkout v3.1.0
nvidia@tegra-ubuntu:~/protobuf$ ./autogen.sh
nvidia@tegra-ubuntu:~/protobuf$ ./configure --prefix=/opt/protobuf
nvidia@tegra-ubuntu:~/protobuf$ make && make install
nvidia@tegra-ubuntu:~/protobuf$ export PATH=/opt/protobuf/bin/:$PATH
nvidia@tegra-ubuntu:~/protobuf$ export LD_LIBRARY_PATH=/opt/protobuf/lib/:$LD_LIBRARY_PATH
nvidia@tegra-ubuntu:~/protobuf$ export CXXFLAGS=-I/opt/protobuf/include
nvidia@tegra-ubuntu:~/protobuf$ export LDFLAGS=-L/opt/protobuf/lib
nvidia@tegra-ubuntu:~/protobuf$ ls -l /opt/protobuf/{lib,bin,include/google/protobuf/io}

/opt/protobuf/bin:
total 268
-rwxr-xr-x 1 root root 272752 Apr  7 13:47 protoc

/opt/protobuf/include/google/protobuf/io:
total 160
-rw-r--r-- 1 root root 59255 Apr  7 13:47 coded_stream.h
-rw-r--r-- 1 root root  6598 Apr  7 13:47 gzip_stream.h
-rw-r--r-- 1 root root 16666 Apr  7 13:47 printer.h
-rw-r--r-- 1 root root  2431 Apr  7 13:47 strtod.h
-rw-r--r-- 1 root root 16598 Apr  7 13:47 tokenizer.h
-rw-r--r-- 1 root root 10185 Apr  7 13:47 zero_copy_stream.h
-rw-r--r-- 1 root root 13655 Apr  7 13:47 zero_copy_stream_impl.h
-rw-r--r-- 1 root root 16753 Apr  7 13:47 zero_copy_stream_impl_lite.h

/opt/protobuf/lib:
total 209472
-rw-r--r-- 1 root root 60953590 Apr  7 13:47 libprotobuf.a
-rwxr-xr-x 1 root root      991 Apr  7 13:47 libprotobuf.la
-rw-r--r-- 1 root root  5724374 Apr  7 13:47 libprotobuf-lite.a
-rwxr-xr-x 1 root root     1026 Apr  7 13:47 libprotobuf-lite.la
lrwxrwxrwx 1 root root       26 Apr  7 13:47 libprotobuf-lite.so -> libprotobuf-lite.so.12.0.0
lrwxrwxrwx 1 root root       26 Apr  7 13:47 libprotobuf-lite.so.12 -> libprotobuf-lite.so.12.0.0
-rwxr-xr-x 1 root root  2390392 Apr  7 13:47 libprotobuf-lite.so.12.0.0
lrwxrwxrwx 1 root root       21 Apr  7 13:47 libprotobuf.so -> libprotobuf.so.12.0.0
lrwxrwxrwx 1 root root       21 Apr  7 13:47 libprotobuf.so.12 -> libprotobuf.so.12.0.0
-rwxr-xr-x 1 root root 24405752 Apr  7 13:47 libprotobuf.so.12.0.0
-rw-r--r-- 1 root root 91333170 Apr  7 13:47 libprotoc.a
-rwxr-xr-x 1 root root     1010 Apr  7 13:47 libprotoc.la
lrwxrwxrwx 1 root root       19 Apr  7 13:47 libprotoc.so -> libprotoc.so.12.0.0
lrwxrwxrwx 1 root root       19 Apr  7 13:47 libprotoc.so.12 -> libprotoc.so.12.0.0
-rwxr-xr-x 1 root root 29662544 Apr  7 13:47 libprotoc.so.12.0.0
drwxr-xr-x 2 root root     4096 Apr  7 13:47 pkgconfig

nvidia@tegra-ubuntu:~/protobuf$ cd ~/
nvidia@tegra-ubuntu:~$ git clone https://github.com/grpc/grpc-java.git && cd grpc-java
nvidia@tegra-ubuntu:~/grpc-java$ ./gradlew build

*** Building codegen requires Protobuf version 3.2.0
*** Please refer to https://github.com/grpc/grpc-java/blob/master/COMPILING.md#how-to-build-code-generation-plugin

FAILURE: Build failed with an exception.

* What went wrong:
A problem occurred configuring project ':grpc-compiler'.
> Exception thrown while executing model rule: NativeComponentModelPlugin.Rules#createBinaries(TargetedNativeComponentInternal, PlatformResolvers, BuildTypeContainer, FlavorContainer, ServiceRegistry)
   > Invalid NativePlatform: linux_aarch64

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 2.646 secs

Googled for a bit and found this discussion amongst others so made some mods...
nvidia@tegra-ubuntu:~/grpc-java$ git diff
diff --git a/compiler/build.gradle b/compiler/build.gradle
index 10d9c31..cfd1850 100644
--- a/compiler/build.gradle
+++ b/compiler/build.gradle
@@ -48,6 +48,9 @@ model {
     }
     gcc(Gcc) {
       target("ppcle_64")
+      target("linux_aarch64"){
+        cppCompiler.executable = "/usr/bin/gcc"
+      }
     }
     clang(Clang) {
     }
@@ -60,6 +63,9 @@ model {
     x86_64 {
       architecture "x86_64"
     }
+    linux_aarch64 {
+      architecture "arm64"
+    }
     ppcle_64 {
       architecture "ppcle_64"
     }
@@ -67,7 +73,7 @@ model {
 
   components {
     java_plugin(NativeExecutableSpec) {
-      if (arch in ['x86_32', 'x86_64', 'ppcle_64']) {
+      if (arch in ['x86_32', 'x86_64', 'arm64', 'ppcle_64']) {
         // If arch is not within the defined platforms, we do not specify the
         // targetPlatform so that Gradle will choose what is appropriate.
         targetPlatform arch

nvidia@tegra-ubuntu:~/grpc-java$ ./gradlew build
*** Building codegen requires Protobuf version 3.2.0
*** Please refer to https://github.com/grpc/grpc-java/blob/master/COMPILING.md#how-to-build-code-generation-plugin
:grpc-context:compileJava
:grpc-context:processResources NO-SOURCE
:grpc-context:classes
:grpc-context:jar
:grpc-core:compileJava
:grpc-core:processResources
:grpc-core:classes
:grpc-core:jar
:grpc-auth:compileJava
:grpc-auth:processResources NO-SOURCE
:grpc-auth:classes
:grpc-auth:jar
:grpc-netty:compileJava
:grpc-netty:processResources
:grpc-netty:classes
:grpc-netty:jar
:grpc-okhttp:compileJava
:grpc-okhttp:processResources
:grpc-okhttp:classes
:grpc-okhttp:jar
:grpc-compiler:compileJava_pluginExecutableJava_pluginCppIn file included from /home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_generator.cpp:1:0:
/home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_generator.h:8:49: fatal error: google/protobuf/io/zero_copy_stream.h: No such file or directory
compilation terminated.

In file included from /home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_plugin.cpp:8:0:
/home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_generator.h:8:49: fatal error: google/protobuf/io/zero_copy_stream.h: No such file or directory
compilation terminated.

/home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_generator.h:8:49: fatal error: google/protobuf/io/zero_copy_stream.h: No such file or directory
compilation terminated.

 FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':grpc-compiler:compileJava_pluginExecutableJava_pluginCpp'.
> Multiple build operations failed.
      C++ compiler failed while compiling java_generator.cpp.
      C++ compiler failed while compiling java_plugin.cpp.
      C++ compiler failed while compiling java_generator.h.
  See the complete log at: file:///home/nvidia/grpc-java/compiler/build/tmp/compileJava_pluginExecutableJava_pluginCpp/output.txt

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 43.251 secs

What did you expect to see?
Successful build
What did you see instead?
In short:
/home/nvidia/grpc-java/compiler/src/java_plugin/cpp/java_generator.h:8:49: fatal error: google/protobuf/io/zero_copy_stream.h: No such file or directory
compilation terminated.

despite protobuf being compiled & installed and CXXFLAGS and LDFLAGS being set.
Also tried adding the 4 exports above at the end of my .bashrc file as it seemed to have helped in [this issue] (#1346)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2889
netty: Pass boolean to builder instead of permit/deny specialized naming
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2890
doc: document that channel state is not implemented.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2891
core: remove incorrect reporting of CLIENT_SERVER_ELAPSED_TIME.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2892
netty: add jitter to max connection age
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2893
core: Remove unused mocks which broke @DoNotMock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2894
testing: remove negative asserts about stats.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2895
okhttp: Add OptionalMethod support for private classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2896
AbstractClientStream2.GetFramer doesn't use statsTraceCtx
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GetFramer doesn't use the normal MessageFramer, so it should probably call statsTraceCtx and report the request message size and similar.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2897
core: Fix unused variables
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2898
NettyServerHandlerTest maxConnectionAge tests are flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As seen at https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/3197/console. Linux on Travis-CI didn't fail and a re-run on Jenkins passed fine.
io.grpc.netty.NettyServerHandlerTest > maxConnectionAge_goAwaySent FAILED
    Wanted but not invoked:
    defaultHttp2FrameWriter.writeGoAway(
        ChannelHandlerContext(NettyServerHandler#0, [id: 0xembedded, L:embedded - R:embedded]),
        2147483647,
        0,
        <any>,
        <any>
    );
    -> at io.grpc.netty.NettyServerHandlerTest.maxConnectionAge_goAwaySent(NettyServerHandlerTest.java:561)
...
io.grpc.netty.NettyServerHandlerTest > maxConnectionAgeGrace_channelStillOpenDuringGracePeriod FAILED
    Wanted but not invoked:
    defaultHttp2FrameWriter.writeGoAway(
        ChannelHandlerContext(NettyServerHandler#0, [id: 0xembedded, L:embedded - R:embedded]),
        2147483647,
        0,
        <any>,
        <any>
    );
    -> at io.grpc.netty.NettyServerHandlerTest.maxConnectionAgeGrace_channelStillOpenDuringGracePeriod(NettyServerHandlerTest.java:579)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2899
netty: ignore flaky max connection age tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2900
core: make MethodDescriptor.Builder non experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 done
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2901
"StatusRuntimeException: INTERNAL: HTTP/2 error code: INTERNAL_ERROR" ,"StatusRuntimeException:UNKNOWN"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.0, 1.2.0
What JVM are you using (java -version)?
1.8
What did you do?
I am running a gRPC-java server with multiple grpc services defined.
When running multiple stubs which multiple threads share, so multiple rpc calls simultaneously, I am seeing this exception below, the exception is only occasionally appear.
(1) io.grpc.statusRuntimeException: UNKNOWN
at  io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:227)
at  io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
at  io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
...............................
.................................
(2)  io.grpc.statusRuntimeException: INTERNAL: HTTP/2 error code: INTERNAL_ERROR
Received Rst Stream
at  io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:227)
at  io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
at  io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
...............................
.................................
What is benchmark scenario?


my benchmark is a distributed program: one  client to three servers.


client tps: 150k+ /s, each server receive message : 50k+ /s


question:

why  the exception is only occasionally appear? Concurrency is too big?
mutiple thread can call the same stub object at the same time?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2902
all: begin 1.4.x development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2903
netty: implement server max connection idle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2904
Service Method Options (Protobuf)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo @ejona86 this is built on top of #2886. There are a few thing that we might want to polish but I'd like to know your opinion about this initial implementation first. I'm open to comments and suggestions. What do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2905
 First received frame was not SETTINGS. Hex dump for first 5 bytes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
openjdk version "1.8.0_111"
OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-2~bpo8+1-b14)
OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode)
What did you do?
I ran a grpc server and client.
When do call I see an error
Dependencies:
  "io.grpc" % "grpc-netty" % "1.2.0",
  "io.grpc" % "grpc-stub" % "1.2.0",
  "io.grpc" % "grpc-protobuf" % "1.2.0",
  "io.netty"%"netty-codec-http2"%"4.1.8.Final",
  "io.netty"%"netty-codec-http"%"4.1.8.Final",
  "io.netty"%"netty-codec"%"4.1.8.Final",
  "io.netty"%"netty-common"%"4.1.8.Final",
  "io.netty"%"netty-handler"%"4.1.8.Final",
  "io.netty"%"netty-resolver"%"4.1.8.Final",
  "io.netty"%"netty-transport"%"4.1.8.Final",
  "io.netty"%"netty-transport-native-epoll"%"4.1.8.Final",


What did you expect to see?
successful call
What did you see instead?
io.grpc.StatusRuntimeException: INTERNAL
at io.grpc.Status.asRuntimeException(Status.java:540)
at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:439)
at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:56)
at myClientTracingInterceptor$$anon$1$$anon$2.onClose(ClientTracingInterceptor.scala:49)
at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:428)
at io.grpc.internal.ClientCallImpl.access$100(ClientCallImpl.java:76)
at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:514)
at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:431)
at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:546)
at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
at io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:152)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Caused by: io.netty.handler.codec.http2.Http2Exception: First received frame was not SETTINGS. Hex dump for first 5 bytes: 485454502f
at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.verifyFirstFrameIsSettings(Http2ConnectionHandler.java:309)
at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:217)
at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:401)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2906
core: use RESOURCE_EXHAUSTED for max message size failures
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2907
Audit/Fix graceful client shutdown in Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Based on https://groups.google.com/d/topic/grpc-io/6e0GFRSWit8/discussion and the code, it seems that channel.shutdown() when using Netty transport kills open streams.
gracefulClose() calls close() which waits for gracefulShutdownTimeoutMillis. It seems we should either set the grace time to infinity or delay calling close until after all the streams are closed.
We need to investigate why AbstractTransportTest.openStreamPreventsTermination() failed to notice this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2908
Do not merge: reproduce flaky max connection age unit test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
reproduced 191 flakes
https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/3216/#showFailuresLink
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2909
netty: move connection.addListner inside constructor of NettyServerHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2910
netty,okhttp: handle ENHANCE_YOUR_CALM and too_many_pings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2911
core: Delete AbstractStream (replaced by AbstractStream2)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2912
core: lookup TXT records when doing name resolution
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2913
netty: fix flaky max connection age tests using sleepAtLeast
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2914
core: record stats for GET requests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2915
benchmarks: disable flag printing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The caller can set the environment variable JAVA_OPTS=-XX:+PrintFlagsFinal to enable the option.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2916
core: clamp keepAliveTime/Timeout in a way easier for test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2917
core: delete the alias LoadBalancer2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Backported in #2919
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2918
core: document that NameResolver is not thread-safe.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2919
core: delete the alias LoadBalancer2.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2920
core: Add support for the AppEngine development sandbox
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2921
core: add inboundHeaders() to ClientStreamTracer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2922
core: rename headersSent to outboundHeaders.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2923
netty,okhttp: handle ENHANCE_YOUR_CALM and too_many_pings (backport to v1.3)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2924
ServerCall.getAuthority() is experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2925
core: add ServerCall.getAuthority()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2926
all: Fix basic compatibility with Mockito 2.7.19
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2927
Move client deframing to the call executor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins: retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2928
netty: more coverage on server keepalive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2929
Remove census.proto from grpc-services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Once google/instrumentation-proto has a release exposing its protos, or the protos are available via some other released instrumentation package, the copy of census.proto should be removed from this repository.
I've filed census-instrumentation/opencensus-proto#31 to track this on the instrumentation-proto repository.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2930
core: pass ServerCall to ServerStreamTracer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2931
The Java performance tests are failing at master in Jenkins
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at https://grpc-testing.appspot.com/job/gRPC_performance_experiment/4065, for example, the log has multiple instances of
E0420 13:30:55.299856866    2975 driver.cc:509]              Worker 0 could not be properly quit because Received RST_STREAM with error code 8
E0420 13:30:55.310985673    2975 driver.cc:509]              Worker 1 could not be properly quit because Received RST_STREAM with error code 8
E0420 13:30:55.510445864    2975 driver.cc:509]              Worker 2 could not be properly quit because Received RST_STREAM with error code 8

followed by hundreds of megabytes of

Apr 20, 2017 3:35:16 PM io.grpc.benchmarks.driver.LoadClient$AsyncUnaryWorker$1 onError
INFO: Error in AsyncUnary call
io.grpc.StatusRuntimeException: INTERNAL: Thrown from handleResolvedAddresses(): java.lang.NullPointerException
	at io.grpc.Status.asRuntimeException(Status.java:540)
	at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:392)
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:426)
	at io.grpc.internal.ClientCallImpl.access$100(ClientCallImpl.java:76)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:512)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:429)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:544)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117)
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)
Caused by: java.lang.NullPointerException
	at io.grpc.internal.InternalSubchannel.<init>(InternalSubchannel.java:164)
	at io.grpc.internal.ManagedChannelImpl$LbHelperImpl.createSubchannel(ManagedChannelImpl.java:604)
	at io.grpc.internal.ManagedChannelImpl$LbHelperImpl.createSubchannel(ManagedChannelImpl.java:585)
	at io.grpc.PickFirstBalancerFactory$PickFirstBalancer.handleResolvedAddressGroups(PickFirstBalancerFactory.java:88)
	at io.grpc.internal.ManagedChannelImpl$NameResolverListenerImpl$1.run(ManagedChannelImpl.java:765)
	at io.grpc.internal.ChannelExecutor.drain(ChannelExecutor.java:87)
	at io.grpc.internal.ManagedChannelImpl$4.get(ManagedChannelImpl.java:359)
	at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:218)
	at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:270)
	at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:249)
	at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:237)
	at io.grpc.stub.ClientCalls.asyncUnaryCall(ClientCalls.java:77)
	at io.grpc.benchmarks.proto.BenchmarkServiceGrpc$BenchmarkServiceStub.unaryCall(BenchmarkServiceGrpc.java:150)
	at io.grpc.benchmarks.driver.LoadClient$AsyncUnaryWorker.run(LoadClient.java:357)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2932
OkHTTP should stop using SSLCertificateSocketFactory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The next version of Android will not work with setting ALPN protocols using SSLCertificateSocketFactory.  Instead, the recommended way is to reflectively find setAlpnProtocols on the created socket, and not directly reference SSLCertificateSocketFactory at all.
From my understanding, setting the protocols using this class currently will become an effective no-op, because the protocols will already be set.
@kruton
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2933
Add cacheable_unary interop test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2934
grpclb: Flatten LB addresses to use pick-first
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2935
cause=io.netty.handler.codec.http2.Http2Exception: Header size exceeded max allowed size (10240)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
1.2.0
java.runtime.name = OpenJDK Runtime Environment
12:22:18     java.runtime.version = 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13
12:22:18     java.specification.name = Java Platform API Specification
12:22:18     java.specification.vendor = Oracle Corporation
12:22:18     java.specification.version = 1.8
12:22:18     java.vendor = Oracle Corporation
12:22:18     java.vendor.url = http://java.oracle.com/
12:22:18     java.vendor.url.bug = http://bugreport.sun.com/bugreport/
12:22:18     java.version = 1.8.0_121
12:22:18     java.vm.info = mixed mode
12:22:18     java.vm.name = OpenJDK 64-Bit Server VM
12:22:18     java.vm.specification.name = Java Virtual Machine Specification
12:22:18     java.vm.specification.vendor = Oracle Corporation
12:22:18     java.vm.specification.version = 1.8
12:22:18     java.vm.vendor = Oracle Corporation
12:22:18     java.vm.version = 25.121-b13
12:22:18     line.separator = \
grpc async call  There really isn't any special options set on the channelbuilder
except usePlaintext it does have that set to true but a the moment not sure why.
The scenario this is running on works for all systems I'v but on these vms.
Ubuntu vm 16.04.
Is there some way to increase that size.
I can't imagine that the packet size would be any different between these system .. it's running the same test.  Is there any other reason this exception might happen?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2936
upgrade netty.tcnative to 2.0.0.Final to overcome collisions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2.0 ( in google-cloud-java )
What JVM are you using (java -version)?
8
What did you do?
If possible, provide a recipe for reproducing the error.
included gcloud-java with rpc into an context that already uses tcnative - spring boot in this case
What did you expect to see?
the application should be able to find and use the native driver
What did you see instead?
An incarnation of the following issue -
netty/netty-tcnative#151
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2937
Use CodedInputStream.newInstance(ByteBuffer) for non-segmented messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is to improve the decode performance of small messages (<16 KB) to avoid a message-sized allocation and copy.
Protobuf already has an optimized code path for decoding a direct ByteBuffer. We currently copy to a byte[], but that could be avoided because small messages will commonly be in a single ByteBuffer.
This will require adding a new interface for retrieving the ByteBuffer from the InputStream. I'm uncertain whether the interface should support returning multiple ByteBuffers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2938
core: integrate instrumentation-java (Census) tracing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please ignore the individual commits and review this PR as a whole.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2939
GrpcHttp2HeadersDecoder uses netty internal classes and fails with netty 4.1.10
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Due to an endianess bug in netty I have to use the fixed version netty 4.1.10
Unfortunatly GrpcHttp2HeadersDecoder references:
import io.netty.handler.codec.http2.internal.hpack.Decoder;
which is gone with netty 4.1.10
Actual behavior
Execution fails with:
Exception in thread "grpc-default-executor-1" java.lang.NoClassDefFoundError: io/netty/handler/codec/http2/internal/hpack/Decoder
at io.grpc.netty.GrpcHttp2HeadersDecoder.(GrpcHttp2HeadersDecoder.java:85)
at io.grpc.netty.GrpcHttp2HeadersDecoder$GrpcHttp2ClientHeadersDecoder.(GrpcHttp2HeadersDecoder.java:147)
at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:120)
at io.grpc.netty.NettyClientTransport.newHandler(NettyClientTransport.java:303)
at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:173)
at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:44)
at io.grpc.internal.TransportSet.startNewTransport(TransportSet.java:233)
at io.grpc.internal.TransportSet.obtainActiveTransport(TransportSet.java:203)
at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:739)
at io.grpc.internal.ManagedChannelImpl$3.getTransport(ManagedChannelImpl.java:677)
at io.grpc.PickFirstBalancerFactory$PickFirstBalancer$1.get(PickFirstBalancerFactory.java:129)
at io.grpc.internal.DelayedClientTransport$2.run(DelayedClientTransport.java:271)
at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
at java.lang.Thread.run(Unknown Source)
Steps to reproduce
Use netty-all-4.1.10.Final-SNAPSHOT.jar
Minimal yet complete reproducer code (or URL to code)
Netty version
4.1.10
JVM version (e.g. java -version)
1.8
OS version (e.g. uname -a)
Windows 10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2940
Unix Domain Socket: UnsatisfiedLinkError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
java version "1.8.0_111"
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)
What did you do?
Creating a ManagedChannel on Unix Domain Socket:
Channel channel = NettyChannelBuilder.forAddress(new DomainSocketAddress("/tmp/somesoscket.socket"))
                .eventLoopGroup(new EpollEventLoopGroup())
                .channelType(EpollDomainSocketChannel.class)
                .usePlaintext(true)
                .build();
What did you expect to see?
Successful creation of a ManagedChannel on Unix Domain Socket.
What did you see instead?
Throwable is launched:
java.lang.UnsatisfiedLinkError: io.netty.shadednetty.channel.epoll.NativeStaticallyReferencedJniMethods.epollin()I
        at io.netty.shadednetty.channel.epoll.NativeStaticallyReferencedJniMethods.epollin(Native Method) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
        at io.netty.shadednetty.channel.epoll.Native.<clinit>(Native.java:69) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
        at io.netty.shadednetty.channel.epoll.IovArray.<clinit>(IovArray.java:57) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
        at io.netty.shadednetty.channel.epoll.EpollEventLoop.<init>(EpollEventLoop.java:54) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
...
java.lang.NoClassDefFoundError: Could not initialize class io.netty.shadednetty.channel.epoll.IovArray
        at io.netty.shadednetty.channel.epoll.EpollEventLoop.<init>(EpollEventLoop.java:54) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
        at io.netty.shadednetty.channel.epoll.EpollEventLoopGroup.newChild(EpollEventLoopGroup.java:134) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
        at io.netty.shadednetty.channel.epoll.EpollEventLoopGroup.newChild(EpollEventLoopGroup.java:35) ~[app-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]
...

note: If I use TCP instead, it works:
Channel channel = ManagedChannelBuilder.forAddress("127.0.0.1", 1234)
My netty dependencies are (gradle project):
compile 'io.netty:netty-all:4.1.8.Final'
compile 'io.netty:netty-transport-native-epoll:4.1.8.Final:linux-x86_64'
I'm shading io.netty to io.netty.shadednetty using shadow plugin as I have other netty dependencies in the project.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2941
Implement GRPCLB client-side load reporting
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@slash-lib, please focus on GrpclbClientLoadRecorder and GrpclbLoadBalancerTest.loadReporting() for their compliance with the spec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2942
CallOptions.Key should document that it uses instance equality
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2.0.
What JVM are you using (java -version)?
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
Client code wants to add value in CallOptions during grpc call for customized load balancing, similar to:
blockingStub.withOption(CallOptions.Key.of("keyName", "defaultValue"), "actualValue"),
but as the SubchannelPicker.pickSubchannel(PickSubchannelArgs args) wants to retrieve the value:  args.getCallOptions().getOption(CallOptions.Key.of("keyName", "defaultValue"))), it fails to get "actualValue", but get "defaultValue" instead.
What did you expect to see?
"actualValue"
What did you see instead?
"defaultValue"
Cause
Problem is CallOptions.getOption:
for (int i = 0; i < customOptions.length; i++) {
if (key.equals(customOptions[i][0])) {
the CallOptions.Key didn't implement hashCode and equals, so even two Key objects with exactly the same values won't match each other.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2943
grpclb: remove non-determinism workaround
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, friendly ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2944
grpclb: expose the token metadata key.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2945
okhttp: Support GET in okhttp transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2946
core: synchronize access to Census flags
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2947
core: stop using static flags for Census control.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2948
netty: Clarify max header list size configuration
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, friendly ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2949
build: fix -PerrorProne=false
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2950
android-interop-testing: Support get option in interop app
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2951
io.grpc.testing.integration.ProxyTest.smallLatency is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a re-appearance of #2176, but that one is so old I feel bad with reopening it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2952
V1.3.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2953
Request streamObserver can still call onNext a million times after stream is closed without being aware of that
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For client streaming call, once the RPC is established, even server is shutdown, the client can still (mistakenly) keep calling requestStreamObserver.onNext() for a million times, and gRPC lib just silently ignores them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2954
stub: add debug info for sending msg after stream closed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No, I don't think we should have a log message there. This happens in normal usage and is "okay." Yes, it is unfortunate that there is no limit to how long they can continue trying to send more messages, but I don't see a good way to fix that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2955
stub: rm redundant call field in StreamObserverToCallListenerAdapter
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2956
Channel.authority() should return the value of overrideAuthority
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI: most of the time we'll rebase instead of merging, and then squash before pushing to the master branch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2957
core: set server stream decompressor in transport thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2958
all: bump recommended gRPC and Proto to 1.3.0 and 3.2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2959
Verify binary header base64 encoding/decoding against grpc spec.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The spec says:

Implementations MUST accept padded and un-padded values and should emit un-padded values.

There should be a unit test to verify that's the case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2960
netty: reduce severity of disconnect message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2961
Maven dependency conversion issues
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
1.8.0_121
What did you do?
mvn compile

If possible, provide a recipe for reproducing the error.
Have the following dependencies in Maven:
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-netty</artifactId>
  <version>1.3.0</version> 
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-protobuf</artifactId>
  <version>1.3.0</version>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-stub</artifactId>
  <version>1.3.0</version>
</dependency>

Looks like artifact com.google.api.grpc:grpc-google-common-protos has a dependency
on grpc-all:1.0.1 which causes a convergence issue if you have the above dependencies and you use the dependency enforcer plugin in Maven.
The workaround is to add grpc-all as an exclusion for that dependency which is always a bit scary.
What did you expect to see?
No dependency conversion issues.
What did you see instead?
Dependency conversion failure in Maven.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2962
 Channel closed while performing protocol negotiation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
What JVM are you using (java -version)?
java version "1.8.0_131"
What did you do?
If possible, provide a recipe for reproducing the error.
If I do:
âž” ./run-test-server.sh
and then,
âž” ./run-test-client.sh --server_port=8080
Gradle is no longer run automatically. Make sure to run
'./gradlew installDist -PskipCodegen=true' or
'./gradlew :grpc-interop-testing:installDist -PskipCodegen=true' after any
changes. -PskipCodegen=true is optional, but requires less setup.
Running test empty_unary
Exception in thread "main" io.grpc.StatusRuntimeException: UNAVAILABLE: Channel closed while performing protocol negotiation
at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:227)
at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:463)
at io.grpc.testing.integration.AbstractInteropTest.emptyUnary(AbstractInteropTest.java:273)
at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:209)
at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:197)
at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:81)
Shutting down
What did you expect to see?
What did you see instead?
The error:
Gradle is no longer run automatically. Make sure to run
'./gradlew installDist -PskipCodegen=true' or
'./gradlew :grpc-interop-testing:installDist -PskipCodegen=true' after any
changes. -PskipCodegen=true is optional, but requires less setup.
Running test empty_unary
Exception in thread "main" io.grpc.StatusRuntimeException: UNAVAILABLE: Channel closed while performing protocol negotiation
at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:227)
at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
at io.grpc.testing.integration.TestServiceGrpc$TestServiceBlockingStub.emptyCall(TestServiceGrpc.java:463)
at io.grpc.testing.integration.AbstractInteropTest.emptyUnary(AbstractInteropTest.java:273)
at io.grpc.testing.integration.TestServiceClient.runTest(TestServiceClient.java:209)
at io.grpc.testing.integration.TestServiceClient.run(TestServiceClient.java:197)
at io.grpc.testing.integration.TestServiceClient.main(TestServiceClient.java:81)
Shutting down
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2963
Server side cancellations should promptly inform server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2964
Avoid reconnect in Load Balancers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2965
build,protobuf: update google_api_protos dependency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
:( Why does it depend on api-common?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2966
compiler: remove streaming calls from javadoc for newFutureStub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2967
android-helloworld: Ignore proguard warnings for javax.naming
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No need for backport. TXT support is not in 1.3.x, and this fix was merged to master before 1.4.x was cut.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2968
android-helloworld: Remove usage of ActionBarActivity
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2969
javadoc: fix broken links in javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@clabot ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2970
Add/Fix some docs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2971
Why is java grpc so slow
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
latest java gRPC
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
I created a simple service which does oracle database query.  The client and server code is based on the HelloWorld example. I am running client and server on the same windows pc. The Oracle database is running on a server.
What did you expect to see?
On server side, the database query is 51ms, which is good.  On client side, I am getting execution time 400 ms.
Using go-grpc, I get <70ms and restful using curl is 120ms.
What did you see instead?
The execution time from client side is very slow.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2972
Graceful shutdown gRPC in Tomcat
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My company uses WAR as the standard deployment mechanism so we use Tomcat deploying and undeploying application.
Since I provider gRPC server in Tomcat like below
@WebListener
public class ServletContextListener implements ServletContextListener {

    private Server server;

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    server = ServerBuilder.forPort(2017).addService(new H2cService()).build();
                    server.start();
                    server.awaitTermination();
                } catch (Exception e) {
                    throw new RuntimeException("start h2c error", e);
                }
            }
           }).start();
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        server.shutdown();
    }
}

and it occur Tomcat memory leak warnning

WARNING [localhost-startStop-1] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [ROOT] appears to have started a thread named [grpc-shared-destroyer-0] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:

so what is right way to start and graceful shutdown gRPC in Tomcat ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2973
Upgrade to netty 4.1.11.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FixedHttp2ConnectionDecoder.java can simply be deleted. It was just a copy in order to do 2cb6ecc since we were delayed upgrading Netty. 9ef0791 overall can be reverted.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2974
core: record individual messages to Census tracing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2975
build: Add Bazel java_grpc_library rule
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2976
FutureStub hangs when wrong netty version is used
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
netty4.version
What did you do?
If possible, provide a recipe for reproducing the error.

Accidentally use netty-codec-http2 4.1.9.Final in your pom
Create a future stub
Call stub.someOperation().get()

What did you expect to see?

The call should fail from the underlying ClassNotFoundException

What did you see instead?

A log message is printed to the console indicating the ClassNotFoundException
The call to .get() blocks indefinitely because the underlying future never returns
If a timeout is used when calling .get(), the request always times out

This problem was especially hard to diagnose because our logger is configured to exclude log messages from libraries (legacy code), so the ClassNotFoundException was never surfaced.
Findings

ChannelExecutor.drain() (line 89) eats all exceptions thrown when processing the outbound task queue when DelayedClientTransport switches from DelayedStream to NettyClientStream in DelayedClientTransport.newStream().
GrpcHttp2HeadersDecoder.<init> fails with a ClassNotFoundException when trying to load io.netty.handler.codec.http2.internal.hpack.Decoder.
Since the stream switch is itself is the task that fails, DelayedClientTransport buffers outbound tasks indefinitely, causing the request to hang.

Possible Mitigations

Propagate exceptions from ChannelExecutor.drain() in a "CompositeException" that aggregates all exceptions encountered. This will cause the client to explode, rather than logging and hoping someone is watching.
Fail conspicuously when starting gRPC with an incompatible netty version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2977
Add package descriptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Multiple package descriptions are missing on http://www.grpc.io/grpc-java/javadoc/index.html
Need to be filled up for release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2978
core: document ServerBuilder return values and method history
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2979
doc: fix broken links
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2980
doc: initiate some package javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2981
grpc not compatible netty newer than 4.1.8.Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-b12)
OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.

set gradle dependencis:

    compile group: 'io.grpc', name: 'grpc-netty', version: '1.3.0'
    compile group: 'io.grpc', name: 'grpc-protobuf', version: '1.3.0'
    compile group: 'io.grpc', name: 'grpc-stub', version: '1.3.0'
    compile group: 'io.netty', name: 'netty-all', version: '4.1.9.Final'


run the grpc service, and send a request to the server

What did you expect to see?
May 06, 2017 2:09:42 AM io.grpc.netty.NettyServerHandler onConnectionError
WARNING: Connection Error
java.lang.NoSuchMethodError: io.netty.handler.codec.http2.Http2Connection$Endpoint.maxStreams(II)V
	at io.grpc.netty.FixedHttp2ConnectionDecoder$FrameReadListener.applyLocalSettings(FixedHttp2ConnectionDecoder.java:416)
	at io.grpc.netty.FixedHttp2ConnectionDecoder$FrameReadListener.onSettingsAckRead(FixedHttp2ConnectionDecoder.java:390)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onSettingsAckRead(Http2InboundFrameLogger.java:86)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:522)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.grpc.netty.FixedHttp2ConnectionDecoder.decodeFrame(FixedHttp2ConnectionDecoder.java:119)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:353)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:413)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:748)

05-06 02:09:42.523 D [grpc-default-worker-ELG-6-1] [i.n.h.c.h.Http2ConnectionHandler][Slf4JLogger.java:86] - [id: 0x89ff7171, L:/240.0.0.3:6001 - R:/240.0.0.1:55454] Sent GOAWAY: lastStreamId '0', errorCode '2', debugData 'io.netty.handler.codec.http2.Http2Connection$Endpoint.maxStreams(II)V'. Forcing shutdown of the connection.
May 06, 2017 2:09:42 AM io.grpc.netty.NettyServerTransport notifyTerminated
SEVERE: Transport failed
java.lang.NoSuchMethodError: io.netty.handler.codec.http2.Http2Connection$Endpoint.maxStreams(II)V
	at io.grpc.netty.FixedHttp2ConnectionDecoder$FrameReadListener.applyLocalSettings(FixedHttp2ConnectionDecoder.java:416)
	at io.grpc.netty.FixedHttp2ConnectionDecoder$FrameReadListener.onSettingsAckRead(FixedHttp2ConnectionDecoder.java:390)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onSettingsAckRead(Http2InboundFrameLogger.java:86)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:522)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.grpc.netty.FixedHttp2ConnectionDecoder.decodeFrame(FixedHttp2ConnectionDecoder.java:119)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:353)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:413)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:748)

What did you see instead?
rpc calls successfully without the exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2982
Fail to to enable server-side keepAlive on 1.3.0 RELEASE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
GRPC 1.3.0
What JVM are you using (java -version)?
1.8.0_112
What did you do?
Try to enable server-side keepAlive(added in gprc-java 1.3) but the feature didn't work properly.
After setting server-side keepAlive to 180s and keepAliveTimeout to 30s. what i expect is the server will sending a keepAlive to client if the connection is idle(didn't sent any data during 180s). however. i did't see such ping packet on network.
Debugging the code(io.grpc.internal.KeepAliveManager), it seems the onTransportActive/onTransportIdle methods didn't be called by NettyServerHandler.  Unlike the NettyClientHandler, the keepAliveManager can't be triggered by stream's created/remove.
Only onDataReceived is called if data received by NettyServerHandler.

So, simply if the client didn't sent any data, the server wouldn't sent back any ping.
In this case, another way to enable server-side KeepAlive is set keepAliveDuringTransportIdle(permitKeepAliveWithoutCalls) to true, so when the io.grpc.internal.KeepAliveManager#onTransportStarted is called, it will schedule a ping future immediately.
However, the call of io.grpc.internal.KeepAliveManager#onTransportStarted didn't make effective too!
the only caller on server is io.grpc.netty.NettyServerHandler#handleProtocolNegotiationCompleted, which didn't invoke onTransportStarted because the keepAliveManager has not been initialized yet(the keepAliveManager always null during this method called).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2983
sending data using gRPC 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
I tried sending data using gRPC via proxy.
I'm doing this inside a VPN and the proxy is the only way to send data to the outside world
What did you expect to see?
The message shouldn't reached the server side
What did you see instead?
A SSLHandshakeException during the protocol negotiation.
This was the error I got:
javax.net.ssl.SSLHandshakeException: error:10000410:SSL routines:OPENSSL_internal:SSLV3_ALERT_HANDSHAKE_FAILURE
It was caught in the ProtocolNegotiators class under method userEventTriggered method.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2984
Scala: Context propagation and async interceptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to pass some values from interceptor to rpc handler. I've read that this can be done with contexts. But the problem is, that my interceptor is asynchronous, i.e. it "waits" for the future to resolve before calling next listener. The context is lost in this situation. My code is in Scala:
case class AsyncContextawareInterceptor[A](
    f: Metadata â‡’ Future[Either[Status, (Context.Key[A], A)]]
)(implicit val system: ActorSystem)
    extends ServerInterceptor
    with AnyLogging {
  import system.dispatcher

  sealed trait Msg
  case object HalfClose extends Msg
  case object Cancel extends Msg
  case object Complete extends Msg
  case object Ready extends Msg
  case class Message[T](msg: T) extends Msg

  override def interceptCall[ReqT, RespT](call: ServerCall[ReqT, RespT],
                                          headers: Metadata,
                                          next: ServerCallHandler[ReqT, RespT]): ServerCall.Listener[ReqT] =
    new ServerCall.Listener[ReqT] {
      private val stash = new java.util.concurrent.ConcurrentLinkedQueue[Msg]()
      private var interceptor: Option[ServerCall.Listener[ReqT]] = None

      private def enqueueAndProcess(msg: Msg) =
        if (interceptor.isDefined) processMessage(msg) else stash.add(msg)

      private def processMessage(msg: Msg) = msg match {
        case HalfClose â‡’ interceptor.foreach(_.onHalfClose)
        case Cancel â‡’ interceptor.foreach(_.onCancel)
        case Complete â‡’ interceptor.foreach(_.onComplete)
        case Ready â‡’ interceptor.foreach(_.onReady)
        case Message(msg: ReqT @unchecked) â‡’ interceptor.foreach(_.onMessage(msg))
      }

      private def processMessages() = while (!stash.isEmpty) {
        Option(stash.poll).foreach(processMessage)
      }

      override def onHalfClose(): Unit = enqueueAndProcess(HalfClose)

      override def onCancel(): Unit = enqueueAndProcess(Cancel)

      override def onComplete(): Unit = enqueueAndProcess(Complete)

      override def onReady(): Unit = enqueueAndProcess(Ready)

      override def onMessage(message: ReqT): Unit = enqueueAndProcess(Message(message))

      f(headers).map {
        case Right((k, v)) â‡’
          val context = Context.current.withValue(k, v)
          interceptor = Some(Contexts.interceptCall(context, call, headers, next))
          processMessages()
        case Left(status) â‡’ call.close(status, new Metadata())
      }.recover {
        case t: Throwable â‡’
          log.error(t, "AsyncContextawareInterceptor future failed")
          call.close(Status.fromThrowable(t), new Metadata())
      }
    }
}

object AuthInterceptor {
  val BOTID_CONTEXT_KEY: Context.Key[Int] = Context.key[Int]("botId")
  val TOKEN_HEADER_KEY: Metadata.Key[String] = Metadata.Key.of[String]("token", Metadata.ASCII_STRING_MARSHALLER)

  def authInterceptor(resolver: String â‡’ Future[Option[Int]])(implicit system: ActorSystem): ServerInterceptor =
    AsyncContextawareInterceptor { metadata â‡’
      import system.dispatcher
      (for {
        token â† OptionT.fromOption[Future](Option(metadata.get(TOKEN_HEADER_KEY)))
        botId â† OptionT(resolver(token))
      } yield botId).value.map {
        case Some(id) â‡’ Right(BOTID_CONTEXT_KEY â†’ id)
        case None â‡’ Left(Status.PERMISSION_DENIED)
      }
    }
}
The problem is that BOTID_CONTEXT_KEY.get is null in RPC handler, even when the future was resolved and the not-null value was set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2985
grpc-all brings in both protobuf-java and protobuf-lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-protobuf</artifactId>
      <version>1.2.0</version>
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-protobuf-lite</artifactId>
      <version>1.2.0</version>
      <scope>compile</scope>
    </dependency>

grpc-protobuf depends on protobuf-java and grpc-protobuf-lite depends on protobuf-lite. Although grpc-protobuf depends on grpc-protobuf-lite and excludes the protobuf-lite dependency, that does nothing for grpc-all which depends directly on both.
We should probably remove the explicit dependency of grpc-protobuf-lite from grpc-all, or add in an exclusion for protobuf-lite.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2986
grpc-cli return Received an error when querying services endpoint.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
grpc version 1.3.0
jdk 1.8
add ProtoReflectionService after my service
private NettyServerBuilder initConfigServer() {
        Integer workers = Optional.fromNullable(providerSettingConfig.getIothreads()).or(0);
        NettyServerBuilder builder = NettyServerBuilder
                .forPort(registryConfig.getServicePort())
                .bossEventLoopGroup(create(Constants.NETTY_BOSS_EVEN_LOOP_GROUP, 1))
                .workerEventLoopGroup(create(Constants.NETTY_WORKER_EVEN_LOOP_GROUP, workers));
        logger.debug("server:netty boss:{} worker:{}", 1, workers);

        for (ServerServiceDefinition ssd : ssds) {
            builder.addService(ssd);
        }

        builder.addService(ProtoReflectionService.newInstance());

        return builder;
    }

then run
./grpc_cli ls localhost:50053

return
Received an error when querying services endpoint.

io.grpc.examples.helloworld.HelloWorldServer is the same problem too
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2987
netty: fix server keepalive not initialized bug
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2988
services: HealthStatusManager not to expose server stub methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2989
Cannot upgrade to Protobuf 3.3.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As of protocolbuffers/protobuf@c2b3b3e Protobuf is depending on Guava 20, while gRPC is stuck at 19.0 for compatibility.
@xfxyjwf and @ejona86 fyi
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2990
all: bump to proto 3.3.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Based on discussion in #2989, we'll wait for a downgrade of Guava to 19 in protobuf before upgrading.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2991
Minor updates to expand javadocs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA (login here to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2992
core: add Since java doc annotations to Server, and clarify return types
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2993
KeepAliveManager IllegalArgumentException scheduling ping
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0 Release
What JVM are you using (java -version)?
java version "1.8.0_45"
Darwin dustbin.local 16.5.0 Darwin Kernel Version 16.5.0: Fri Mar  3 16:52:33 PST 2017; root:xnu-3789.51.2~3/RELEASE_X86_64 x86_64
I'm trying out the client-based keepalives and KeepAliveManager attempts to schedule delayed pings in the past, resulting in an IllegalArgument: delay: -42540410 (expected: >= 0) on line 89.  This could be fixed with a Math.max(X,0) wrapped around the call, but I'm guessing there's something else going on.
FWIW, I've configure the client with an idle timeout of 30s and a keepalive of 90s.  The server is set with a permitted keepalive time of 1m.  The RPC channel is basically idle, I'm using a long-running, streaming RPC call to await some notifications.
https://github.com/grpc/grpc-java/blob/v1.3.0/core/src/main/java/io/grpc/internal/KeepAliveManager.java#L89
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2994
[Question] How to disable some logs?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
Hi,
How can I disable logging such as the following?
12:15:30.350 [epollEventLoopGroup-2-1] DEBUG io.grpc.netty.NettyClientHandler - 
----------------INBOUND--------------------
[id: 0x15e293c9, L:null - R:/tmp/4449017254441488790.socket] WINDOW_UPDATE: streamId=7, windowSizeIncrement=16384

Many thanks,
Marc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2995
GrpcServerRule doesn't support interceptors
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.2.0
We have interceptors which catch our internal exceptions and serialize them as GRPC trailers; these are then deserialized on the client and used as the cause on the Status.
There isn't anyway to add interceptors when using the GRPCServerRule and we can't see anyway to set the cause of the Status passed to onError by GRPC.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2996
Running gRPC with Tomcat is problematic
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I ran into this issue trying to use the Google Cloud PubSub API from a Spring Boot app, using Tomcat by default. The issue is explained here.
Jetty ALPN/NPN has not been properly configured
A workaround is basically to use Jetty instead of Tomcat. However, ideally this should work with Tomcat too.
After reading around a bit, I tried pulling in the netty-tcnative-boringssl-static dependency, and org.eclipse.jetty.npn.npn-api since the code appears to be checking for a org.eclipse.jetty.npn.NextProtoNego class in the classpath, to no avail.
What can be done to make this work with Tomcat as well?
What version of gRPC are you using?
grpc-netty 1.2.0
What JVM are you using (java -version)?
1.8.0_121
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2997
core: clarify more origin docs for Channel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2998
Set always record events option for the RPC spans.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/2999
Any plan upgrade to OkHttp 3?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As title.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3000
netty: fix server keepalive not initialized bug
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3001
Javadoc improvements, especially to Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3002
doc: generate use page in javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Have you looked at the output and found it useful?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3003
FixedHttpProxyHandler: allow setting headers on HTTP CONNECT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Were the changes actually submitted upstream?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3004
protobuf-lite: fix typo. s/Marhsaller/Marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3005
ConnectivityStateInfo never update when using RoundRobinLoadBalancerFactory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
integrate grpc with spring-cloud-eureka
What did you expect to see?
I have done it with grpc 1.0.0 and spring-boot 1.5.2.RELEASE.
everything is ok.
What did you see instead?
But when I try to update grpc to 1.2.0. client can not connect to server.
Then I found the cause.  In class RoundRobinLoadBalancerFactory,   subchannel is initialized as IDLE and never updated.  See https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/util/RoundRobinLoadBalancerFactory.java#L122  .
But when client try to connect server, method filterNonFailingSubchannels will retrieve channels of which state is READY.  See https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/util/RoundRobinLoadBalancerFactory.java#L179 .
How can I trigger the updating of subchannel's state?
to reproduce my issue.


git clone https://github.com/iamtiancaif/spring-boot-starter-grpc.git


install this project to integrate grpc and spring-cloud-eureka.


download this project : https://github.com/iamtiancaif/grpc-java-demos/tree/master/springboot


build this projects downloaded in step 4, then run them in order of : eureka-server, grpc-server, grpc-client.


Thanks a lot.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3006
Fixes for static checker failures
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3007
Netty caused "onStreamAllocated was not called, but it seems the stream is active"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reported by https://groups.google.com/d/topic/grpc-io/gpapLCscalk/discussion
Seen in grpc 1.3.0
22:42:37.609 |- WARN  i.n.u.c.DefaultPromise - An exception was thrown by io.grpc.netty.NettyClientStream$Sink$2.operationComplete()
java.lang.IllegalStateException: onStreamAllocated was not called, but it seems the stream is active
        at com.google.common.base.Preconditions.checkState(Preconditions.java:174)
        at io.grpc.internal.AbstractStream2$TransportState.onSentBytes(AbstractStream2.java:287)
        at io.grpc.netty.NettyClientStream$Sink$2.operationComplete(NettyClientStream.java:172)
        at io.grpc.netty.NettyClientStream$Sink$2.operationComplete(NettyClientStream.java:166)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:481)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:420)
        at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:95)
        at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:76)
        at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:71)
        at io.netty.handler.codec.http2.StreamBufferingEncoder$Frame.release(StreamBufferingEncoder.java:309)
        at io.netty.handler.codec.http2.StreamBufferingEncoder$DataFrame.release(StreamBufferingEncoder.java:357)
        at io.netty.handler.codec.http2.StreamBufferingEncoder$PendingStream.close(StreamBufferingEncoder.java:292)
        at io.netty.handler.codec.http2.StreamBufferingEncoder.writeRstStream(StreamBufferingEncoder.java:184)
        at io.grpc.netty.NettyClientHandler.cancelStream(NettyClientHandler.java:470)
        at io.grpc.netty.NettyClientHandler.write(NettyClientHandler.java:244)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731)
        at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:817)
        at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:724)
        at io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:1022)
        at io.netty.channel.AbstractChannel.write(AbstractChannel.java:291)
        at io.grpc.netty.WriteQueue.flush(WriteQueue.java:127)
        at io.grpc.netty.WriteQueue.access$000(WriteQueue.java:47)
        at io.grpc.netty.WriteQueue$1.run(WriteQueue.java:59)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3008
core: don't expose internal Metadata.headerCount
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3009
interop-testing,okhttp,testing: update tests to pass with ipv6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please wait until this passes on all of the test platforms (Windows, Linux, Mac)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3010
java.lang.NoClassDefFoundError: io.grpc.ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
v1.3.0
What JVM are you using (java -version)?
1.8.0_45
What did you do?
I created a library project that sends data to server over GPRC. I tested it as a module dependency on a sample project and it is working fine. When I take the aar file and add it as a dependency on apps, the app is crashing.
What did you expect to see?
The app should run without crashing as it runs when I add it as a normal module dependency.
What did you see instead?
I get a crash with trace
E/AndroidRuntime: FATAL EXCEPTION: main
Process: com.myapp.tuktuk, PID: 7362
java.lang.NoClassDefFoundError: io.grpc.ManagedChannelBuilder

My library project gradle file looks like below
apply plugin: 'com.android.library'
apply plugin: 'com.google.protobuf'

android {
    compileSdkVersion 25
    buildToolsVersion '25.0.2'

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 24
        versionCode 1
        versionName "1.0"
        consumerProguardFiles 'proguard-project.pro'

    }
}

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.2.0'
    }
    plugins {
        javalite {
            artifact = "com.google.protobuf:protoc-gen-javalite:3.0.0"
        }
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.3.0' // CURRENT_GRPC_VERSION
        }
    }
    generateProtoTasks {
        all().each { task ->
            task.plugins {
                javalite {}
                grpc {
                    // Options added to --grpc_out
                    option 'lite'
                }
            }
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.3.1'
    compile 'io.grpc:grpc-okhttp:1.3.0'
    compile 'io.grpc:grpc-protobuf-lite:1.3.0'
    compile 'io.grpc:grpc-stub:1.3.0'
    compile 'javax.annotation:javax.annotation-api:1.2'
    compile 'com.google.firebase:firebase-messaging:9.8.0'
    compile 'com.google.code.gson:gson:2.8.0'
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3011
toString not include the field which type is map?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in my .protobuf file, I have a class like:
message Demo{
int32 intValue = 1;
map<string,string> mapValue = 2;
string stringValue = 3;
}
in my java code, I had put map into mapValue,
but when i call toString(), the field mapValue is excluded.
And I print toString, stringValue return "\123\535\153"
these form is not human readable
Have one method can log all message in human readable form
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3012
how to build grpc-java for mips64el 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When i build bazel, it depends grpc-java-plugin. But i build grpd-java git source code get error,
20:34:20.419 [INFO] [com.google.gradle.osdetector.OsDetector] ------------------------------------------------------------------------
20:34:20.419 [INFO] [com.google.gradle.osdetector.OsDetector] Detecting the operating system and CPU architecture
20:34:20.420 [INFO] [com.google.gradle.osdetector.OsDetector] ------------------------------------------------------------------------
20:34:20.420 [INFO] [com.google.gradle.osdetector.OsDetector] os.detected.name=linux
20:34:20.420 [INFO] [com.google.gradle.osdetector.OsDetector] os.detected.arch=unknown
20:34:20.422 [DEBUG] [org.gradle.configuration.project.BuildScriptProcessor] Timing: Running the build script took 3.707 secs
20:34:20.429 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] 
20:34:20.430 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] FAILURE: Build failed with an exception.
20:34:20.430 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] 
20:34:20.430 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] * Where:
20:34:20.431 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] Build file '/home/grpc-java/all/build.gradle' line: 31
20:34:20.431 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] 
20:34:20.431 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] * What went wrong:
20:34:20.432 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] A problem occurred evaluating project ':grpc-all'.
20:34:20.432 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] > A problem occurred configuring project ':grpc-protobuf-lite'.
20:34:20.432 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter]    > unknown os.arch: mips64el
20:34:20.433 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] 
20:34:20.433 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] * Try:
20:34:20.433 [ERROR] [org.gradle.internal.buildevents.BuildExceptionReporter] Run with --stacktrace option to get the stack trace. 
20:34:20.433 [LIFECYCLE] [org.gradle.internal.buildevents.BuildResultLogger] 
20:34:20.434 [LIFECYCLE] [org.gradle.internal.buildevents.BuildResultLogger] BUILD FAILED
20:34:20.434 [LIFECYCLE] [org.gradle.internal.buildevents.BuildResultLogger] 
20:34:20.435 [LIFECYCLE] [org.gradle.internal.buildevents.BuildResultLogger] Total time: 9.424 secs


my environment:
os: fedora21
arch: mips64el
protoc: v3.3.0
Could you give me some ideas for building it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3013
SECURITY.md references non-existing ServerCall.SSL_SESSION_KEY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Security.md file refers in Section "Mutual TLS" to ServerCall.SSL_SESSION_KEY to get a handle to the SSLSession in use.
This constant does neither exist in the current Master (commit 5dc8a12 at the time of writing), nor in
the 1.3.0 release.
To circumvent, I iterated over all keys and
for (Key<?> key : call.getAttributes().keys()) {
	if (key.toString().equals("ssl-session")) {
		SSLSession sslSession = (SSLSession) call.getAttributes().get(key);
		// ..
	}
}

does the trick, but having a proper constant would be nicer and stable. In addition,
interceptCall(ServerCall<RespT> call, // ... 
in the very same session could / should be fixed to
interceptCall(ServerCall<ReqT, RespT> call, // ... 
with kind regards,
daniel heldt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3014
all: fix bad ref to ServerCall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3015
testing: Add missing RunWith to GrpcServerRuleTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I thought this test was going to be factored @dapengzhang0  ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3016
core: ServerCallImpl error if >1 client message in SERVER_STREAMING, split up test suite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3017
Duplicate headers causes c-core failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
1.8.0_121
What did you do?
If possible, provide a recipe for reproducing the error.
I made a server interceptor as follows:
    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(final ServerCall<ReqT, RespT> serverCall,
                                                                 final Metadata headers,
                                                                 final ServerCallHandler<ReqT, RespT> next) {
        final Optional<String> targetAlias = resolveRedirectTarget();
        if (!targetAlias.isPresent()) {
            return next.startCall(serverCall, headers);
        }

        final ManagedChannel channel;
        final ClientCall<ReqT, RespT> clientCall;
        try {
            channel = channelFactory.get(targetAlias.get());
            clientCall = channel.newCall(serverCall.getMethodDescriptor(), CallOptions.DEFAULT);
            clientCall.start(new ClientCall.Listener<RespT>() {
                @Override
                public void onHeaders(final Metadata headers) {
                    // Issue is here
                    serverCall.sendHeaders(headers);
                }

                @Override
                public void onMessage(final RespT message) {
                    serverCall.sendMessage(message);
                }

                @Override
                public void onClose(final Status status, final Metadata trailers) {
                    serverCall.close(status, trailers);
                }

                @Override
                public void onReady() {
                    serverCall.request(1);
                }

            }, headers);
            clientCall.request(2);
            serverCall.request(1);
        } catch (final Exception ignored) {
            return next.startCall(serverCall, headers);
        }

        return new ServerCall.Listener<ReqT>(){
            public void onMessage(final ReqT message) {
                clientCall.sendMessage(message);
            }

            public void onHalfClose() {
                clientCall.halfClose();
            }

            public void onCancel() {
                clientCall.cancel("Redirect call was cancelled upstream.", null);
            }

             public void onReady() {
                clientCall.request(1);
            }
        };
    }

What did you expect to see?
A caller of this service to get a response that has been proxied through to a different backend target.
What did you see instead?
This works in Java, but not in c-core from the client side.  As a result of forwarding the proxy target response headers, there ends up being 2 entries for "content-type"  Java clients are okay with this, c based clients are not.  I'm not sure who is "right" here as the spec is ambiguous as to the desired behavior if there are multiple headers for the same key(and in this case, their values are identical as well).  My fix for now is to simply send a new Metadata() rather than forwarding headers, but this might lose some custom headers from the proxy target.  I also considered doing a headers.removeAll(GrpcUtil.CONTENT_TYPE/ENCODING_TYPE/ETC) but since those are in the internal package I didn't.  I'm wondering what your thoughts are on how I'm doing this.  Maybe there's even a trick where I could pull this off at a pure bytestream level so my proxy isn't parsing the bytes at all?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3018
Use periodic builds for release branches
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo friendly ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3019
POC: channel state API plumbing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3020
[Question] Catch exceptionCaught() event was fired, and it reached at the tail of the pipeline
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.2.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
Connect to a Unix domain socket that is not existing anymore with the following:
NettyChannelBuilder.forAddress(new DomainSocketAddress("/tmp/socket123.so"))
                    .eventLoopGroup(new EpollEventLoopGroup())
                    .channelType(EpollDomainSocketChannel.class)
                    .usePlaintext(true)
                    .build();
Then those WARN will be produced in the output:
WARN  [epollEventLoopGroup-2-5] 2017-05-18 23:10:17,648  Slf4JLogger.java:151 - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. 
It usually means the last handler in the pipeline did not handle the exception.
test.io.netty.channel.AbstractChannel$AnnotatedConnectException: connect() failed: No such file or directory: /tmp/socket123.so

How can we handle those exceptions or make them silent?
Many thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3021
core,netty,okhttp: detect proxy via ProxySelector
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3022
protobuf: make toStatusProto return null when metadata key is absent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3023
Excessive Logging?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
What did you do?
If possible, provide a recipe for reproducing the error.
Set a deadline in an interceptor higher than context deadline.
What did you expect to see?
The lower of the two enforced.
What did you see instead?
The lower of the two enforced, with a lot of logging :)
May 19, 2017 3:39:39 PM io.grpc.internal.ClientCallImpl logIfContextNarrowedTimeout
INFO: Call timeout set to '1999578360' ns, due to context deadline. Explicit call timeout was '4999976265' ns.
Is this intentional to log at INFO, and if so, should I just change my logging config to silence this class?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3024
Fix incorrect assertEquals argument ordering
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zpencer, friendly ping.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3025
Stop telling people Jetty ALPN has not been configured
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If both OpenSsl (tcnative) and Jetty ALPN are unavailable then we end up failing with "Jetty ALPN/NPN has not been properly configured". We should tell them to configure tcnative, and not encourage the use of Jetty ALPN.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3026
core: delete deprecated affinity API.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3027
Grpc.Core.RpcException method is unimplemented with C# client and Java Server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using grpc 1.3.0 on both Java(1.8) server and C# client.
I implemented a simple service using protobuf and grpc-gen. The C# client and Java Server both have the same .proto file. Using java client everything works fine but when using C# I get the following error:
Grpc.Core.RpcException Status(StatusCode=Unimplemented, Detail="Method tourism.RemoteService/Login is unimplemented")
Anyway the server receives the request, logs the information that was sent in the request but then throws an exception, probably because the client stopped running.
I've tried mulptiple projects and changed the service , .proto file, the port.
syntax = "proto3";

package tourism;

service RemoteService {
  rpc Login(LoginUserDTO) returns (Response) {}
}

message AgencyDTO{
  int32 id=1;
  string name=2;
  string email=3;
  string password=4;
}

message LoginUserDTO{
  string password=1;
  string email=2;
}

message SearchAttractionsDTO{
  string name=1;
  int32 start_hour=2;
  int32 start_minute=3;
  int32 stop_hour=4;
  int32 stop_minute=5;
  AgencyDTO loggedUser=6;
}

message AttractionDTO{
  int32 id=1;
  string name=2;
  string agency=3;
  int32 hour=4;
  int32 minute=5;
  int32 seats=6;
  int32 price=7;
}

message ReservationDTO{
  int32 id=1;
  string first_name=2;
  string last_name=3;
  string phone=4;
  int32 seats=5;
  AttractionDTO attraction=6;
  AgencyDTO agency=7;
}

message Response{
  enum ResponseType{
    OK=0;
    NOT_LOGGED_ID=1;
    SERVER_ERROR=2;
    VALIDATOR_ERROR=3;
  }
  ResponseType type=1;
  AgencyDTO user=2;
  string message=3;
}

Program.cs
namespace testGrpc2
{
    class MainClass
    {
        public static void Main(string[] args)
        {
            var channel = new Channel("127.0.0.1:61666",ChannelCredentials.Insecure);
            var client = new RemoteService.RemoteServiceClient(channel);
            Response response=client.Login(new LoginUserDTO{Email="ex@ex.com",Password="notmypassword"});
            Console.WriteLine(response);
            Console.ReadKey();
        }
    }
} 

Java Server
import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.grpc.stub.StreamObserver;
import tourism.RemoteServiceGrpc;
import tourism.Service;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by Andu on 21/05/2017.
 */
public class ServerGrpc {
    Logger logger= Logger.getLogger(ServerGrpc.class.getName());
    private final Server server;
    private final int port;

    public ServerGrpc(int p){
        port=p;
        server= ServerBuilder.forPort(port).addService(new ServiceImp()).build();
    }

    public void start() throws IOException {
        server.start();
        logger.info("Server started, listening on " + port);
        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                // Use stderr here since the logger may has been reset by its JVM shutdown hook.
                System.err.println("*** shutting down gRPC server since JVM is shutting down");
                ServerGrpc.this.stop();
                System.err.println("*** server shut down");
            }
        });
    }

    public void stop() {
        if (server != null) {
            server.shutdown();
        }
    }

    void blockUntilShutdown() throws InterruptedException {
        if (server != null) {
            server.awaitTermination();
        }
    }

    private class ServiceImp extends RemoteServiceGrpc.RemoteServiceImplBase {
        Logger log=Logger.getLogger(ServiceImp.class.getName());

        @Override
        public void login(Service.LoginUserDTO request, StreamObserver<Service.Response> responseStreamObserver){
            super.login(request,responseStreamObserver);
            log.log(Level.INFO,"Request from "+request.getEmail());
            Service.Response response= Service.Response.newBuilder().setMessage("Hello "+request.getEmail()+", I know your password: "+request.getPassword()).build();
            responseStreamObserver.onNext(response);
            responseStreamObserver.onCompleted();
        }
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3028
Log deadline narrowing events at FINE instead of INFO.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 hopefully this small change works for #3023
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3029
core: Simplify ChannelImpl constructor; testable Builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3030
core,netty,okhttp: plumb Attributes from NameResolver to ClientTransportFactory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3031
all: bump to 1.5.0-SNAPSHOT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3032
OkHttp is incompatible with newer C-core binaries
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported by grpc/grpc#11258. This is caused by grpc/proposal#19 and a bug in the OkHttp transport that doesn't ignore unknown settings frames (as required by the HTTP/2 spec).
It's unclear how this wasn't caught in the integration tests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3033
Too Many Logs 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.0
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
Not sure.
What did you expect to see?
No logs.
What did you see instead.
[id: 0xbf3948c7, L:/127.0.0.1:56373 - R:localhost/127.0.0.1:8080] DATA: streamId=5, padding=0, endStream=false, length=166, bytes=00000000a10a02696412640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...

------------------------------------
11:36:20.377 [grpc-default-worker-ELG-2-13] DEBUG io.grpc.netty.NettyClientHandler - 
----------------INBOUND--------------------

[id: 0xbf3948c7, L:/127.0.0.1:56373 - R:localhost/127.0.0.1:8080] DATA: streamId=5, padding=0, endStream=false, length=166, bytes=00000000a10a02696412640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
11:36:20.377 [grpc-default-worker-ELG-2-13] DEBUG io.grpc.netty.NettyClientHandler - 
------------------------------------

I am pretty new to using grpc-java so this might be a very basic issue. When I run my code I receive extensive logging (seen above). So much so that it has crashed my IDE before. I have tried to follow the thread here:
#1577
Logger log = Logger.getlogger("io.grpc");
log.setLevel(Level.WARNING);
Unfortunately, I have had no success. Has anyone else seen this issue or know of a solution?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3034
SerializingExecutorBenchmark fails to run
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It appears it was broken on the initial commit a4d698f. It's not quite obvious to me what executor was intended to be used.
java.lang.NullPointerException: 'executor' must not be null.
        at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:228)
        at io.grpc.internal.SerializingExecutor.<init>(SerializingExecutor.java:69)
        at io.grpc.internal.SerializingExecutorBenchmark.<init>(SerializingExecutorBenchmark.java:58)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_jmhType_B1.<init>(SerializingExecutorBenchmark_jmhType_B1.java:3)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_jmhType_B2.<init>(SerializingExecutorBenchmark_jmhType_B2.java:3)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_jmhType_B3.<init>(SerializingExecutorBenchmark_jmhType_B3.java:2)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_jmhType.<init>(SerializingExecutorBenchmark_jmhType.java:2)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_oneRunnableLatency_jmhTest._jmh_tryInit_f_serializingexecutorbenchmark0_0(SerializingExecutorBenchmark_oneRunnableLatency_jmhTest.java:337)
        at io.grpc.internal.generated.SerializingExecutorBenchmark_oneRunnableLatency_jmhTest.oneRunnableLatency_SampleTime(SerializingExecutorBenchmark_oneRunnableLatency_jmhTest.java:207)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:453)
        at org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call(BenchmarkHandler.java:437)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3035
hbase-client-1.3.1is protobuf-2.5   conflict with  grpc-1.2.0 is protobuf-3.2  ï¼Œso how can  I use this two package in one procket
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my pom file:
  <dependency>
			<groupId>org.apache.hbase</groupId>
			<artifactId>hbase-client</artifactId>
			<version>1.3.1</version>
			<exclusions>
				<exclusion>
					<groupId>io.netty</groupId>
					<artifactId>netty</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
               <dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-protobuf</artifactId>
			<version>1.2.0</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-stub</artifactId>
			<version>1.2.0</version>
		</dependency>
		<dependency>
			<groupId>com.google.protobuf</groupId>
			<artifactId>protobuf-java</artifactId>
			<version>3.2.0</version>
		</dependency>

hbase-client 's protobuf  conflict with  grpc-1.2.0's  protobuf
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3036
okhttp: ignore unknown HTTP/2 settings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You might consider backporting this to 1.4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3037
interop-testing: add alpnagent to support okhttp in test client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This does not work if you move the install files to a different machine or clear the gradle cache. It has a hard-coded path:
$ grep javaagent interop-testing/build/install/grpc-interop-testing/bin/test-client
DEFAULT_JVM_OPTS='"-javaagent:/usr/local/google/home/ejona/.gradle/caches/modules-2/files-2.1/org.mortbay.jetty.alpn/jetty-alpn-agent/2.0.6/ecca008cfd140e088590c0f2e0f223523cdb18d2/jetty-alpn-agent-2.0.6.jar"'
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3038
netty: increase message quantum
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
bigger quantum for the win ... did you happen to try the uniform allocator during this evaluation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3039
core: remove 2 suffix from streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3040
compiler: Fix compilation error
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3041
Netty does not support TLS on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
Currently i'm using gRPC 1.3.0
What JVM are you using (java -version)?
Using openjdk 1.8.0, Android version 25
What did you do?
If possible, provide a recipe for reproducing the error.
I'm trying to create a secured server on an android device. To do so i created the following method:
` public ServerAndroid(LogicInfo infoManager, GroupInfo groupInfo)  {
this.infoManager = infoManager;
this.groupInfo = groupInfo;
this.serverListener = ServerListener.NO_LISTENER;
    InputStream certificate = infoManager.getContext().getResources().openRawResource(R.raw.cert);
    InputStream key = infoManager.getContext().getResources().openRawResource(R.raw.key);
    try {

        this.keyserver = File.createTempFile("key", "pem");
        this.cert = File.createTempFile("cert","pem");
        FileUtils.copyInputStreamToFile(certificate, this.cert);
        FileUtils.copyInputStreamToFile(key, this.keyserver);
    } catch (IOException e) {
        e.printStackTrace();
    }


    this.server = ServerBuilder.forPort(LogicConstants.DEFAULT_SERVER_PORT)
            .useTransportSecurity(this.cert, this.keyserver)
            .addService(new InnerServer()).build();

}`

The thing is, when I compile the project it returns an error "java.lang.IllegalArgumentException: Jetty ALPN/NPN has not been properly configured."
I searched everywhere, and everyone says to run -Xbootclasspath/p:<alp-boot-version.jar>. but I can't do that on Android.
I tried to insert a compile dependencie on gradle (  compile 'org.mortbay.jetty.alpn:alpn-boot:8.1.11.v20170118' ) but when I try to run the project it gives the error:
Error converting bytecode to dex: Cause: Dex cannot parse version 52 byte code. This is caused by library dependencies that have been compiled using Java 8 or above. If you are using the 'java' gradle plugin in a library submodule add targetCompatibility = '1.7' sourceCompatibility = '1.7' to that submodule's build.gradle file. ...while parsing org/eclipse/jetty/alpn/ALPN.class
What did you expect to see?
No error.
What did you see instead?
java.lang.IllegalArgumentException: Jetty ALPN/NPN has not been properly configured.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3042
Remove thrift-related code from grpc/grpc-java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #3477 This will probably need to be rebased, which might as well be a new PR.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3043
okhttp: ignore unknown HTTP/2 settings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3044
Improve contributing.md guidelines.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3045
core: include how long deadline was in Status message
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3046
OkHttp exception logging level too high?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
Normal usage
What did you expect to see?
No logs
What did you see instead?
May 31, 2017 5:04:13 PM io.grpc.okhttp.AsyncFrameWriter$14 run
WARNING: Failed closing connection
java.net.SocketException: Socket closed
        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:118)
        at java.net.SocketOutputStream.write(SocketOutputStream.java:155)
        at okio.Okio$1.write(Okio.java:80)
        at okio.AsyncTimeout$1.write(AsyncTimeout.java:155)
        at okio.RealBufferedSink.close(RealBufferedSink.java:234)
        at io.grpc.okhttp.internal.framed.Http2$Writer.close(Http2.java:568)
        at io.grpc.okhttp.AsyncFrameWriter$14.run(AsyncFrameWriter.java:218)
        at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)

It looks like the socket is already dead and the close call here throws as a result 
  
    
      grpc-java/okhttp/src/main/java/io/grpc/okhttp/AsyncFrameWriter.java
    
    
         Line 221
      in
      89bc2cd
    
  
  
    

        
          
           log.log(Level.WARNING, "Failed closing connection", e); 
        
    
  

 .  It isn't clear to me that this needs to be a WARNING since the exception is coming from us trying to close a closed socket.  Maybe other failure modes here should be a warning, but should we maybe inspect the SocketException type specifically and log at FINE if the message is "Socket closed" ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3047
all: update to Apache2 licence
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Copyright lines have to change to "gRPC Authors", and an AUTHORS file needs to be added that contains Google Inc.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3048
all: fix gradle file for licence type
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3049
mvn build problem
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
I use mvn to build my project and protobuf-mavne-plugin to generate code as the grpc-java/READMME.md guide. The config is shown below. I show all the pom files
in next comment.
        <grpc-netty.version>1.3.0</grpc-netty.version>
        <grpc-protobuf.version>1.3.0</grpc-protobuf.version>
        <grpc-stub.version>1.3.0</grpc-stub.version>

            <!-- thirdparty -->
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-netty</artifactId>
                <version>${grpc-netty.version}</version>
            </dependency>
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-protobuf</artifactId>
                <version>${grpc-protobuf.version}</version>
            </dependency>
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-stub</artifactId>
                <version>${grpc-stub.version}</version>
            </dependency>

What JVM are you using (java -version)?
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-0ubuntu1.16.04.2-b11)
OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
I want to creat a new project in Opendaylight which will use gRPC/protobuf. I creat a project framework.
Becasue the proto file which I needed haven't finished, so I copy the example/helloworld.proto and HelloWorldClient.java to my project, and then I try to build. But, it failed.
hll@hll:/home/opendaylight/project/p4plugin$ tree
.
â”œâ”€â”€ parent
â”‚Â Â  â””â”€â”€ pom.xml
â”œâ”€â”€ pom.xml
â””â”€â”€ sbchannel
    â”œâ”€â”€ pom.xml
    â””â”€â”€ src
        â””â”€â”€ main
            â”œâ”€â”€ java
            â”‚Â Â  â””â”€â”€ HelloWorldClient.java
            â””â”€â”€ proto
                â””â”€â”€ helloworld.proto


What did you expect to see?
What's the problem below? How to solve?
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] p4plugin-parent .................................... SUCCESS [  2.989 s]
[INFO] p4plugin-sbchannel ................................. FAILURE [  4.572 s]
[INFO] p4plugin-aggregator ................................ SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 8.661 s
[INFO] Finished at: 2017-06-01T16:37:37+08:00
[INFO] Final Memory: 58M/1332M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project p4plugin-sbchannel: Compilation failure: Compilation failure:
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[14,24] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[14,24] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[18,62] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[72,51] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[258,45] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[246,45] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[18,60] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[72,51] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[258,45] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[246,45] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[266,53] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[279,47] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[332,40] cannot find symbol
[ERROR] symbol:   class OneofDescriptor
[ERROR] location: class com.google.protobuf.Descriptors
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[266,53] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[279,47] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[332,40] cannot find symbol
[ERROR] symbol:   class OneofDescriptor
[ERROR] location: class com.google.protobuf.Descriptors
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloWorldProto.java:[20,43] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloWorldProto.java:[25,43] package com.google.protobuf.GeneratedMessageV3 does not exist
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/grpc-java/io/grpc/examples/helloworld/GreeterGrpc.java:[41,38] method marshaller in class io.grpc.protobuf.ProtoUtils cannot be applied to given types;
[ERROR] required: T
[ERROR] found: io.grpc.examples.helloworld.HelloReply
[ERROR] reason: inferred type does not conform to upper bound(s)
[ERROR] inferred: io.grpc.examples.helloworld.HelloReply
[ERROR] upper bound(s): com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/grpc-java/io/grpc/examples/helloworld/GreeterGrpc.java:[40,38] method marshaller in class io.grpc.protobuf.ProtoUtils cannot be applied to given types;
[ERROR] required: T
[ERROR] found: io.grpc.examples.helloworld.HelloRequest
[ERROR] reason: inferred type does not conform to upper bound(s)
[ERROR] inferred: io.grpc.examples.helloworld.HelloRequest
[ERROR] upper bound(s): com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[13,15] io.grpc.examples.helloworld.HelloRequest is not abstract and does not override abstract method getRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,int) in com.google.protobuf.MessageOrBuilder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[497,51] getDefaultInstanceForType() in io.grpc.examples.helloworld.HelloRequest cannot implement getDefaultInstanceForType() in com.google.protobuf.MessageOrBuilder
[ERROR] return type io.grpc.examples.helloworld.HelloRequest is not compatible with com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[51,39] cannot find symbol
[ERROR] symbol:   method readStringRequireUtf8()
[ERROR] location: variable input of type com.google.protobuf.CodedInputStream
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[59,36] incompatible types: io.grpc.examples.helloworld.HelloRequest cannot be converted to com.google.protobuf.MessageLite
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[62,11] incompatible types: java.io.IOException cannot be converted to java.lang.String
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[64,7] cannot find symbol
[ERROR] symbol:   method makeExtensionsImmutable()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[126,26] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[131,16] cannot find symbol
[ERROR] symbol:   variable memoizedSize
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[136,34] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[138,5] cannot find symbol
[ERROR] symbol:   variable memoizedSize
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[149,14] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[161,9] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[162,14] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[168,26] cannot find symbol
[ERROR] symbol:   variable unknownFields
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[169,5] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[196,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[203,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[208,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[215,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[221,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[228,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[244,3] method does not override or implement a method from a supertype
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[257,23] io.grpc.examples.helloworld.HelloRequest.Builder is not abstract and does not override abstract method getUnknownFields() in com.google.protobuf.MessageOrBuilder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[300,53] getDefaultInstanceForType() in io.grpc.examples.helloworld.HelloRequest.Builder cannot implement getDefaultInstanceForType() in com.google.protobuf.MessageOrBuilder
[ERROR] return type io.grpc.examples.helloworld.HelloRequest is not compatible with com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[284,30] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[284,10] illegal start of type
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[289,7] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[307,15] cannot find symbol
[ERROR] symbol:   method newUninitializedMessageException(io.grpc.examples.helloworld.HelloRequest)
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[315,7] cannot find symbol
[ERROR] symbol:   method onBuilt()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[320,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[325,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[329,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[333,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[338,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[343,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[346,11] incompatible types: com.google.protobuf.Message cannot be converted to io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[347,68] incompatible types: com.google.protobuf.Message cannot be converted to io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[349,9] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[358,9] cannot find symbol
[ERROR] symbol:   method onChanged()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[360,7] cannot find symbol
[ERROR] symbol:   method onChanged()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[376,90] incompatible types: com.google.protobuf.MessageLite cannot be converted to io.grpc.examples.helloworld.HelloRequest
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[377,16] cannot find symbol
[ERROR] symbol:   method unwrapIOException()
[ERROR] location: variable e of type com.google.protobuf.InvalidProtocolBufferException
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[428,7] cannot find symbol
[ERROR] symbol:   method onChanged()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[437,7] cannot find symbol
[ERROR] symbol:   method onChanged()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[448,3] cannot find symbol
[ERROR] symbol:   method checkByteStringIsUtf8(com.google.protobuf.ByteString)
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[451,7] cannot find symbol
[ERROR] symbol:   method onChanged()
[ERROR] location: class io.grpc.examples.helloworld.HelloRequest.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[479,55] type argument io.grpc.examples.helloworld.HelloRequest is not within bounds of type-variable MessageType
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloRequest.java:[492,3] method does not override or implement a method from a supertype
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[13,15] io.grpc.examples.helloworld.HelloReply is not abstract and does not override abstract method getRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,int) in com.google.protobuf.MessageOrBuilder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[497,49] getDefaultInstanceForType() in io.grpc.examples.helloworld.HelloReply cannot implement getDefaultInstanceForType() in com.google.protobuf.MessageOrBuilder
[ERROR] return type io.grpc.examples.helloworld.HelloReply is not compatible with com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[51,39] cannot find symbol
[ERROR] symbol:   method readStringRequireUtf8()
[ERROR] location: variable input of type com.google.protobuf.CodedInputStream
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[59,36] incompatible types: io.grpc.examples.helloworld.HelloReply cannot be converted to com.google.protobuf.MessageLite
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[62,11] incompatible types: java.io.IOException cannot be converted to java.lang.String
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[64,7] cannot find symbol
[ERROR] symbol:   method makeExtensionsImmutable()
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[126,26] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[131,16] cannot find symbol
[ERROR] symbol:   variable memoizedSize
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[136,34] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[138,5] cannot find symbol
[ERROR] symbol:   variable memoizedSize
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[149,14] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[161,9] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[162,14] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[168,26] cannot find symbol
[ERROR] symbol:   variable unknownFields
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[169,5] cannot find symbol
[ERROR] symbol:   variable memoizedHashCode
[ERROR] location: class io.grpc.examples.helloworld.HelloReply
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[196,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[203,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[208,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[215,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[221,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[228,31] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[244,3] method does not override or implement a method from a supertype
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[257,23] io.grpc.examples.helloworld.HelloReply.Builder is not abstract and does not override abstract method getUnknownFields() in com.google.protobuf.MessageOrBuilder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[300,51] getDefaultInstanceForType() in io.grpc.examples.helloworld.HelloReply.Builder cannot implement getDefaultInstanceForType() in com.google.protobuf.MessageOrBuilder
[ERROR] return type io.grpc.examples.helloworld.HelloReply is not compatible with com.google.protobuf.Message
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[284,30] cannot find symbol
[ERROR] symbol:   class GeneratedMessageV3
[ERROR] location: package com.google.protobuf
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[284,10] illegal start of type
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[289,7] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[307,15] cannot find symbol
[ERROR] symbol:   method newUninitializedMessageException(io.grpc.examples.helloworld.HelloReply)
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[315,7] cannot find symbol
[ERROR] symbol:   method onBuilt()
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[320,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[325,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder
[ERROR] /home/opendaylight/project/p4plugin/sbchannel/target/generated-sources/protobuf/java/io/grpc/examples/helloworld/HelloReply.java:[329,24] cannot find symbol
[ERROR] symbol:   variable super
[ERROR] location: class io.grpc.examples.helloworld.HelloReply.Builder

What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3050
testing: GrpcServerRule#directExecutor can only be called at instantiation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3051
core: don't return concrete type from AbstractServerImplBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3052
all: fix licence whitespace
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3053
examples: migrate unittest examples to GrpcServerRule
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How does this resolve #2488?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3054
Status.withCause() is not effective
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
java version "1.8.0_51"
Java(TM) SE Runtime Environment (build 1.8.0_51-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)
What did you do?
In server interceptor, I close ServerCall and set a Status with Throwable instance:
@Override
public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
    ServerCall<ReqT, RespT> call,
    Metadata headers,
    ServerCallHandler<ReqT, RespT> next) {

     try{
          ... 
     } catch(CustomException e){
         call.close(Status.UNAUTHENTICATED.withDescription("TOKEN_INCORRECT").withCause(e), headers);
     }
     return next.startCall(new ForwardingServerCall.SimpleForwardingServerCall<ReqT, RespT>(call) {}, headers);
}

In client, I use Status status = Status.fromThrowable(e); to get the Status returned from server.
status.getCode() and status.getDescription() can get the correct value , but status.getCause() is always null.
What did you expect to see?
In client, I can get the correct Throwable instance rather than null by status.getCause()
What did you see instead?
staus.getCause() is always null
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3055
core: JumpToApplication...Listener should not close context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3056
grpc-netty:jar:1.3.0 is using a buggy netty package?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
why client is using http2 when i want it to use socket to connect unix domain?
`
public static void main(String[] args) throws Exception {
    HelloWorldClient client = new HelloWorldClient(
            NettyChannelBuilder.forAddress(new DomainSocketAddress("/tmp/grpc.sock"))
            .channelType(KQueueDomainSocketChannel.class)
            .eventLoopGroup(new KQueueEventLoopGroup())
            .usePlaintext(true)
    );
    try {
  /* Access a service running on the local machine on port 50051 */
        String user = "world";
        if (args.length > 0) {
            user = args[0]; /* Use the arg as the name to greet if provided */
        }
        client.greet(user);
    } finally {
        client.shutdown();
    }
}

`
The above is how I setup my client to connect to the rpc server based-on unix domain.
But I got the following exception.
Jun 05, 2017 4:11:46 PM com.alex.grpctest.HelloWorldClient greet
INFO: Will try to greet world ...
Exception in thread "main" java.lang.RuntimeException: java.lang.InstantiationError: io.netty.util.internal.PriorityQueue
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:144)
	at com.alex.grpctest.rpc.GreeterGrpc$GreeterBlockingStub.sayHello(GreeterGrpc.java:156)
	at com.alex.grpctest.HelloWorldClient.greet(HelloWorldClient.java:54)
	at com.alex.grpctest.HelloWorldClient.main(HelloWorldClient.java:80)
Caused by: java.lang.InstantiationError: io.netty.util.internal.PriorityQueue
	at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State.<init>(WeightedFairQueueByteDistributor.java:244)
	at io.netty.handler.codec.http2.WeightedFairQueueByteDistributor.<init>(WeightedFairQueueByteDistributor.java:57)
	at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.<init>(DefaultHttp2RemoteFlowController.java:65)
	at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController.<init>(DefaultHttp2RemoteFlowController.java:56)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.<init>(DefaultHttp2ConnectionEncoder.java:52)
	at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:145)
	at io.grpc.netty.NettyClientHandler.newHandler(NettyClientHandler.java:124)
	at io.grpc.netty.NettyClientTransport.start(NettyClientTransport.java:190)
	at io.grpc.internal.ForwardingConnectionClientTransport.start(ForwardingConnectionClientTransport.java:44)
	at io.grpc.internal.InternalSubchannel.startNewTransport(InternalSubchannel.java:216)
	at io.grpc.internal.InternalSubchannel.obtainActiveTransport(InternalSubchannel.java:186)
	at io.grpc.internal.ManagedChannelImpl$SubchannelImplImpl.obtainActiveTransport(ManagedChannelImpl.java:812)
	at io.grpc.internal.GrpcUtil.getTransportFromPickResult(GrpcUtil.java:592)
	at io.grpc.internal.DelayedClientTransport.newStream(DelayedClientTransport.java:161)
	at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:222)
	at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:270)
	at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:249)
	at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:186)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:132)
	... 3 more

I can I configure my client to connect to the unix domain?
Update 1
After some digging, I found that at this line:
io.netty.handler.codec.http2.WeightedFairQueueByteDistributor$State.<init>(WeightedFairQueueByteDistributor.java:244)

which is in package: netty-codec-http2-4.1.8.Final-sources.jar
it is using
        State(Http2Stream stream, int initialSize) {
            this.stream = stream;
            queue = new PriorityQueue<State>(initialSize);
        }

There PriorityQueue is an interface which cannot be instantiated.
This might be a netty bug?
Update 2
after using mvn dependency:tree
âžœ  grpctest mvn dependency:tree
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ------------------------------------------------------------------------
[INFO] os.detected.name: osx
[INFO] os.detected.arch: x86_64
[INFO] os.detected.classifier: osx-x86_64
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building grpctest 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ grpctest ---
[INFO] com.alex:grpctest:jar:1.0-SNAPSHOT
[INFO] +- io.grpc:grpc-netty:jar:1.3.0:compile
[INFO] |  +- io.grpc:grpc-core:jar:1.3.0:compile (version selected from constraint [1.3.0,1.3.0])
[INFO] |  |  +- com.google.errorprone:error_prone_annotations:jar:2.0.19:compile
[INFO] |  |  +- com.google.code.findbugs:jsr305:jar:3.0.0:compile
[INFO] |  |  +- io.grpc:grpc-context:jar:1.3.0:compile
[INFO] |  |  \- com.google.instrumentation:instrumentation-api:jar:0.3.0:compile
[INFO] |  +- io.netty:netty-codec-http2:jar:4.1.8.Final:compile (version selected from constraint [4.1.8.Final,4.1.8.Final])
[INFO] |  |  +- io.netty:netty-codec-http:jar:4.1.8.Final:compile
[INFO] |  |  |  \- io.netty:netty-codec:jar:4.1.8.Final:compile
[INFO] |  |  \- io.netty:netty-handler:jar:4.1.8.Final:compile
[INFO] |  \- io.netty:netty-handler-proxy:jar:4.1.8.Final:compile
[INFO] |     \- io.netty:netty-codec-socks:jar:4.1.8.Final:compile
[INFO] +- io.grpc:grpc-protobuf:jar:1.3.0:compile
[INFO] |  +- com.google.guava:guava:jar:19.0:compile
[INFO] |  +- com.google.protobuf:protobuf-java-util:jar:3.2.0:compile
[INFO] |  |  \- com.google.code.gson:gson:jar:2.7:compile
[INFO] |  +- com.google.api.grpc:grpc-google-common-protos:jar:0.1.6:compile
[INFO] |  \- io.grpc:grpc-protobuf-lite:jar:1.3.0:compile
[INFO] +- io.grpc:grpc-stub:jar:1.3.0:compile
[INFO] +- com.google.protobuf:protobuf-java:jar:3.3.0:compile
[INFO] \- io.netty:netty-transport-native-kqueue:jar:osx-x86_64:4.1.11.Final:compile
[INFO]    +- io.netty:netty-common:jar:4.1.11.Final:compile
[INFO]    +- io.netty:netty-buffer:jar:4.1.11.Final:compile
[INFO]    +- io.netty:netty-transport-native-unix-common:jar:4.1.11.Final:compile
[INFO]    \- io.netty:netty-transport:jar:4.1.11.Final:compile
[INFO]       \- io.netty:netty-resolver:jar:4.1.11.Final:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.951 s
[INFO] Finished at: 2017-06-05T16:53:13+08:00
[INFO] Final Memory: 15M/220M
[INFO] ------------------------------------------------------------------------

it is io.grpc:grpc-netty:jar:1.3.0 that is using the buggy netty package.
Update 3
This bug is introduced in this commit:
netty/netty@904e70a
and it was fixed in this commit:
netty/netty@3482651
which is supposed to be in 4.1.11.Final.
I donot know how to check whether that commit is in that release, it needs to confirm.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3057
what is the best practice to handle such kind of traffic?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.0.0
What JVM are you using (java -version)?
JDK1.7.0_79
What did you do?
when I run top, I found about 100 thread are running(or waiting) in our GRPC server.
Threads:  98 total,   6 running,  92 sleeping,   0 stopped,   0 zombie
%Cpu(s): 28.4 us,  5.0 sy,  0.0 ni, 66.1 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st
KiB Mem:  12305560 total,  6309616 used,  5995944 free,   141816 buffers
KiB Swap:        0 total,        0 used,        0 free.  2453180 cached Mem
What did you expect to see?
I am not sure this is normal. Will this cause too much context switch?
What did you see instead?
As above.
More details about our application
We build a queue service with gRPC. A bout 1000 nodes(VM) are sending request to our gRPC server with "while(true)" and only several of them could get the real traffic.
We choose the default server, i.e. netty to serve that kind of traffic. So, what is the proper config or coding we should use?
Another question is that we shared the "ManagedChannel" object in about 200 nodes(they may use this object concurrently) and build the stub in each call. Is this the right way to use?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3058
core: Avoid DNS test when no networking available
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3059
ServerStreamListenerImpl closing ServerStream in unsafe way
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is not an actual problem because of the way stubs are implemented today, but the code can potentially allow the below to happen:
ServerStreamListenerImpl is executing in the network thread (in the case of the direct executor) or in a application thread (via JumpToApplicationThreadServerStreamListener in the case of an application thread pool). ServerStreamListenerImpl.messageRead can detect an inconsistent gRPC protocol state, and close the ServerStream. This is a problem because the user application responsible for sending data (a different application thread from the JumpToApplicationThreadServerStreamListener) can be in the middle of working with the stream.
A possible fix is to treat this particular invalid gRPC protocol state as a special case, because for clientSendsOne methods, we can require the client to halfClose before we trigger the application code. This allows us to detect the problem in the stub before the application gets triggered, and we avoid any synchronization concerns. We should investigate further into other inconsistent states we want to detect, and make sure this strategy of moving it to the stub also works.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3060
netty: Eagerly create SslContext
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3061
OverrideAuthorityNameResolverFactory fails to forward NameResolver.refresh()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems we should create a ForwardingNameResolver and use it in OverrideAuthorityNameResolverFactory. Let's keep the new forwarding class internal for now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3062
core: OverrideAuthorityNameResolverFactory should forward refresh()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixing license problem, then will squash merge. This is v1.4.x and needs the old styled license.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3063
testing: move out inner class tests in GrpcServerRuleTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What did you think about the scanForTestClasses = false suggestion?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3064
core: Do not leak server state when application callbacks throw exceptions
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3065
core: move NameResolverProvider to internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This doesn't look right. This is similar to the channel and server providers, and those we can't move to internal.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3066
core: hide access to Status code and message keys
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3067
netty: Eagerly create SslContext (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3068
stub: detect invalid states on server side (eg zero responses for unary)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Codecov Report

Merging #3068 into master will decrease coverage by 0.19%.
The diff coverage is 91.89%.


@@            Coverage Diff             @@
##             master   #3068     +/-   ##
==========================================
- Coverage     84.69%   84.5%   -0.2%     
+ Complexity     2052    2048      -4     
==========================================
  Files           184     184             
  Lines         10254   10282     +28     
  Branches       1204    1206      +2     
==========================================
+ Hits           8685    8689      +4     
- Misses         1114    1134     +20     
- Partials        455     459      +4



Impacted Files
Coverage Î”
Complexity Î”





...src/main/java/io/grpc/internal/ServerCallImpl.java
86.11% <Ã¸> (-0.5%)
22 <0> (Ã¸)



stub/src/main/java/io/grpc/stub/ServerCalls.java
88.02% <91.89%> (+2.57%)
8 <1> (+1)
â¬†ï¸


.../src/main/java/io/grpc/EquivalentAddressGroup.java
59.25% <0%> (-7.41%)
8% <0%> (-1%)



...rc/main/java/io/grpc/internal/DnsNameResolver.java
71.12% <0%> (-6.34%)
16% <0%> (Ã¸)



.../java/io/grpc/internal/PickSubchannelArgsImpl.java
61.11% <0%> (-5.56%)
7% <0%> (-1%)



context/src/main/java/io/grpc/Deadline.java
90.9% <0%> (-4.55%)
24% <0%> (-1%)



...in/java/io/grpc/internal/AbstractClientStream.java
82.45% <0%> (-3.51%)
17% <0%> (Ã¸)



netty/src/main/java/io/grpc/netty/NettyServer.java
81.63% <0%> (-2.05%)
13% <0%> (Ã¸)



...src/main/java/io/grpc/internal/ClientCallImpl.java
80.32% <0%> (-1.21%)
47% <0%> (Ã¸)



core/src/main/java/io/grpc/internal/GrpcUtil.java
86.48% <0%> (-1.09%)
31% <0%> (Ã¸)



... and 7 more







Continue to review full report at Codecov.

Legend - Click here to learn more
Î” = absolute <relative> (impact), Ã¸ = not affected, ? = missing data
Powered by Codecov. Last update 0622dce...f7f1aea. Read the comment docs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3069
V1.4.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Readme needs to be updated on the release branch, because people look at the actual tag itself.
"start v1.4.0" is strange, since it was "started" earlier. How about just "Version 1.4.0"?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3070
core: Bump up instrumentation_api to 0.4.3, use instrumentation-defined STATS_CONTEXT_KEY.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3071
context: add Context.Builder.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3072
Revert "core: move NameResolverProvider to internal"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Name resolution falls in the same bucket as transport implementation as far as support goes: internal.  I don't think I can approve this request until it has gone under more thorough API review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3073
Allow gRPC LB to override and delegate DNS name resolution
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3074
core: Mark NameResolverProvider experimental and clarify docs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3075
all: update to gradle 3.5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, this missed android-interop-testing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3076
all: remove PATENTS file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fyi: @hsaliak and @louiscryan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3077
grpc bundle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
I use mvn to build my project and protobuf-mavne-plugin to generate code as the grpc-java/READMME.md guide. The config is shown below.
        <grpc-netty.version>1.3.0</grpc-netty.version>
        <grpc-protobuf.version>1.3.0</grpc-protobuf.version>
        <grpc-stub.version>1.3.0</grpc-stub.version>

            <!-- thirdparty -->
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-netty</artifactId>
                <version>${grpc-netty.version}</version>
            </dependency>
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-protobuf</artifactId>
                <version>${grpc-protobuf.version}</version>
            </dependency>
            <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-stub</artifactId>
                <version>${grpc-stub.version}</version>
            </dependency>

What JVM are you using (java -version)?
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-0ubuntu1.16.04.2-b11)
OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)

What did you do?  (Sorry for my poor English.)
I want to creat a new project in Opendaylight which will use gRPC/protobuf. The environment is apache/karaf, but these dependencies(grpc-netty, grpc-protobuf, grpc-stub) are only ordinary jar packages, I write these dependencies in my bundle pom file, when running it will give a note "jar is not a bundle". So I try to wrap these jar packages in a bundle,.
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty</artifactId>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
        </dependency>

I use maven-bundle-plugin according to the guide.
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.artifactId}</Bundle-Name>
                        <Import-Package>*</Import-Package>
                        <Export-Package>io.grpc,com.google.protobuf</Export-Package>
                        <Private-Package />
                        <Embed-Dependency>*;scope=compile|runtime;inline=false</Embed-Dependency>
                    </instructions>
                </configuration>
            </plugin>

Unfortunately, when running, it always give an error as below. After I  add  dependency which is about this package, it will give the same error but with another package name. For example errorprone,instrumentation,bootstrap, protobuf-java-util, netty and etc. There are so many dependencies, perhaps infinity, I think when I add a new dependency named A in pom file,  A's denpendecy will also need to be added.
could not be resolved. Reason: Missing Constraint: Import-Package: io.netty.buffer; version="[4.1.0,5.0.0)"
What did you expect to see?
How to slove this problem?Who can help me? How use grpc/protobuf in apache karaf?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3078
Patents already part of Apache2 license
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Something wrong with existing pr #3076 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3079
android-interop-testing: instrumented interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ericgribkoff, this breaks building of the app for me (proguard + junit).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3080
Memory leak when using Jetty ALPN SSL provider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-1-b11)
OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
We have observed a memory leak when using the Jetty ALPN SSL provider. This occurs when using a name resolver that returns multiple results, one of which fails to connect (in practice this was because of faulty firewall rules, but for the sake of testing it can be reproduced by just using a bad port number). I believe the managed channel will keep trying to open up a subchannel, but the callbacks in the ALPN.objects map aren't getting cleared.
I've created a minimal reproducer for this here: https://github.com/JackOfMostTrades/memory-leak-reproducer
When left running overnight, the size of the map grew to over 2300 objects (since there's only ever one actual connection in this test, that's pretty clearly an issue).
This may be a bug in the underlying netty channel rather than gRPC's managed channel where it's not properly cleaning up its ALPN callback when this type of error occurs, but I didn't dig deep enough into the issue to be able to tell.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3081
netty: update to netty tcnative 2.0.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3082
core: scheduler.schedule() can be used normally
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3083
Add unit tests to verify reads and writes are ignored after ServerStream#close 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After ServerStream#close is called, any attempts to read from or write to the server stream should be silently ignored. Add unit tests to AbstractTransportTest to enforce this behavior.
(See also #3068)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3084
Potential deadlock due to calling callbacks while holding a lock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
InProcessClientStream and InProcessServerStream are synchronized on their own. InProcessClientStream.serverStreamListener is called under synchronized (InProcessClientStream.this), and vice versa.
If the application tries to call methods on ClientCall or ServerCall from within the callbacks (assuming that it has already taken care of the thread-safety of the method calls on "Call" objects), a deadlock is possible when direct executor is used. For example:


Thread1

InProcessClientStream.serverRequested (locks InProcessClientStream.this)
InProcessClientStream.serverStreamListener.messageRead()
Eventually reaches application callback, which calls ServerCall.close()
InProcessServerStream.close() (locks InProcessServerStream.this)



Thread2

InProcessServerStream.clientRequested (locks InProcessServerStream.this)
InProcessServerStream.clientStreamListener.messageRead()
Eventually reaches application callback, which calls ClientCall.close()
InProcessClientStream.close() (locks InProcessClientStream.this)



As locks are acquired in reverse orders from two threads, a deadlock is possible.
The fundamental issue is that we should not call into application code while holding a lock, because we don't know what application code can do thus we can't control the order of subsequent locking.
OkHttp has the same issue, because OkHttpClientStream.transportDataReceived(), which will call into application code, is called under lock.
We could use ChannelExecutor (maybe renamed) to prevent calling into callbacks while holding a lock.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3085
Allow choosing the ManagedChannelProvider based on the NameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ManagedChannelBuilder.forTarget knows the scheme of the target, but doesn't pass it to the ManagedChannelProvider.  This makes it hard for the service loader to pick a proper Provider, because it may pick incorrectly.
Consider passing the scheme to the MCP, so that it can decide whether or not its available.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3086
Introduce MethodDescriptorSupplier
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(Splitted into two commit as per @ejona86's suggestion)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3087
update netty-tcnative version in SECURITY.md
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3088
v1.4.x: update netty-tcnative version in SECURITY.md; and bump to 4.0.3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So there's good news and bad news.
ðŸ‘ The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
ðŸ˜• The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
Note to project maintainer: This is a terminal state, meaning the cla/google commit status will not change from this state. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3089
all: update readme to point to 1.4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3090
DNS creates unbounded number of grpc-default-executor threads, and can't be overriden
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
1.8.0_101
What did you do?
I'm running about fifty processes that use grpc to communicate with each other. The workload involves events that trigger bursts of all-to-all messaging between the processes, and thereby moments of high load. After each instance of this event, I see 5-10 grpc-default-executor threads being created per process.
I have supplied FixedThreadPools through executor() for both the server and client channels.
Why are grpc-defaut-executor threads showing up despite overriding executor()? Is this expected behavior?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3091
core: OverrideAuthorityNameResolverFactory should forward refresh() (#3062)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3092
core: ensure ServerStream and ClientStream become noops after closing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3093
all: Filter out Internal* classes from Javadoc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does it exclude io.grpc.netty.InternalNettyChannelBuilder?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3094
core: Simplify ServerImpl constructor; testable Builder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3095
How to cancel a GRPC Server streaming call
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I made a Call to server. The server streams. I want to cancel the call from client.
How to cancel? No Method to cancel a call.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3096
Add config and build files to run Windows tests on Kokoro
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3097
No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-0ubuntu1.16.04.2-b11)
OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
I want to creat a gRPC client in my project, but it failed and throw an exception as below.
Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
Status: Failure
Blueprint
6/16/17 11:01 AM
Exception: 
Unable to initialize bean provider
org.osgi.service.blueprint.container.ComponentDefinitionException: Unable to initialize bean provider
	at org.apache.aries.blueprint.container.BeanRecipe.runBeanProcInit(BeanRecipe.java:738)
	at org.apache.aries.blueprint.container.BeanRecipe.internalCreate2(BeanRecipe.java:848)
	at org.apache.aries.blueprint.container.BeanRecipe.internalCreate(BeanRecipe.java:811)
	at org.apache.aries.blueprint.di.AbstractRecipe$1.call(AbstractRecipe.java:79)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at org.apache.aries.blueprint.di.AbstractRecipe.create(AbstractRecipe.java:88)
	at org.apache.aries.blueprint.container.BlueprintRepository.createInstances(BlueprintRepository.java:255)
	at org.apache.aries.blueprint.container.BlueprintRepository.createAll(BlueprintRepository.java:186)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.instantiateEagerComponents(BlueprintContainerImpl.java:724)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:411)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:276)
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:300)
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:269)
	at org.apache.aries.blueprint.container.BlueprintExtender.access$900(BlueprintExtender.java:68)
	at org.apache.aries.blueprint.container.BlueprintExtender$BlueprintContainerServiceImpl.createContainer(BlueprintExtender.java:602)
	at org.opendaylight.controller.blueprint.BlueprintBundleTracker.modifiedBundle(BlueprintBundleTracker.java:210)
	at org.opendaylight.controller.blueprint.BlueprintBundleTracker.addingBundle(BlueprintBundleTracker.java:191)
	at org.opendaylight.controller.blueprint.BlueprintBundleTracker.addingBundle(BlueprintBundleTracker.java:51)
	at org.osgi.util.tracker.BundleTracker$Tracked.customizerAdding(BundleTracker.java:467)
	at org.osgi.util.tracker.BundleTracker$Tracked.customizerAdding(BundleTracker.java:414)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:229)
	at org.osgi.util.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:443)
	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:847)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEventPrivileged(Framework.java:1568)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1504)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1499)
	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:391)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:300)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:292)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.startBundle(FeaturesServiceImpl.java:516)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeatures(FeaturesServiceImpl.java:474)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeature(FeaturesServiceImpl.java:415)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeature(FeaturesServiceImpl.java:390)
	at Proxy9ea82f09_8a94_4504_9a9a_22d21cb913b4.installFeature(Unknown Source)
	at org.apache.karaf.features.command.InstallFeatureCommand.doExecute(InstallFeatureCommand.java:72)
	at org.apache.karaf.features.command.FeaturesCommandSupport.doExecute(FeaturesCommandSupport.java:38)
	at org.apache.karaf.shell.console.AbstractAction.execute(AbstractAction.java:33)
	at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:39)
	at org.apache.karaf.shell.commands.basic.AbstractCommand.execute(AbstractCommand.java:33)
	at Proxy666faf16_140a_4912_a865_ab4c33d9d7c6.execute(Unknown Source)
	at Proxy666faf16_140a_4912_a865_ab4c33d9d7c6.execute(Unknown Source)
	at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)
	at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:480)
	at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:406)
	at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:182)
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:119)
	at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:94)
	at org.apache.karaf.shell.console.impl.jline.ConsoleImpl.run(ConsoleImpl.java:210)
	at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1$1.run(LocalConsoleManager.java:109)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.apache.karaf.jaas.modules.JaasHelper.doAs(JaasHelper.java:57)
	at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1.run(LocalConsoleManager.java:102)
Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
	at io.grpc.ManagedChannelProvider.provider(ManagedChannelProvider.java:126)
	at io.grpc.ManagedChannelBuilder.forAddress(ManagedChannelBuilder.java:45)
	at org.opendaylight.p4plugin.southboundchannel.GrpcClient.<init>(GrpcClient.java:33)
	at org.opendaylight.p4plugin.southboundchannel.SouthboundChannelProvider.init(SouthboundChannelProvider.java:30)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:299)
	at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:980)
	at org.apache.aries.blueprint.container.BeanRecipe.runBeanProcInit(BeanRecipe.java:736)

my grpc and netty version config is shown as below.
    <properties>
        <grpc.version>1.3.0</grpc.version>
        <grpc.netty.version>4.1.11.Final</grpc.netty.version>
        <protobuf.version>3.3.0</protobuf.version>
    </properties>

What did you expect to see?
Who can help me to solve this probelm?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3098
core,netty,okhttp: strip outbound headers with reserved names
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice to avoid checks once per send, though it will mean a bit of coupling between the Metadata which is transport agnostic and the HTTP transport. I see some pre-existing code in validateName() that finds keys starting with a single ':' and allows them, contrary to the API. Removing this would get us most of the way there, except for "content-type", "user-agent" and "te".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3099
stub: add generic method handler registry
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3100
testing: add inProcessGenericMethod descriptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@dapengzhang0 and I spoke offline. We're thinking all that's really necessary for most interceptor users is a simple test service. We're planning on adding a .proto with such a test service, for users to use in their own tests. It will be very simple though, with only 1 or 4 methods (because streaming). Users that need more should create their own test.proto.
This does mean interceptor tests would depend on proto, although they wouldn't need to run protoc. We considered having a simple MethodDescriptor instead, but found it still a bit too annoying because you have to create your own ServerServiceDefinition. Not the end of the world, but the proto-based solution seems easier for our users and we don't except a superficial test dependency on protobuf to be burdensome. If we're wrong, we can add it in the future.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3101
all: update readme to point to 1.4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why not #3089 (and #3088) that I sent out earlier this week?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3102
all: bump netty to 4.1.12-Final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3103
core: Mark InternalNotifyOnServerBuilder @Internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ericgribkoff, I feel like there needs to be a public API for users, otherwise they'll start using the Internal API, because that's what we did and they don't have any other option.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3104
netty: rename HandlerSettings to InternalHandlerSettings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3105
Remove internal-only methods from testing package
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As mentioned in comments in #3099, there are some issues and limitation to the current unit test tools:

It's hard to test a user-defined generic interceptor.
People are abusing NoopClientCall, using it as an alternative of mock(ClientCall.class), which is as bad as a mock.
TestMethodDescriptors.noopMarshaller does not gain much benefit. It violates the interface's contract, it's equivalent to a mock(Marshaller.class), and it does not work in InProcess transport or interop test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3106
core: don't intern Metadata keys
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3107
Fix LICENSE file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3108
benchmark service: sync protos with c-core 070a8ee
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3109
Use CodedInputStream#newInstance(ByteBuffer) for non-segmented messages
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3110
Make Kokoro logs less noisy
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3111
netty: move sslContext into transportCreationParamsFilterFactory
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3112
core: add RunWith annotation to OverrideAuthorityNameResolverTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3113
benchmarks: add missing ReportQpsScenarioServiceGrpc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
May I ask what's the usage of this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3114
core: hide access to pseudo headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3115
Implemented ClientCallStreamObserver.cancel()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3116
inprocess: mark all classes final
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm curious...why? Is there an explicit need to prevent extension of the inprocess classes? What's the harm? Why block future use cases just because you can't envision them right now?
Requiring someone to ask to remove finality stifles innovation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3117
Tracking issue for ServerBuilder.intercept() being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3118
core: ServerBuilder.intercept().
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To be in the same pattern with ManagedChannelBuilder, should it be named as ServerBuilder.intercept(...)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3119
Manual flow-control and back-pressure demo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3120
StatusRuntimeException: INTERNAL: Received headers twice
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
io.grpc:grpc-netty:1.4.0
What JVM are you using (java -version)?
java version "1.8.0_66"
Java(TM) SE Runtime Environment (build 1.8.0_66-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)
What did you do?
Setting up a simple streaming test POC using dummy data. With the following rpc definition.
service Mediation {
    rpc StreamMediate (HelloRequest) returns (stream HiResponses) {}
}

What did you expect to see?
Expecting to stream back a list of responses. To my test client .
What did you see instead?
The server seems to respond fine however the client complains about duplicate headers. With the following stack trace when run without warming up. After several requests it eventually goes away.
io.grpc.StatusRuntimeException: INTERNAL: Received headers twice
headers: Metadata(:status=200,content-type=application/grpc,grpc-encoding=identity,grpc-accept-encoding=gzip)
DATA-----------------------------
ï¿½
ï¿½121
ï¿½12123ï¿½
ï¿½121
ï¿½12123
trailers: Metadata(grpc-status=0)
	at io.grpc.Status.asRuntimeException(Status.java:543)
	at io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:392)
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:426)
	at io.grpc.internal.ClientCallImpl.access$100(ClientCallImpl.java:76)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:512)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:429)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:544)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3121
testing: move NoopClientCall & NoopServerCall to internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think these classes were for people to extend, instead of mocking them.  Since CC and SC are abstract, and people just want to stub out one method, that was the intended use.  I dont think they should be internal, they are supposed to be used.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3122
netty: fix race condition for listeners attaching to connect future
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3123
[Question] Is grpc-java still 1.6 Compatibility 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found out in https://github.com/grpc/grpc-java/blob/master/build.gradle#L50,
    sourceCompatibility = 1.6
    targetCompatibility = 1.6

But in GRPC quick-start website, http://www.grpc.io/docs/quickstart/java.html, it required for version 7 or higher
Which one is right? It is different because of runtime and compile-time?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3124
Update ClientCall and InProcessServer javadoc wrt mocking
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The @DoNotMock annotation should really refer to InProcessServerBuilder instead of InProcessTransport, and InProcessServer should have a good example in its javadoc.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3125
Add CI testing for Bazel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In #2975 we got Bazel support. We should have continuous testing with Bazel (per-PR would be nice, but at least on master).
Kokoro initially seems the easiest place for this, but that will be hard for an external contributor to do, since Kokoro as-of-yet still requires a Googler to do some operations. If we can get Bazel working on Travis-CI without slowing it down insanely, that could be an alternative. Maybe only build it on Linux, or use build matrix in some way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3126
Channel state incorrect when creating LB
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(I've not confirmed all this behavior; some of what I say here could be wrong.)
The time during which the LoadBalancer is waiting for the initial set of addresses from the NameResolver should be CONNECTING. Right now it's likely to be considered IDLE.
Also, once the LB receives the addresses, the Subchannels need to begin connecting immediately (unclear if this is LB's job of Subchannel's). This happens today because the LB changes its picker and we drain the DelayedClientTransport, but there is a moment when the Subchannel's state is IDLE and so the LB's state will likely be IDLE.
I'll also note that exitIdleMode() does not exit IDLE (it does exit idle mode, FWIW), since only the NameResolver and LoadBalancer to be created, but the InternalSubchannel will be IDLE because the picker was never called to get the transport and so obtainActiveTransport was not called and so there won't be connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3127
maven's grpc plugin is unable to resolve google.protobuf.Empty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
java version "1.8.0_111"
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)
protoc version
libprotoc 3.3.0
Properties
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <kotlin.version>1.1.2-5</kotlin.version>
    <grpc.version>1.4.0</grpc.version><!-- CURRENT_GRPC_VERSION -->
  </properties>
Plugin definition
  <plugin>
        <groupId>org.xolstice.maven.plugins</groupId>
        <artifactId>protobuf-maven-plugin</artifactId>
        <version>0.5.0</version>
        <configuration>
          <protocArtifact>com.google.protobuf:protoc:3.3.0:exe:${os.detected.classifier}</protocArtifact>
          <pluginId>grpc-java</pluginId>
          <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>compile</goal>
              <goal>compile-custom</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
Extensions
<build>
 <extensions>
      <extension>
        <groupId>kr.motd.maven</groupId>
        <artifactId>os-maven-plugin</artifactId>
        <version>1.4.1.Final</version>
      </extension>
    </extensions>
   ....
</build>
What did you do?
mvn clean compile
What did you expect to see?
BUILD SUCCESS
What did you see instead?
[INFO] Compiling 2 proto file(s) to ..../target/generated-sources/protobuf/java
[ERROR] PROTOC FAILED: myservice.proto:40:59: "google.protobuf.Empty" is not defined.
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
I'm I able to resolve it or I have to define my own Empty message ?
Note that the google.api.http type is resolved successfully.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3128
Can I exclude proto files under protobuf-java.jar when shading jar
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can I exclude those file when shading jar?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3129
DO NOT REVIEW #1: trying to repro flakey test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3130
all: migrate .proto files from testing-proto to interop-testing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3131
DO NOT REVIEW #2: another branch to try to repro flakey test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3132
Can I create client Channel from java Socket?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to create the ManagedChannel from an existing Socket object instead of calling ManagedChannelBuilder.forAddress(host, port)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3133
Periodical Refresh of DnsNameResolver
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3134
Exception occours if client sends reset frame while the server is sending headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when I use grpc-go as the client and use gprc-java as the server to build a project, if the client sents a reset frame to the server while the server is sending headers, exception will occours(netty version is 4.1.8.final),
io.netty.handler.codec.http2.Http2Exception: Request stream 2414839 is not correct for server connection
   at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
   at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultEndpoint.checkNewStreamAllowed(DefaultHttp2Connection.java:1095)
   at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultEndpoint.createStream(DefaultHttp2Connection.java:942)
   at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultEndpoint.createStream(DefaultHttp2Connection.java:960)
   at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultEndpoint.createStream(DefaultHttp2Connection.java:868)
   at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:158)
   at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeHeaders(DefaultHttp2ConnectionEncoder.java:148)
   at com.c.t.h2c.netty.NettyServerHandler.sendResponseHeaders(NettyServerHandler.java:293)
   at com.c.t.h2c.netty.NettyServerHandler.write(NettyServerHandler.java:253)
   at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
   at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHutor$5.run(SingleThreadEventExecutor.java:858)
   at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
   at java.lang.Thread.run(Thread.java:745)

https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java#L156
when the server receives reset frame  it will remove the stream from the streamMap, but  it will create the stream when it writes headers if it finds the stream is nullã€‚
https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java#L687
here the netty will check whether the streamId is even, but the streamId from upstream is always odd.So is there any method to resolve this problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3135
netty: upgrade tonetty tcnative 2.0.5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3136
benchmark: add missing server side workloads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3137
netty: client transport needs to flush fence operation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3138
core: Fix Bazel building for :util
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3139
gitignore Bazel build result symlinks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3140
core: update javadocs regarding ClientCall mocks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3141
No functional channel service provider found after shading io.grpc 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4
What JVM are you using (java -version)?
1.8
What did you do?
I have a code base that relies on Guava 14.0 and I would also like to use gRPC in my project.
gRPC needs Guava 19.0, which is not compatible with Guava 14.0.
Following some instructions online (https://maven.apache.org/plugins/maven-shade-plugin/examples/class-relocation.html), I tried to shade/relocate gRPC library using the following pom.xml file.
I manually rename affected classed in the files that protobuf generates. The project builds fine, but when I ran it, I got the following error msg:
com.shade.io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
As shown in the pom.xml, those dependencies have been added.
If possible, provide a recipe for reproducing the error.
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.shade</groupId>
    <artifactId>shade_grpc</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <dependencies>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty</artifactId>
            <version>1.4.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>1.4.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>1.4.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-okhttp</artifactId>
            <version>1.4.0</version>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.3</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <relocations>
                                <relocation>
                                    <pattern>com.google.common</pattern>
                                    <shadedPattern>com.shade.google.common</shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>io.grpc</pattern>
                                    <shadedPattern>com.shade.io.grpc</shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>io.netty</pattern>
                                    <shadedPattern>com.shade.io.netty</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

What did you expect to see?
expect it to run without exceptions
What did you see instead?
The project builds fine, but when I ran it, I got the following error msg:
com.shade.io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
As shown in the pom.xml, those dependencies have been added.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3142
Java performance benchmarks dirty shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://grpc-testing.appspot.com/view/Performance/job/gRPC_performance_experiment/4231/consoleFull
In most of scenarios, the java qps_workers don't seem to shutdown cleanly:
2017-06-26 12:32:42,813 WAITING: ETA 66.3 sec; 0 queued, 1 jobs running, 1 complete, 0 failed
2017-06-26 12:32:42,860 E0626 12:32:42.832971879   11903 driver.cc:501]              Worker 0 could not be properly quit because Received RST_STREAM with error code 8
E0626 12:32:42.847037641   11903 driver.cc:501]              Worker 1 could not be properly quit because Received RST_STREAM with error code 8
E0626 12:32:42.859240520   11903 driver.cc:501]              Worker 2 could not be properly quit because Received RST_STREAM with error code 8

2017-06-26 12:32:42,860 FAILED: qps_json_driver.quit [ret=1, pid=11902]

The log also has occasional  [GC (Allocation Failure)] messages:
[GC (Allocation Failure) [PSYoungGen: 524800K->11962K(611840K)] 524800K->11978K(2010112K), 0.0112577 secs] [Times: user=0.04 sys=0.00, real=0.02 secs] 
[GC (Allocation Failure) [PSYoungGen: 536762K->4660K(611840K)] 536778K->4684K(2010112K), 0.0062845 secs] [Times: user=0.03 sys=0.01, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 529460K->4580K(611840K)] 529484K->4612K(2010112K), 0.0056438 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3143
netty: InternalHandlerSettings should not be used by non-Internal classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3144
netty: fix NettyHandlerSettings synchronized on wrong object.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3145
Support for deframing in the application thread
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3146
core: stop spying ServerCall in UtilServerInterceptorsTest.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3147
core: minor cleanup of 859d211b6ece5827fdde56c257e9da7e3f4d56c1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3148
using protoc 3.3.0 generate wrong parseMethodï¼Ÿ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
grpc 1.4.0
using protoc generate version 3.2.0

using protoc generate version 3.3.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3149
proto message using map NoSuchMethodError
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it seems invoke  CodedOutputStream.class in grpc-protobuf-lite



  <dependency>
                <groupId>io.grpc</groupId>
                <artifactId>grpc-all</artifactId>
                <version>1.3.0</version>
            </dependency>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3150
examples: add bazel build example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3151
examples: use the official error_details.proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3152
proto-google-common-protos is built with Java 1.7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tracking issue to follow-up on https://github.com/googleapis/googleapis/issues/333#issuecomment-299289896. gRPC's status proto, and soon/now the example directory's error details proto (#3151), come from com.google.api.grpc:proto-google-common-protos, which is built with Java 1.7. My understanding is that this is fine as long as the proto-google-common-protos jar is bytecode compatible with Java 1.6, but this should be investigated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3153
all: Don't depend directly on grpc-protobuf-lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This should be backported to 1.4.x branch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3154
build.gradle: bump proto-google-common-protos to v0.1.12
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Whoa, this shouldn't be necessary. If updating the proto is required, then there is a regression in protobuf that needs to be fixed. (Unless if the application wants to use the new method directly.)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3155
build,protobuf: update google_api_protos dependency
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3156
bazel: update netty tcnative to 2.0.5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3157
okhttp: ignore unknown HTTP/2 settings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3158
examples: Enable maven enforcer requireUpperBoundDeps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3159
core: Move client-side decompressor selection to stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3160
all: Use fixed version number for java 6 signature
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does netty need a fixed version number for java 7 signature?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3161
Release 1.3.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3162
GrpcServerRule with directExecutor creates extra thread during teardown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
at java.util.concurrent.Executors$DefaultThreadFactory.newThread(Executors.java:613)
	at com.google.common.util.concurrent.ThreadFactoryBuilder$1.newThread(ThreadFactoryBuilder.java:162)
	at java.util.concurrent.ThreadPoolExecutor$Worker.<init>(ThreadPoolExecutor.java:612)
	at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:925)
	at java.util.concurrent.ThreadPoolExecutor.ensurePrestart(ThreadPoolExecutor.java:1587)
	at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:336)
	at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:555)
	at java.util.concurrent.Executors$DelegatedScheduledExecutorService.schedule(Executors.java:729)
	at io.grpc.internal.SharedResourceHolder.releaseInternal(SharedResourceHolder.java:139)
	at io.grpc.internal.SharedResourceHolder.release(SharedResourceHolder.java:92)
	at io.grpc.internal.SharedResourcePool.returnObject(SharedResourcePool.java:41)
	at io.grpc.internal.ServerImpl.checkForTermination(ServerImpl.java:293)
	at io.grpc.internal.ServerImpl.access$700(ServerImpl.java:67)
	at io.grpc.internal.ServerImpl$ServerListenerImpl.serverShutdown(ServerImpl.java:333)
	at io.grpc.inprocess.InProcessServer.shutdown(InProcessServer.java:65)
	at io.grpc.internal.ServerImpl.shutdown(ServerImpl.java:201)
	at io.grpc.internal.ServerImpl.shutdown(ServerImpl.java:67)
	at io.grpc.testing.GrpcServerRule.after(GrpcServerRule.java:100)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3163
Backport: Add Kokoro files to v1.0.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3164
Backport: Add Kokoro files to v1.1.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3165
Backport: Add Kokoro files to v1.2.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3166
Backport: Add Kokoro files to v1.3.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3167
Backport: Add Kokoro files to v1.4.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3168
interop-testing: Skip Netty Jetty ALPN tests if it is unavailable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3169
netty: add timeouts to address test flakiness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3170
interop-testing: Support conscrypt at runtime with OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3171
I try to connect to server gRPC with socket NIO but server not response.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I try to connect to server gRPC with socket NIO but server not response.
When client gRPC request to socket like that;
PRI * HTTP/2.0
SM
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½
I am not sure about it. Please help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3172
Generate interface for each rpc method.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3173
Create @GrpcClass annotation processor hook for generated source files.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To write an annotation processor that further augments the generated source from the grpc protoc plugin is a little difficult.
Currently, I process @Generated annotations and search for value ~= /gRpc/.
As an external example, looking at the new grpc-dagger in 2.11 (google/dagger#647), the additional dagger code generation is triggered off of an annotation applied to the implementing class. It would be nice to have all the code generation based off of the gprc classes.  Right now it feels like a two step process.  Add the proto, generate the grpc stub, implement the stub, add the processor annotation, compile again for the additional code.
WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3174
core: Force conscrypt for all AppEngine clients
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I thought Java 8 users were going to use tcnative. Is that not the case?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3175
com_google_protobuf() and com_google_protobuf_java() are identical
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If this was intended, documentation should be added. Otherwise one of them should be removed.
def com_google_protobuf():
  native.http_archive(
      name = "com_google_protobuf",
      sha256 = "df77b0e60afcd3d90b2654cd305e61ae8ae2e2281b4d6540c7093da4c4245d75",
      strip_prefix = "protobuf-3.3.1",
      urls = ["https://github.com/google/protobuf/archive/v3.3.1.zip"],
  )

def com_google_protobuf_java():
  native.http_archive(
      name = "com_google_protobuf_java",
      sha256 = "df77b0e60afcd3d90b2654cd305e61ae8ae2e2281b4d6540c7093da4c4245d75",
      strip_prefix = "protobuf-3.3.1",
      urls = ["https://github.com/google/protobuf/archive/v3.3.1.zip"],
  )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3176
Enable Stetho for Android by exposing OkHttpClient
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
Android's Java
What did you do?
If possible, provide a recipe for reproducing the error.
N/A
What did you expect to see?
Can access the underlying OkHttpClient
What did you see instead?
Can't access the underlying OkHttpClient
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3177
protobuf-lite: restrict visibility of protobuf_lite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3178
Backport (v1.0.x): Fix Windows build to specify Studio version
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3179
protobuf: configureProtoCompilation() seems not needed anymore
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3180
fix misuse of bazel repo @com_google_protobuf
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3181
all: begin 1.6 release cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3182
all: update to gradle 4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3183
core: Stop using context ClassLoader in Providers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3184
core: Server uses transport's ScheduledExecutorService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I do have one pending question for this change: whether it is a good idea for the InProcess server to use the channel's scheduler. In one way, it is nicer, since it is one fewer things to configure. In another, why should the client's configuration be impacting the server's behavior? I think I am leaning toward changing it so the server has its own scheduler, but I'm still on the fence.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3185
core: Channel uses transport's ScheduledExecutorService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3186
java.lang.ClassNotFoundException when rebuild my connector
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi. I make grpc libs for project like connector. It contains server and client realizations. When I rebuild my jar lib, and restart my service with new jar, but other service keep old jar I see:
Exception in thread "grpc-default-executor-401" java.lang.NoClassDefFoundError: tnt/club/feed/connector/GetSocialPostIdsResponse$PostId
	at tnt.club.feed.connector.GetSocialPostIdsResponse.toBuilder(GetSocialPostIdsResponse.java:972)
	at tnt.club.feed.connector.GetSocialPostIdsResponse.newBuilder(GetSocialPostIdsResponse.java:966)
	at tnt.club.feed.post.service.FeedPostService.getModeratorFeedPosts(FeedPostService.java:145)
	at tnt.club.feed.grpc.FeedServiceImpl.getSocialPostIds(FeedServiceImpl.java:32)
	at tnt.club.feed.connector.FeedGrpc$MethodHandlers.invoke(FeedGrpc.java:390)
	at io.grpc.stub.ServerCalls$1$1.onHalfClose(ServerCalls.java:148)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:267)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$2.runInContext(ServerImpl.java:573)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.ClassNotFoundException: tnt.club.feed.connector.GetSocialPostIdsResponse$PostId
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 13 more
I use java 1.8_131 and grpc 1.4.0
thx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3187
netty: remove unneeded license file
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3188
all,interop-testing: update google-auth-library-oauth2-http
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3189
all,interop-testing: update google-auth-library-oauth2-http
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3190
core: Stop using context ClassLoader in Providers (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm... thinking about this more, the original intention was to backport this before the 1.5.0 release. However, it didn't get in 1.5.0 and I think this isn't something we want in a patch release. So I'm going to trash this instead. Sorry @ericgribkoff
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3191
context: stop using logger at all in static initialization.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sometimes turtles all the way down is a bad thing I guess :P
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3192
core: clarify security methods on channel and server
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3193
context: avoid a lock on maybeLogStorageOverrideNotFound.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closed in favor of #3198
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3194
Update auth lib to 0.7.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3195
Implement compression interop tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are four compression interop tests defined in interop-test-descriptions.md but not implemented for Java:

client_compressed_unary
client_compressed_streaming
server_compressed_unary
server_compressed_streaming

These should be implemented and enabled in run_interop_tests.py.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3196
all: upgrade to latest error prone
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3197
Update to Error Prone 2.0.21
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3198
context avoid maybeLogStorageOverrideNotFound by lazy initialization
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3199
benchmarks: update to jmh 1.19
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3200
wired build error in a grpc and protobuf project and the build tool is Basel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
bazel build failed after we used maxInboundMessageSize(max) used in our project.
What did you expect to see?
successfully built since this API was brought since 1.1.0
What did you see instead?
bazel build failed after we used maxInboundMessageSize(max) used in our project.
error: cannot find symbol
                        .maxInboundMessageSize(MAX_MSG_SIZE)
                        ^
  symbol:   method maxInboundMessageSize(int)
  location: class ManagedChannelBuilder<CAP#1>
  where CAP#1 is a fresh type-variable:
    CAP#1 extends ManagedChannelBuilder<CAP#1> from capture of ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3201
ClientCall.isReady() is true after ClientCall.halfClose()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have code like this for a client streaming call:
ClientCall call = ...;
ClientCall.Listener listener = new ClientCall.Listener() {
  @Override
  public void onReady() {
    while(call.isReady()) {
      if (allDataSent()) {
        call.halfClose();
        return;
      }
      sendMessage();
    }
  }
}
call.start(listener, metadata);
call.request(1);
I found call.halfClose() to be called more than once (and thus crash). I would have expected call.isReady() to be false after call.halfClose() was called since after half-closing, we certainly can't send any new messages.
Thoughts?
P.S: I am using this API, cause I need flow control and the CallStreamObserver is marked experimental.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3202
Move checkstyle config to buildscripts/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3203
context: Lazy load storage
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 can you rebase first?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3204
core: Change gRPC to use io.opencensus:opencensus-api:0.5.1.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3205
Add support for specifying a custom hostname verifier when using on OkHttpChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3206
testing: refactor part of TestUtils to internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3207
Data race in TestServiceImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
WARNING: ThreadSanitizer: data race (pid=982210)
  Read of size 8 at 0x7fd444897628 by thread T36:
    #0 io.grpc.internal.MessageFramer.close()V (MessageFramer.java:305)  
    #1 io.grpc.internal.AbstractStream.endOfMessages()V (AbstractStream.java:68)  
    #2 io.grpc.internal.AbstractServerStream.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (AbstractServerStream.java:129)  
    #3 io.grpc.internal.ServerCallImpl.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ServerCallImpl.java:173)  
    #4 io.grpc.PartialForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (PartialForwardingServerCall.java:46)  
    #5 io.grpc.ForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:22)  
    #6 io.grpc.ForwardingServerCall$SimpleForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:39)  
    #7 io.grpc.testing.integration.TestServiceImpl$6$1.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (TestServiceImpl.java:579)  
    #8 io.grpc.PartialForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (PartialForwardingServerCall.java:46)  
    #9 io.grpc.ForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:22)  
    #10 io.grpc.ForwardingServerCall$SimpleForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:39)  
    #11 io.grpc.testing.integration.TestServiceImpl$5$1.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (TestServiceImpl.java:552)  
    #12 io.grpc.PartialForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (PartialForwardingServerCall.java:46)  
    #13 io.grpc.ForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:22)  
    #14 io.grpc.ForwardingServerCall$SimpleForwardingServerCall.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (ForwardingServerCall.java:39)  
    #15 io.grpc.testing.integration.TestServiceImpl$4$1.close(Lio/grpc/Status;Lio/grpc/Metadata;)V (TestServiceImpl.java:525)  
    #16 io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onError(Ljava/lang/Throwable;)V (ServerCalls.java:302)  
    #17 io.grpc.testing.integration.TestServiceImpl$2.onError(Ljava/lang/Throwable;)V (TestServiceImpl.java:212)  
    #18 io.grpc.stub.ServerCalls$2$1.onCancel()V (ServerCalls.java:233)  
    #19 io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.closed(Lio/grpc/Status;)V (ServerCallImpl.java:280)  
    #20 io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$3.runInContext()V (ServerImpl.java:613)  
    #21 io.grpc.internal.ContextRunnable.run()V (ContextRunnable.java:37)  
    #22 io.grpc.internal.SerializingExecutor.run()V (SerializingExecutor.java:102)  
    #23 java.util.concurrent.ThreadPoolExecutor.runWorker(Ljava/util/concurrent/ThreadPoolExecutor$Worker;)V (ThreadPoolExecutor.java:1142)  
    #24 java.util.concurrent.ThreadPoolExecutor$Worker.run()V (ThreadPoolExecutor.java:617)  
    #25 java.lang.Thread.run()V (Thread.java:745)  
    #26 (Generated Stub)  

  Previous write of size 8 at 0x7fd444897628 by thread T38 (mutexes: write M173247660336208224):
    #0 io.grpc.internal.MessageFramer.commitToSink(ZZ)V (MessageFramer.java:331)  
    #1 io.grpc.internal.MessageFramer.flush()V (MessageFramer.java:282)  
    #2 io.grpc.internal.AbstractStream.flush()V (AbstractStream.java:59)  
    #3 io.grpc.internal.ServerCallImpl.sendMessage(Ljava/lang/Object;)V (ServerCallImpl.java:134)  
    #4 io.grpc.ForwardingServerCall.sendMessage(Ljava/lang/Object;)V (ForwardingServerCall.java:32)  
    #5 io.grpc.ForwardingServerCall.sendMessage(Ljava/lang/Object;)V (ForwardingServerCall.java:32)  
    #6 io.grpc.ForwardingServerCall.sendMessage(Ljava/lang/Object;)V (ForwardingServerCall.java:32)  
    #7 io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onNext(Ljava/lang/Object;)V (ServerCalls.java:293)  
    #8 io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher.dispatchChunk()V (TestServiceImpl.java:338)  
    #9 io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher.access$000(Lio/grpc/testing/integration/TestServiceImpl$ResponseDispatcher;)V (TestServiceImpl.java:249)  
    #10 io.grpc.testing.integration.TestServiceImpl$ResponseDispatcher$1.run()V (TestServiceImpl.java:263)  
    #11 io.grpc.internal.LogExceptionRunnable.run()V (LogExceptionRunnable.java:41)  
    #12 java.util.concurrent.Executors$RunnableAdapter.call()Ljava/lang/Object; (Executors.java:511)  
    #13 java.util.concurrent.FutureTask.run()V (FutureTask.java:266)  
    #14 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Ljava/util/concurrent/ScheduledThreadPoolExecutor$ScheduledFutureTask;)V (ScheduledThreadPoolExecutor.java:180)  
    #15 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run()V (ScheduledThreadPoolExecutor.java:295)  
    #16 java.util.concurrent.ThreadPoolExecutor.runWorker(Ljava/util/concurrent/ThreadPoolExecutor$Worker;)V (ThreadPoolExecutor.java:1142)  
    #17 java.util.concurrent.ThreadPoolExecutor$Worker.run()V (ThreadPoolExecutor.java:617)  
    #18 java.lang.Thread.run()V (Thread.java:745)  
    #19 (Generated Stub)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3208
Make Kokoro show actual Gradle results
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@matt-kwong Would you please use our commit message style?  Something like:
all: make Kokoro show actual Gradle results
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3209
Add GAPIC client to grpc-java testing framework
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3210
all: update to netty 4.1.13
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3211
Implement client-side compression tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@makdharma  fyi
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3212
Canonicalize URL prefixes to https://grpc.io
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo I have created backport PRs for all branches, but not sure how far back is a good idea, so please take charge in updating the branches as the Java team deems appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3213
Canonicalize URL prefixes to https://grpc.io (backport to v1.0.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
abandoning backport on this branch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3214
Canonicalize URL prefixes to https://grpc.io (backport to 1.1.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Whoops, forgot to say this earlier: can you please format the commit message to match our style?  It should be like:
all: canonicalize URL prefixes to https://grpc.io
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3215
Canonicalize URL prefixes to https://grpc.io (backport to 1.2.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3216
Canonicalize URL prefixes to https://grpc.io (backport to 1.3.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3217
Canonicalize URL prefixes to https://grpc.io (backport to 1.4.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3218
Canonicalize URL prefixes to https://grpc.io (backport to 1.5.x)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3219
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins, test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3220
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins, test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3221
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins, test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3222
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins, test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3223
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3224
all: make Kokoro show actual Gradle results (backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could you also approve #3223 #3222 #3221 #3220 #3219? Only assigning one PR to avoid spamming notifcations
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3225
benchmarks: add initial context benchmarks
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83  ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3226
all: update to gradle 4.0.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3227
android-interop-testing: use google() repository
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
better add a comment why google() repo it is used.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3228
doc (minor): Uppercase Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3229
doc: update external link
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3230
backport v1.4.x: update javadoc link
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3231
backport v1.5.x: update javadoc link
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3232
core: refactor SubchannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3233
stub: Use nameed classes rather than anonymous in ServerCalls
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3234
netty: quieter errors in NettyServerTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo please take a look
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3235
stub: clean up client calls to avoid synthetic class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3236
stub: name more anonymous classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3237
all: update to proto gradle plugin 0.8.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3238
examples: don't use deprecated MethodDescriptor API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This silences a warning when building.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3239
testing-proto: add string message to testing proto
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please include a reason for the change in the commit message. The title and description should include what the change is, but it's equally important to include in the description why the change is being made (although this is generally not best in the commit title (the first line)).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3240
ClientStreamTracer instances are threadsafe, but mocks of it aren't
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In AbstractInteropTest,  instances of ClientStreamTracer are created using spy.  These instances are not thread safe and cause the race detector to complain about it.
ClientStreamTracer and the other stream tracers should probably be marked DoNotMock because the mocks will not be able to fulfill the API.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3241
core: Use Class.forName(String) in provider for Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at this now, but FYINettyChannelProviderTest#getCandidatesViaHardCoded and OkHttpChannelProviderTest#getCandidatesViaHardCoded need to have the class loader argument removed from their calls to getCandidatesViaHardCoded
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3242
benchmarks: don't block shutdown when using netty epoll
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3243
build.gradle: intellij fix for gradle 4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3244
ChannelExecutor is not threadsafe
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Found with TSAN:
WARNING: ThreadSanitizer: data race (pid=255771)
  Read of size 8 at 0x7fd6d9ff3608 by thread T41 (mutexes: write M223068742301678088):
    #0 io.netty.channel.DefaultChannelPipeline.estimatorHandle()Lio/netty/channel/MessageSizeEstimator$Handle; (DefaultChannelPipeline.java:100)  
    #1 io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.init(Lio/netty/channel/AbstractChannelHandlerContext$AbstractWriteTask;Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:1060)  
    #2 io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.newInstance(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/AbstractChannelHandlerContext$WriteAndFlushTask; (AbstractChannelHandlerContext.java:1126)  
    #3 io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.access$1600(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/AbstractChannelHandlerContext$WriteAndFlushTask; (AbstractChannelHandlerContext.java:1114)  
    #4 io.netty.channel.AbstractChannelHandlerContext.write(Ljava/lang/Object;ZLio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:821)  
    #5 io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:794)  
    #6 io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:831)  
    #7 io.netty.channel.DefaultChannelPipeline.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (DefaultChannelPipeline.java:1032)  
    #8 io.netty.channel.AbstractChannel.writeAndFlush(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (AbstractChannel.java:296)  
    #9 io.grpc.netty.NettyClientTransport.start(Lio/grpc/internal/ManagedClientTransport$Listener;)Ljava/lang/Runnable; (NettyClientTransport.java:227)  
    #10 io.grpc.internal.ForwardingConnectionClientTransport.start(Lio/grpc/internal/ManagedClientTransport$Listener;)Ljava/lang/Runnable; (ForwardingConnectionClientTransport.java:29)  
    #11 io.grpc.internal.InternalSubchannel.startNewTransport()V (InternalSubchannel.java:202)  
    #12 io.grpc.internal.InternalSubchannel.obtainActiveTransport()Lio/grpc/internal/ClientTransport; (InternalSubchannel.java:175)  
    #13 io.grpc.internal.ManagedChannelImpl$SubchannelImplImpl.obtainActiveTransport()Lio/grpc/internal/ClientTransport; (ManagedChannelImpl.java:813)  
    #14 io.grpc.internal.GrpcUtil.getTransportFromPickResult(Lio/grpc/LoadBalancer$PickResult;Z)Lio/grpc/internal/ClientTransport; (GrpcUtil.java:578)  
    #15 io.grpc.internal.DelayedClientTransport.reprocess(Lio/grpc/LoadBalancer$SubchannelPicker;)V (DelayedClientTransport.java:280)  
    #16 io.grpc.internal.ManagedChannelImpl$LbHelperImpl$5.run()V (ManagedChannelImpl.java:719)  
    #17 io.grpc.internal.ChannelExecutor.drain()V (ChannelExecutor.java:72)  
    #18 io.grpc.internal.ManagedChannelImpl$LbHelperImpl.runSerialized(Ljava/lang/Runnable;)V (ManagedChannelImpl.java:710)  
    #19 io.grpc.internal.ManagedChannelImpl$NameResolverListenerImpl.onAddresses(Ljava/util/List;Lio/grpc/Attributes;)V (ManagedChannelImpl.java:759)  
    #20 io.grpc.internal.DnsNameResolver$1.run()V (DnsNameResolver.java:176)  
    #21 java.util.concurrent.ThreadPoolExecutor.runWorker(Ljava/util/concurrent/ThreadPoolExecutor$Worker;)V (ThreadPoolExecutor.java:1142)  
    #22 java.util.concurrent.ThreadPoolExecutor$Worker.run()V (ThreadPoolExecutor.java:617)  
    #23 java.lang.Thread.run()V (Thread.java:745)  
    #24 (Generated Stub)  

  Previous write of size 8 at 0x7fd6d9ff3608 by thread T42:
    #0 io.netty.channel.DefaultChannelPipeline.estimatorHandle()Lio/netty/channel/MessageSizeEstimator$Handle; (DefaultChannelPipeline.java:101)  
    #1 io.netty.channel.AbstractChannel$AbstractUnsafe.write(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (AbstractChannel.java:800)  
    #2 io.netty.channel.DefaultChannelPipeline$HeadContext.write(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (DefaultChannelPipeline.java:1291)  
    #3 io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:738)  
    #4 io.netty.channel.AbstractChannelHandlerContext.invokeWrite(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:730)  
    #5 io.netty.channel.AbstractChannelHandlerContext.write(Ljava/lang/Object;ZLio/netty/channel/ChannelPromise;)V (AbstractChannelHandlerContext.java:816)  
    #6 io.netty.channel.AbstractChannelHandlerContext.write(Ljava/lang/Object;Lio/netty/channel/ChannelPromise;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:723)  
    #7 io.netty.channel.AbstractChannelHandlerContext.write(Ljava/lang/Object;)Lio/netty/channel/ChannelFuture; (AbstractChannelHandlerContext.java:704)  
    #8 io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.sendPreface(Lio/netty/channel/ChannelHandlerContext;)V (Http2ConnectionHandler.java:339)  
    #9 io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.channelActive(Lio/netty/channel/ChannelHandlerContext;)V (Http2ConnectionHandler.java:234)  
    #10 io.netty.handler.codec.http2.Http2ConnectionHandler.channelActive(Lio/netty/channel/ChannelHandlerContext;)V (Http2ConnectionHandler.java:383)  
    #11 io.grpc.netty.AbstractNettyHandler.channelActive(Lio/netty/channel/ChannelHandlerContext;)V (AbstractNettyHandler.java:74)  
    #12 io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive()V (AbstractChannelHandlerContext.java:213)  
    #13 io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(Lio/netty/channel/AbstractChannelHandlerContext;)V (AbstractChannelHandlerContext.java:199)  
    #14 io.netty.channel.AbstractChannelHandlerContext.fireChannelActive()Lio/netty/channel/ChannelHandlerContext; (AbstractChannelHandlerContext.java:192)  
    #15 io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(Lio/netty/channel/ChannelHandlerContext;)V (DefaultChannelPipeline.java:1322)  
    #16 io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive()V (AbstractChannelHandlerContext.java:213)  
    #17 io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(Lio/netty/channel/AbstractChannelHandlerContext;)V (AbstractChannelHandlerContext.java:199)  
    #18 io.netty.channel.DefaultChannelPipeline.fireChannelActive()Lio/netty/channel/ChannelPipeline; (DefaultChannelPipeline.java:902)  
    #19 io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(Lio/netty/channel/ChannelPromise;Z)V (AbstractNioChannel.java:311)  
    #20 io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect()V (AbstractNioChannel.java:341)  
    #21 io.netty.channel.nio.NioEventLoop.processSelectedKey(Ljava/nio/channels/SelectionKey;Lio/netty/channel/nio/AbstractNioChannel;)V (NioEventLoop.java:632)  
    #22 io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized()V (NioEventLoop.java:579)  
    #23 io.netty.channel.nio.NioEventLoop.processSelectedKeys()V (NioEventLoop.java:496)  
    #24 io.netty.channel.nio.NioEventLoop.run()V (NioEventLoop.java:458)  
    #25 io.netty.util.concurrent.SingleThreadEventExecutor$5.run()V (SingleThreadEventExecutor.java:858)  
    #26 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run()V (DefaultThreadFactory.java:138)  
    #27 java.lang.Thread.run()V (Thread.java:745)  
    #28 (Generated Stub)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3245
"gradlew installDist" gives error No tool chain is available to build for platform 'x86_64':
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm following https://grpc.io/docs/quickstart/android.html
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
When I run $ ./gradlew installDist on my Windows 10 x64, it throws exception
FAILURE: Build failed with an exception.


What went wrong:
Execution failed for task ':grpc-compiler:compileJava_pluginExecutableJava_pluginCpp'.


No tool chain is available to build for platform 'x86_64':
- Tool chain 'visualCpp' (Visual Studio): Could not locate a Visual Studio installation, using the Windows registry and system path.
- Tool chain 'gcc' (GNU GCC): Could not find C compiler 'gcc' in system path.
- Tool chain 'clang' (Clang): Could not find C compiler 'clang' in system path.


But I did install Visual Studio 2017 Preview.
How to fix the issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3246
Android ClientInterceptor not working to add metadata ?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0 on android .
compile 'io.grpc:grpc-okhttp:1.4.0'
compile 'io.grpc:grpc-protobuf:1.4.0'
compile 'io.grpc:grpc-stub:1.4.0'
What JVM are you using (java -version)?
java 8
What did you do?
If possible, provide a recipe for reproducing the error.
I am trying to add a custom header to my grpc call using metadata inside ClientInterceptor. I am unable to send as explained here ,
https://stackoverflow.com/questions/45125601/android-how-to-add-a-custom-header-in-grpc-client
What did you expect to see?
I am expecting server to recognize this parameter and send extra data items.
What did you see instead?
When I use okhttp3 alone and send this as header "Grpc-Match-Metadata", "match.items" with requestbody. i receive the extra data as I expect . But am unable to get any extra items  in grpc call .
===
I might be doing some thing wrong . I appreciate if some one could point to it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3247
Clarify docs/examples: ServerCall, interceptors, flow control
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No longer needed because we now have a detailed flow control example
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3248
Context: alternative data structure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now Context uses a linked list of mutations for implementing its mapping structure. This is serving us reasonably well as it has low mutation cost and is simple to implement. However, it may be using a noticeable amount of CPU time[1] and it is fairly easy to accidentally create very long chains when using async APIs (as discussed in #1926). The main thing we'd want from an alternative data structure is to scale in terms of number of elements instead of number of mutations.
For fun, I investigated binary trees, b-trees, b+trees, and hash trees as possible alternative structures. An order 3 b+tree and HAMT both look pretty reasonable in terms of simplicity (~200 lines) and allocation size per mutation. I think I like the HAMT most as I found it to have fewer/easier cases to consider.
There's no urgency to this, or very much evidence that it is necessary. But we've been discussing it some, so wanted a place to discuss and report some alternatives.

It's unclear whether this is Context's fault. There was a user that was always adding 4 keys, even though only 1 was changed. The user was cleaned up, and while a rough view of the data would seem to imply this improved the performance, there's a lot of guesswork involved. We really need more data of typical Context chain lengths in order to produce a useful benchmark and to help determine per-call costs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3249
1.5.0 Point Release
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
optional: update examples/WORKSPACE with v1.5.0 tag at 1.5.0 point release
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3250
examples: fix errorprone warning about charset
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3251
all: recommend latest os maven detector
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3252
all: fix minor lint warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3253
Logging all messages using ClientInterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
java version "1.8.0_91"
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
What did you do?
I'm trying to use interceptor to log all messages sent and received from a client.
The implementation of the ClientInterceptor looks like this
@Override
public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> methodDescriptor,
                                                           CallOptions callOptions, Channel channel) {
    return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(
            channel.newCall(methodDescriptor, callOptions.withoutWaitForReady())) {

        @Override
        public void sendMessage(ReqT message) {
            log.info("*** SENDING GRPC MESSAGE [{}]\n{}:\n{}", deviceId, methodDescriptor.getFullMethodName(),
                     message.toString());
            super.sendMessage(message);
        }

        @Override
        public void start(Listener<RespT> responseListener, Metadata headers) {

            ClientCall.Listener<RespT> listener = new ClientCall.Listener<RespT>() {
                @Override
                public void onMessage(RespT message) {
                    log.info("*** RECEIVED GRPC MESSAGE [{}]\n{}:\n{}", deviceId,
                             methodDescriptor.getFullMethodName(),
                             message.toString());
                    super.onMessage(message);
                }
            };
            super.start(listener, headers);
        }
    };
}
The first RPC i request after creating the channel is SayHello from the following service definition:
service DummyService {
    rpc SayHello (DummyMessageThatNoOneWouldReallyUse) returns (DummyMessageThatNoOneWouldReallyUse) {
    }
}

message DummyMessageThatNoOneWouldReallyUse {
}
What did you expect to see?
When executing the SayHello RPC, I expect to see two messages in the log, one with the request message sent and one with the response message received.
What did you see instead?
I only see the request message, it seems that the execution of the interceptor thread hangs and the response message is never logged/processed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3254
core: not to expose ClientCallImpl#cancelled()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3255
all: update animal sniffer and error prone
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seems to add some caching: https://github.com/xvik/gradle-animalsniffer-plugin/releases/tag/1.4.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3256
Passing CallOptions to ClientStreamTracer.newClientStreamTracer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Any thoughts on passing the CallOptions into ClientStreamTracer.newClientStreamTracer?  We have an interceptor chain with roughly 10 interceptors.  The first interceptor sets a MetricsContext and our internal implementation of ClientStreamTracer.Factory on the CallOptions.  Each subsequent interceptor may add tags to the MetricsContext.  MetricsContext is hierarchical so we can have sub contexts for things like retries and hedged requests.  We'd need access the MetricsContext from our ClientStreamTracer implementation.  The contract would look something like,
public abstract ClientStreamTracer newClientStreamTracer(CallOptions callOptions, Metadata headers);
Alternatively, we could track our MetricsContext as described above but only specify the ClientStreamTracer.Factory in the last interceptor.  I'm not sure this approach will work long term as it sounds like your guys are leaning towards setting the ClientStreamTracer.Factory on the channel as opposed to the CallOptions (which I like as it would be more consistent with how things are done on the server).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3257
Revert interop-testing: overrideAuthority breaks JWT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please (double-quotes strikes again!)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3258
Implement flush coalescing in OkHttp
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OkHttpClientTransport currently forces the connection to use TCP_NODELAY: https://github.com/grpc/grpc-java/blob/master/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java#L426
For my use case (and, I would argue, other Android "next billion users" use cases) prioritizing low resource usage over performance seems to make more sense, so I would like to see this option to be configurable. I agree that enabling TCP_NODELAY seems the better default in general: #256
In my case I have a good number of low-throughput streaming RPCs that will stay open until the connection is closed. Speed and latency are secondary, low resource usage and reliability are important. Most of the streaming RPCs are primarily intended to let the server stream any changes in system state. For my Android "next billion users" use case I expect the connection to break fairly frequently, at which point the client will re-establish the streaming RPCs, so that it can catch up with the server, and the server can resume streaming any changes in system state. Consequently the first thing that will happen upon reconnect is all the streaming RPCs piping their header information down the new connection. With TCP_NODELAY enabled I expect this to mean several packets PER STREAMING RPC. Without that flag I would hope to see no more than a few packets TOTAL. Because the overall throughput of actual state data is low for this system and connections could break frequently, I think this could have a notable effect on total mobile data used.
I am still in the design phase for the system and identifying the potential bottlenecks from the perspective of a new gRPC & HTTP2 user, so please excuse and correct any false assumptions. I realize I could probably use just one streaming RPC to pipe data down to the client, but that kind of defeats the purpose of a protobuf-based RPC design, as I have different types of data to send. Being able to squeeze the connection initialization data into a few packets would make the overhead more negligible.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3259
all: Bump Jetty ALPN agent version, for new JREs (1.0 backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3260
all: Bump Jetty ALPN agent version, for new JREs (1.1 backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3261
all: Bump Jetty ALPN agent version, for new JREs (1.2 backport)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3262
Context: add test for the scenario that Context's logger itself is using Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This test is brittle, as it assumes test functionality and order (not within the test class, but between test classes). You could use StaticTestingClassLoader though.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3263
benchmark: context benchmark
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3264
Client does not detect a truncated message at the end of stream
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As discovered during the course of #3145. The server does detect and fail in the case of truncated message frame ("Encountered end-of-stream mid-frame"), but client doesn't have such logic.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3265
core: Override SubchannelImpl.toString()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3266
Connections cannot be re-established after network loss/recovery 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
Ran a grpc-java client program with netty that uses application-level pings to a grpc-java server. Ran the client in a loop, it will ping, sleep, ping, sleep. If I disconnect the network, I get deadline exceeded (good), but if I reconnect the network, I continue to get deadline exceeded messages.
If possible, provide a recipe for reproducing the error.

Build http://github.com/stephenh/mirror
On one machine, run ./mirror server
On another machine, run ConnectionDetector.Impl.main (e.g. in an IDE)
Disrupt the network (for me, I log off the VPN), see deadline exceeded start happening
Reconnect the network (re-connect to VPN), deadline exceeded keeps happening

What did you expect to see?
For new connections work successfully after the network was restored.
FWIW, while debugging the issue, I paused the ClientCalls thread and poked around for awhile, e.g. ~5-10 minutes. I didn't really find anything, but when I hit "resume", I saw a broken pipe exception (which I don't usually see, usually it's just the deadline exceeded), and then the connection started working. E.g. I don't want to lead you astray, but it seems like until this pipe was broken, the connection was not fully getting restarted.
Understood this may not be a grpc-java issue, but some underlying netty or even inherent TCP issue that I just don't understand.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3267
UNAUTHORIZED if Auth Server is down?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using GoogleAuthLibraryCredentials to authenticate our gRPC calls and we sometimes have the case where the authentication fails, because the auth server is not reachable and then the call fails with UNAUTHENTICATED status code.
Some people on my team argue that it should fail with UNAVAILABLE, I personally think UNAUTHENTICATED makes sense, so that a user can distinquish between a call and auth having gone wrong. However, arguably [1] is not clear about this.
The discussion arose, because of retries. In Bazel, we want to retry certain status codes i.e. UNAUTHENTICATED if the server could not be reached, but not if it failed due to wrong credentials. Any thoughts?
cc: @ejona86 @zhangkun83
[1] https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3268
Channel creation best practice
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
gRPC version?
1.4.0
JVM
java version "1.8.0_102"
Case:
If possible, provide a recipe for reproducing the error.
What is the best practice with regards to a channel, when using multiple (10+) grpc stream services stubs.
The channel I am using has tls enabled and generally when making the initial connection takes a few seconds to complete the full handshake.
Question:
Should the ManagedChannel by created in a singleton and used via that on all the grpc stubs or should the channel builder be used for every stub in order to create a new channel.
I don't wish to go through the handshake every time, however I get random cases of unknown channel state where I don't get a error in the streamObserver, however nothing gets received on the server side either.
Issue:
This is specifically with regards to network connectivity changing causing the connections to drop and in my case not reconnect and no implemented option to get the channel state yet.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3269
Why does not implement Comparable for ByteString?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am looking for a proper way to make ByteString being comparable. I got one in my mind but it is pretty ugly. It would be super nice if ByteString implements Comparable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3270
core,netty,okhttp: remove 2-arg ClientTransport.newStream()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jenkins, retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3271
Possible to use a web browser client ? (ie. gRPC-Web)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.4.0
What JVM are you using?
1.8.0_66
What did you do?
Tried to use a web client which follows the gRPC-Web api. Specifically, i use the grpc-web client part generated from Typescript here.
What did you expect to see?
Would like to see grpc-java talk successfully with a pure web/browser client.
Is it currently possible ?
Any example available ?
What did you see instead?
Error in the form of a Http2Exception$StreamException  when calling a grpc endpoint made with grpc-java.
Logs excerpt :
[sandbox] [grpc-default-worker-ELG-4-3] WARN  [2017-07-23 19:41:22.643] i.g.n.NettyServerHandler | Stream Error
io.netty.handler.codec.http2.Http2Exception$StreamException: Content-Type is missing from the request
    at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:129)
    at io.grpc.netty.NettyServerHandler.verifyContentType(NettyServerHandler.java:597)
    at io.grpc.netty.NettyServerHandler.onHeadersRead(NettyServerHandler.java:353)
    at io.grpc.netty.NettyServerHandler.access$500(NettyServerHandler.java:105)
( ..etc..)

Thanks a lot for any help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3272
Request with deadline cause to many GC overhead
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.4.0 Release
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What the problem?

When uses deadline on each client call, gRPC creates TimeouOutExcepton before real deadline
occurs https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/Context.java#L703
it's very expensive operation that also allocate not necessary junk for GC. In screen above you can see
That during 60 second gRPC allocate 786mb memory on fillStackTrace.
What do you think about move creation exception to place when it's really necessary? Yes in this case stacktrace will be different in case when deadline already expired and when deadline occurs after some time, but is it really make sense?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3273
Use service.load(class) instead of service.load(class, classloader) for OSGi compat
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
1.8

What did you do?
I'm trying to wrap GRPC jar to OSGI bundle. There is a problem of making java.util.service works in OSGI environment. The reason is GRPC use service.load api with classloader parameter, such as:
@VisibleForTesting
public static Iterable<ManagedChannelProvider> getCandidatesViaServiceLoader(
  ClassLoader classLoader) {
return _ServiceLoader.load(ManagedChannelProvider.class,_ classLoader);
}

Iâ€˜m using Apache Aries spi-fly to transferring  java.util.service to OSGI service. But unfortunately this plugin does not support the api service.load(class, classloader) now, and there is no other way to figure this issue out. Actually assigning  classloader is conflicts with OSGI in my opinion.
What did you expect to see?
It seems no necessary to assign classloader parameter when use service.load(), could we just use service.load(class)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3274
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3275
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3276
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3277
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3278
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3279
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3280
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3281
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3282
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3283
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3284
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3285
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3286
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3287
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3288
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3289
[]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3290
Prevent Access to "grpc-" headers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Headers that begin with "grpc-" are meant for use by gRPC and not by other clients.  Using this as a namespace allows the gRPC team to add new headers without fear of colliding with another users headers.
To this end, such headers should be locked down from reading and writing in the library.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3291
grpclb: force GRPCLB policy when NameResolver returns at least one balancer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3292
context: change storage API to return a restoreable context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3293
Go to "permanent error mode" if ChannelExecutor throws exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As mentioned in discussion in #3288, it's questionable only catching instead of throwing exceptions in ChannelExecutor. Should we throw regardless or should we only log in production and throw in test evn?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3294
core: enable Census tags propagation by default.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I assume that since Census impl isn't a dependency, "by default" the tags won't be propagated. It's only "by default" when you are already using Census.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3295
Don't schedule multiple pings.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3296
Sending Grpc Request in Appengine Java 8 Standard Environment Could Fail
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
Google-cloud-java has received issues (googleapis/google-cloud-java#2150, googleapis/google-cloud-java#2275) regarding sending grpc reqeust in appengine (specifically, using google-cloud-java Pub/Sub client library).  When initiating grpc connection in appengine, grpc picks up currentRequestThreadFactory for its thread factory (https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/GrpcUtil.java#L482).  This could cause appengine runtime to throw NPE (see below for a typical stack trace). A hack to force defaultThreadFactory to be used by Grpc seems to resolve this issue.
Sending Grpc request within Appengine request thread seems to be a valid scenario. Grpc should support it.
java.lang.NullPointerException
	at com.google.apphosting.runtime.ApiProxyImpl$CurrentRequestThreadFactory.newThread(ApiProxyImpl.java:1267)
	at com.google.common.util.concurrent.ThreadFactoryBuilder$1.newThread(ThreadFactoryBuilder.java:162)
	at java.util.concurrent.ThreadPoolExecutor$Worker.<init>(ThreadPoolExecutor.java:612)
	at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:925)
	at java.util.concurrent.ThreadPoolExecutor.ensurePrestart(ThreadPoolExecutor.java:1587)
	at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:336)
	at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:555)
	at io.grpc.internal.ManagedChannelImpl.rescheduleIdleTimer(ManagedChannelImpl.java:334)
	at io.grpc.internal.ManagedChannelImpl.exitIdleMode(ManagedChannelImpl.java:299)
	at io.grpc.internal.ManagedChannelImpl$4$1.run(ManagedChannelImpl.java:357)
	at io.grpc.internal.ChannelExecutor.drain(ChannelExecutor.java:87)
	at io.grpc.internal.ManagedChannelImpl$4.get(ManagedChannelImpl.java:359)
	at io.grpc.internal.ClientCallImpl.start(ClientCallImpl.java:218)
	at io.grpc.ForwardingClientCall.start(ForwardingClientCall.java:47)
	at com.google.api.gax.grpc.GrpcHeaderInterceptor$1.start(GrpcHeaderInterceptor.java:62)
	at io.grpc.stub.ClientCalls.startCall(ClientCalls.java:276)
	at io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:252)
	at io.grpc.stub.ClientCalls.futureUnaryCall(ClientCalls.java:186)
	at com.google.pubsub.v1.PublisherGrpc$PublisherFutureStub.publish(PublisherGrpc.java:538)
	at com.google.cloud.pubsub.v1.Publisher.publishOutstandingBatch(Publisher.java:330)
	at com.google.cloud.pubsub.v1.Publisher.publishAllOutstanding(Publisher.java:304)
	at com.google.cloud.pubsub.v1.Publisher.access$500(Publisher.java:79)
	at com.google.cloud.pubsub.v1.Publisher$5.run(Publisher.java:283)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:295)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

/cc @jbaldassari @cmaan @jabubake @tcoffee-google @garrettjonesgoogle
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3297
Channel shutdown without calling shutdown()?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are sometimes seeing StatusRuntimeException with Status.UNAVAILABLE and the message Channel requested transport to shut down.  However, our codebase does not contain a call to ManagedChannel.shutdown(Now)(). We never close the channel.
Does gRPC ever invoke shutdown() internally i.e. in error cases - I always thought it doesn't, but my knowledge of internals is out of date.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3298
Correct way to interrupt client call from ServerInterceptor?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
1.8.0_111
What did you do?
I've made an interceptor that checks call metadata, gets custom token from it and if it's correct - continues the call, otherwise - interrupts it with Status.PERMISSION_DENIED. The question is - what is correct way to interrupt call chain in that case?
my interceptor looks like:
private class AuthInterceptor implements ServerInterceptor {
    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            ServerCall<ReqT, RespT> call,
            Metadata headers,
            ServerCallHandler<ReqT, RespT> next
    ) {
        byte[] authBytes = headers.get(Metadata.Key.of("auth-bin", Metadata.BINARY_BYTE_MARSHALLER));
        if (isCorrect(authBytes)) {
            return next.startCall(call, headers);
        } else {
            call.close(Status.PERMISSION_DENIED, headers);
            return next.startCall(call, headers); // most questionable part for me
        }
    }

    /* ... */
}
as I understand it should be fine, and it seems so. But when I launched ab -c 50 -n 100000 through my proxy where every request contains wrong token, I can see 1 or 2 log entries from my service that says, that it enters onNext() method on server side. My grpc service is defined as:
service ProductsService {
    rpc createProducts(stream Product) returns (ProductCreationSummary); 
}
Server constructing code:
ServerBuilder.forPort(port).addService(new ProductsService()).intercept(new AuthInterceptor()).build();
if it's might be a bug, and not just some simple mistake, I'll provide more reproducible codes etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3299
grpc-protobuf-lite 1.4.0 not resolve some classes on android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
java version "1.8.0_144"
I generated .proto file with libprotoc 3.3.2 and followed java README.md, where I found notation about using grpc-protobuf-lite or grpc-protobuf-nano instead of grpc-protobuf for android client.
But in fact it won't compile, there are no such classes as ExtensionRegistry, GeneratedMessageV3, Descriptors etc.
Grpc-protobuf dependency on the other hand works well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3300
core: implement Channel State API for PickFirst
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3301
Document how to use Conscrypt on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86  can you update the size of the Conscrypt it will add to the app in read me ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3302
compiler: Fix some warnings when building with Bazel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3303
all: Remove unused variables and squelch incorrect ErrorProne warning
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3304
Network retries or time outs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0 on Android
What JVM are you using (java -version)?
1.8
What did you do?
I am trying to add a retry policy. It seems grpc after network failure doesn't re-connect immidiately even when network is back.
If possible, provide a recipe for reproducing the error.

disable network n keep on aeroplane mode
try to run the app
enable back network

You will see grpc doesn't connect back even when you retry so many times. it takes for 25-30 secs to retry again.
What did you expect to see?
grpc should connect immediately on network availability. I like to know the right amount of time for waiting .
What did you see instead?
it never connects back
Is there a way to configure the retries ? or to get to know the retry connection time ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3305
testing,core: don't use mocks for stream tracers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3306
interop-testing: Only enable tracing when metrics are expected
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks like it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3307
netty: Update netty to 4.1.14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You may want to update repositories.bzl as well?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3308
after network had closed over 30 seconds , client receive server stream problem  
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
server code
 @Override
        public void markStream(req request, StreamObserver<resp> responseObserver) {
            int i = request.getCount();
            while (true) {
                try {
                    Thread.currentThread().sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                responseObserver.onNext(resp.newBuilder().setCount(i++).build());
            }
        }

client code
 public static void main(String[] args) throws InterruptedException, ExecutionException {
        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 8080)
                .usePlaintext(true)
                .build();
        BenchServiceGrpc.BenchServiceBlockingStub stub = BenchServiceGrpc.newBlockingStub(channel);
        req req = demo.req.newBuilder().setCount(1).build();
        Iterator<resp> iterable = stub.markStream(req);
        while (iterable.hasNext()) {
            resp resp = iterable.next();
            System.out.println(resp.getCount());
        }
    }

client-side closed network  after 30 second
server throws exception
java.io.IOException: Operation timed out
	at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	at java.lang.Thread.run(Thread.java:745)

but  client-side didn't get any further exception messages  before network recover or after
and didn't receive server-side any stream messages
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3309
Custom gRPC marshaller for one of the service method
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
Latest snapshot 02cb718
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What the problem?
I have a grpc service with 9 methods. One of the method very hot because contails many many repeatable objects inside protobuf, instead of deserialize it to proto on server side, I want put request in bynary form to off-head structure, and then process it as batch sequential read from off-head structure.
For resolve problem describe above I want to override unmarshaller only for one of 9 methods, but generated code not allow do it easy and require copy-past whole generated class(ServiceImplBase implements io.grpc.BindableService) as a result adding a new method to my grpc service will bring pain.
To allow easier override marshaller maybe need change signature for generated method
    @java.lang.Override public final io.grpc.ServerServiceDefinition bindService() {
      return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3310
NettyFlowControlTest is flaky
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://grpc-testing.appspot.com/job/gRPC-Java-PR-Windows/3956/console
io.grpc.testing.integration.NettyFlowControlTest > largeBdp FAILED
    java.lang.AssertionError: Window was 655140 expecting 314570
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.assertTrue(Assert.java:41)
        at io.grpc.testing.integration.NettyFlowControlTest.doTest(NettyFlowControlTest.java:154)
        at io.grpc.testing.integration.NettyFlowControlTest.largeBdp(NettyFlowControlTest.java:106)

289 tests completed, 1 failed
:grpc-interop-testing:test FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3311
core: implement Channel State API for RoundRobin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3312
core/stats: report message count metrics to Census.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3313
interop-testing: fix NPE on empty args to test service client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3314
netty: check for stream before freeing flow control bytes on client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3315
core,netty,okhttp: add grpc-payload-bin in GET requests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3316
Finish support for GET methods in OkHttp transport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3317
benchmark: client side workloads
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3318
InputStream from MethodDescriptor.Marshaller does not close
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0 Release
What JVM are you using (java -version)?
java version "1.8.0"
Java(TM) SE Runtime Environment (build 1.8.0-b132)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)
What the problem?
I have a gRPC method with custom marshaller, that deserialize protobuf request from off-heap ByteBuf.
private static final MethodDescriptor<ByteBuf, ShardCommandResponse> BINARY_METHOD_BULK_SHARD_COMMAND = 
            MethodDescriptor.<ByteBuf, ShardCommandResponse>newBuilder()
                    .setType(MethodDescriptor.MethodType.UNARY)
                    .setFullMethodName(StockpileServiceGrpc.METHOD_BULK_SHARD_COMMAND.getFullMethodName())
                    .setRequestMarshaller(new ByteBufMarshaller())
                    .setResponseMarshaller(ProtoUtils.marshaller(ShardCommandResponse.getDefaultInstance()))
                    .build();
Marshaller looks like
import java.io.InputStream;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.WillNotClose;

import io.grpc.MethodDescriptor;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufInputStream;

@ParametersAreNonnullByDefault
public class ByteBufMarshaller implements MethodDescriptor.Marshaller<ByteBuf> {

    @Override
    public InputStream stream(@WillNotClose ByteBuf value) {
        ByteBuf buffer = value.retain();
        // todo wrap to {@link io.grpc.KnownLength} for improve transport
        InputStream delegate = new ByteBufInputStream(buffer, true);
        return delegate;
    }

    @Override
    @WillNotClose
    public ByteBuf parse(InputStream stream) { 
        throw new UnsupportedOperationException("Not implemented yet!");
    }
}
Use netty ByteBuf as request required release resources. And I expected that gRPC close InputStream after send request, but it's doesn't happens. As a result of memory leak my service
that use gRPC client failed with OOM.
[Time-limited test] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 4
#4:
	io.netty.buffer.AdvancedLeakAwareByteBuf.getBytes(AdvancedLeakAwareByteBuf.java:246)
	io.netty.buffer.CompositeByteBuf.getBytes(CompositeByteBuf.java:861)
	io.netty.buffer.CompositeByteBuf.getBytes(CompositeByteBuf.java:44)
	io.netty.buffer.ReadOnlyByteBuf.getBytes(ReadOnlyByteBuf.java:260)
	io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:851)
	io.netty.buffer.ByteBufInputStream.read(ByteBufInputStream.java:179)
	java.io.InputStream.read(InputStream.java:101)
	com.google.common.io.ByteStreams.copy(ByteStreams.java:110)
	io.grpc.internal.MessageFramer.writeToOutputStream(MessageFramer.java:254)
	io.grpc.internal.MessageFramer.writeUncompressed(MessageFramer.java:155)
	io.grpc.internal.MessageFramer.writePayload(MessageFramer.java:127)
	io.grpc.internal.AbstractStream.writeMessage(AbstractStream.java:52)
	io.grpc.internal.ClientCallImpl.sendMessage(ClientCallImpl.java:386)
	io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:239)
	io.grpc.stub.ClientCalls.asyncUnaryRequestCall(ClientCalls.java:222)
	io.grpc.stub.ClientCalls.asyncUnaryCall(ClientCalls.java:62)

I also recheck it via implement empty InputStream that log close method. And it method was not execute.
I think for resolve this issue need resolve this todo https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ClientCallImpl.java#L387
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3319
Creating a channel with a tls address cause NameResolver issue on Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_144"
I try to establish connection to tls address (https://srv-1.app.somehost.im or this one https://geo.app.im:9000) with
OkHttpChannelBuilder.forTarget(address).usePlaintext(true)
but NameResolver cannot recognize such address. I tried the same with localhost, where NameResolver is not used and it works good. Proguard is off.
 Caused by: java.lang.IllegalArgumentException: cannot find a NameResolver for https://geo.app.im:9000
                                                                   at io.grpc.internal.ManagedChannelImpl.getNameResolver(ManagedChannelImpl.java:449)
                                                                   at io.grpc.internal.ManagedChannelImpl.<init>(ManagedChannelImpl.java:378)
                                                                   at io.grpc.internal.AbstractManagedChannelImplBuilder.build(AbstractManagedChannelImplBuilder.java:331)
                                                                   at im.app.location.grpc.ApiClient.<init>(ApiClient.kt:35)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3320
core: Providers should consider Robolectric as Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3321
core: Refactor Java code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ok to test
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3322
core: Java Refactor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3323
Infinite cycle during parse client request
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0 Release
What JVM are you using (java -version)?
java version "1.8.0"
Java(TM) SE Runtime Environment (build 1.8.0-b132)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)
What the problem?
After minor change my proto request all of my request start failed with deadline.
Thread-dumps from server side show that root cause of this deadlines in parsing code
"stockpile-server-grpc-1-2" #14 prio=5 os_prio=0 tid=0x00007f455c170800 nid=0x90b runnable [0x00007f4589dbd000]
   java.lang.Thread.State: RUNNABLE
	at io.grpc.protobuf.lite.ProtoLiteUtils$2.parse(ProtoLiteUtils.java:133)
	at io.grpc.protobuf.lite.ProtoLiteUtils$2.parse(ProtoLiteUtils.java:79)
	at io.grpc.MethodDescriptor.parseRequest(MethodDescriptor.java:280)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messageRead(ServerCallImpl.java:246)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1.runInContext(ServerImpl.java:571)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:102)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	at java.lang.Thread.run(Thread.java:748)

This cycle never completed, because try read zero bytes from InputStream
https://github.com/grpc/grpc-java/blob/master/protobuf-lite/src/main/java/io/grpc/protobuf/lite/ProtoLiteUtils.java#L133
              int chunkSize;
              int position = 0;
              while ((chunkSize = stream.read(buf, position, size - position)) != -1) {
                position += chunkSize;
              }
              if (size != position) {
                throw new RuntimeException("size inaccurate: " + size + " != " + position);
InputSteam contract say that read method will always return zero if reads zero bytes.

If len is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value -1 is returned; otherwise, at least one byte is read and stored into b.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3324
ProtoLiteUtils fix infinity loop
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3325
okhttp,interop-testing: use forked OkHttp classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3326
NettyServerHandlerTest keepalive tests are flaky since netty 4.1.14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://travis-ci.org/grpc/grpc-java/jobs/262360341
io.grpc.netty.NettyServerHandlerTest > maxConnectionAgeGrace_channelClosedAfterGracePeriod FAILED
    java.nio.channels.ClosedChannelException
        at io.netty.channel.embedded.EmbeddedChannel.checkOpen(EmbeddedChannel.java:644)
        at io.netty.channel.embedded.EmbeddedChannel.ensureOpen(EmbeddedChannel.java:656)
        at io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:310)
        at io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
        at io.grpc.netty.NettyServerHandlerTest.createStream(NettyServerHandlerTest.java:735)
        at io.grpc.netty.NettyServerHandlerTest.maxConnectionAgeGrace_channelClosedAfterGracePeriod(NettyServerHandlerTest.java:709)
260 tests completed, 1 failed, 3 skipped
:grpc-netty:test FAILED
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3327
grpclb: implement Channel State API for GRPCLB
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks a lot for reviewing all the Channel State API PRs @zhangkun83
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3328
Mismatch in naming with bazel maven jars
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to use grpc-java in an existing project which uses bazel, java, and a bunch of jars from maven. I added this to my WORKSPACE:
load("@grpc_java//:repositories.bzl", "grpc_java_repositories")

grpc_java_repositories(
  omit_com_google_guava=True,
)

The problem is that I use the migration-tooling project to add maven jars, and its naming for external jars does not match yours. For example, you call it @com_google_guava[1] but that project uses @com_google_guava_guava[2]. So if I try to use the omits, I get:
no such package '@com_google_guava//jar': The repository could not be resolved

And if I remove the omits, my project references two different versions of guava and I get runtime errors (since this project uses guava 19 and I want 21).
Is it possible to switch the naming of external maven jars to match bazel's tooling?
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
% java -version
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)

[1] https://github.com/grpc/grpc-java/blob/master/repositories.bzl#L113
[2]
% bazel run //generate_workspace -- --output_dir /tmp --artifact=com.google.guava:guava:21.0
...
Wrote /tmp/generate_workspace.bzl

% cat /tmp/generate_workspace.bzl 
# The following dependencies were calculated from:
#
# generate_workspace --output_dir /tmp --artifact=com.google.guava:guava:21.0


def generated_maven_jars():
  native.maven_jar(
      name = "com_google_guava_guava",
      artifact = "com.google.guava:guava:21.0",
  )




def generated_java_libraries():
  native.java_library(
      name = "com_google_guava_guava",
      visibility = ["//visibility:public"],
      exports = ["@com_google_guava_guava//jar"],
  )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3329
grpclb: update load_balancer.proto to the latest version.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3330
okhttp: Make Headers package-private
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3331
all: create dedicated sourceSets for generated code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3332
<RequestT,ResponseT>create(...) in MethodDescriptor has been deprecated
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
1.8.0_102
What did you do?
gradle clean && gradle build
What did you expect to see?
No deprecation warnings.
What did you see instead?
:compileJavaNote: C:\Users\...\build\generated\source\proto\main\grpc\...\proto\ServerGrpc.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.

and/or:
:extractIncludeProto
:extractProto UP-TO-DATE
:generateProto UP-TO-DATE
:compileJavaC:\Users\...\build\generated\source\proto\main\grpc\...\proto\ServerGrpc.java:33: warning: [deprecation] <RequestT,Respon
seT>create(MethodType,String,Marshaller<RequestT>,Marshaller<ResponseT>) in MethodDescriptor has been deprecated
      io.grpc.MethodDescriptor.create(
                              ^
  where RequestT,ResponseT are type-variables:
    RequestT extends Object declared in method <RequestT,ResponseT>create(MethodType,String,Marshaller<RequestT>,Marshaller<ResponseT>)
    ResponseT extends Object declared in method <RequestT,ResponseT>create(MethodType,String,Marshaller<RequestT>,Marshaller<ResponseT>)

Relevant Versions
classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.2'
compile 'io.grpc:grpc-netty:1.5.0'
compile 'io.grpc:grpc-protobuf:1.5.0'
compile 'io.grpc:grpc-stub:1.5.0'
compile 'io.grpc:grpc-core:1.5.0'
compile 'io.grpc:grpc-context:1.5.0'
compile 'io.grpc:grpc-protobuf-lite:1.5.0'
compile 'io.grpc:protoc-gen-grpc-java:1.5.0'
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3333
interop-testing: larger timeout for HTTP/2 client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3334
Merge remote-tracking branch 'grpc/master'
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3335
core,grpclb: deprecate LoadBalancer.Helper.updatePicker()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3336
Failed to load any of the given libraries: [netty-tcnative-linux-x86_64, netty-tcnative-linux-x86_64-fedora, netty-tcnative]
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
I've tried to use grpc-java library to connect sever side with SSL successfully in one lab, but when I change another lab to test that it was failure. I don't know whether the lab need to be set some environment variables or installed some rpms.
What version of gRPC are you using?
<grpc.version>1.2.0</grpc.version>
What JVM are you using (java -version)?
[root@bryan-appos-1709-1 ~]# java -version
openjdk version "1.8.0_111"
OpenJDK Runtime Environment (build 1.8.0_111-b15)
OpenJDK 64-Bit Server VM (build 25.111-b15, mixed mode)

What did you do?
If possible, provide a recipe for reproducing the error.
Try to connection with SSL.
Here is my netty pom.xml
       ...... 
       <dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-tcnative-boringssl-static</artifactId>
            <version>1.1.33.Fork26</version>
        </dependency>
        ......

What did you expect to see?
Connection with SSL works fine.
What did you see instead?
Exception in thread "main" java.lang.UnsatisfiedLinkError: failed to load the required native library
         at io.netty.handler.ssl.OpenSsl.ensureAvailability(OpenSsl.java:324)
         at serviceconfiguration.Test.main(Test.java:44)
Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty-tcnative-linux-x86_64, netty-tcnative-linux-x86_64-fedora, netty-tcnative]
         at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:177)
         at io.netty.handler.ssl.OpenSsl.loadTcNative(OpenSsl.java:412)
         at io.netty.handler.ssl.OpenSsl.<clinit>(OpenSsl.java:90)
         at serviceconfiguration.Test.main(Test.java:40)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3337
springboot startup with java.lang.ClassNotFoundException: com.google.instrumentation.trace.TraceComponentImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0 1.4.0 1.5.0
What JVM are you using (java -version)?
jdk6 jdk7 jdk8
What did you do?
If possible, provide a recipe for reproducing the error.
startup springboot with log debug level
What did you expect to see?
not output debug exception.
What did you see instead?
2017-08-11 10:18:54.111 DEBUG 9000 --- [           main] com.google.instrumentation.trace.Tracer  : Using default implementation for TraceComponent.

java.lang.ClassNotFoundException: com.google.instrumentation.trace.TraceComponentImpl
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_121]
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_121]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_121]
	at java.lang.Class.forName0(Native Method) ~[na:1.8.0_121]
	at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_121]
	at com.google.instrumentation.trace.Tracing.loadTraceComponent(Tracing.java:51) [instrumentation-api-0.4.3.jar:0.4.3]
	at com.google.instrumentation.trace.Tracing.<clinit>(Tracing.java:25) [instrumentation-api-0.4.3.jar:0.4.3]
	at io.grpc.internal.AbstractServerImplBuilder.getTracerFactories(AbstractServerImplBuilder.java:209) [grpc-core-1.5.0.jar:1.5.0]
	at io.grpc.internal.AbstractServerImplBuilder.build(AbstractServerImplBuilder.java:189) [grpc-core-1.5.0.jar:1.5.0]
	at cn.enncloud.ceres.spring.ServiceBean.createServer(ServiceBean.java:185) [ceres-1.0.3-SNAPSHOT.jar:1.0.3-SNAPSHOT]
	at cn.enncloud.ceres.spring.ServiceBean.onApplicationEvent(ServiceBean.java:98) [ceres-1.0.3-SNAPSHOT.jar:1.0.3-SNAPSHOT]
	at cn.enncloud.ceres.spring.ServiceBean.onApplicationEvent(ServiceBean.java:58) [ceres-1.0.3-SNAPSHOT.jar:1.0.3-SNAPSHOT]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:167) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:383) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:337) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:545) [spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) [spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) [spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) [spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) [spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) [spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]
	at com.demo.boot.CeresBootServerApplication.main(CeresBootServerApplication.java:10) [classes/:na]

grpc dependency:
<dependency>
    <groupId>com.google.instrumentation</groupId>
    <artifactId>instrumentation-api</artifactId>
    <version>0.4.3</version>
</dependency>

not exist TraceComponentImpl.java
now new alternatives:
census-instrumentation/opencensus-java
impl/src/main/java/io/opencensus/trace/TraceComponentImpl.java
but not release
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3338
all: Fix mismatch in naming Bazel Maven jars
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3339
netty: fix keepalive test flakiness
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3340
netty: not to ignore tests for window overriding
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
test this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3341
core: use static imports for repeated state enums
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3342
all: fix typo of overridden
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3343
grpclb: use two-level drop behavior
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@markdroth please review the behavior. @dapengzhang0 will take care of the Java part.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3344
interop-testing: use Activity.RESULT_OK instead of 0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3345
Disable hostname verification for NettyChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.3.0
What JVM are you using (java -version)?
java version "1.8.0_73"
Java(TM) SE Runtime Environment (build 1.8.0_73-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.73-b02, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
Using certificated with
What did you expect to see?
Need some mechanism to disable hostname verification during SSL handshake.
What did you see instead?
We are using certificates having generic CommonName which doesn't reflect the hostname. And hence the hostname verification fails.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3346
android-interop-testing: remove gms version metadata, add minimum sdk
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3347
NullPointerException: trailers
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
1.8.0
What did you do?
Running my grpc services on DC/OS... it works just fine but on the error log I sometimes see this NullPointerException.
What did you see instead?
Aug 14, 2017 8:04:46 PM io.grpc.internal.SerializingExecutor run
SEVERE: Exception while executing runnable io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1@567724e8
java.lang.NullPointerException: trailers
  at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:228)
  at io.grpc.internal.AbstractServerStream.close(AbstractServerStream.java:125)
  at io.grpc.internal.ServerCallImpl.close(ServerCallImpl.java:173)
  at ascoli.api.server.grcp.AuthInterceptor.interceptCall(AuthInterceptor.scala:29)
  at io.grpc.ServerInterceptors$InterceptCallHandler.startCall(ServerInterceptors.java:229)
  at io.grpc.internal.ServerImpl$ServerTransportListenerImpl.startCall(ServerImpl.java:485)
  at io.grpc.internal.ServerImpl$ServerTransportListenerImpl.access$1500(ServerImpl.java:346)
  at io.grpc.internal.ServerImpl$ServerTransportListenerImpl$1.runInContext(ServerImpl.java:429)
  at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
  at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:102)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
  at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3348
Unable to Publish Message to Pub/Sub due to error No functional channel service provider found
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
1.7
What did you do?
If possible, provide a recipe for reproducing the error.
No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact
What did you expect to see?
I am trying to publish a message from java to Google Pub/Sub
What did you see instead?
Ending up with error.
Maven Dependency tree
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building Miracle GCP Pub/Sub Plugin 1.0
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.3:tree (default-cli) @ gcppubsub-plugin2 ---
[INFO] gcppubsub-plugin2:gcppubsub-plugin2:hpi:1.0
[INFO] +- com.google.cloud:google-cloud-pubsub:jar:0.20.1-beta:compile
[INFO] |  +- io.netty:netty-tcnative-boringssl-static:jar:2.0.3.Final:compile
[INFO] |  +- com.google.cloud:google-cloud-core:jar:1.2.1:compile
[INFO] |  |  +- joda-time:joda-time:jar:2.9.2:compile
[INFO] |  |  +- org.json:json:jar:20160810:compile
[INFO] |  |  - com.google.api.grpc:proto-google-iam-v1:jar:0.1.12:compile
[INFO] |  +- com.google.cloud:google-cloud-core-grpc:jar:1.2.1:compile
[INFO] |  |  +- io.grpc:grpc-context:jar:1.4.0:compile
[INFO] |  |  - com.google.api:gax-grpc:jar:0.21.1:compile
[INFO] |  +- com.google.api.grpc:proto-google-cloud-pubsub-v1:jar:0.1.12:compile
[INFO] |  +- com.google.api.grpc:grpc-google-cloud-pubsub-v1:jar:0.1.12:compile
[INFO] |  +- io.grpc:grpc-netty:jar:1.4.0:compile
[INFO] |  |  +- io.netty:netty-codec-http2:jar:4.1.11.Final:compile
[INFO] |  |  |  +- io.netty:netty-codec-http:jar:4.1.11.Final:compile
[INFO] |  |  |  |  - io.netty:netty-codec:jar:4.1.11.Final:compile
[INFO] |  |  |  - io.netty:netty-handler:jar:4.1.11.Final:compile
[INFO] |  |  |     - io.netty:netty-buffer:jar:4.1.11.Final:compile
[INFO] |  |  |        - io.netty:netty-common:jar:4.1.11.Final:compile
[INFO] |  |  - io.netty:netty-handler-proxy:jar:4.1.11.Final:compile
[INFO] |  |     +- io.netty:netty-transport:jar:4.1.11.Final:compile
[INFO] |  |     |  - io.netty:netty-resolver:jar:4.1.11.Final:compile
[INFO] |  |     - io.netty:netty-codec-socks:jar:4.1.11.Final:compile
[INFO] |  +- io.grpc:grpc-stub:jar:1.4.0:compile
[INFO] |  - io.grpc:grpc-auth:jar:1.4.0:compile
[INFO] +- com.google.api:gax:jar:1.4.0:compile
[INFO] |  +- com.google.guava:guava:jar:19.0:compile
[INFO] |  +- com.google.auto.value:auto-value:jar:1.2:compile
[INFO] |  +- com.google.auth:google-auth-library-oauth2-http:jar:0.7.0:compile
[INFO] |  |  +- com.google.http-client:google-http-client:jar:1.19.0:compile
[INFO] |  |  |  - org.apache.httpcomponents:httpclient:jar:4.2.5:compile
[INFO] |  |  |     +- org.apache.httpcomponents:httpcore:jar:4.2.4:compile
[INFO] |  |  |     +- commons-logging:commons-logging:jar:1.1.1:compile
[INFO] |  |  |     - commons-codec:commons-codec:jar:1.4:compile
[INFO] |  |  - com.google.http-client:google-http-client-jackson2:jar:1.19.0:compile
[INFO] |  |     - com.fasterxml.jackson.core:jackson-core:jar:2.1.3:compile
[INFO] |  +- com.google.api:api-common:jar:1.1.0:compile
[INFO] |  +- org.threeten:threetenbp:jar:1.3.3:compile
[INFO] |  - com.google.code.findbugs:jsr305:jar:3.0.0:compile
[INFO] +- com.google.auth:google-auth-library-credentials:jar:0.7.1:compile
[INFO] +- io.grpc:grpc-protobuf:jar:1.4.0:compile
[INFO] |  +- io.grpc:grpc-core:jar:1.4.0:compile
[INFO] |  |  +- com.google.errorprone:error_prone_annotations:jar:2.0.19:compile
[INFO] |  |  - com.google.instrumentation:instrumentation-api:jar:0.4.2:compile
[INFO] |  +- com.google.protobuf:protobuf-java:jar:3.3.1:compile
[INFO] |  +- com.google.protobuf:protobuf-java-util:jar:3.3.1:compile
[INFO] |  |  - com.google.code.gson:gson:jar:2.7:compile
[INFO] |  +- com.google.api.grpc:proto-google-common-protos:jar:0.1.9:compile
[INFO] |  - io.grpc:grpc-protobuf-lite:jar:1.4.0:compile
[INFO] +- org.jenkins-ci.main:jenkins-war:war:1.609:test
[INFO] +- org.jenkins-ci.main:jenkins-core:jar:1.609:provided
[INFO] |  +- org.jenkins-ci.plugins.icon-shim:icon-set:jar:1.0.5:provided
[INFO] |  +- org.jenkins-ci.main:remoting:jar:2.50:provided
[INFO] |  |  - org.jenkins-ci:constant-pool-scanner:jar:1.2:provided
[INFO] |  +- org.jenkins-ci.main:cli:jar:1.609:provided
[INFO] |  +- org.jenkins-ci:version-number:jar:1.1:provided
[INFO] |  +- org.jenkins-ci:crypto-util:jar:1.1:provided
[INFO] |  +- org.jvnet.hudson:jtidy:jar:4aug2000r7-dev-hudson-1:provided
[INFO] |  +- com.google.inject:guice:jar:4.0-beta:provided
[INFO] |  |  +- javax.inject:javax.inject:jar:1:provided
[INFO] |  |  - aopalliance:aopalliance:jar:1.0:provided
[INFO] |  +- org.jruby.ext.posix:jna-posix:jar:1.0.3-jenkins-1:provided
[INFO] |  +- com.github.jnr:jnr-posix:jar:3.0.1:provided
[INFO] |  |  +- com.github.jnr:jnr-ffi:jar:1.0.7:provided
[INFO] |  |  |  +- com.github.jnr:jffi:jar:1.2.7:provided
[INFO] |  |  |  +- com.github.jnr:jffi:jar:native:1.2.7:provided
[INFO] |  |  |  +- org.ow2.asm:asm:jar:4.0:provided
[INFO] |  |  |  +- org.ow2.asm:asm-commons:jar:4.0:provided
[INFO] |  |  |  +- org.ow2.asm:asm-analysis:jar:4.0:provided
[INFO] |  |  |  +- org.ow2.asm:asm-tree:jar:4.0:provided
[INFO] |  |  |  +- org.ow2.asm:asm-util:jar:4.0:provided
[INFO] |  |  |  - com.github.jnr:jnr-x86asm:jar:1.0.2:provided
[INFO] |  |  - com.github.jnr:jnr-constants:jar:0.8.5:provided
[INFO] |  +- org.kohsuke:trilead-putty-extension:jar:1.2:provided
[INFO] |  +- org.jenkins-ci:trilead-ssh2:jar:build217-jenkins-8:provided
[INFO] |  +- org.kohsuke.stapler:stapler-groovy:jar:1.236:provided
[INFO] |  |  - org.kohsuke.stapler:stapler-jelly:jar:1.236:provided
[INFO] |  |     +- org.jenkins-ci:commons-jelly:jar:1.1-jenkins-20120928:provided
[INFO] |  |     - org.jenkins-ci.dom4j:dom4j:jar:1.6.1-jenkins-4:provided
[INFO] |  +- org.kohsuke.stapler:stapler-jrebel:jar:1.236:provided
[INFO] |  |  - org.kohsuke.stapler:stapler:jar:1.236:provided
[INFO] |  |     +- javax.annotation:javax.annotation-api:jar:1.2:provided
[INFO] |  |     +- commons-discovery:commons-discovery:jar:0.4:provided
[INFO] |  |     - org.jvnet:tiger-types:jar:1.3:provided
[INFO] |  +- org.kohsuke:windows-package-checker:jar:1.0:provided
[INFO] |  +- org.kohsuke.stapler:stapler-adjunct-zeroclipboard:jar:1.3.5-1:provided
[INFO] |  +- org.kohsuke.stapler:stapler-adjunct-timeline:jar:1.4:provided
[INFO] |  +- org.kohsuke.stapler:stapler-adjunct-codemirror:jar:1.3:provided
[INFO] |  +- com.infradna.tool:bridge-method-annotation:jar:1.13:provided
[INFO] |  +- org.kohsuke.stapler:json-lib:jar:2.4-jenkins-2:provided
[INFO] |  |  - net.sf.ezmorph:ezmorph:jar:1.0.6:provided
[INFO] |  +- commons-httpclient:commons-httpclient:jar:3.1:provided
[INFO] |  +- args4j:args4j:jar:2.0.31:provided
[INFO] |  +- org.jenkins-ci:annotation-indexer:jar:1.7:provided
[INFO] |  +- org.jenkins-ci:bytecode-compatibility-transformer:jar:1.5:provided
[INFO] |  |  - org.kohsuke:asm5:jar:5.0.1:provided
[INFO] |  +- org.jenkins-ci:task-reactor:jar:1.4:provided
[INFO] |  +- org.jvnet.localizer:localizer:jar:1.23:provided
[INFO] |  +- antlr:antlr:jar:2.7.6:provided
[INFO] |  +- org.jvnet.hudson:xstream:jar:1.4.7-jenkins-1:provided
[INFO] |  +- jfree:jfreechart:jar:1.0.9:provided
[INFO] |  |  - jfree:jcommon:jar:1.0.12:provided
[INFO] |  +- org.apache.antðŸœjar:1.8.4:provided
[INFO] |  |  - org.apache.ant:ant-launcher:jar:1.8.4:provided
[INFO] |  +- commons-io:commons-io:jar:2.4:provided
[INFO] |  +- commons-lang:commons-lang:jar:2.6:provided
[INFO] |  +- commons-digester:commons-digester:jar:2.1:provided
[INFO] |  +- commons-beanutils:commons-beanutils:jar:1.8.3:provided
[INFO] |  +- javax.mail:mail:jar:1.4.4:provided
[INFO] |  +- org.jvnet.hudson:activation:jar:1.1.1-hudson-1:provided
[INFO] |  +- jaxen:jaxen:jar:1.1-beta-11:provided
[INFO] |  +- commons-jelly:commons-jelly-tags-fmt:jar:1.0:provided
[INFO] |  +- commons-jelly:commons-jelly-tags-xml:jar:1.1:provided
[INFO] |  +- org.jvnet.hudson:commons-jelly-tags-define:jar:1.0.1-hudson-20071021:provided
[INFO] |  +- org.jenkins-ci:commons-jexl:jar:1.1-jenkins-20111212:provided
[INFO] |  +- org.acegisecurity:acegi-security:jar:1.0.7:provided
[INFO] |  |  +- org.springframework:spring-jdbc:jar:1.2.9:provided
[INFO] |  |  |  - org.springframework:spring-dao:jar:1.2.9:provided
[INFO] |  |  +- oro:oro:jar:2.0.8:provided
[INFO] |  |  - log4j:log4j:jar:1.2.9:provided
[INFO] |  +- org.codehaus.groovy:groovy-all:jar:1.8.9:provided
[INFO] |  +- jline:jline:jar:0.9.94:provided
[INFO] |  +- org.fusesource.jansi:jansi:jar:1.9:provided
[INFO] |  +- org.springframework:spring-webmvc:jar:2.5.6.SEC03:provided
[INFO] |  |  +- org.springframework:spring-beans:jar:2.5.6.SEC03:provided
[INFO] |  |  +- org.springframework:spring-context:jar:2.5.6.SEC03:provided
[INFO] |  |  +- org.springframework:spring-context-support:jar:2.5.6.SEC03:provided
[INFO] |  |  - org.springframework:spring-web:jar:2.5.6.SEC03:provided
[INFO] |  +- org.springframework:spring-core:jar:2.5.6.SEC03:provided
[INFO] |  +- org.springframework:spring-aop:jar:2.5.6.SEC03:provided
[INFO] |  +- xpp3:xpp3:jar:1.1.4c:provided
[INFO] |  +- javax.servlet:jstl:jar:1.1.0:provided
[INFO] |  +- com.sun.xml.txw2:txw2:jar:20110809:provided
[INFO] |  |  +- javax.xml.stream:stax-api:jar:1.0-2:provided
[INFO] |  |  - relaxngDatatype:relaxngDatatype:jar:20020414:provided
[INFO] |  +- commons-collections:commons-collections:jar:3.2.1:provided
[INFO] |  +- org.jvnet.winp:winp:jar:1.22:provided
[INFO] |  +- org.jenkins-ci:memory-monitor:jar:1.9:provided
[INFO] |  +- org.codehaus.woodstox:wstx-asl:jar:3.2.9:provided
[INFO] |  |  - stax:stax-api:jar:1.0.1:provided
[INFO] |  +- org.jenkins-ci:jmdns:jar:3.4.0-jenkins-3:provided
[INFO] |  +- net.java.dev.jna:jna:jar:4.1.0:provided
[INFO] |  +- org.kohsuke:akuma:jar:1.9:provided
[INFO] |  +- org.kohsuke:libpam4j:jar:1.8:provided
[INFO] |  +- org.jvnet.libzfs:libzfs:jar:0.5:provided
[INFO] |  +- com.sun.solaris:embedded_su4j:jar:1.1:provided
[INFO] |  +- net.java.sezpoz:sezpoz:jar:1.9:provided
[INFO] |  +- org.kohsuke.jinterop:j-interop:jar:2.0.6-kohsuke-1:provided
[INFO] |  |  - org.kohsuke.jinterop:j-interopdeps:jar:2.0.6-kohsuke-1:provided
[INFO] |  |     - org.samba.jcifs:jcifs:jar:1.2.19:provided
[INFO] |  +- org.jvnet.robust-http-client:robust-http-client:jar:1.2:provided
[INFO] |  +- org.kohsuke:access-modifier-annotation:jar:1.4:provided
[INFO] |  +- commons-fileupload:commons-fileupload:jar:1.3.1-jenkins-1:provided
[INFO] |  +- org.mindrot:jbcrypt:jar:0.3m:provided
[INFO] |  - com.jcraft:jzlib:jar:1.1.3-kohsuke-1:provided
[INFO] +- org.jenkins-ci.main:jenkins-test-harness:jar:1.609:test
[INFO] |  +- org.jenkins-ci.main:jenkins-war:jar:war-for-test:1.609:test
[INFO] |  |  +- org.jenkins-ci.modules:instance-identity:jar:1.4:test
[INFO] |  |  |  - org.bouncycastle:bcpkix-jdk15on:jar:1.47:test
[INFO] |  |  |     - org.bouncycastle:bcprov-jdk15on:jar:1.47:test
[INFO] |  |  +- org.jenkins-ci.modules:ssh-cli-auth:jar:1.2:test
[INFO] |  |  +- org.jenkins-ci.modules:slave-installer:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.modules:windows-slave-installer:jar:1.4:test
[INFO] |  |  +- org.jenkins-ci.modules:launchd-slave-installer:jar:1.2:test
[INFO] |  |  +- org.jenkins-ci.modules:upstart-slave-installer:jar:1.1:test
[INFO] |  |  +- org.jenkins-ci.modules:systemd-slave-installer:jar:1.1:test
[INFO] |  |  - org.slf4j:slf4j-jdk14:jar:1.7.7:test
[INFO] |  |     - org.slf4j:slf4j-api:jar:1.7.7:test
[INFO] |  +- org.jenkins-ci.main:maven-plugin:jar:2.7.1:test
[INFO] |  |  +- org.jenkins-ci.plugins:javadoc:jar:1.0:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven-agent:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven-interceptor:jar:1.5:test
[INFO] |  |  +- org.jvnet.hudson:maven2.1-interceptor:jar:1.2:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven3-agent:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven31-agent:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven3-interceptor:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven31-interceptor:jar:1.5:test
[INFO] |  |  +- org.jenkins-ci.main.maven:maven3-interceptor-commons:jar:1.5:test
[INFO] |  |  +- org.apache.maven:maven-core:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-model:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-settings:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-settings-builder:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-repository-metadata:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-artifact:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-plugin-api:jar:3.1.0:test
[INFO] |  |  |  +- org.apache.maven:maven-model-builder:jar:3.1.0:test
[INFO] |  |  |  +- org.codehaus.plexus:plexus-interpolation:jar:1.16:test
[INFO] |  |  |  +- org.codehaus.plexus:plexus-utils:jar:3.0.10:test
[INFO] |  |  |  +- org.codehaus.plexus:plexus-component-annotations:jar:1.5.5:test
[INFO] |  |  |  - org.sonatype.plexus:plexus-sec-dispatcher:jar:1.3:test
[INFO] |  |  +- org.apache.maven:maven-compat:jar:3.1.0:test
[INFO] |  |  +- org.apache.maven:maven-aether-provider:jar:3.1.0:test
[INFO] |  |  +- org.apache.maven:maven-embedder:jar:3.1.0:test
[INFO] |  |  |  +- org.sonatype.plexus:plexus-cipher:jar:1.7:test
[INFO] |  |  |  - commons-cli:commons-cli:jar:1.2:test
[INFO] |  |  +- org.eclipse.aether:aether-api:jar:0.9.0.M3:test
[INFO] |  |  +- org.eclipse.aether:aether-impl:jar:0.9.0.M3:test
[INFO] |  |  +- org.eclipse.aether:aether-spi:jar:0.9.0.M3:test
[INFO] |  |  +- org.eclipse.aether:aether-util:jar:0.9.0.M3:test
[INFO] |  |  +- org.eclipse.aether:aether-transport-wagon:jar:0.9.0.M3:test
[INFO] |  |  +- org.eclipse.sisu:org.eclipse.sisu.plexus:jar:0.0.0.M5:test
[INFO] |  |  |  +- javax.enterprise:cdi-api:jar:1.0:test
[INFO] |  |  |  |  - javax.annotation:jsr250-api:jar:1.0:test
[INFO] |  |  |  - org.eclipse.sisu:org.eclipse.sisu.inject:jar:0.0.0.M5:test
[INFO] |  |  +- com.google.inject:guice:jar:no_aop:4.0-beta:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-http:jar:2.4:test
[INFO] |  |  |  - org.apache.maven.wagon:wagon-http-shared4:jar:2.4:test
[INFO] |  |  |     - org.jsoup:jsoup:jar:1.7.1:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-file:jar:2.4:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-ftp:jar:2.4:test
[INFO] |  |  |  - commons-net:commons-net:jar:3.1:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-ssh:jar:2.4:test
[INFO] |  |  |  +- com.jcraft:jsch:jar:0.1.44-1:test
[INFO] |  |  |  - org.apache.maven.wagon:wagon-ssh-common:jar:2.4:test
[INFO] |  |  |     - org.codehaus.plexus:plexus-interactivity-api:jar:1.0-alpha-6:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-ssh-external:jar:2.4:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-provider-api:jar:2.4:test
[INFO] |  |  +- org.apache.maven.reporting:maven-reporting-api:jar:3.0:test
[INFO] |  |  |  - org.apache.maven.doxia:doxia-sink-api:jar:1.0:test
[INFO] |  |  +- org.codehaus.plexus:plexus-classworlds:jar:2.5.1:test
[INFO] |  |  +- org.jenkins-ci.lib:lib-jenkins-maven-artifact-manager:jar:1.2:test
[INFO] |  |  +- org.jenkins-ci.lib:lib-jenkins-maven-embedder:jar:3.11:test
[INFO] |  |  |  - org.eclipse.aether:aether-connector-wagon:jar:0.9.0.M2:test
[INFO] |  |  +- org.apache.maven.wagon:wagon-webdav-jackrabbit:jar:2.4:test
[INFO] |  |  |  +- org.apache.maven.wagon:wagon-http-shared:jar:2.4:test
[INFO] |  |  |  - org.apache.jackrabbit:jackrabbit-webdav:jar:2.5.2:test
[INFO] |  |  - org.jenkins-ci:SECURITY-144-compat:jar:1.0:test
[INFO] |  +- org.jenkins-ci.pluginsðŸœjar:1.2:test
[INFO] |  +- org.jenkins-ci.plugins:subversion:jar:1.45:test
[INFO] |  |  - org.jenkins-ci.svnkit:svnkit:jar:1.7.6-jenkins-1:test
[INFO] |  |     +- org.tmatesoft.sqljet:sqljet:jar:1.1.0:test
[INFO] |  |     |  - org.antlr:antlr-runtime:jar:3.4:test
[INFO] |  |     - de.regnis.q.sequence:sequence-library:jar:1.0.1:test
[INFO] |  +- org.jenkins-ci.plugins:mailer:jar:1.10:test
[INFO] |  +- org.jenkins-ci.plugins:matrix-auth:jar:1.0.2:test
[INFO] |  +- org.jenkins-ci.plugins:antisamy-markup-formatter:jar:1.0:test
[INFO] |  |  - org.kohsuke:owasp-html-sanitizer:jar:r88:test
[INFO] |  +- org.jenkins-ci.plugins:matrix-project:jar:1.4.1:test
[INFO] |  |  - org.jenkins-ci.plugins:script-security:jar:1.13:test
[INFO] |  |     - org.kohsuke:groovy-sandbox:jar:1.8:test
[INFO] |  +- org.jenkins-ci.plugins:junit:jar:1.2-beta-4:test
[INFO] |  +- org.mortbay.jetty:jetty:jar:6.1.26:test
[INFO] |  |  +- org.mortbay.jetty:jetty-util:jar:6.1.26:test
[INFO] |  |  - org.mortbay.jetty:servlet-api:jar:2.5-20081211:test
[INFO] |  +- org.jenkins-ci:test-annotations:jar:1.1:test
[INFO] |  +- org.jvnet.mock-javamail:mock-javamail:jar:1.7:test
[INFO] |  +- junit:junit:jar:4.11:test
[INFO] |  |  - org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] |  +- org.hamcrest:hamcrest-library:jar:1.3:test
[INFO] |  +- org.jenkins-ci:htmlunit:jar:2.6-jenkins-6:test
[INFO] |  |  +- org.jvnet.hudson:htmlunit-core-js:jar:2.6-hudson-1:test
[INFO] |  |  +- xerces:xercesImpl:jar:2.9.1:test
[INFO] |  |  +- net.sourceforge.nekohtml:nekohtml:jar:1.9.13:test
[INFO] |  |  - net.sourceforge.cssparser:cssparser:jar:0.9.5:test
[INFO] |  |     - org.w3c.css:sac:jar:1.3:test
[INFO] |  +- xalan:xalan:jar:2.7.1:test
[INFO] |  |  - xalan:serializer:jar:2.7.1:test
[INFO] |  |     - xml-apis:xml-apis:jar:1.3.04:test
[INFO] |  +- org.jvnet.hudson:embedded-rhino-debugger:jar:1.2:test
[INFO] |  +- org.jvnet.hudson:netx:jar:0.5-hudson-2:test
[INFO] |  +- org.easymock:easymock:jar:2.4:test
[INFO] |  +- org.netbeans.modules:org-netbeans-insane:jar:RELEASE72:test
[INFO] |  +- com.github.stephenc.findbugs:findbugs-annotations:jar:1.3.9-1:test
[INFO] |  - org.codehaus.geb:geb-implicit-assertions:jar:0.7.2:test
[INFO] +- javax.servlet:servlet-api:jar:2.4:provided
[INFO] - org.codehaus.mojo:animal-sniffer-annotations:jar:1.9:provided
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 12.913 s
[INFO] Finished at: 2017-08-15T20:22:41+05:30
[INFO] Final Memory: 35M/605M
[INFO] ------------------------------------------------------------------------
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3349
cronet: open-source experimental Cronet transport code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3350
add bloom filter to Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3351
core: pass status to ManagedClientTransport.shutdown()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3352
core/test: remove ineffective assertions.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3353
Resource leak in netty tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I haven't tracked down the responsible, but I ran with leak detection and found this:
Aug 16, 2017 10:58:18 AM io.netty.util.ResourceLeakDetector reportTracedLeak
SEVERE: LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
WARNING: 3 leak records were discarded because the leak record count is limited to 4. Use system property io.netty.leakDetection.maxRecords to increase the limit.
Recent access records: 4
#4:
	io.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:936)
	io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:84)
	io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:109)
	io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:256)
	io.netty.channel.embedded.EmbeddedChannel.doWrite(EmbeddedChannel.java:723)
	io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:872)
	io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:839)
	io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1.flush(EmbeddedChannel.java:819)
	io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1321)
	io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)
	io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)
	io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:191)
	io.netty.handler.codec.http2.Http2ConnectionHandler.channelReadComplete(Http2ConnectionHandler.java:509)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelReadComplete(AbstractChannelHandlerContext.java:373)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelReadComplete(DefaultChannelPipeline.java:1364)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)
	io.netty.channel.DefaultChannelPipeline.fireChannelReadComplete(DefaultChannelPipeline.java:941)
	io.netty.channel.embedded.EmbeddedChannel.flushInbound(EmbeddedChannel.java:359)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:320)
	io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
	io.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)
	io.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.lang.reflect.Method.invoke(Method.java:498)
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)
	org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)
	org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	org.junit.runners.ParentRunner$3.run(ParentRunner.java:240)
	org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:65)
	org.junit.runners.ParentRunner.runChildren(ParentRunner.java:238)
	org.junit.runners.ParentRunner.access$000(ParentRunner.java:55)
	org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:231)
	org.junit.runners.ParentRunner.run(ParentRunner.java:316)
#3:
	io.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:924)
	io.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:35)
	io.netty.util.ReferenceCountUtil.retain(ReferenceCountUtil.java:36)
	io.netty.channel.embedded.EmbeddedChannel.doWrite(EmbeddedChannel.java:721)
	io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:872)
	io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:839)
	io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1.flush(EmbeddedChannel.java:819)
	io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1321)
	io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)
	io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)
	io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:191)
	io.netty.handler.codec.http2.Http2ConnectionHandler.channelReadComplete(Http2ConnectionHandler.java:509)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelReadComplete(AbstractChannelHandlerContext.java:373)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelReadComplete(DefaultChannelPipeline.java:1364)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)
	io.netty.channel.DefaultChannelPipeline.fireChannelReadComplete(DefaultChannelPipeline.java:941)
	io.netty.channel.embedded.EmbeddedChannel.flushInbound(EmbeddedChannel.java:359)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:320)
	io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
	io.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)
	io.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.lang.reflect.Method.invoke(Method.java:498)
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)
	org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)
	org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)
#2:
	Hint: 'DefaultChannelPipeline$HeadContext#0' will handle the message from this point.
	io.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116)
	io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:810)
	io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:260)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)
	org.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)
	org.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)
	org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)
	org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)
	org.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)
	org.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)
	org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)
	org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)
	org.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)
	io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)
	io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)
	io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)
	io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)
	io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
	io.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)
	io.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.lang.reflect.Method.invoke(Method.java:498)
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)
	org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)
	org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)

#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.writeInt(AdvancedLeakAwareByteBuf.java:558)
	io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal(Http2CodecUtil.java:260)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:259)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)
	org.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)
	org.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)
	org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)
	org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)
	org.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)
	org.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)
	org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)
	org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)
	org.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)
	io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)
	io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)
	io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)
	io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)
	io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
	io.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)
	io.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.lang.reflect.Method.invoke(Method.java:498)
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)
	org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)
	org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)

Created at:
	io.netty.util.ResourceLeakDetector.track(ResourceLeakDetector.java:237)
	io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:331)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:181)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:172)
	io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:109)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:258)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)
	org.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)
	org.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)
	org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)
	org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)
	org.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)
	org.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)
	org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)
	org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)
	org.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)
	io.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)
	io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)
	io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)
	io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)
	io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)
	io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)
	io.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)
	io.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)
	io.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)
	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.lang.reflect.Method.invoke(Method.java:498)
	org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)
	org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)
	org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
	org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3354
context: move KeyValueEntries into an abstract class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Synced with team members and decided to just go directly to integrating the hash based struct from #3248 without this refactoring.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3355
GRPCLB: drop doesn't work with wait-for-ready RPCs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GrpclbLoadBalancer may drop (fail immediately) certain RPCs in order to shed load for the servers. It is done by returning a PickResult.withError(). However, withError() only fail fail-fast (which is default) RPCs, and will buffer wait-for-ready RPCs, because it is meant to signal transient failures. "Dropped" RPCs should fail immediately regardless of wait-for-ready, and should not be conflated with transient failures.
Options considered:

Add createFailingSubchannel() to Helper to be used for dropped RPCs. This would work but feel awkward, because nearly all methods on Subchannel don't apply to the failing Subchannel.
Add a new type of PickResult in addition to withError(), and will fail the RPC regardless of its wait-for-ready option. This sounds like a better option.

/cc @ejona86
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3356
Running grpc server on Android Platform
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5
What JVM are you using (java -version)?
1.7
What did you do?
If possible, provide a recipe for reproducing the error.
Goal
Run the HelloWorldServer grpc-java example in a system app running on a Marshmallow Android platform.
Steps


Follow the grpc-java documentation for retrieving and buiding the examples.  The build environment is created by sourcing the AOSP file build/envsetup.sh, then running the lunch command for our platform.  I'm guessing that you could use an emulated lunch platform or a Nexus/Pixel lunch platorm to recreate this step.


Use the jar files built from step 1 and necessary HelloWorld java file in an AOSP system app project which will create the HelloWorld grpc server just like the grpc-java example.  In the Android.mk file, proguard is disabled so nothing should be removed.  Here is the list of jars from step 1 that are included in the project:


api-common-1.0.0-rc1.jar
auto-value-1.1.jar
error_prone_annotations-2.0.19.jar
examples.jar
grpc-context-1.5.0.jar
grpc-core-1.5.0.jar
grpc-netty-1.5.0.jar
grpc-protobuf-1.5.0.jar
grpc-protobuf-lite-1.5.0.jar
grpc-stub-1.5.0.jar
gson-2.7.jar
guava-19.0.jar
instrumentation-api-0.4.3.jar
joda-time-2.8.2.jar
jsr305-3.0.0.jar
netty-buffer-4.1.12.Final.jar
netty-codec-4.1.12.Final.jar
netty-codec-http2-4.1.12.Final.jar
netty-codec-http-4.1.12.Final.jar
netty-codec-socks-4.1.12.Final.jar
netty-common-4.1.12.Final.jar
netty-handler-4.1.12.Final.jar
netty-handler-proxy-4.1.12.Final.jar
netty-resolver-4.1.12.Final.jar
netty-transport-4.1.12.Final.jar
protobuf-java-3.3.1.jar
protobuf-java-util-3.3.1.jar
proto-google-common-protos-0.1.9.jar
More details can be provided as needed.
What did you expect to see?
I expected the HelloWorld server to properly start.
What did you see instead?
When the system app executes, I see the following message in logcat:
io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional server found. Try adding a dependency on the grpc-netty artifact
Note: This issue is similar to the close issue #2227  but in my case, I'm trying to build and run a system app on an Android Platform which I control/own.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3357
all: bump to 1.7.0-SNAPSHOT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
please use standard commit format.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3358
gRPC throws io.grpc.StatusRuntimeException: UNKNOWN with netty-4.1.14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
Depend on Netty 4.1.14 instead of 4.1.11
Sample project demonstrating the issue: https://github.com/NathanHowell/spanner-test
What did you expect to see?
A more obvious success or error message
What did you see instead?
There is a rather large set of exceptions being raised on a 200 response from the server. The same project runs successfully if I downgrade netty to 4.1.13.
17:11:18.029 [grpc-default-worker-ELG-2-1] DEBUG io.grpc.netty.NettyClientHandler - [id: 0x5de32e1f, L:/172.25.44.46:58714 - R:spanner.googleapis.com/172.217.5.74:443] INBOUND PRIORITY: streamId=3 headers=GrpcHttp2ResponseHeaders[:status: 200, content-disposition: attachment, content-type: application/grpc, date: Fri, 18 Aug 2017 00:11:18 GMT, alt-svc: quic=":443"; ma=2592000; v="39,38,37,35"] padding=0 endStream=false

<trimmed>

	at io.grpc.netty.AbstractHttp2Headers.status(AbstractHttp2Headers.java:555)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:288)

Full exception:
17:11:18.029 [grpc-default-worker-ELG-2-1] DEBUG io.grpc.netty.NettyClientHandler - [id: 0x5de32e1f, L:/172.25.44.46:58714 - R:spanner.googleapis.com/172.217.5.74:443] INBOUND PRIORITY: streamId=3 headers=GrpcHttp2ResponseHeaders[:status: 200, content-disposition: attachment, content-type: application/grpc, date: Fri, 18 Aug 2017 00:11:18 GMT, alt-svc: quic=":443"; ma=2592000; v="39,38,37,35"] padding=0 endStream=false
17:11:18.031 [grpc-default-worker-ELG-2-1] DEBUG io.grpc.netty.NettyClientHandler - [id: 0x5de32e1f, L:/172.25.44.46:58714 - R:spanner.googleapis.com/172.217.5.74:443] OUTBOUND GO_AWAY: lastStreamId=0 errorCode=2 length=0 bytes=
17:11:18.032 [grpc-default-worker-ELG-2-1] DEBUG io.netty.handler.codec.http2.Http2ConnectionHandler - [id: 0x5de32e1f, L:/172.25.44.46:58714 - R:spanner.googleapis.com/172.217.5.74:443] Sent GOAWAY: lastStreamId '0', errorCode '2', debugData ''. Forcing shutdown of the connection.
Exception in thread "main" com.google.cloud.spanner.SpannerException: UNKNOWN: io.grpc.StatusRuntimeException: UNKNOWN
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerExceptionPreformatted(SpannerExceptionFactory.java:119)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:71)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:58)
	at com.google.cloud.spanner.SessionPool$Waiter.take(SessionPool.java:413)
	at com.google.cloud.spanner.SessionPool$Waiter.access$3300(SessionPool.java:399)
	at com.google.cloud.spanner.SessionPool.getReadSession(SessionPool.java:754)
	at com.google.cloud.spanner.DatabaseClientImpl.singleUse(DatabaseClientImpl.java:42)
	at Main.main(Main.java:17)
Caused by: com.google.cloud.spanner.SpannerException: UNKNOWN: io.grpc.StatusRuntimeException: UNKNOWN
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerExceptionPreformatted(SpannerExceptionFactory.java:119)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:71)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:58)
	at com.google.cloud.spanner.SessionPool$4.run(SessionPool.java:1072)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: com.google.cloud.spanner.SpannerException: UNKNOWN: io.grpc.StatusRuntimeException: UNKNOWN
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerExceptionPreformatted(SpannerExceptionFactory.java:119)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:43)
	at com.google.cloud.spanner.SpannerExceptionFactory.newSpannerException(SpannerExceptionFactory.java:80)
	at com.google.cloud.spanner.spi.v1.GrpcSpannerRpc.get(GrpcSpannerRpc.java:414)
	at com.google.cloud.spanner.spi.v1.GrpcSpannerRpc.createSession(GrpcSpannerRpc.java:332)
	at com.google.cloud.spanner.SpannerImpl$2.call(SpannerImpl.java:221)
	at com.google.cloud.spanner.SpannerImpl$2.call(SpannerImpl.java:218)
	at com.google.cloud.spanner.SpannerImpl.runWithRetries(SpannerImpl.java:200)
	at com.google.cloud.spanner.SpannerImpl.createSession(SpannerImpl.java:217)
	at com.google.cloud.spanner.SessionPool$4.run(SessionPool.java:1063)
	... 7 more
Caused by: java.util.concurrent.ExecutionException: io.grpc.StatusRuntimeException: UNKNOWN
	at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:500)
	at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:479)
	at com.google.cloud.spanner.spi.v1.GrpcSpannerRpc.get(GrpcSpannerRpc.java:408)
	... 13 more
Caused by: io.grpc.StatusRuntimeException: UNKNOWN
	at io.grpc.Status.asRuntimeException(Status.java:543)
	at io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:442)
	at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:56)
	at com.google.cloud.spanner.spi.v1.SpannerErrorInterceptor$1$1.onClose(SpannerErrorInterceptor.java:100)
	at io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:56)
	at com.google.cloud.spanner.spi.v1.WatchdogInterceptor$MonitoredCall$1.onClose(WatchdogInterceptor.java:190)
	at io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:426)
	at io.grpc.internal.ClientCallImpl.access$100(ClientCallImpl.java:76)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:512)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:429)
	at io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:544)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117)
	... 3 more
Caused by: java.lang.UnsupportedOperationException
	at io.grpc.netty.AbstractHttp2Headers.status(AbstractHttp2Headers.java:555)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:288)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:269)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:56)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader$2.processFragment(DefaultHttp2FrameReader.java:483)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:491)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:254)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:354)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:414)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1336)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1127)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1162)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1342)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:934)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3359
Census: enable requestz sampling for generated methods 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Census has an open-source requestz implementation that can show traces of live, sampled and error RPCs. In order to sample RPCs, gRPC needs to call SampledSpanStore.registerSpanNamesForCollection() with any known method name. This is fairly expensive, thus should not be called on a per-RPC basis. A few options:

In a static initializer in the generated code. If we don't want to call Census directly from the generated code, maybe call Census code in a helper function in ClientCalls and ServerCalls which is called from generated code.
In MethodDescriptor constructor. This will be called once per method, which might slow start-up speed. This would also all custom-created methods to be registered, @bogdandrutu is this desirable, or do you only expect generated methods to be registered?

Option 1 sounds like a better option. @ejona86 WDYT?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3360
netty: Handle shutdown and failures during negotiator
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3361
core: enable Census trace context propagation.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3362
core: ForwardingChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3363
Tracking ForwardingChannelBuilder being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3364
Seeing lots of "failed to mark a promise as failure because it has succeeded already" warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.0-SNAPSHOT (master branch, 8d6ff4c)
What JVM are you using (java -version)?
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
Only appears at high load (one node sending a unary RPC each to a ~1000 other nodes).
What did you see instead?
A lot of log spam with the following:
WARN [elg-rapid-97:1234-3-1] (Slf4JLogger.java:146) - Failed to mark a promise as failure because it has succeeded already: DefaultChannelPromise@6ac7d732(success)
java.lang.UnsupportedOperationException
        at io.netty.handler.codec.http2.DefaultHttp2Connection$ConnectionStream.resetSent(DefaultHttp2Connection.java:606)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.resetStream(Http2ConnectionHandler.java:732)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.resetStream(Http2ConnectionHandler.java:710)
        at io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeRstStream(DefaultHttp2ConnectionEncoder.java:243)
        at io.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeRstStream(DecoratingHttp2FrameWriter.java:65)
        at io.netty.handler.codec.http2.StreamBufferingEncoder.writeRstStream(StreamBufferingEncoder.java:174)
        at io.grpc.netty.NettyClientHandler.cancelStream(NettyClientHandler.java:472)
        at io.grpc.netty.NettyClientHandler.write(NettyClientHandler.java:236)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
        at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816)
        at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
        at io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:1030)
        at io.netty.channel.AbstractChannel.write(AbstractChannel.java:291)
        at io.grpc.netty.WriteQueue$AbstractQueuedCommand.run(WriteQueue.java:186)
        at io.grpc.netty.WriteQueue.flush(WriteQueue.java:124)
        at io.grpc.netty.WriteQueue.access$000(WriteQueue.java:32)
        at io.grpc.netty.WriteQueue$1.run(WriteQueue.java:44)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3365
grpc.ssl_target_name_override
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
how to set  ChannelOption  grpc.ssl_target_name_override in java
i konw c# like this new ChannelOption(ChannelOptions.SslTargetNameOverride,"name")
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3366
How to use the healthcheck service?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
jdk1.8.0
What did you do?
If possible, provide a recipe for reproducing the error.
What did you expect to see?
I want to get the server instantaneous status ã€‚
What did you see instead?
I have seen the health.proto and  HealthServiceImpl.java  in gRPC 1.5.0ï¼Œbut I don't know how to use it.
Is this part of the code complete? If complete, how the client to get the server healthy status, is there any examples? If not complete, Is it being perfected?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3367
Grpc android client giving : "Protocol negotiation failed" when using grpc server behind AWS ELB.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
java version "1.8.0_101"
What did you do?
If possible, provide a recipe for reproducing the error.
Deploy a grpc C++ server inside  AWS EC2 instance.
Make a ELB with a certificate using  ACM.
Use android client to hit the ELB domain name.
What did you expect to see?
Excpected response from grpc server
What did you see instead?
Protocol negotiation failed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3368
context: hashtrie based keyvalue store
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3369
grpclb: refactor main GRPCLB logic out of GrpclbLoadBalancer.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3370
Netty server poorly handles unknown content type
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If the content-type is missing or unknown, the Netty transport sends RST_STREAM with REFUSED_STREAM. That's bonkers on multiple levels.
We should probably respond with HTTP 415 instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3371
context: remove unused fields
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3372
context: compress cancellation ancestor chain
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3373
Client close the TCP conneting When the right end is not reached
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
gRPC1.5.0
What JVM are you using (java -version)?
JDK1.8.0
What did you do?
If possible, provide a recipe for reproducing the error.
I create gRPC client and gRPC server in different host, I  broken network  to make the Network from client to server inaccessible.
What did you expect to see?
I want to see the client  can quickly respond to the service unavailable as far as possible,
What did you see instead?
I  see that the NettyClientHandler will do the onConnectionError after about 20 seconds, what Throwable it catch is

Status{code=UNAVAILABLE, description=null, cause=java.io.IOException: The remote host forced an existing connection to be closed

Then ManagedChannelImpl will handle the handleSubchannelState, make the subchannel to IDLE and try to reconnect. But I don't understand What's the mechanism? How does the client feel disconnected from the server network.
And is there some  methods that the client is able to perceive the server unavailable state more quicklyï¼
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3374
netty: fix transport spuriously in notInUse state
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3375
Version 1.6.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3376
Client try tothe TCP conneting When the right end is not reached
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
What JVM are you using (java -version)?
What did you do?
If possible, provide a recipe for reproducing the error.
What did you expect to see?
What did you see instead?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3377
gRPC client try to reconnect subchannel about 20 Seconds after I make the gRPC server network unreachable
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
gRPC1.5.0
What JVM are you using (java -version)?
JDK1.8.0
What did you do?
If possible, provide a recipe for reproducing the error.
1ã€I create gRPC client and gRPC server in different host,
2ã€Send message to server interval of one second
3ã€Disable network  to make the network from client to server unreachable.(unplug the serverâ€˜s cable)
What did you expect to see?
I want to see the client can quickly respond to the service unavailable as far as possible, rather than wait for about 20 seconds to know that the server is unavailable.
What did you see instead?
I see that the NettyClientHandler will do the onConnectionError after about 20 seconds, what Throwable it catch is

Status{code=UNAVAILABLE, description=null, cause=java.io.IOException: The remote host forced an existing connection to be closed

Then ManagedChannelImpl will handle the handleSubchannelState, make the subchannel to IDLE and try to reconnect. But I don't understand What's the mechanism? How does the client feel disconnected from the server network.
And is there some methods that the client is able to perceive the server unavailable state more quicklyï¼
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3378
Socket leak in client when server sends GoAway
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0 (previously 1.0.2)
What JVM are you using (java -version)?
Various versions of 1.8, this one 1.8.0_66
What did you do?
If possible, provide a recipe for reproducing the error.
Golang gRPC server configured with MaxConnectionAge set to 30s. Simple java main client:
ManagedChannel chan = NettyChannelBuilder.forTarget("myhost:port").negotiationType(NegotiationType.PLAINTEXT).build();
RpcClient rpcClient = createStubFromChan(chan);
long start = System.currentTimeMillis();
    try {
      int lastCount = 0;
      while (true) {
        try {
            rpcClient.execute(ctx, Vtgate.ExecuteRequest
                .newBuilder()
                .setQuery(Query.BoundQuery.newBuilder().setSql("select 1").build())
                .setSession(Vtgate.Session
                    .newBuilder()
                    .setTargetString("vttest@master")
                    .setAutocommit(true))
                .build()).get();
          int count = 0;
          for (Thread t : Thread.getAllStackTraces().keySet()) {
            if (t.getName().contains("grpc-default-worker")) {
              count++;
            }
          }
          if (count != lastCount) {
            System.out.println("Threads: " + Long.toString(count));
            lastCount = count;
          }
        } catch (Exception e) {
          System.out.println("Caught exception: " + e.getMessage());
        }
      }
    } finally {
      System.out.println("Finished after: " + Long.toString(System.currentTimeMillis() - start));
    }
What did you expect to see?
Max age is set low to exacerbate the issue, but is also seen over a longer period of time when run in production with a larger value.
On GoAway, the streams should be drained and the connection closed once gracefully finished. I expect to see no growth in count of grpc-default-worker threads. On the server side I expect to see no growth in grpc http2_client goroutines.
What did you see instead?
Every time max age is triggered, sending a GoAway, streams seem to be drained and unary calls fail. On retry a new connection and thus grpc-default-worker thread is created. Those threads are never cleaned up, even over the course of many hours. When the loop restarts a new connection is created, which results in a new grpc-default-worker thread. Therefore we see growth over time.
On the server side, we see a growth in grpc http2_client goroutines. They are all stuck on readFrame, waiting to receive a ping or EOF from the client.
Setting the GRPCMaxConnectionAgeGrace mitigates this a little, in that the server will force close the connections. However, this is not acceptable because sometimes we do have long running streams which we want to allow to finish gracefully.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3379
Fix gson / opencensus bazel naming mixup
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3380
testing: add FrozenClock
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3381
all: Keep artifacts dependencyConvergence-clean
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3382
Avoid request threads on AppEngine Java 8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CC @garrettjonesgoogle
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3383
Netty{Client/Server}Transport.shutdown() has 5 sec timeout, which does not agree with the spec of the interface
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The transport shutdown() API specifies that existing streams continue, but the AbstractNettyHandler sets a GRACEFUL_SHUTDOWN_TIMEOUT = SECONDS.toMillis(5), so when Netty{Client/Server}Transport.shutdown() is called, it actually will kill the existing streams in 5 seconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3384
interop-testing: fix dealineExceeded test by increasing time interval
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Test results before #3387 and after #3389
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3385
context: make Ticker a public API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The problem with this is that a lot of times you may not control where the ticker comes from.  gRPC code often creates deadlines that don't have access to the ticker, which makes having a custom Ticker not that valuable.
This was the problem with my original PR that did pretty much the same thing here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3386
netty: graceful shutdowns should for streams to close
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3387
Do not merge: reproduce flakiness of deadlineExceeded test
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@dapengzhang0, you can make a PR on your own fork of grpc-java to test Travis changes, if you've enabled travis for that fork.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3388
context: Store Deadline in CancellableContext directly
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks simpler. Nice
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3389
Do not merge: reproduce flakiness of deadlineExceeded test after fix
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Results:
Jenkins: All passed
Kokoro: All passed
Travis Linux: Testware error
* What went wrong:
Execution failed for task ':grpc-interop-testing:loadTest'.
> No tests found for given includes: [io.grpc.testing.integration.AutoWindowSizingOnTest.deadlineExceeded, io.grpc.testing.integration.Http2NettyLocalChannelTest.deadlineExceeded, io.grpc.testing.integration.TransportCompressionTest.deadlineExceeded, io.grpc.testing.integration.InProcessTest.deadlineExceeded, io.grpc.testing.integration.Http2NettyTest.deadlineExceeded
Travis MacOS: All passed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3390
netty: Update to Netty 4.1.15
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3391
jmh: accidentally checked in foo.txt
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3392
core: advance past empty buffer in CompositeReadableBuffer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Yeah, the code currently assumes the current buffer isn't empty. I think ignoring empty buffers (just closing them immediately when added) would be the least bug-prone.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3393
all: update to proto 3.4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3394
netty,okhttp: include more detail about ALPN missing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Updates #3025
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3395
core: add gzip inflater for compressed streams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86 Added a call to inflater.end() upon reaching the end of a gzipped stream without sufficient bytes to immediately begin processing a concatenated stream. This required tracking a bit of additional state (awareness of the bytes written to the inflater's input buffer) directly in GzipInflatingBuffer, as we can no longer rely on a potentially closed inflater to tell us what data it has and hasn't looked at.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3396
Following gRPC tutorial: Error: Could not find or load main class org.gradle.wrapper.GradleWrapperMain
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
I've been following the gRPC java tutorial, after modifying the server and client classes, I tried to compile again with gradlew installDist and I get the following error:
Could not find or load main class org.gradle.wrapper.GradleWrapperMain
What did you expect to see?
Success compilation
What did you see instead?
The following error:
Could not find or load main class org.gradle.wrapper.GradleWrapperMain
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3397
 The recommented way to use the gRPC in highly concurrent environments.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
gRPC-1.5.0
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
1ã€create a gRPC server binding a port  the server side
2ã€create a gRPC client of singleton pattern
3ã€start multiple threads to send messages simultaneously using the same client(Using blockingStub)
What did you expect to see?
I hope that the gRPC able to cope with a certain amount of concurrent pressure
What did you see instead?
when I use a threads to send messages  using the client, one "send to return" takes about 40ms ;
when I increase to 20 threads to send messages simultaneously using the same client, what time one "send to return" take increase to about 200ms;
I don't think the 20 concurrent  threads would have so big impact .
Are there any other parameters that need to be configured to improve performance in a concurrent environment? or  recommend way to use gRPC in a concurrent environment better?
Hope for answers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3398
grpclb: remove expiration_interval.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3399
Tracking issue for full-stream compression being experimental
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3400
core: fix lint warnings
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zpencer PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3401
Add support for Conscrypt with Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3402
compiler: Produce unified output on diff failure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3403
Part 2 - Client-side full-stream decompression
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ejona86  the included tests here bump coverage up by 0.9%. I think this recovers from the reduction of 0.7% in the earlier client-thread deframing PR, #3145
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3404
Move jmh benchmarks to their respective modules
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Merged as 6164b7b
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3405
Remove two unnecessary fields from Context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3406
Investigate usage of deprecated ApplicationProtocolNegotiator
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In #3390 we ignored the deprecation warning. We need to investigate whether we need the checks (and so tweak netty to keep the API semi-public) or whether we want to just delete them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3407
Backport Bazel and GAE 8 bug fixes to v1.6.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So there's good news and bad news.
ðŸ‘ The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
ðŸ˜• The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
Note to project maintainer: This is a terminal state, meaning the cla/google commit status will not change from this State. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3408
TransportTest.serverNotListening flakiness possibly due to recent changes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According to @ejona86 this is likely not the same root cause as #1877 and is instead likely due to: 6ca91c4
The recent occurances:
https://travis-ci.org/grpc/grpc-java/jobs/268231091
https://travis-ci.org/grpc/grpc-java/jobs/268545284
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3409
context: add missing RunWith annotation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3410
google-common-protos are not included in extracted-include-protos
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_144"
I don't know either it is protobuf or grpc-lite problem:
using annotation.proto from proto commons throws error, though it is included in libraries folder.

Also, extracted-include-protos (or extracted-protos) build directory does not include anything related with it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3411
netty: NOOP_MESSAGE must be staged before connect()
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3412
Compiler warnings in bazel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
Master at 6164b7b (waiting for the bazel naming fixes to be released)
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
We have configued a custom java toolchain in bazel so we can catch java warnings:
java_toolchain(
  name = "myjava",
  ...
  xlint = [
    "all",
    "-processing",
    "-serial",
  ],
  misc = [
    "-Werror",
  ],
)

# build --java_toolchain=//:myjava

But now if we include the grpc-java rules, we get errors.
WORKSPACE:
git_repository(
  name = "grpc_java",
  remote = "https://github.com/grpc/grpc-java.git",
  commit = "6164b7b2ee8066c5f047f6ea49c477b6f9e3aba6",
)

load(
  "@grpc_java//:repositories.bzl",
  "grpc_java_repositories",
)

grpc_java_repositories()

BUILD:
load("@grpc_java//:java_grpc_library.bzl", "java_grpc_library")

java_grpc_library(
  name = "grpc-protobuf",
  srcs = [":proto-library"],
  deps = [":messages-protobuf"],
)

% bazel build //...
ERROR: /home/admin/.cache/bazel/_bazel_admin/61e657d6884c63362b8b441914a1bc68/external/com_google_protobuf_java/BUILD:609:1: Building external/com_google_protobuf_java/libprotobuf_java.jar (76 source files, 1 source jar) failed: Worker process sent response with exit code: 1.
warning: [options] source value 1.6 is obsolete and will be removed in a future release
warning: [options] target value 1.6 is obsolete and will be removed in a future release
warning: [options] To suppress warnings about obsolete options, use -Xlint:-options.
error: warnings found and -Werror specified

It seems like it's trying to compile protobuf_java using our java toolchain (instead of just pulling in precompiled jars?).
Is there a way to prevent the compilation from using our java_toolchain? Or some other way to leave our warnings on, but not fail on grpc/protobuf?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3413
Document CallStreamObserver.request() thread-safety
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.5.0
The javadoc for CallStreamObserver.request() makes no statement about thread safety. I see that the applicable implementations call request() methods that are documented as thread-safe, and that CallStreamObserver.request() is called as if it were thread-safe. I assume that this is meant to be a contract, as otherwise usage would be oddly complicated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3414
Update README to reference v1.6.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3415
Update README to reference 1.6.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Merged this one instead: #3428
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3416
Bump version to 1.6.0, then 1.6.1-SNAPSHOT
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There should be two commits in this PR, one bumping to 1.6.0 and another starting 1.6.1-SNAPSHOT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3417
core: save alloc in SerializingExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3418
core: remove unused buffer methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3419
core: {Server,Client}CallImpl should close InputStream from marshaller
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3420
Trying to get a basic Google Cloud Endpoints gRPC project working with an OAuth2.0 auth provider
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
We are trying to get  a Google Cloud Endpoints project with gRPC working with an OAuth2.0 authentication provider using ServiceAccountJwtAccessCredentials.
Below is the relevant piece of my Client code :
/**
 * Reporter Client that requests a response from the {@link ReporterServer}.
*/
public class ReporterClient {
public static void main(String[] args) throws Exception {

    // Create gRPC stub
    String audience =
        "https://reporter.endpoints." + computeProjectId + ".cloud.goog";
    ReporterGrpc.ReporterBlockingStub reporterBlockingStub = new ReporterClient()
        .createReporterStub(cmd.getOptionValue(HOSTPORT_OPTION), audience);

  // Construct request
    GenerateReportRequest request = GenerateReportRequest.newBuilder()
            .setDomain(domain) .setType(type).setObjectName(object).setData(data).build();

    // Send Request to Server
    GenerateReportResponse response = reporterBlockingStub.generateReport(request);
  }
  public ReporterGrpc.ReporterBlockingStub createReporterStub(String hostport, String audience)
      throws Exception {
    HostAndPort value = HostAndPort.fromString(hostport);
    Channel channel = ManagedChannelBuilder.forAddress(value.getHostText(), value.getPort())
        .usePlaintext(true).build();

    return ReporterGrpc.newBlockingStub(channel)
        .withCallCredentials(
            new GoogleAuthLibraryCallCredentials(
                Environment.get().computeEngineServiceAccountJwtAccessCredentials(audience)));
  }
}

/** Constructing credentials */
 public ServiceAccountJwtAccessCredentials withAudience(String audience) {
      // Uri is the audience that is set in ServiceAccountJwtAccessCredentials for the client
      // request to the cloud endpoint api. Eg: https://reporter.endpoints.pojectid.cloud.goog
      try {
        return new ServiceAccountJwtAccessCredentials(
            this.serviceAccountJwtAccessCredentials.getClientId(),
            this.serviceAccountJwtAccessCredentials.getClientEmail(),
            this.serviceAccountJwtAccessCredentials.getPrivateKey(),
            this.serviceAccountJwtAccessCredentials.getPrivateKeyId(), new URI(audience));
      } catch (URISyntaxException e) {
        throw new IllegalArgumentException("Audience value: " + audience + " is not a valid uri");
      }
A question concerning this issue has already been asked by me in the google groups here: (https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!topic/grpc-io/xP2CHQPwR_s)
What did you expect to see?
Currently  the audience that  is set by  ServiceAccountJwtAccessCredentials is being overwritten by the above line:
return ReporterGrpc.newBlockingStub(channel)
.withCallCredentials(
new GoogleAuthLibraryCallCredentials(
Environment.get().computeEngineServiceAccountJwtAccessCredentials(audience)));
So instead of the audience (SERVICE_CONFIGURATION_NAME) that we set, we are obtaining a string like : https://35.195.24.28:80/reporter.Reporter
What did you see instead?
Did not expect the GoogleAuthLibraryCallCredentials.java to overwrite the audience we set.
We were wondering whether ServiceAccountJwtAccessCredentials class is compatible with CallCredentials class or if there is another wrapper available to pass the ServiceAccountJwtAccessCredentials.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3421
First received frame was not SETTINGS. Hex dump for first 5 bytes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
What did you do?
Inside a test I ran a grpc server and 5 clients that accessed the server concurrently (all from the same IP; everyone with its own channel). This is only happening sometimes, looks to me like some kind of race condition within grpc.
Gradle dependencies:
 compile 'com.google.protobuf:protobuf-java:3.0.0'
    compile 'io.grpc:grpc-netty:1.4.0'
    compile 'io.grpc:grpc-stub:1.4.0'
    compile 'io.grpc:grpc-protobuf:1.4.0'
    compile 'com.squareup.okhttp3:okhttp:3.8.1'
    compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.8.2'
    compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.8.2'
    testCompile 'org.testng:testng:6.8'

What did you expect to see?
Successful call
What did you see instead?
io.grpc.StatusRuntimeException: INTERNAL
	at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:227)
	at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:208)
	at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:141)
	at xyz.CalculationServiceGrpc$CalculationServiceBlockingStub.getResult(CalculationServiceGrpc.java:261)
	at xyz.Calculation.run(Calculation.java:35)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.handler.codec.http2.Http2Exception: First received frame was not SETTINGS. Hex dump for first 5 bytes: 0000000401
	at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.verifyFirstFrameIsSettings(Http2ConnectionHandler.java:320)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:221)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:413)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3422
Resource leak in grpc 1.5.0 + netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using grpc 1.5.0 + netty
Backend configuration:
    server = NettyServerBuilder.forAddress(new InetSocketAddress(config.getServerHost(), config.getServerPort()))
//        .channelType(EpollServerSocketChannel.class)
        .intercept(coreInterceptor)
        .maxMessageSize(10 * GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE)
        .executor(
                Executors.newFixedThreadPool(
                        config.getWorkerCount(),
                        new ThreadFactoryBuilder()
                            .setNameFormat("grpc-worker-%d")
                            .setUncaughtExceptionHandler((thread, t) -> log.error("uncaught exception in {}", thread.getName(), t))
                            .build()
                )
        .addService(service1)
        .addService(service2)
        .addService(service3)
        .build()
        .start();

jvm:
$ java -version
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-1~bpo8+1-b11)
OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)

As you see, the number of executors were limited. At one point single request execution started to get too much time on the backend (seconds), that caused executor starvation and resulted in the following stacktrace:
[07:12:15,418] [grpc-default-worker-ELG-3-11] ERROR io.netty.util.ResourceLeakDetector ~ LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://n
etty.io/wiki/reference-counted-objects.html for more information.
WARNING: 107 leak records were discarded because the leak record count is limited to 4. Use system property io.netty.leakDetection.maxRecords to increase the limit.
Recent access records: 4
#4:
        io.netty.buffer.AdvancedLeakAwareByteBuf.readBytes(AdvancedLeakAwareByteBuf.java:498)
        io.grpc.netty.NettyReadableBuffer.readBytes(NettyReadableBuffer.java:60)
        io.grpc.internal.CompositeReadableBuffer$3.readInternal(CompositeReadableBuffer.java:95)
        io.grpc.internal.CompositeReadableBuffer$ReadOperation.read(CompositeReadableBuffer.java:216)
        io.grpc.internal.CompositeReadableBuffer.execute(CompositeReadableBuffer.java:174)
        io.grpc.internal.CompositeReadableBuffer.readBytes(CompositeReadableBuffer.java:91)
        io.grpc.internal.ReadableBuffers$BufferInputStream.read(ReadableBuffers.java:327)
        io.grpc.protobuf.lite.ProtoLiteUtils$2.parse(ProtoLiteUtils.java:133)
        io.grpc.protobuf.lite.ProtoLiteUtils$2.parse(ProtoLiteUtils.java:79)
        io.grpc.MethodDescriptor.parseRequest(MethodDescriptor.java:280)
        io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messageRead(ServerCallImpl.java:246)
        io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1.runInContext(ServerImpl.java:571)
        io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
        io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:102)
        java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        java.lang.Thread.run(Thread.java:748)
#3:
        io.netty.buffer.AdvancedLeakAwareByteBuf.readUnsignedByte(AdvancedLeakAwareByteBuf.java:402)
        io.grpc.netty.NettyReadableBuffer.readUnsignedByte(NettyReadableBuffer.java:55)
        io.grpc.internal.CompositeReadableBuffer$1.readInternal(CompositeReadableBuffer.java:71)
        io.grpc.internal.CompositeReadableBuffer$ReadOperation.read(CompositeReadableBuffer.java:216)
        io.grpc.internal.CompositeReadableBuffer.execute(CompositeReadableBuffer.java:174)
        io.grpc.internal.CompositeReadableBuffer.readUnsignedByte(CompositeReadableBuffer.java:74)
        io.grpc.internal.AbstractReadableBuffer.readInt(AbstractReadableBuffer.java:48)
        io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:330)
        io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:232)
        io.grpc.internal.MessageDeframer.request(MessageDeframer.java:143)
        io.grpc.internal.AbstractStream$TransportState.requestMessagesFromDeframer(AbstractStream.java:195)
        io.grpc.netty.NettyServerStream$Sink$1.run(NettyServerStream.java:90)
        io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
        io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        java.lang.Thread.run(Thread.java:748)
#2:
        io.netty.buffer.AdvancedLeakAwareByteBuf.readUnsignedByte(AdvancedLeakAwareByteBuf.java:402)
        io.grpc.netty.NettyReadableBuffer.readUnsignedByte(NettyReadableBuffer.java:55)
        io.grpc.internal.CompositeReadableBuffer$1.readInternal(CompositeReadableBuffer.java:71)
        io.grpc.internal.CompositeReadableBuffer$ReadOperation.read(CompositeReadableBuffer.java:216)
        io.grpc.internal.CompositeReadableBuffer.execute(CompositeReadableBuffer.java:174)
        io.grpc.internal.CompositeReadableBuffer.readUnsignedByte(CompositeReadableBuffer.java:74)
        io.grpc.internal.AbstractReadableBuffer.readInt(AbstractReadableBuffer.java:47)
        io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:330)
        io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:232)
        io.grpc.internal.MessageDeframer.request(MessageDeframer.java:143)
        io.grpc.internal.AbstractStream$TransportState.requestMessagesFromDeframer(AbstractStream.java:195)
        io.grpc.netty.NettyServerStream$Sink$1.run(NettyServerStream.java:90)
        io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
        io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        java.lang.Thread.run(Thread.java:748)
#1:
        io.netty.buffer.AdvancedLeakAwareByteBuf.readUnsignedByte(AdvancedLeakAwareByteBuf.java:402)
        io.grpc.netty.NettyReadableBuffer.readUnsignedByte(NettyReadableBuffer.java:55)
        io.grpc.internal.CompositeReadableBuffer$1.readInternal(CompositeReadableBuffer.java:71)
        io.grpc.internal.CompositeReadableBuffer$ReadOperation.read(CompositeReadableBuffer.java:216)
        io.grpc.internal.CompositeReadableBuffer.execute(CompositeReadableBuffer.java:174)
        io.grpc.internal.CompositeReadableBuffer.readUnsignedByte(CompositeReadableBuffer.java:74)
        io.grpc.internal.AbstractReadableBuffer.readInt(AbstractReadableBuffer.java:46)
        io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:330)
        io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:232)
        io.grpc.internal.MessageDeframer.request(MessageDeframer.java:143)
        io.grpc.internal.AbstractStream$TransportState.requestMessagesFromDeframer(AbstractStream.java:195)
        io.grpc.netty.NettyServerStream$Sink$1.run(NettyServerStream.java:90)
        io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
        io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        java.lang.Thread.run(Thread.java:748)
Created at:
        io.netty.util.ResourceLeakDetector.track(ResourceLeakDetector.java:237)
        io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:331)
        io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:181)
        io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:172)
        io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:133)
        io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator$MaxMessageHandle.allocate(DefaultMaxMessagesRecvByteBufAllocator.java:80)
        io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:122)
        io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
        io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
        io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
        io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
        io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        java.lang.Thread.run(Thread.java:748)


After request execution time was fixed, no more leak records were seen.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3423
How to match versions of com_google_protobuf and com_google_protobuf_cc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If you want to use grpc-java in the same workspace as compiling C++ protos, you need to make sure the protobuf versions match. If you get the version wrong, your C++ builds fail with "This file was generated by a newer version of protoc".
For example, our WORKSPACE currently contains:
# Protobuf for C++ (others are provided by grpc_java_repositories() below)
# If you change the version, check it matches the version in:
# https://github.com/grpc/grpc-java/blob/master/repositories.bzl
http_archive(
    name = "com_google_protobuf_cc",
    sha256 = "542703acadc3f690d998f4641e1b988f15ba57ebca05fdfb1cd9095bec007948",
    strip_prefix = "protobuf-3.4.0",
    url = "https://github.com/google/protobuf/archive/v3.4.0.zip",
)

# grpc java binding
# If you change the version, you might need to change the version for
# com_google_protobuf_cc above.
git_repository(
    name = "grpc_java",
    commit = "32cd4a066040c64cc6d88cb54c04cc1a3702f9a7",
    remote = "https://github.com/grpc/grpc-java.git",
)

I couldn't find anyone else who has reported the issue, so I'm hoping to discuss the best way to deal with this here. Options:

Manually keep them in sync (as above).
Use omit_com_google_protobuf_* flags to grpc_java_repositories() and define protobuf repos in the WORKSPACE.
Make grpc_java_repositories() define com_google_protobuf_cc.
Get Bazel to avoid relying on multiple com_google_protobuf* names for the same google/protobuf repo.

1 is tedious, 2 could break grpc-java and 3 is potential surprising. There is probably a good reason 4 hasn't been done.
Can you think of a better option for this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3424
core: use Closeables.closeQuietly from guava
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI Closeables is @Beta
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3425
Feature: StatusException and StatusRuntimeException utility methods
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like to propose adding additional static utility methods to the Status class to simplify common patterns for dealing with StatusException and StatusRuntimeException. Since SE and SRE are unrelated, working with them cannot be done with polymorphism.
I'd like to propose the following additional API for Status:
public static boolean hasStatus(Throwable t)
public static boolean hasStatusCode(Throwable t, Status.Code code)
public static void doWithStatus(Throwable t, BiConsumer<Status, Metadata> action)
These methods support handling gRPC statuses like:
Futures.addCallback(
    response,
    new FutureCallback<HelloReply>() {   
        @Override
        public void onFailure(Throwable t) {
            if (hasStatusCode(t, Status.Code.NOT_FOUND)) {
                // If you are prepared for the error's status code, handle it
                doWithStatus(t, (status, metadata) -> dealWithNotFoundStatus(status));
            } else if (hasStatus(t)) {
                // Other gRPC errors can be handled generically
                doWithStatus(t, (status, metadata) -> handleGrpcProblem(status, metadata));
            } else {
                // Other non-grpc exceptions are handled normally
                dealWithUnknownException(t);
            }
        }
    },
    executor);
The above code can be written using the existing APIs, but requires multiple nested if statements and instanceof checks.
Futures.addCallback(
    response,
    new FutureCallback<HelloReply>() {
        @Override
        public void onFailure(Throwable t) {
            if (t instanceof StatusRuntimeException || t instanceof StatusException) {
                Status status = Status.fromThrowable(t);
                Metadata trailers = Status.trailersFromThrowable(t);
                if (status == Status.Code.NOT_FOUND) {
                    // If you are prepared for the error's status code, handle it
                    dealWithNotFoundStatus(status);
                } else {
                    // Other gRPC errors can be handled generically
                    handleGrpcProblem(status, metadata);
                }
            } else {
                // Other non-grpc exceptions are handled normally
                dealWithUnknownException(t);
            }
        }
    },
    executor);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3426
Release for v1.6.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3427
grpc client sometimes stuck after connection reset
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.2
What JVM are you using (java -version)?
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
What did you do?
If possible, provide a recipe for reproducing the error.
We run the services in kubernetes load balanced by a kubernetes. The servers are running grpc java server with TLS. Clients are also running grpc java. After we have changed a kubernetes setting of --conntrack-tcp-timeout-close-wait duration from default 1h0m0s to 60s and --conntrack-tcp-timeout-established durationâ€‚from default 24h0m0s to 15m. We have started to see a lot of stuck clients where all calls timed out after seeing this exception:
java.io.IOException: Connection reset by peer
	at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:367)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)

What did you expect to see?
All our calls are unary calls. I expect them they will go through even after seeing the connection reset.
What did you see instead?
About 0.5% of clients are stuck (we have about 10k clients running). And inspecting the heap dump of a stuck client after the calls is made revealed the state 2 instances of InternalSubchannel and activeTransport and pendingTransport are null in them. Forcing the client call did not change the state of the InternalSubchannel, the client was stuck indefinitely until the process was killed and restarted. After restarting the process it became normal again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3428
Update README to reference 1.6.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3429
core,okhttp: use Executor interface rather than SerializingExecutor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wouldn't we get incorrect behavior if we use any Executor that is not SerializingExecutor though?

+1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3430
core: name more anonymous classes in ServerImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3431
core: refactor transportProvider creating fewer transport instances
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
close it for the moment
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3432
core: shard SerializeExecutor queues
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in that each SE has to maintain its
own queue of runnables, and is likely to schedule work on an idle
Executor thread.

Why is this a problem? That sounds good to me.

Additionally, the SE API doesn't lend itself to reuse, notably in
that it doesn't handle direct executors well.

What is this referring to?
I just took a glance, but it seems like this uses a single SerializingExecutor for everything (I see 1 shard specified it ManagedChannelImpl). Yes, we can change it to use multiple shards, but we are still forced to figure out that configuration.
I see two problems with the approach:

We don't know the number of shards to use. We don't know the concurrency level the application requires. This is why we use a cached thread pool instead of a fixed-size thread pool by default.
This can starve callbacks, if they are placed on the same shard as a callback that blocks for a very long time.

Today it is fine to block in callbacks, but with this change it would not be. Yes, the QPS benchmark is better, but it does no work in the application threads. In a real application that sometimes blocks, I would expect tail latency to increase dramatically.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3433
protobuf-nano: avoid using @Beta API com.google.common.io.ByteStreams
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3434
Cannot throw custome runtime exception inside clientinterceptor
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
1.8.0_144
What did you do?
If possible, provide a recipe for reproducing the error.
So i was trying to use ClientInterceptor by overiding onMessage(RespT message).  So i'm trying to throw my custome runtime exception inside ForwaringClientCall.listener something like this
Field code;
@Override
public void onMessage(RespT message) {
    try {
        getCode = message.getClass().getMethod("getCode");
        getMessage = message.getClass().getMethod("getMessage");
        returnCode = (int) getCode.invoke(message);
        returnMessage = (String) getMessage.invoke(message);
     } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {}
     
     if (returnCode != 200) {
          throw new CustomeRuntimeException(returnCode, returnMessage); // here
     }
     logger.info("{} fnished ...", methodName);
     super.onMessage(message);
}

What did you expect to see?
I excpect it will throw my custom exception
What did you see instead?
it always end inside inside this method catch (Throwable t) and it will end with statusruntimeexception cancel
@Override
public void messageRead(final InputStream message) {
  class MessageRead extends ContextRunnable {
    MessageRead() {
    super(context);
  }

  @Override
  public final void runInContext() {
   try {
       if (closed) {
          return;
   }
   try {
         observer.onMessage(method.parseResponse(message));
      } finally {
        message.close();
      }
    } catch (Throwable t) {
       Status status =
       Status.CANCELLED.withCause(t).withDescription("Failed to read message.");
       stream.cancel(status);
       close(status, new Metadata());
     }
  }
}

Thank you for your attention
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3435
grpc multiple instances of same service different ports within same jvm ubuntu
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using? 1.3.0
What JVM are you using (java -version)? openjdk version "1.8.0_131"
What did you do?
I have a service EventServer with one method sendEvent.  I have created a unit test client for EventServerImpl1
My use case is there are 2 instances of EventServer running on different ports for this test case where one propagates the event to other and response vice versa
Example: EventTestClient invokes sendEvent to EventServerImpl1 and in sendEvent method of EventServerImpl1 it propagates to sendEvent method of EventServerImpl2.
Here 2 grpc servers EventServerImpl1(port 17123) and EventServerImpl2(port 17124) implements EventServer within same JVM for this.
Now in
EventTestClient: I have code as
eventChannel = InProcessChannelBuilder.forAddress("localhost", 17123).directExecutor()
.usePlaintext(true).build();
stub = EventsServerGrpc.newBlockingStub(eventChannel );
stub.sendEvent(request); //This is fine
EventServerImpl1:
eventChannel2 = ManagedChannelBuilder.forAddress("localhost", 17124).usePlaintext(true).build();
stub2 = EventsServerGrpc.newBlockingStub(eventChannel2 );
stub2.sendEvent(request); //This is hung
Both are blocking stubs only
What did you expect to see?
I expect to see the request propagates to EventServerImpl2 as EventServerImpl1 being the client to it
What did you see instead?
When EventServerImpl1.sendEvent is triggered( stub2.sendEvent(request) ) the process hangs forever.
When I directly query EventServerImpl2(port 17124) from other java process during this hang over period it works fine. But within that same process its hung forever.
Again on Windows this is fine and test case runs well. But only on Ubuntu I see this issue
Please suggest if there is something I am missing here
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3436
core/census: set method name tag to the server handler's context
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3437
protobuf-nano: use existing class IoUtils for toByteArray
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3438
inprocess,core: add ManagedChannelBuilder and ServerBuilder factory hâ€¦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3439
grpclb: fallback to backend addresses
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks like we've decided that the timeout default should be 10 seconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3440
Move Static factory methods off the class they construct.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The ManagedChannelBuilder and ServerBuilder classes both expose static factory methods as a means to construct instances of themselves.  These classes can be extended, which means that all subclasses inherit the static methods.
However, when these static methods are call on the subclasses, they often return a different type than expected (InProcessChannelBuilder returns based on the service loader, for instance. See #3438).  This leads to confusion, and forces every subclass to add static methods that match the signatures)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3441
core: consolidate termination state in ManagedChannelImpl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3442
Netty server doesn't send multiple GOAWAYs during graceful shutdown
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For full graceful shutdown, we should send one GOAWAY with last-steam-id=MAX_INT and a PING. When the PING ACK is received then we send another GOAWAY with the actual last-stream-id. We can choose to set a timer for if the PING ACK doesn't arrive back promptly.
It looks like we try to do shutdown gracefully with maxConnectionAge, but it seems like it may not actually function.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3443
Review only: retry prototype
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3444
Problem with ssl
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
What did you do?
If possible, provide a recipe for reproducing the error.
I was setting up ssl with grpc. I have a self signed certificate with private key and certificate. The server is running fine using                 .useTransportSecurity(crt, key);
The client fails on rpc request.
What did you expect to see?
client rpc connection should go through
What did you see instead?
client fails with following error. Request does not reach server.
Sep 08, 2017 2:33:53 AM org.mediaiq.caps.platform.DemoClient warning
WARNING: RPC failed: Status{code=UNAVAILABLE, description=Channel closed while performing protocol negotiation, cause=null}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3445
NettyChannelBuilder uses Java 1.7 APIs
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Intellij complains that NettyChannelBuilder's usage of InetSocketAddress.getHostString is Java 1.7
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3446
netty: hide ProtocolNegotiator, and expose initial ChannelHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Quote characters makes our jenkins script sad
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3447
Error of Tutorial example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4
What JVM are you using (java -version)?
java version "1.8.0_111"
What did you do?
If possible, provide a recipe for reproducing the error.
Follow the example of Maven section. Try to run mvn verify.
What did you expect to see?
No ERROR for maven verifying.
What did you see instead?
[ERROR] Failed to execute goal on project examples: Could not resolve dependencies for project io.grpc:examples:jar:1.4.0-SNAPSHOT: The following artifacts could not be resolved: io.grpc:grpc-netty:jar:1.4.0-SNAPSHOT, io.grpc:grpc-protobuf:jar:1.4.0-SNAPSHOT, io.grpc:grpc-stub:jar:1.4.0-SNAPSHOT: Could not find artifact io.grpc:grpc-netty:jar:1.4.0-SNAPSHOT -> [Help 1]

I just start to learn gRPC, hope someone can give me some suggestions.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3448
core: ClientCallImpl start should not be called after cancel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3449
Feature: Lifecycle events for service implementations
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like my service implementations to be notified of server lifecycle events for server start and shutdown. These operations could be used to warm caches, persist data, or close files.
The least intrusive implementation would be an interface a service implementer would opt into for receiving these events. Ex:
public interface ServiceLifecycle {
  // Called when Server.start() is called
  void onStart(...);
 
  // Called when Server.shutdown() or Server.shutdownNow() is called
  void onShutdown(boolean hard, ...);
}
My initial thought is that onStart() would block Server.start(), so that the server wouldn't be ready until all services had successfully started. onShutdown() is trickier. It needs to be called only after the server has drained all requests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3450
protobuf-nano: do not use preexisting IoUtils internal class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3451
Introduce MethodDescriptorSupplier
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So there's good news and bad news.
ðŸ‘ The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
ðŸ˜• The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
Note to project maintainer: This is a terminal state, meaning the cla/google commit status will not change from this State. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3452
core: add finalizer checks for ManagedChannels
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3453
core: allow to fallback to ServiceLoader.load withouth classloader to make GRCP more OSGi friendly.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3454
netty,core: add a TransportTracer class
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I need to fix the netty FlowController windows, just realized the class is not thread safe
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3455
Proposal: Move forwarders into io.grpc.util
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have a couple classes in the top io.grpc. package that are "Forwarding"  classes.  These classes are generally useful on their own, and provide an interception mechanism for changing or monitoring the behavior of the forwardee.  While users could implement forwarders themselves, it would be better if we did it.  There are a couple reasons:


Forwarding is error prone.  As the classes we have evolve, we continually add methods that should have been abstract but cannot be due to backwards compatibility. ManagedChannel is one such class.  Because they are not abstract, they are easy to forget to override, as has happened in the past.  We are in a position to update the forwarding class as we modify the original class.  Additionally, we can take on the burden of testing that each method is forwarded more easily than users.


Forwarders act as good alternatives to mocks.  Often in tests we use mocks for ease of use.  This has proven to make our tests brittle and hard to understand.  It would be better to make dummy classes that are suitable for test use.   Forwarders act as a good base class for tests to extend.  It allows an inplace migration from mocks to not mocks.  Forwarders can delegate to a mock as the test is being updated.  Traditionally we haven't moved test helper classes to a shared spot, but this is due to inconvenience rather than it being  bad idea.


In #3105 the issue was raised that NoopClientCall and BaseClientCall were prone to abuse.  Their original intent was a stand in for mocks, as many callsites needed a nonnull instance.  However, because their default behavior was "do nothing", they were more easily abused.  I believe forwarding classes neatly solve both problems.  A forwarder can wrap a null instance to be used at call sites that expect a non null instance.  If any methods are called, they will fail with NPE preventing users from abusing the behavior.  They can define the methods they only need for their tests instead.
The reason I raise this is that there may be a lot of Forwarders if we adopt this pattern.  I think they are useful in both test code and in regular code, so the logical place to put them would be in a place accessible to both.  io.grpc.util seems appropriate, because they are supplemental to the core library.
As for the existing Forwarding classes, they will become shim classes, and their implementation will move to io.grpc.util.
As for which new Forwarders would live in the new location, the following have been on my wish list (with the first one being recently fulfilled by @dapengzhang0 )

ForwardingManagedChannelBuilder
ForwardingManagedChannel (people mock this class today!)
ForwardingServerBuilder
ForwardingLoadBalancer

Each of these would be useful to either users and/or ourselves.
@ejona86 @zhangkun83 @zpencer  thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3456
Https with grpc
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6
What JVM are you using (java -version)?
1.8
What did you do?
If possible, provide a recipe for reproducing the error.
I create a HTTPS with grpc use code as follow:
https://github.com/grpc/grpc-java/blob/master/interop-testing/src/test/java/io/grpc/testing/integration/TlsTest.java
What did you see instead?
But i got this
Exception in thread "main" java.lang.IllegalArgumentException: Jetty ALPN/NPN has not been properly configured.
at io.grpc.netty.GrpcSslContexts.selectApplicationProtocolConfig(GrpcSslContexts.java:159)
at io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:136)
at Demo.grpcSSLetcd(Demo.java:144)
at Demo.main(Demo.java:64)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3457
Attributes.Key equality by name
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
I am using client certificates and trying to verify the name of the caller (e.g. whitelist certain callers of my grpc server). Here is the code I wanted to write in a ServerInterceptor:
    SSLSession sslSession = (SSLSession) serverCall.getAttributes().get(Attributes.Key.of("ssl-session"));
And then I can use this SSLSession to extract info about the caller.
However, this does not work since Attributes.Key does not implement equals/hashCode. Instead, I think I have to write something like this:
    Attributes.Key<?> key =
      serverCall.getAttributes().keys().stream()
        .filter(k -> k.toString().equals("ssl-session"))
        .findFirst()
        .get();

    SSLSession sslSession = (SSLSession) serverCall.getAttributes().get(key);
Is this intentional behavior? I went to submit a pull request to implement these methods and then discovered there is a test explicitly asserting this behavior:

  
    
      grpc-java/core/src/test/java/io/grpc/AttributesTest.java
    
    
         Line 43
      in
      ec600fe
    
  
  
    

        
          
           .set(Attributes.Key.of("yolo"), "I'm not a duplicate") 
        
    
  


This seems related to #2942
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3458
FR: Port sharing with traditional HTTP services
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As of v1.6.1, there appears to be no way, when using gRPC with Netty, to host traditional HTTP services side-by-side with gRPC on the same port. I am working with an existing framework that wants to support gRPC but only has one port available and expects to also serve HTTP.
At the moment, the workaround would involve rearchitecting several disparate systems to know about split fleets of services or multiple ports, followed by some careful rollouts to migrate traffic. I'd like to avoid this if at all possible.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3459
context: log severe warning if ancestry chain > 1000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
would be nice to show the max ancestry in a "typical" grpc app, configured with metrics and tracing, just for comparison's sake
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3460
Tracking issue for deleting deprecated methods in StreamTracer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
outboundMessage() and inboundMessage() will be released as deprecated in 1.7.0, thus should be deleted in 1.8.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3461
core: record individual messages with sizes to Census/tracing
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ericgribkoff, just a heads up: this PR changes how sizes are reported to stats in the framer and deframer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3462
Revert netty: hide ProtocolNegotiator, and expose initial ChannelHandler
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3463
core,netty,okhttp,protobuf-lite: avoid @Beta guava classes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3464
core: add internal API to disable stats and/or tracing.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3465
okhttp: update caller of Headers.createRequestHeaders
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3466
Migrate OS X CI to Kokoro
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Travis works quickly. For Linux. But not OS X.
OS X tends to have a long build queue (right now it is at least 3 hours long). This could be fine, except if 5 OS X jobs are queued they starve out Linux builds. This has been a problem since OS X support was added to Travis, so waiting for things to get better doesn't seem a good strategy. Since the "Backlog macOS Builds for Open Source projects" tells a good story on https://www.traviscistatus.com/ , we could notice when things have improved in the future.
In principle it'd be fine to only run on master (not per-PR), but I don't know of any option to do that for Travis. Kokoro shouldn't have any trouble handling our rate of PR builds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3467
core/compiler: register Span names for code-generated methods.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3468
android-interop-testing: use Java Style enums
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This CL is a port originally from @arielbackenroth
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3469
Could not add interceptor(s) to ProtoReflectionService
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What did you do?
Add interceptor(s) to ProtoReflectionService.
What did you expect to see?
ProtoReflectionService works with interceptor(s).
What did you see instead?
Got a NullPointerException or compilation error.
Problem
I ask a question on Gitter.
https://gitter.im/grpc/grpc?at=59b9090bcfeed2eb65033bad
and I have got a reply from @e.jona86.
https://gitter.im/grpc/grpc?at=59b9a7f9c101bc4e3ac3404a
I think it is not easy to fix. So I report an issue.
ProtoReflectionService needs a reference to Server via notifyOnBuild but it could not, because an intercepted service is an instance of ServerServiceDefinition.
I think it is consisting some problems (may not a bug or may not a problem) as below.

ServerInterceptors#intercept binds a service and returns ServerServiceDefinition.
ServerBuilder#addService doesn't add ServerServiceDefinition to notifyOnBuildList.
ServerServiceDefinition doesn't implement InternalNotifyOnBuild.

Therefore, I could not add interceptor(s) to ProtoReflectionService.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3470
The parameter usage of KeepAlive
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
jkd1.8.0
What did you do?
If possible, provide a recipe for reproducing the error.


create a client and a server in two different virtual machine (machine 1, machine2);
NettyChannelBuilder nettyChannelBuilder = (NettyChannelBuilder)ManagedChannelBuilder.forTarget(authHost).loadBalancerFactory(lbFactory).nameResolverFactory(nameResolverFactory).usePlaintext(true);channel = nettyChannelBuilder.keepAlive(10, TimeUnit.SECONDS).keepAliveTimeout(10, TimeUnit.SECONDS).build()


call one rpc request and server response success ,then unplug the cable of machine2 to make the network from machine 1 to machine 2 unreachableï¼›


call another rpc request after one minuteï¼›


What did you expect to see?
I want to seen that the client quickly know that the server unreachable;
What did you see instead?
I seen that the client  throw exception after 10 seconds.

io.grpc.StatusRuntimeException:UNAVAILABLE: Keepalive failed.The connection is likely gone

How to use The keepAlive and the keepAliveTimeout, why the second rpc need to wait another 10 seconds to sense the server unreachable.
What the keepAlive mechanism I understand is that the client send the ping after the keepAlive time,if the response don't back before the keepAliveTimeout, shuwdown the transport and make the channel
unavailable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3471
core/compiler: register Span names for code-generated methods (take 2).
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3472
netty:  use channel writability as signal to flush
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3473
Auto detection and use of epoll for ELG
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I know it's possible to pass in a custom ELG to the NettyServerBuilder, but it'd be great if by adding a dependency on the proper packages if the DefaultELGResource would just use reflection and use epoll instead. If I were to submit a PR, is this something that would be accepted?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3474
java.lang.NoSuchMethodError xxx.yyy$Builder.<init>(xxx.yyy$1;)V exception
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.4.0
What JVM are you using (java -version)?
1.7
What did you do?
If possible, provide a recipe for reproducing the error.
not stable reprodce this issue.
What did you expect to see?
no exception
What did you see instead?
a lot of the same exceptions:
java.lang.NoSuchMethodError: user.AllCapacityLableParam$Builder.(Luser/AllCapacityLableParam$1;)V
just one details:
org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.NoSuchMethodError: user.AllCapacityLableParam$Builder.(Luser/AllCapacityLableParam$1;)V
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:978)
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:848)
at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1772)
at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:205)
at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1759)
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1751)
at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:582)
at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)
at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:548)
at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)
at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1180)
at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:512)
at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)
at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1112)
at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:213)
at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:119)
at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)
at org.eclipse.jetty.server.Server.handle(Server.java:534)
at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:320)
at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:251)
at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:283)
at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:108)
at org.eclipse.jetty.io.SelectChannelEndPoint$2.run(SelectChannelEndPoint.java:93)
at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.executeProduceConsume(ExecuteProduceConsume.java:303)
at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceConsume(ExecuteProduceConsume.java:148)
at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:136)
at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:671)
at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:589)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NoSuchMethodError: user.AllCapacityLableParam$Builder.(Luser/AllCapacityLableParam$1;)V
at user.AllCapacityLableParam.toBuilder(AllCapacityLableParam.java:195)
at user.AllCapacityLableParam.newBuilder(AllCapacityLableParam.java:189)
at com.xindny.ndp.controller.splitpackage.UnitController.importUnitExcel(UnitController.java:713)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133)
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963)
... 37 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3475
Errorprone fixes: Avoid catching AssertionError in tests, use .class literal when able
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zhangkun83, please review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3476
okhttp/test: add missing annotation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3477
Remove Thrift
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It isn't supported or used.   Maybe some kind user will ask for it back, but until that happens, rm.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3478
core: remove reference to Guava collect.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3479
core: allow to fallback to ServiceLoader.load withouth classloader to make GRCP more OSGi friendly.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3480
core: pull out reusable forwarding test, refactoring forwarding tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3481
Census contexts not propagated by in-process
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In-process transport currently disables Census altogether. However, we still need to propagate the Census StatsContext and tracing Span from the client to the server.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3482
StreamObserver stops receiving messages from server stream after 30 minutes of being silent
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
Android
What did you do?
Android client application with gRPC and backend written on go.
Client starts receiving message from server stream. But if there was no messages during 30 minutes, stream stops receiving messages at all. No logs, errors or crashes was caught by onError() or onCompleted().
By watching logs at server side I can see, that these messages were sent to stream without any errors.
Client code:
observer = new StreamObserver<Order>() {
            @Override
            public void onNext(Order value) {
                Log.d(TAG, "observer onNext: " + value);
                handleOrder(value, false);
            }
            @Override
            public void onError(Throwable t) {
                Log.d(TAG, "observer onError: ");
                t.printStackTrace();
            }
            @Override
            public void onCompleted() {
                Log.d(TAG, "observer onCompleted: ");
            }

Server code:
func (a *API) ActiveOrders(in *empty.Empty, stream pb.Foreman_ActiveOrdersServer) error {
	ctx := stream.Context()
	user, ok := user.FromContext(ctx)
	if !ok {
		return grpc.Errorf(codes.Unauthenticated, "user not found")
	}
	OrdersChan := pubsub.AddActiveOrderReader(user.CabNumber)

	for {
		select {
		case order := <-OrdersChan:
			if err := stream.Send(order); err != nil {
				grpclog.Infof("Foreman.active_orders: cant send order %v", err)
			}
		case <-ctx.Done():
			close(OrdersChan)
			pubsub.LeaveActiveOrderReader(user.CabNumber)
			return ctx.Err()
		}
	}
}

What did you expect to see?
I expect stream still receiving messages even it was inactive for some time.
What did you see instead?
No messages received.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3483
java_grpc_library.bzl: fix path-manipulation bug.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3484
manual flow control enabled not worked effectively
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
java 8
What did you do?
I have a server side stream api and on client side I have manual flow control enabled.
        public void onNext(ImageOuterClass.ImageResponse response) {
                 // process response
                 requestStream.request(1);
        }
If I send multiple messages without pause between response.onNext(),
for (Image im : images) {
  if (serverCallStreamObserver.isReady()) {
    response.onNext(imageResponse);
  }
  //Thread.sleep(100);
}
got exception:-
,Quote 912017-09-22 00:01:09.800  INFO 39104 --- [dPoolExecutor-2] org.ditto.sexyimage.grpc.ImageService    : SendImages onNext url=[https://imgcache.cjmx.com/star/201512/20151201213056390.jpg]
,Quote 922017-09-22 00:01:09.799  INFO 39104 --- [dPoolExecutor-1] org.ditto.sexyimage.grpc.ImageService    : SendImages onNext url=[https://imgcache.cjmx.com/star/201512/20151201213056390.jpg]
,Quote 932017-09-22 00:01:09.800  WARN 39104 --- [-worker-ELG-3-1] io.netty.util.ReferenceCountUtil         : Failed to release a message: UnpooledSlicedByteBuf(freed)

io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1
	at io.netty.buffer.AbstractReferenceCountedByteBuf.release0(AbstractReferenceCountedByteBuf.java:101) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:89) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractDerivedByteBuf.release0(AbstractDerivedByteBuf.java:89) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractDerivedByteBuf.release(AbstractDerivedByteBuf.java:85) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.CompositeByteBuf$Component.freeIfNecessary(CompositeByteBuf.java:1672) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.CompositeByteBuf.deallocate(CompositeByteBuf.java:1937) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractReferenceCountedByteBuf.release0(AbstractReferenceCountedByteBuf.java:106) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:89) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractDerivedByteBuf.release0(AbstractDerivedByteBuf.java:89) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.buffer.AbstractDerivedByteBuf.release(AbstractDerivedByteBuf.java:85) ~[netty-buffer-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:84) ~[netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:109) ~[netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:256) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:337) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:448) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:856) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:362) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:823) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1304) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:172) [netty-codec-http2-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:982) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.AbstractChannel.flush(AbstractChannel.java:244) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.grpc.netty.WriteQueue.flush(WriteQueue.java:124) [grpc-netty-1.6.1.jar:1.6.1]
	at io.grpc.netty.WriteQueue.access$000(WriteQueue.java:32) [grpc-netty-1.6.1.jar:1.6.1]
	at io.grpc.netty.WriteQueue$1.run(WriteQueue.java:44) [grpc-netty-1.6.1.jar:1.6.1]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463) [netty-transport-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_121]

2017-09-22 00:01:09.800  INFO 39104 --- [dPoolExecutor-3] org.ditto.sexyimage.grpc.ImageService    : SendImages onNext url=[https://imgcache.cjmx.com/star/201512/20151201213056390.jpg]
,Quote 942017-09-22 00:01:09.800  INFO 39104 --- [dPoolExecutor-4] org.ditto.sexyimage.grpc.ImageService    : SendImages onNext url=[https://imgcache.cjmx.com/star/201512/20151201213056390.jpg]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3485
core,netty: InputStream support in SslContextBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3486
core: nonnull pendingStreams in DelayedClientTransport
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3487
core: unit test for new abstract methods that break API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3488
compiler: interfaces with java7 support
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The recommend way of testing your stubs is to use InProcessChannel, and implement a dummy service.   Mocking the stubs leads to code that is surreptitiously wrong, but appears to work.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3489
Revisit the threading and ordering guarantees of StreamTracer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently StreamTracer must be thread-safe, as gRPC doesn't guarantee synchronized invocation for it. While the entire class can't be marked as not-thread-safe, as inboundUncompressedSize() may be called from a different thread (app thread) from inboundMessage() (network thread), some methods are called sequentially, e.g., inboundMessage() and outboundMessage(). If a tracer implementation only cares about inboundMessage(), it may be totally safe to not to synchronize. We need to find a way to relax the thread-safety requirement to make it easier to implement.
We also need a better definition on the ordering of the methods, e.g., is it possible for inboundMessage() to happen after streamClosed()?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3490
core: remove static field in ManagedChannelImplTest
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think the orphanedChannelsAreLogged test actually depends on state across all of the test classes that may create and not shutdown a channel, not just channels created in the ManagedChannelImplTest class (unless I missed something in our test setup, all of the test classes run in a single JVM).  I think this was the reason that the test's "clean-up" block at the beginning had to assert assertThat(remaining).isAtMost(0); instead of just asserting equals to zero.
Is there any reason to keep this test case as-is? There might be an easier alternative that I'm missing, but otherwise it seems this should either (1) be placed in its own class and somehow get junit to fork a new JVM just for this class or (2) have some modification of ManagedChannelImpl so that the reference queue can be injected for test purposes, so the checks here don't get impacted by stray references from other tests.
@carl-mastrangelo what do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3491
Question: what is used as :path pseudo header
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
I am trying to load balance a grpc service using linkerd service mesh. They mention in the docs that they use the :path pseudo header to proxy the request. I wanted to understand what :path equates to with reference to a proto file definition? Is it {package}.{service}?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3492
Grpc Transport failed
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0
What JVM are you using (java -version)?
openjdk:8-jdk
What did you do?
If possible, provide a recipe for reproducing the error
[ ERROR][2017-09-24 21:03:08] io.grpc.netty.NettyServerTransport [130] - Transport failed
io.netty.handler.codec.http2.Http2Exception: HTTP/2 client preface string missing or corrupt. Hex dump for received bytes: 303030303030303030303030303030303030303030303030
        at io.netty.handler.codec.http2.Http2Exception.connectionError(Http2Exception.java:85)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.readClientPrefaceString(Http2ConnectionHandler.java:288)
        at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:221)
        at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:413)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
        at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3493
Need to set keep-alive through ManagedChannelBuilder
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For Pub/Sub streaming pull, we need to set keep-alive to prevent connections from being dropped. Unfortunately, this seems to only be available on NettyChannelBuilder (
  
    
      grpc-java/netty/src/main/java/io/grpc/netty/NettyChannelBuilder.java
    
    
         Line 278
      in
      8ee9fb5
    
  
  
    

        
          
           public NettyChannelBuilder keepAliveTime(long keepAliveTime, TimeUnit timeUnit) { 
        
    
  

) and not ManagedChannelBuilder. Can we get a way to set this through ManagedChannelBuilder?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3494
how to pass exception cause from server to client
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
1.8
What did you do?
server throw IndexOutOfBoundsException
observer.onError(new StatusRuntimeException(Status.INTERNAL.withCause(new IndexOutOfBoundsException()).withDescription(e.getCause().getClass().getName() + ":" + e.getCause().getMessage()), metadata));
client receive StatusRuntimeException but inside cause is null

What did you expect to see?
client receive IndexOutOfBoundsException
What did you see instead?
client receive StatusRuntimeException but inside cause is null
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3495
Review Only: retry take 2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3496
Promote keepalive to ManagedChannelBuilder; stabilize
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@carl-mastrangelo, @zhangkun83, @zpencer, do y'all have any complaints with the keepalive API or my defaulting to throw UnsupportedOperationException?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3497
testing: reduce mocks in AbstractTransportTest to eliminate flakes
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3498
Enable flow control push back tests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins: retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3499
core: make enableFullStreamDecompression non-abstract
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jenkins: retest this please (?)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3500
gradle: add japicmp plugin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3501
netty: update to 4.1.16
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3502
Add CI for Bazel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While users are good at noticing when Bazel breaks, I suspect they'd appreciate it to compile without their intervention.
This probably should be on Kokoro.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3503
CensusTracingModule is breaking Bazel build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ERROR: /usr/local/google/home/zdapeng/git/grpc-java/core/BUILD.bazel:33:1: Java compilation in rule '//core:internal' failed: Worker process sent response with exit code: 1.
core/src/main/java/io/grpc/internal/CensusTracingModule.java:189: error: cannot find symbol
      eventBuilder.setUncompressedMessageSize(optionalUncompressedSize);
                  ^
  symbol:   method setUncompressedMessageSize(long)
  location: variable eventBuilder of type Builder
core/src/main/java/io/grpc/internal/CensusTracingModule.java:192: error: cannot find symbol
      eventBuilder.setCompressedMessageSize(optionalWireSize);
                  ^
  symbol:   method setCompressedMessageSize(long)
  location: variable eventBuilder of type Builder
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3504
Fix readme typo
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3505
Can not build maven project on Raspberry Pi 2 (Arm32)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
All maven projects were easily built on my macbook but now I can not get them to built on my Raspberry Pi (the culprit seems to be the ARM architecture?!)
What version of gRPC are you using?
Tried several, also tried to simply build the examples on commit hash "589da07" which seems to be using version 1.7.0. I was also using version 1.5.0.
What JVM are you using (java -version)?
Pre-installed one on Raspberry Pi:
java version "1.8.0_65"
Java(TM) SE Runtime Environment (build 1.8.0_65-b17)
Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode)

What did you do?

I tried to build the examples on version 1.7.0, where it fails to resolve the dependencies:

[ERROR] Failed to execute goal on project examples: 
Could not resolve dependencies for project io.grpc:examples:jar:1.7.0-SNAPSHOT: 
The following artifacts could not be resolved: io.grpc:grpc-netty:jar:1.7.0-SNAPSHOT, io.grpc:grpc-protobuf:jar:1.7.0-SNAPSHOT, io.grpc:grpc-stub:jar:1.7.0-SNAPSHOT, io.grpc:grpc-testing:jar:1.7.0-SNAPSHOT: 
Could not find artifact io.grpc:grpc-netty:jar:1.7.0-SNAPSHOT


I tried to build by own example based on earlier tutorials on version 1.5.0, with the plugin from github: com.github.os72:protoc-jar-maven-plugin which tells me that ARM is not supported

[ERROR] Failed to execute goal com.github.os72:protoc-jar-maven-plugin:3.4.0:run (default) on project sila_library: 
Error extracting protoc for version 340: Unsupported platform: linux/arm


On version 1.5.0 I tried to use the "standard" maven plugin, which similarly doesn't seem to find the fitting architecture in protoc executables:

[ERROR] Failed to execute goal org.xolstice.maven.plugins:protobuf-maven-plugin:0.5.0:compile (default) on project sila_library: Missing:
[ERROR] ----------
[ERROR] 1) com.google.protobuf:protoc:exe:linux-arm_32:3.4.0

Are ARM architectures simply not supported for "Java protobuf compilers", or am I missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3506
Utility class for automatically cancelling a context after an operation
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CancellableContext must always be cancelled at the end of the request. Let's add a utility that simplifies the common cases, for example:

run a Runnable, and then cancel when done or exception thrown
run a Callable, and then cancel when done or exception thrown
run a Callable<ListenableFuture>, and cancel when done, or exception thrown, or ListenableFuture cancelled by user
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3507
context: CancellableContext runAndCancel and callAndCancel
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3508
Unexpected RST_STREAM(CANCEL) and subsequent RPC-call cancelling
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.5.0 on both sides
What JVM are you using (java -version)?
On both sides
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
What did you do?
I have GRPC server(aka service) and GRPC client, both in java. Client is doing some frequent task. Earlier client was using only one rpc-call per task, but today I've add second subsequent rpc-call to task processing. Rpc-calls are different - goes to different Service.methods). After adding second call I started to catch  io.grpc.StatusRuntimeException: CANCELLED in second subsequent rpc-call on rpc client-side. Exception is not so frequent, it was only two times per day, but reason of cancelling is unknown.
One maybe important thing: thread in which rpc-client work - is a GRPC-server rpc processing thread(so client is also a GRPC-server but I think it should not be relevant).
There is no timeouts or cancellations in my code. Channel created as(this is kotlin, sorry):
val sslContext: SslContext
val serverCA = loadResourceAsStream("${config.certsPath}serverCA.crt")
val clientCert = loadResourceAsStream("${config.certsPath}client.crt")
val clientKey = loadResourceAsStream("${config.certsPath}client.key")
sslContext = GrpcSslContexts.configure(SslContextBuilder.forClient(), SslProvider.OPENSSL)
         .trustManager(serverCA)
         .keyManager(clientCert, clientKey)
         .clientAuth(ClientAuth.REQUIRE)
          .build()
builder = NettyChannelBuilder.forAddress(config.host, config.port).sslContext(sslContext)
builder.build()
This is how rpc-call is made:
val request = OnlineInfoRequestDto.newBuilder().setPlayerId(playerId.toString()).build()
val response = OnlineInfoServiceGrpc.newBlockingStub(channel)
                    .info(request)
In task processing code calls are going in this order(code is synchronous):

MatchmakingInfoService.Info
OnlineInfoService.Info

This is log of exception:
ERROR 2017-09-26 22:22:41,258 mm.public.rpc-60 (b.m.r.RemoteOnlineInfoService:?  ) - On request online info
io.grpc.StatusRuntimeException: CANCELLED
        at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:212)
        at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:193)
        at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:126)
        at base.rpc.profile.mm.OnlineInfoServiceGrpc$OnlineInfoServiceBlockingStub.info(OnlineInfoServiceGrpc.java:172)
        at base.mm.rpc.RemoteOnlineInfoService$info$1.invoke(RemoteOnlineInfoService.kt:24)
        at base.mm.rpc.RemoteOnlineInfoService$info$1.invoke(RemoteOnlineInfoService.kt:17)

From this log we can see the time and stub - CANCEL was triggered for OnlineInfoService call.
But in GRPC logs I didn't find any call to this rpc(OnlineInfoService) with CANCEL, instead I've found call with RST_STREAM for previous call
Logs from client, stream with RST_STREAM:
DEBUG 2017-09-26 22:22:41,196 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=821, headers=GrpcHttp2OutboundHeaders[:authority: SERVER_DOMAIN:50050, :path: /base.rpc.profile.mm.MatchmakingInfoService/Info, :method: POST, :scheme: https, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.5.0, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 22:22:41,197 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] DATA: streamId=821, padding=0, endStream=true, length=51, bytes=000000002e0a06313331373531122438376263343334612d626533612d346436612d383239382d613039343738313963666638
--
DEBUG 2017-09-26 22:22:41,254 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=821, headers=GrpcHttp2ResponseHeaders[:status: 200, content-type: application/grpc, grpc-encoding: identity, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 22:22:41,256 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] DATA: streamId=821, padding=0, endStream=false, length=13, bytes=00000000081802200128023001
--
DEBUG 2017-09-26 22:22:41,256 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=821, headers=GrpcHttp2ResponseHeaders[grpc-status: 0], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=true
--
DEBUG 2017-09-26 22:22:41,257 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] RST_STREAM: streamId=821, errorCode=8

What we can see here:

The call is base.rpc.profile.mm.MatchmakingInfoService/Info
RST_STREAM is sent after receiving response(reason?)

Right after that going normal call to second service - OnlineInfoService:
DEBUG 2017-09-26 22:22:41,319 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=825, headers=GrpcHttp2OutboundHeaders[:authority: SERVER_DOMAIN:50050, :path: /base.rpc.profile.mm.OnlineInfoService/Info, :method: POST, :scheme: https, content-type: application/grpc, te: trailers, user-agent: grpc-java-netty/1.5.0, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 22:22:41,319 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] DATA: streamId=825, padding=0, endStream=true, length=13, bytes=00000000080a06313331373531
--
DEBUG 2017-09-26 22:22:41,372 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=825, headers=GrpcHttp2ResponseHeaders[:status: 200, content-type: application/grpc, grpc-encoding: identity, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 22:22:41,372 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] DATA: streamId=825, padding=0, endStream=false, length=50, bytes=000000002d08cff58cfdeb2b1a2438376263343334612d626533612d346436612d383239382d613039343738313963666638
--
DEBUG 2017-09-26 22:22:41,372 grpc-default-worker-ELG-3-18 (i.g.n.NettyClientHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0x670e3d3c, L:/CLIENT_IP:56240 - R:SERVER_DOMAIN/SERVER_IP:50050] HEADERS: streamId=825, headers=GrpcHttp2ResponseHeaders[grpc-status: 0], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=true

BUT timestamp of call is after exception was thrown.
Logs from server(server is -1 hour from client) for streamId=821:
DEBUG 2017-09-26 21:22:41,223 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] HEADERS: streamId=821, headers=GrpcHttp2RequestHeaders[:path: /base.rpc.profile.mm.MatchmakingInfoService/Info, :authority: SERVER_DOMAIN:50050, :method: POST, :scheme: https, te: trailers, content-type: application/grpc, user-agent: grpc-java-netty/1.5.0, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 21:22:41,223 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] DATA: streamId=821, padding=0, endStream=true, length=51, bytes=000000002e0a06313331373531122438376263343334612d626533612d346436612d383239382d613039343738313963666638
--
DEBUG 2017-09-26 21:22:41,228 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] HEADERS: streamId=821, headers=GrpcHttp2OutboundHeaders[:status: 200, content-type: application/grpc, grpc-encoding: identity, grpc-accept-encoding: gzip], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=false
--
DEBUG 2017-09-26 21:22:41,228 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] DATA: streamId=821, padding=0, endStream=false, length=13, bytes=00000000081802200128023001
--
DEBUG 2017-09-26 21:22:41,228 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------OUTBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] HEADERS: streamId=821, headers=GrpcHttp2OutboundHeaders[grpc-status: 0], streamDependency=0, weight=16, exclusive=false, padding=0, endStream=true
--
DEBUG 2017-09-26 21:22:41,283 grpc-default-worker-ELG-4-20 (i.g.n.NettyServerHandler:71 ) [] -
----------------INBOUND--------------------
[id: 0xc59e81bf, L:/SERVER_IP:50050 - R:/CLIENT_IP:56240] RST_STREAM: streamId=821, errorCode=8

So, two questions:

Why is RST_STREAM(CANCEL) was triggered after response is received?
Why cancelled was next after RST_STREAM call?

This situation was under load like one task per minute(so no load at all).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3509
services: delete deprecated Proto reflection service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3510
services: add proto generated classes to intellij path
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3511
core,grpclb: use denser atomics for census
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3512
Added methods in AbstractStub to identify type of Stub
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your pull request. The automated tests will run as soon as one of the admins verifies this change is ok for us to run on our infrastructure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3513
Identifying the type of Stub after an instance is created
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
1.8
Currently once a Stub is generated extending from AbstractStub, there is no way to identify whether is a BlockingStub, FutureStub or simple AsnycStub except from the name which is NOT ideal. Identification of Stub, will help enforce any application level checks such as enforcing deadlines for BlockingStub in the enviornment.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3514
Start 1.8.0 development cycle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3515
RELEASING.md: Split out release branch; tweak
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3516
thrift: delete thrift
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We can just delete it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3517
core: make in-process transport support StreamTracer
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3518
examples-gae: add GAE example projects
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3519
core: fix Bazel build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3520
examples: fix Bazel build
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
retest this please
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3521
Android on-device cache example
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3522
gRPC Java is not usable from Java 9 modules
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
java version "9"
Java(TM) SE Runtime Environment (build 9+181)
Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)

What did you do?
Java 9 allows users to depend on older, non-modularized versions of the libraries by "converting" them to automatic modules. For example, when Maven dependencies on grpc are configured correctly, Java 9 allows me to do the following:
module myapp.foo {
    exports com.myapp.foo;
    requires grpc.core;
}

This allowed me to use classes from the grpc-core within my Java 9 module, but unfortunately it wouldn't compile:
ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.2:compile (default-compile) on project myapp.foo: Compilation failure: Compilation failure: 
[ERROR] the unnamed module reads package io.grpc from both grpc.core and grpc.context
[ERROR] module grpc.context reads package io.grpc from both grpc.core and grpc.context
[ERROR] module guava reads package io.grpc from both grpc.core and grpc.context
[ERROR] module error.prone.annotations reads package io.grpc from both grpc.core and grpc.context
[ERROR] module jsr305 reads package io.grpc from both grpc.core and grpc.context
[ERROR] module instrumentation.api reads package io.grpc from both grpc.core and grpc.context
[ERROR] module opencensus.api reads package io.grpc from both grpc.core and grpc.context
[ERROR] module grpc.core reads package io.grpc from both grpc.core and grpc.context

The issue is that Java 9 does not support split packages across modules and this is exactly what's happening here, as io.grpc package exists in both grpc-core and grpc-context, and to make things worse both grpc-core and grpc-stub have transitive dependency on grpc-context.
I've tried excluding grpc-context from both modules using Maven exclusions, which allowed me to compile successfully, as I don't have any direct dependencies on grpc-context. However, I was not able to run the test server, because of the missing Context class:
java.lang.NoClassDefFoundError: io/grpc/Context
        at io.grpc.internal.AbstractServerImplBuilder.build(AbstractServerImplBuilder.java:188)
        at io.grpc.testing.GrpcServerRule.before(GrpcServerRule.java:133)

There are several possible solutions, some better than the others:

Merge classes from grpc-context into grpc-core and leave empty/dummy grpc-context module around for backwards compatibility (although most people probably do not depend on it directly).
Do the same as above, but get rid of unnecessary grpc-context module.
Rename the io.grpc package in grpc-context to io.grpc.context, which would eliminate split package issue, but would break existing code that uses classes from the current location.

In any case, I'm happy to help do the work, but someone will need to decide which approach to take.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3523
Provide Automatic-Module-Name entry in JAR manifests
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please answer these questions before submitting your issue.
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
java version "9"
Java(TM) SE Runtime Environment (build 9+181)
Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)

What did you do?
Attempted to use gRPC from a Java 9 module.
What did you expect to see?
No compiler warnings or errors.
What did you see instead?
Maven complaining about the file-based automatic module name for gRPC and its dependencies:
[INFO] --- maven-compiler-plugin:3.6.2:compile (default-compile) @ oracle.coherence.grpc ---
[WARNING] *****************************************************************************************************
[WARNING] * Required automodules detected. Please don't publish this project to a public artifact repository! *
[WARNING] *****************************************************************************************************

This is happening because Java 9 uses JAR file names to calculate automatic module name, and this is very fragile.
The better approach would be to add Automatic-Module-Name entry to each JAR's manifest, specifying the reliable name consumers of gRPC libraries can use, even before the gRPC itself is fully modularized.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3524
core: move census registration into internal
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3525
GoogleAuthLibraryCallCredentials should not use ReflectiveOperationException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GoogleAuthLibraryCallCredentials uses ReflectiveOperationException, which requires Android API level 19. It appears that the animal sniffer plugin does not detect exception types in try/catch blocks (mojohaus/animal-sniffer#41). According to the user who reported this bug, GoogleAuthLibraryCallCredentials works on emulators running API levels <= 18 but on physical devices the use of GoogleAuthLibraryCallCredentials causes the app to crash with a VerifyError (https://developer.android.com/reference/java/lang/VerifyError.html).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3526
SSL offload best practice?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What version of gRPC are you using?
1.6.1
What JVM are you using (java -version)?
1.8
I've developed a backend API for mobile and desktop application using gRPC, its now ready for online, but I can not find any documents about SSL offloading.
In traditional HTTP + JSON backend API, we often put a Nginx box between clients and application servers, client talks to Nginx with HTTPS, and Nginx talks to application servers using HTTP. But as this issue indicates, Nginx doesn't support sending http2 traffic to upstream servers yet, and we can't do the same thing we gRPC APIs.
I've searched a lot, and find nghttp2 and envoy, but I do not know whether its mature enough, I want to using something proven robust and stable like Nginx.
Any suggestions?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/grpc/grpc-java/issues/3527
auth: remove use of JDK7 ReflectiveOperationException
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

