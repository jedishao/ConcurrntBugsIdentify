225
RObject#delete returns false object doesn't exist
It seems that in the following test, RObject#delete() will always return false, even though it appears the delete call should be synchronous.

329
RLock did not work
It's very wired. I just run a very simple test case to try redisson lock. But the result is not good.
Can anyone show me why RLock didn't work?

514
RedissonSortedSet's order seems broken
Hi, we have been using RedissonSortedSet and just found that on certain cases the order can be broken and I assume RedissonSortedSet is supposedly thread safe.
Assuming RedissonSortedSet of integers are added with the following integers : 103, 101, 102. RedissonSortedSet state (list in the redis server) should be: 101, 102, 103. However, there are cases when it is not. It may become 102, 101, 103 instead. And looking at RedissonSortedSet's source code, it uses binary search that requires the list/state to be always sorted. Therefore it breaks many other functionality.
The use case that breaks (in my case) is when we are adding multiple items and there is another thread that delete an item in between. Looking the source code implementation briefly, it may be because when removing an item it does not consider getCurrentVersion() (just a quick guess).

548
redisson creates non-daemon threads
There are times we don't want to explicitly call RedissonClient::shutdown,
but because redisson creates some non-daemon threads when using the MasterSlaveConnectionManager (by using HashedWheelTimer's default thread factory)
then the JVM will never be able to quit without calling the shutdown method.
Please add support or change the default behaviour to start HashedWheelTimer with daemon threads.
https://github.com/mrniko/redisson/blob/master/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java#L202
new HashedWheelTimer(new DefaultThreadFactory("HashedWheelTimer", true), minTimeout, TimeUnit.MILLISECONDS);

693
Redisson JUnit tests due leaks connections/clients/threads
If you run the JUnit tests for Redisson a lot of client and their associated connections/threads are leaking because they are not properly shutdown. This will prevent the build to be successful on system with limited number of user-processes/open-files (i.e. MacOS El Capitain).
To verify this, build the project with an attached debugger and watch the constantly growing amount of threads.

757
Unlock does not really unlock
If you unlock a FairLock from some thread, there is a delay until all threads actually see that lock as available.
Example test clase
public class RedissonLockTest {
}

586
redisson lock failure problem