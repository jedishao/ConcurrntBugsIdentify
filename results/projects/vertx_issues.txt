

https://github.com/eclipse-vertx/vert.x
https://github.com/eclipse-vertx/vert.x/issues/1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
blah blah
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete the Net module.
Remaining to do:

SSL support
Sendfile
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete this.
Remaining to do:

HTTPS
Cookies
Pipelining test currently commented out
Some missing tests, including: chaining methods, multiple connections, pause/resume
Write some examples including: Websockets, sendfile, POST/PUT example
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete this module.
Consider adding methods for getting, setting and appending primitive types.
Test remains to be done.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implement this.
Initially use new Java 7 async file IO.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete these with associated tests. We should accept any value that's a primitive type, String, or implements the Threadsafe interface
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete this.
Consider renaming when() and provide other ways of composing. Update methods in other modules to return Completions as appropriate
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/9
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implement this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/10
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For reading/writing from console
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/11
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/12
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Timer functionality
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/13
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/15
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/16
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/17
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/18
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/19
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/20
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/21
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/22
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Module for spawning processes and capturing their input output streams etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/23
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For integrating with Twitter/Facebook/Google+
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/24
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For interfacing with JMS providers
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/25
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Asynchronous connection pool will be needed for:
Net, HTTP, AMQP, Redis etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/26
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We need to create a package manager for node.x
We should also host a public repository (e..g on Amazon) where people can upload and download modules.
All modules other than core should be managed via the package manager.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/27
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should write a super lightweight framework in the style of sinatra/express that can be layered on top of core HTTP.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/28
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
AMQP 0.9.1 client.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/29
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Erdi,
Looking at the code, I think you are on the right track, but I think I can see a couple of issues.


The responded flag on the ServerConnection never gets set back to false after the response has been sent. A ServerConnection can be used my many different requests in succession.


If the user sends back a response such as 200-OK from inside the request handler, then the 100-continue will never get sent, and your client side continue handler will never get called. In this case I think we need to intercept at the point the user sends the response and send back a 100 continue just before the user sends their response.


I think these should be easy changes :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/30
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Wolf.
If you are interested in any more substantial contributions, please join us on the google group :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/31
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hybi-10 is now supported by IE, Thunderbird and Chrome.
We need to update our implementation to hybi-10 so it works (the current impl now won't work with the latest version of Chrome)
Someone has made a pull request in Netty here:
netty/netty#26
We should take a look and merge it into our forked Netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/32
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tim,
The check in HttpServerResponse.writeHead is used to intercept the response write. I wasn't able to intercept it(and send a 100-continue) at HttpServer level. I could do it by adding some more logic to ServerConnection but it wouldn't be nice.
You may be right about the responded flag, but I need to check it. As far as I remember, they(responded and pendingResponse) were slightly different. I'm not really sure now. I got a really strict schedule for weekend. Gonna give it another shot on Monday.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/33
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm going to reissue another pull request with more stuff in it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/34
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This looks good. I'm going to merge it.
Would be nice to see some tests though :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/35
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is cool. I'll merge it then we can just keep it alongside the old ant build until it has full functionality, then we'll delete the ant build.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/36
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/37
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi running tests (with gradle or with ant) fails at org.vertx.tests.core.file.FileSystemTest
getting null as message for all fails. I am on ubuntu 11.10, using openjdk 1.7
Copy of the gradle report:
org.vertx.tests.core.file.FileSystemTest
testMkdirWithParentsFails
testChmod
testMkdirCreateParents
testMkdirCreateParentsWithPerms
testCopyEmptyDir
testMkdirSimple
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/38
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If you are running vert.x in clustered mode and do not specify -cluster-host, it will default to 0.0.0.0 which means if you have multiple nodex running on the network they won't see each other (since they try to connect to the others at 0.0.0.0).
Workaround is to always specify -cluster-host when running clustered.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/39
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/40
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/41
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/42
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/43
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/44
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FYI:
http://purplefox.github.com/vert.x/ -- returns a 404
Is there another location / site with documentation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/45
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java examples ant build script in the 1.0.0.beta.1 distribution is broken.
To fix, change:

to
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/46
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/47
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Around the area of nodes joining and leaving the cluster
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/48
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pingers so cluster connections are properly closed when nodes disappear from network
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/49
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Produce a vert.x core library as part of the distribution.
This can be used embedded in any Java application.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/50
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Modify build.xml so vertx.bat is in the bin directory of the distribution along with vertx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/51
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/52
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/53
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to the overzealous nature of IntelliJ refactoring, the string 'body' was renamed to 'payload' in multiple places in the project, including some of the static html used by SockJS.
This may cause SockJS to fail to work with all transports.
This effects vertx-1.0.0.beta2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/54
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to an error in the way handlers are applied in DefaultSockJSBridge, it means that only websockets will work for all sockJS transport.
This is because the bridge is applying a catch all handler for all requests which wipes out any non websockets handlers applied by the sock js server.
This effects 1.0.0.beta2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/55
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/56
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/57
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/58
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Remove buffer factory methods etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/59
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/60
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When two or more event loops attempt to send to the new server concurrently and the connection has not yet been setup
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/61
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Interesting.... I only use Linux for building distributions, which works fine, so I guess this is an OSX only issue...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/62
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/63
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Antoine,
I think the chmod test is failing because of your umask. There is a comment on the build wiki page about this.
Thanks for the patch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/64
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On this page: http://vertx.io/wsver-0002/ruby_web_tutorial.html in step 4 ("Get the persistor up and running") there is the following line which isn't grammatically correct and a bit confusing.
Vert.x ships with an out of the box bus module (busmod) called MongoPersistor. This is a busmod is component which communicates with other components on the vert.x event bus by exchanging JSON messages.

I think it should be more like the following?
Vert.x ships with an out-of-the-box bus module (busmod) called MongoPersistor.  A busmod is a component which communicates with other components on the vert.x event bus by exchanging JSON messages.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/65
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ta very muchly
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/66
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Run a Vert.x server, deploy the SockJSExample.groovy sample app, send a couple of messages via the browser. Now try to undeploy the app. Server is currently throwing the exception:
Mar 30, 2012 5:41:58 PM org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink
WARNING: Failed to initialize an accepted socket.
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
at java.util.ArrayList.rangeCheck(ArrayList.java:604)
at java.util.ArrayList.get(ArrayList.java:382)
at org.vertx.java.core.net.impl.VertxWorkerPool.nextWorker(VertxWorkerPool.java:39)
at org.vertx.java.core.net.impl.VertxWorkerPool.nextWorker(VertxWorkerPool.java:30)
at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.nextWorker(NioServerSocketPipelineSink.java:187)
at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink$Boss.registerAcceptedChannel(NioServerSocketPipelineSink.java:260)
at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink$Boss.run(NioServerSocketPipelineSink.java:225)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
at java.lang.Thread.run(Thread.java:722)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/67
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/68
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Johan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/69
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/70
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thx for fixing the 'rabbit lib' issue;
build the branch successfully, and did run the JS file;
Now I am getting the below:
qa:amqp matzew$ vertx run amqp.js
Apr 10, 2012 6:45:32 PM org.vertx.java.core.logging.impl.JULLogDelegate error
SEVERE: Failed to create verticle
java.lang.NoClassDefFoundError: com/rabbitmq/client/Consumer
at java.lang.Class.getDeclaredConstructors0(Native Method)
at java.lang.Class.privateGetDeclaredConstructors(Class.java:2404)
at java.lang.Class.getConstructor0(Class.java:2714)
at java.lang.Class.newInstance0(Class.java:343)
at java.lang.Class.newInstance(Class.java:325)
at org.vertx.java.deploy.impl.java.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:38)
at org.vertx.java.deploy.impl.VerticleManager$1.run(VerticleManager.java:185)
at org.vertx.java.core.impl.DefaultVertx$1.run(DefaultVertx.java:145)
at org.vertx.java.core.impl.Context$1.run(Context.java:88)
at org.vertx.java.core.impl.WorkerContext$1.run(WorkerContext.java:35)
at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.ClassNotFoundException: com.rabbitmq.client.Consumer
at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
... 14 more
sent message
sent message
sent message
sent message
sent message
sent message
sent message
sent message
sent message
sent message
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/71
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The JS logging API is a bit infulencent by a java language:
var logger = vertx.logger;
logger.info(....)
while for JS folks it might be more 'natural' to use something like:
console.log() / console.error() / etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/72
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Complete the full Groovy core api along with full examples and docs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/73
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Usage of singletons (and static caching) should be removed everywhere from the vert.x API
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/74
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Factory methods should be used for constructing servers and clients rather than the new operator.
This allows the vertx context to be passed behind the scenes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/75
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Maps should be used for representing HTTP headers and trailers throughout the API
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/76
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Various other small changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/77
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/78
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Rob, this is actually already fixed in the ws_beta6 branch which is being released on Monday.
But thanks anyway :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/79
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/80
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/81
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/82
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/83
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/84
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/85
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/86
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/87
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/88
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/89
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/90
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/91
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/92
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/93
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/94
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/95
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/96
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/97
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/98
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/99
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That should be in quotes too, you are right here -- nothing special as long as that one is yet another environment var containing path(s) in it.
I have updated the code.
Well spotted. Thanks, Narigo.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx apparently does not support registering a handler with a server that is already listening. This needs to be documented, but also policed to ease problem diagnosis. For example, an exception could be thrown when an attempt is made to register a handler with a listening server.
See this thread for background.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please provide sources for download for Vert.x binary releases.
This is especially useful when developing in Java since it allows to browse directly framework javadoc and internals.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Testing Code:
https://gist.github.com/2773638
Run:
vertx run server.js -cluster -cluster-port 25501 -cluster-host 127.0.0.1
vertx run client.js -cluster -cluster-host 127.0.0.1
Kill Server
Restart Server.
Client raises exception.
May 23, 2012 4:50:57 PM org.vertx.java.core.logging.impl.JULLogDelegate error
SEVERE: Exception on netclient
java.nio.channels.ClosedChannelException
    at org.jboss.netty.handler.stream.ChunkedWriteHandler.discard(ChunkedWriteHandler.java:173)
    at org.jboss.netty.handler.stream.ChunkedWriteHandler.handleDownstream(ChunkedWriteHandler.java:124)
    at org.jboss.netty.channel.Channels.write(Channels.java:712)
    at org.jboss.netty.channel.Channels.write(Channels.java:679)
    at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:245)
    at org.vertx.java.core.net.impl.DefaultNetSocket.doWrite(DefaultNetSocket.java:164)
    at org.vertx.java.core.net.impl.DefaultNetSocket.write(DefaultNetSocket.java:63)
    at org.vertx.java.core.eventbus.impl.BaseMessage.write(BaseMessage.java:99)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus$ConnectionHolder.writeMessage(DefaultEventBus.java:552)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.sendRemote(DefaultEventBus.java:443)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.sendToSubs(DefaultEventBus.java:283)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.access$200(DefaultEventBus.java:51)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus$2.handle(DefaultEventBus.java:315)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus$2.handle(DefaultEventBus.java:310)
    at org.vertx.java.core.eventbus.impl.hazelcast.HazelcastSubsMap.get(HazelcastSubsMap.java:77)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.send(DefaultEventBus.java:310)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.send(DefaultEventBus.java:89)
    at org.vertx.java.core.eventbus.impl.DefaultEventBus.send(DefaultEventBus.java:93)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.mozilla.javascript.MemberBox.invoke(MemberBox.java:161)
    at org.mozilla.javascript.NativeJavaMethod.call(NativeJavaMethod.java:260)
    at org.mozilla.javascript.optimizer.OptRuntime.call2(OptRuntime.java:76)
    at org.mozilla.javascript.gen.core_event_bus_js_4._c_anonymous_11(core/event_bus.js:150)
    at org.mozilla.javascript.gen.core_event_bus_js_4.call(core/event_bus.js)
    at org.mozilla.javascript.optimizer.OptRuntime.call2(OptRuntime.java:76)
    at org.mozilla.javascript.gen.client_js_1._c_anonymous_1(client.js:8)
    at org.mozilla.javascript.gen.client_js_1.call(client.js)
    at org.mozilla.javascript.ContextFactory.doTopCall(ContextFactory.java:426)
    at org.mozilla.javascript.ScriptRuntime.doTopCall(ScriptRuntime.java:3131)
    at org.mozilla.javascript.gen.client_js_1.call(client.js)
    at org.mozilla.javascript.InterfaceAdapter.invokeImpl(InterfaceAdapter.java:147)
    at org.mozilla.javascript.InterfaceAdapter$1.run(InterfaceAdapter.java:122)
    at org.mozilla.javascript.Context.call(Context.java:521)
    at org.mozilla.javascript.ContextFactory.call(ContextFactory.java:536)
    at org.mozilla.javascript.InterfaceAdapter.invoke(InterfaceAdapter.java:125)
    at org.mozilla.javascript.jdk13.VMBridge_jdk13$1.invoke(VMBridge_jdk13.java:163)
    at $Proxy6.handle(Unknown Source)
    at org.vertx.java.core.impl.DefaultVertx$InternalTimerHandler.run(DefaultVertx.java:330)
    at org.vertx.java.core.impl.DefaultVertx$3.run(DefaultVertx.java:263)
    at org.vertx.java.core.impl.Context$2.run(Context.java:113)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:360)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:244)
    at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:38)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
    at java.lang.Thread.run(Thread.java:722)

Cheers,
Daryl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is there a way to shutdown all of vertx from a verticle?  Basically, I am looking for a way to kill off vertx at the end of some automated tests and killing the java process doesn't seem very elegant.
thanks,
Jake
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could you resubmit your changes without moving the classes? It's a lot simpler then to see what has changed.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As said here:
https://groups.google.com/d/topic/vertx/b6R-b_5MkWg/discussion
There is currently no way to disable the registerHandler() for clients ( SockJSServer.bridge() for example).
Maybe the SockJSServer config could disallow "register" and "unregister" messages somehow?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When working with JSON and passing around collections of things, it is tedious to always need to wrap in an envelope JsonObject.
You should allow sending of JsonArray on the event bus. This will require a small refactoring in JsonMessage. But you could  also probably achieve more uniformity to the APIs by making your JsonObject and JsonArray share a trivial common supertype, similar to how GSON has a JsonElement supertype for its JsonObject and JsonArray. This could also be done in an API backwards compatible way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Receiving java.lang.NoClassDefFoundError: org/mozilla/javascript/ContextFactory while starting JavaScript samples.
Comparing vertx 1.0 and 1.0.1 I've found out js.jar is missing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be awesome if Vert.x was available as a gem for JRuby. That way it would integrate better into the way people write JRuby applications and the whole dependency management toolchain in Ruby -- Bundler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Per discussion here: https://groups.google.com/d/topic/vertx/4bFaLj0V3_M/discussion
It would be great to have a supervisor process for Vert.x.
The following is a code of mine that uses Java 7 File Monitoring APIs to watch file changes and restart a Vert.x process if required.
https://github.com/chanwit/vail/blob/master/vail-bootstrap/src/main/java/org/vail/bootstrap/cli/Starter.java
Cheers,
Chanwit
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using the worker-queue, currently an reply message from a worker behind a worker-queue can not be received by the sender.
Could you please make a small change to allow the replies to get back to the sender.
Right now, the sender gets a reply when the work has been accepted by the queue, not when the work has been processed.
Based on the initial discussion in the google group (https://groups.google.com/forum/?fromgroups#!topic/vertx/rfIJbzpaOhk).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
It would be nice to have a way to be informed of the disconnection of the underlying TCP connection. (I.E. long polling handling).
Currently

the exception is voluntarily swallowed by
org.vertx.java.core.http.impl.ServerConnection.handleHandlerException(Throwable).
an exception handler is not triggered

Suggested evolution:

Add a connectionClosed handler on the ReadStream interface
Config param to throw the connection to the exceptionHandler

This issue is created in response to this thread : http://groups.google.com/group/vertx/browse_thread/thread/d8bbc0ec58f347b2?pli=1
Thank you.
Jocelyn.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually, I forgot to include scala-library-2.9.2.jar in vertex-dev script, so the Scala examples end with ClassNotFoundException.
Do you want me to close this one and open another pull request, with all the right code in?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In sendRemote it currently says
ConnectionHolder prevHolder = connections.putIfAbsent(serverID, holder);
if (prevHolder != null) {
// Another one sneaked in
prevHolder = holder;
} else {
I think what you actually need is
holder = prevHolder
prevHolder is not used anywhere afterwards
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I think the 2nd remove is redundant and can be removed.
    if (connections.remove(serverID, holder)) {
        connections.remove(serverID);
        log.debug("Cluster connection closed: " + serverID + " holder " + holder);

holder has not toString() which is why the debug output might not be of great value.
And, yes I know it's sometimes a pain, but I think it's generally a good idea to use if (log.isDebugEnabled()) ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think either exception handler is redundant
    private synchronized void connected(NetSocket socket, final String address) {
        this.socket = socket;
        connected = true;
        socket.exceptionHandler(new Handler<Exception>() {
            public void handle(Exception e) {
                cleanupConnection(address, serverID, ConnectionHolder.this);
            }
        });
          ....

    void connect(NetClient client, final ServerID serverID, final String address) {
        client.connect(serverID.port, serverID.host, new Handler<NetSocket>() {
            public void handle(final NetSocket socket) {
                connected(socket, address);
            }
        });
        client.exceptionHandler(new Handler<Exception>() {
            public void handle(Exception e) {
                cleanupConnection(address, serverID, ConnectionHolder.this);
            }
        });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That's how it looks like today
private void runOnContext(final Context context, final Runnable runnable) {
context.execute(new Runnable() {
public void run() {
runnable.run();
}
});
}
why not?
private void runOnContext(final Context context, final Runnable runnable) {
context.execute(runnable);
}
If that change is ok, than we might not need runOnContext at all.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
All subclasses to ConnectionBase override
protected Context getContext() {
    return context;
}

with
public  Context getContext() {
return super.getContext();
}
May I suggest to change ConnectionBase to
public final Context getContext() {
    return context;
}

and remove all overrides. I think getContext() should be final and not be overriden. I cannot think of a use case where that makes sense.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With changes for inbound and outbound permitted in webserver module
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Many examples use "match" when "matcher" is the correct setting
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think it is  more efficient (and cleaner) to change eventbus.close() to properly unregister all handlers and invoke eb.close by a ctx close hook which gets added when the context gets created.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think there is a bug in the code (copied below). As you can see, all handlers associated with the same address are removed if only one is a reply handler. I guess either the reply handler only must be removed, or if all handlers are reply handler, the whole "address" can be removed.
        boolean replyHandler = false;
        for (final HandlerHolder holder : map.keySet()) {
            if (holder.replyHandler) {
                replyHandler = true;
            }

            // Each handler gets a fresh copy
            final Message copied = msg.copy();

            holder.context.execute(new Runnable() {
                public void run() {
                    // Need to check handler is still there - the handler might have
                    // been removed after the message were sent but
                    // before it was received
                    if (map.containsKey(holder)) {
                        holder.handler.handle(copied);
                    }
                }
            });
        }
        if (replyHandler) {
            handlers.remove(msg.address);
        }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The deployWorkerVerticle here is redundant, since when deploying a module, whether it's a worker or not is always taken from the worker attribute of mod.json, so you can always use deployVerticle even if it's a worker module
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
try
NetServer listen = vertx.createNetServer();
or
HttpServer listen = vertx.createHttpServer();
result
java.lang.NullPointerException
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I run 'ant dist' or 'ant yardoc' I'm getting:
[exec] [error]: Missing 'redcarpet' gem for Markdown formatting. Install it with gem install redcarpet
But I actually have theses gems installed in Jruby 1.6.7:
json (1.7.3 java)
rake (0.8.7)
rdiscount (1.6.8)
redcarpet (2.1.1)
sources (0.0.1)
yard (0.8.1)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Consider adding a deployModule function
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public void unregisterHandler(final String id,
        final AsyncResultHandler<Void> completionHandler) {

    HandlerInfo info = handlersByID.get(id);
    if (info != null) {
        unregisterHandler(info.address, info.handler, completionHandler);
    }

I think, the following should be added.
else {
callCompletionHandler(completionHandler);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
the usage of the ant exec task in the build.xml doesn't work on windows. One solution is to use git bash or cygwin on windows.
But using the ant copy and chmod tasks should be a good solution for unix and windows:
<copy file="src/scripts/vertx.bat" todir="${dist-build}/bin/"/>
<copy file="src/scripts/vertx" todir="${dist-build}/bin/"/>
<chmod file="${dist-build}/bin/vertx" perm="ugo+rx"/>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Setting a header in a http server and ending the response with a sendFile will ignore the header and not send it to the browser.
load('vertx.js')
var server = vertx.createHttpServer();
server.requestHandler(function(req) {
req.response.putHeader("X-MyHeader", "value");
//req.response.end("hello world");
req.response.sendFile("lib/jars/netty.jar")
}).listen(8080, 'localhost');
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
$ java -version
java version "1.7.0_04"
Java(TM) SE Runtime Environment (build 1.7.0_04-b21)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)

$ ruby -v
jruby 1.7.0.preview1 (ruby-1.9.3-p203) (2012-05-19 00c8c98) (Java HotSpot(TM) 64-Bit Server VM 1.7.0_04) [darwin-x86_64-java]

$ vertx run echo/echo_server.rb
Exception in thread "main" java.util.ServiceConfigurationError: org.vertx.java.deploy.VerticleFactory: Provider org.vertx.java.deploy.impl.rhino.RhinoVerticleFactory could not be instantiated: java.lang.NoClassDefFoundError: org/mozilla/javascript/ContextFactory
    at java.util.ServiceLoader.fail(ServiceLoader.java:224)
    at java.util.ServiceLoader.access$100(ServiceLoader.java:181)
    at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:370)
    at java.util.ServiceLoader$1.next(ServiceLoader.java:438)
    at org.vertx.java.deploy.impl.VerticleManager.<init>(VerticleManager.java:89)
    at org.vertx.java.deploy.impl.cli.VertxMgr.startCluster(VertxMgr.java:264)
    at org.vertx.java.deploy.impl.cli.VertxMgr.runApplication(VertxMgr.java:115)
    at org.vertx.java.deploy.impl.cli.VertxMgr.<init>(VertxMgr.java:84)
    at org.vertx.java.deploy.impl.cli.VertxMgr.main(VertxMgr.java:61)
Caused by: java.lang.NoClassDefFoundError: org/mozilla/javascript/ContextFactory
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:264)
    at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:362)
    ... 6 more
Caused by: java.lang.ClassNotFoundException: org.mozilla.javascript.ContextFactory
    at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    ... 9 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx start  -port 25572 -cluster -cluster-port 25502
Starting clustering...No cluster-host specified so using address 10.101.92.100
Started
Exception in thread "main" org.jboss.netty.channel.ChannelException: Failed to bind to: localhost/127.0.0.1:25571
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since vert.x has a site at vertx.io rather than at vertx.org, its package names should be "io.vertx..." rather than "org.vertx..." in order to respect the Java package naming convention.
I know this is a big change, but perhaps it would be better to get it out of the way before vert.x becomes much more popular.
See this thread for background.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When specifying more then 1 instances of a sockjs server (either through -instances or deployVerticle), the internal http/user session information is lost of misdirected resulting in a 404 Not Found on the sockjs endpoint.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you resubmit the request? The diff is showing that the files have been fully rewritten (maybe you have different end of line delimiters?), so it's very hard to tell what has changed by the diffs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the install-rhino script contains a link to get ant 1.8.3
the location however only contains the latest, and as they went up a minor version it breaks the install script
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
config:
load('vertx.js');

var eb = vertx.eventBus;

vertx.deployWorkerVerticle(
    'mailer',
    {
        "address": "mailer",
        "host": "foobar.com",
        "port": 99,
        "ssl": true,
        "auth": true,
        "username": "nobody",
        "password": "home"
    },
    1,
    function() {
        stdout.println("deployed");
    }
);

eb.send("mailer", {
    "from": "tim@wibble.com",
    "to": "bob@wobble.com",                
    "subject": "Congratulations on your new armadillo!",
    "body": "Dear Bob, great to here you have purchased......"
});

log output:
Jun 08, 2012 10:28:48 AM org.vertx.java.core.logging.impl.JULLogDelegate error
SEVERE: Failed to setup mail transport
javax.mail.MessagingException: Could not connect to SMTP host: foobar.com, port: 25;
  nested exception is:
    java.net.ConnectException: Operation timed out
    at com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:1934)
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:638)
    at javax.mail.Service.connect(Service.java:317)
    at javax.mail.Service.connect(Service.java:176)
    at javax.mail.Service.connect(Service.java:125)
    at org.vertx.mods.Mailer.start(Mailer.java:89)
    at org.vertx.java.deploy.impl.VerticleManager$2.run(VerticleManager.java:288)
    at org.vertx.java.core.impl.DefaultVertx$2.run(DefaultVertx.java:249)
    at org.vertx.java.core.impl.Context$2.run(Context.java:113)
    at org.vertx.java.core.impl.Context$1.run(Context.java:103)
    at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
    at java.lang.Thread.run(Thread.java:722)
Caused by: java.net.ConnectException: Operation timed out
    at java.net.PlainSocketImpl.socketConnect(Native Method)
    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:391)
    at java.net.Socket.connect(Socket.java:579)
    at sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:612)
    at sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:160)
    at com.sun.mail.util.SocketFetcher.createSocket(SocketFetcher.java:288)
    at com.sun.mail.util.SocketFetcher.getSocket(SocketFetcher.java:205)
    at com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:1900)
    ... 13 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What has been the reason why the reply shall be of the same type as the message?
protected abstract void handleReply(T reply, Handler<Message<T>> replyHandler);

Isn't that a rather unknown case?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See: https://github.com/purplefox/vert.x/blob/master/src/main/java/org/vertx/java/busmods/BusModBase.java#L108
The argument is an int and I get this when using the default value:
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long
    at org.vertx.java.busmods.BusModBase.getOptionalLongConfig(BusModBase.java:109)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This snippet
    RecordParser rp = RecordParser.newDelimited("abc", new Handler<Buffer>() {
        @Override
        public void handle(Buffer buf) {
            System.out.println(buf);
        }
    });
    rp.handle(new Buffer("start-a-b-c-dddabc"));

will print 2 output records:
    start-a-
    -ddd

I believe the correct output should be
   start-a-b-c-ddd
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks - I will take a close look at this in the next week
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redundant since I have removed the check now
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sendFile works fine on OSX, but on Ubuntu 12.04LTS 32bit, sends content as text/plain.
Solved (as suggested in issue #146) by installing shared-mime-info, as follows:
sudo apt-get install shared-mime-info
nevertheless, this problem needs to be addressed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if the vertx start script ($VERTX_HOME/bin/vertx) used $JAVA_HOME/bin/java for starting the JVM. In this case running Vert.X from a the Netbens IDE with maven would be much easier.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a module with a Java main verticle.
In this module I also have a JavaScript verticle.
I try to deploy the JS verticle from the Java verticle with container.deployVerticle("myverticle.js").
Deploying myverticle.js starts, the JS verticle tries to load vertx.js with the load("vertx.js") command
I get the following error:  java.io.FileNotFoundException: Cannot find script: vertx.js
If I run the JS verticle from the module directory with vertx run myverticle.js it starts successfully.
If I put the JS verticle into another module ant call container.deployVerticle("js-module-name") I get the same error.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It happens with master. Steps to reproduce:
1.) Clone master
2.) Build it
3.) Open $VERTX_HOME/mods/web-server/mod.json
4.) Add host and port to the configuration (e.g.: "host": "localhost","port": 8080)
5.) vertx run web-server
The error I get is:
Jun 16, 2012 10:14:45 PM org.vertx.java.core.logging.impl.JULLogDelegate error
SEVERE: Exception in Java verticle script
org.jboss.netty.channel.ChannelException: Failed to bind to: /0.0.0.0:80
at org.jboss.netty.bootstrap.ServerBootstrap.bind(ServerBootstrap.java:298)
at org.vertx.java.core.http.impl.DefaultHttpServer.listen(DefaultHttpServer.java:210)
at org.vertx.mods.WebServer.start(WebServer.java:75)
If I try reading module configuration from a module that I created,  container.getConfig() returns an empty JSON object.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How to reproduce
Connection with the SockJS in Chrome, then reload the page
Errors that occur
java.lang.NullPointerException
    at java.util.concurrent.ConcurrentHashMap.remove(ConcurrentHashMap.java:1109)
    at org.vertx.java.core.shareddata.impl.SharedMap.remove(SharedMap.java:87)
    at org.vertx.java.core.sockjs.impl.Session.shutdown(Session.java:148)
    at org.vertx.java.core.sockjs.impl.WebSocketTransport$WebSocketListener$2.handle(WebSocketTransport.java:103)
    at org.vertx.java.core.SimpleHandler.handle(SimpleHandler.java:27)
    at org.vertx.java.core.SimpleHandler.handle(SimpleHandler.java:24)
    at org.vertx.java.core.http.impl.DefaultWebSocket.handleClosed(DefaultWebSocket.java:217)
    at org.vertx.java.core.http.impl.ServerConnection.handleClosed(ServerConnection.java:194)
    at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler$3.run(DefaultHttpServer.java:600)
    at org.vertx.java.core.impl.Context$2.run(Context.java:119)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:360)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:244)
    at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:38)
    at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:102)
    at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
    at java.lang.Thread.run(Thread.java:722)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Extend work queue to support dispatch of message to N workers.
When N workers, or a timeout has occurred, reply will be sent back to the sender specify timeout error or list of replies received from the workers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks. Can you correct your identation? Then I'll merge it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In asynchronous, event bus based applications, it's often difficult to work out what's going on. Was an event triggered? Did the listener pick it up? What was the content of the event?
We really need a mechanism, such as the wiretap feature of Spring Integration, to inspect what's happening in the event bus. Without it, debugging problems in Vert.x applications will be difficult.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Explain in docs that JSON received on the server side is received as a JS object, Hash in Ruby etc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In a dummy.groovy verticle, launched by "vertx run dummy.groovy" :
vertx.createHttpClient(port: 80, host: 'www.google.com') => OK
But :
vertx.createHttpClient(port: 80, host: 'www.google.com', maxPoolSize: 10) => KO
juin 19, 2012 5:12:06 PM org.vertx.java.core.logging.impl.JULLogDelegate error
Grave: Exception in Groovy verticle
java.lang.reflect.InvocationTargetException
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:601)
at org.vertx.java.deploy.impl.groovy.GroovyVerticleFactory$1.start(GroovyVerticleFactory.java:101)
at org.vertx.java.deploy.impl.VerticleManager$2.run(VerticleManager.java:288)
at org.vertx.java.core.impl.DefaultVertx$2.run(DefaultVertx.java:249)
at org.vertx.java.core.impl.Context$2.run(Context.java:113)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:360)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:244)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:38)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:102)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
at java.lang.Thread.run(Thread.java:722)
Caused by: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'org.vertx.java.core.http.impl.DefaultHttpClient@61ffdf0d' with class 'org.vertx.java.core.http.impl.DefaultHttpClient' to class 'org.vertx.groovy.core.http.HttpClient'
at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:360)
at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
at org.vertx.groovy.core.http.HttpClient.setMaxPoolSize(HttpClient.groovy:52)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:601)
at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2384)
at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3312)
at org.vertx.groovy.core.http.HttpClient.setProperty(HttpClient.groovy)
at org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:179)
at groovy.lang.Closure.setPropertyTryThese(Closure.java:380)
at groovy.lang.Closure.setPropertyOwnerFirst(Closure.java:374)
at groovy.lang.Closure.setProperty(Closure.java:363)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:601)
at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
at org.vertx.groovy.core.http.impl.DefaultHttpClient$_closure1.doCall(DefaultHttpClient.groovy:31)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:601)
at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
at groovy.lang.Closure.call(Closure.java:412)
at org.codehaus.groovy.runtime.DefaultGroovyMethods.callClosureForMapEntry(DefaultGroovyMethods.java:3578)
at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1405)
at org.codehaus.groovy.runtime.dgm$163.invoke(Unknown Source)
at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
at org.vertx.groovy.core.http.impl.DefaultHttpClient.(DefaultHttpClient.groovy:30)
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)
at org.vertx.groovy.core.Vertx.createHttpClient(Vertx.groovy:107)
at org.vertx.groovy.core.Vertx$createHttpClient.call(Unknown Source)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
at dummy.run(dummy.groovy:1)
... 16 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cannot merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently HttpClient only supports setConnectionTimeout(). It would be better that we could set timeout for the whole request.
HttpClientRequest clientRequest = client.post("/calculate", new Handler<HttpClientResponse>() {
        @Override
        public void handle(HttpClientResponse resp) {
             // ...
        }
});
// set Timeout of the request, and a hanlder to invoke when timeout occurrs.
clientRequest.setTimeout(1000, new Hanlder<?>() {
        @Override
        public void handle(Object obj) {
             // ...
        }
});
clientRequest.end();
Another issue would be what to provide for the timeout handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since the vertx start, stop, deploy and undeploy commands are no longer available, please remove them from the usage help as well. I mean the help text that comes up when you start vertx without any command line arguments.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please package vert.x-core and vert.x-platform javadocs as jar files to be able to deploy them simply to a Maven repository.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Which example exactly are you referring to?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I gziped javascript and css files, but web-server modul sent it back without "Content-Encoding: gzip" http header entry.
More details: Make the Web Faster: https://developers.google.com/speed/articles/gzip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to reproduce:

deploy a verticle that registers itself as a periodic task with e.g. vertx.setPeriodic(10000, this)
modify the Java class (I modified a logging line)
overwrite the class file in the module directory
redeployment kicks in
the new version is deployed and starts, but the old one still runs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This looks good, but I don't know much about AMD so I'm interesting in how it works - who calls the anonymous function etc. It's not clear to me how this gets executed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have written once before in google groups about the about limitations in the current design of HttpClient given that it was intended to be reused and requests pipelined. I have recently come across another problem that is a serious issue and I think can really only be addressed by redesigning the HttpClient, which is something I'm happy to take on. However, I want to make sure that I have a full understanding of intents and reasons for the initial design, so I would like some peer review of the idea before I go off and do this.
Let's start with the easy problem: HttpClient is supposed to be reusable with pipelined requests being executed on a pool of connections. The first problem is that the client has setter methods, allowing mutation of some of the operating parameters mid use. While by the nature of a verticle only one thread will be using the HttpClient at a time, the same instance may be used in various parts of the code, and since the properties can be mutated, can be left in an unexpected state for the next place that uses it.
A more serious problem is that connection exceptions are reported on the HttpClient exception handler, and NOT on the HttpClientRequest's exception handler. This means either each user of the HttpClient sets it's exception handler (which overwrites the last) OR there is one generic exception handler that can do little more than log the error. The problem with the first case: Imagine two requests are made one after the other, potentially via different code paths. The second's use of the HttpClient overwrites the first's exception handler. Now, since the connections are made on a separate thread in the case of a pool, this means that if a connection exception occurs connecting on the first request, and there is enough delay such that the exception handler has already been set by the second use of HttpClient, the exception for the connection of the first attempt is reported to the second handler, even though the second attempt to connect may succeed. This makes it impossible to know which request actually had the error and act on closing down, cleaning up, reporting accordingly. There is a simple test case provided below. Finally, If the second method is used, where we set the HttpClient's exception handler once, and provide some generic logging implementation, the HttpClientRequest's exception handler is never invoked either. To make matters worse, since there is no timeout feature on HttpClient, this results in a dead end; neither the HttpClientRequest's end nor exception handler is ever invoked. There is no way to know that the HttpClientRequest will never complete.
I propose and would like comment on the following changes:

Deprecate both HttpClient and Vertx.createHttpClient()
Create the interface SharedHttpClient that is immutable, in that is has no setters and no way to set an exception handler. It has an isClosed() method so that a new client can be created if some code path decided to close the Client for some reason. All connection exceptions are passed to the exception handler of the HttpClientRequest, the HttpClient has no exceptionHandler() method. I would create a new interface to preserve backward compatibility, with the idea we would eventually remove the current HttpClient.
Create a new interface/class called HttpClientParams that has all of the setters on the current HttpClient.
Create a new method on Vertx: public SharedHttpClient createSharedHttpClient(HttpClientParams params);
Add a setTimeoutMs(long) method to HttpClientRequest the idea being if the HttpClient.request() (and related) does not complete and call the passed in response handler before the timeout, the exception handler for the request will be called with TimeoutException(). This would default to -1 which means no timeout and has the current behavior.
Add a setTimeoutMs(long) method to HttpClientResponse the idea being if the HttpClientRepsonse.end() (or exceptionHandler()) is not called the timeout, the exception handler for the response will be called with TimeoutException(). This would default to -1 which means no timeout and has the current behavior.
Alternatively to 5 and 6, there is one setTimeoutMs(long) on the SharedHttpClient, and the implementations of the DefaultHttpClientRequest and DefaultHttpClientResponse, handle each half of the timeout.
The implementation of DefaultSharedHttpClient is largely based on the current implementation of DefaultHttpClient, but delegates the connection exceptions to the appropriate HttpClientRequest so that code can know which request failed because of a connection error. It also does not need to implement any of the mutator methods that were present in DefaultHttpClient.

I believe without these changes (and from hours of debugging and trying to work around the current design) the HttpClient is not really reusable, the internal connection pool and boss threads notwithstanding.
Test Case to prove non-reuasbility of HttpClient when shared among code paths:
/**
 * Show that HttpClient is really not reusable as intended.
 *
 * @author Nathan Pahucki, <a href="mailto:nathan@gmail.com"> nathan@gmail.com</a>
 */
public final class TestHttpClientReuse extends Verticle {

    @Override
    public void start() throws Exception {
        final HttpClient sharedClient = getVertx().createHttpClient();
        sharedClient.setBossThreads(1);
        sharedClient.setMaxPoolSize(1);
        sharedClient.setConnectTimeout(5);
        sharedClient.setHost("bogus");
        sharedClient.setPort(8080);
        execCodePathOne(sharedClient);
        execCodePathTwo(sharedClient);

    }

    private void execCodePathOne(final HttpClient client) {
        final Handler<Exception> requestExceptionHandler = new Handler<Exception>() {
            @Override
            public void handle(final Exception event) {
                System.out.println("There was an exception on code path One");
                // Here we might report back that this request failed, so it can be retried, or reported back up the stack.
            }
        };

        final HttpClientRequest request = client.get("/whatever", new Handler<HttpClientResponse>() {
            @Override
            public void handle(final HttpClientResponse event) {
                // Should not happen in this example, since we don't actually connect to anything
                System.out.println("Response handler One was called!");
            }
        });
        client.exceptionHandler(new Handler<Exception>() {
            @Override
            public void handle(final Exception error) {
                System.out.println("Got exception during connect for code path One.");
                // here is where we would indicate, or otherwise clean up stuff related to this request because
                // this request can noit proceed.
                requestExceptionHandler.handle(error);
            }
        });

        request.exceptionHandler(requestExceptionHandler);
        request.end();
    }

    private void execCodePathTwo(final HttpClient client) {
        final Handler<Exception> requestExceptionHandler = new Handler<Exception>() {
            @Override
            public void handle(final Exception event) {
                System.out.println("There was an exception on code path Two");
                // Here we might report back that this request failed, so it can be retried, or reported back up the stack.
            }
        };

        final HttpClientRequest request = client.get("/whatever", new Handler<HttpClientResponse>() {
            @Override
            public void handle(final HttpClientResponse event) {
                // Should not happen in this example, since we don't actually connect to anything
                System.out.println("Response handler Two was called!");
            }
        });
        client.exceptionHandler(new Handler<Exception>() {
            @Override
            public void handle(final Exception error) {
                System.out.println("Got exception during connect for code path Two.");
                // here is where we would indicate, or otherwise clean up stuff related to this request because
                // this request can noit proceed.
                requestExceptionHandler.handle(error);
            }
        });

        request.exceptionHandler(requestExceptionHandler);
        request.end();
    }
}
Results when run:
Got exception during connect for code path Two.
There was an exception on code path Two
You can see the exception handler for the first request was never called, so so it would just hang there, never having the exception handler nor end handler called.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The SockJS server documentation (http://vertx.io/core_manual_java.html#sockjs-server) states (emphasis mine):
session_timeout: The server sends a close event when a client receiving connection have not been seen for a while. This delay is configured by this setting. By default the close event will be emitted when a receiving connection wasn't seen for 5 seconds.
But the code (DefaultSockJSServer.java) is implemented as a 5 minute session timeout:
 
     config.putNumber("session_timeout", 5l * 60 * 1000);

The code is correct, the documentation is wrong.  BTW, all document versions state it as 5 seconds, not just Java's.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
both tests fail with Maven and Eclipse.
replacing
final String content = TestUtils.randomUnicodeString(10000);
with
final String content = TestUtils.randomAlphaString(10000);
works (no more failure). I did additional tests like
final String content = "This is a test:";
final String content = "This is a test: ";
and it starts failing with the first non-Ascii char
In case of failure, the "return" string matches the original up until the first unicode char
Env:
Win7: English language, but with German keyboard and date configured => iso 8859-1
Java 7
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Interface org.vertx.java.core.file.impl.ModuleDir is not used anywhere and might be deleted.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Great! Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a main.js script that deploys the mongodb persistor module like this:
mongoConfig = { ... };
vertx.deployVerticle('mongo-persistor', mongoConfig);
Vertx is installed in C:\Users\<user>\AppData\Local\vertx\.  My main.js script is stored at G:\dev\app\main.js. Before running my script using vertx, I open cmd and cd  /d G:\dev\app.  I then run vertx run main.js to start the main verticle.  These exceptions are thrown after running that command:
[vert.x-worker-thread-0] 21:25:00,501 SEVERE [deployment-ed068dce-54f0-4b8f-a0b9-ac56d99d0443-0]  Exception in Java verticle script
java.lang.IllegalArgumentException: 'other' has different root
        at sun.nio.fs.WindowsPath.relativize(Unknown Source)
        at sun.nio.fs.WindowsPath.relativize(Unknown Source)
        at org.vertx.java.deploy.impl.VerticleManager.setPathAdjustment(VerticleManager.java:198)
        at org.vertx.java.deploy.impl.VerticleManager.access$600(VerticleManager.java:50)
        at org.vertx.java.deploy.impl.VerticleManager$2.run(VerticleManager.java:286)
        at org.vertx.java.core.impl.Context$2.run(Context.java:119)
        at org.vertx.java.core.impl.Context$1.run(Context.java:109)
        at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
        at java.lang.Thread.run(Unknown Source)
[vert.x-worker-thread-0] 21:25:00,505 SEVERE [deployment-ed068dce-54f0-4b8f-a0b9-ac56d99d0443-0]  Exception in Java verticle script
java.lang.NullPointerException
        at org.vertx.mods.MongoPersistor.stop(MongoPersistor.java:77)
        at org.vertx.java.deploy.impl.VerticleManager$3.run(VerticleManager.java:422)
        at org.vertx.java.core.impl.Context$2.run(Context.java:119)
        at org.vertx.java.core.impl.Context$1.run(Context.java:109)
        at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
        at java.lang.Thread.run(Unknown Source)

I think the first exception is due to the fact that the current working directory's root, G:\, is not the same as the root directory where vertx is installed, C:\.
I did not investigate the cause of the second exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have created a Maven plugin for vert.x (https://github.com/rhart/vertx-maven-plugin) which allows verticles to be run as part of a Maven build.  Primarily useful for integration testing.  My intention was to put the plugin on Maven central using a group id of "org.vert-x.plugins" but I would need your permission to do that as you have already 'registered' the use of  "org.vert-x".  On speaking to PID he suggested that an alternative might be to fork my plugin repo into the main vert.x repo and maintain the plugin with the rest of vert.x.  Do you think this is a good idea and something you'd be happy to do??  If not then I'll just use a different group id.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I would prefer to see any changes made in multiple pull requests, not a single one.
This is because I don't necessarily want to merge all the changes (e.g. a HttpClient is only designed to be used from a single verticle, so the shared stuff should be unnecessary)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
filesystem/TestClient contains the following code:
    public void testPropsFollowLink() throws Exception {
        final String fileName = "some-file.txt";
        final long fileSize = 1234;
        final long start = 1000 * (System.currentTimeMillis() / 1000);
        createFileWithJunk(fileName, fileSize);
        final long end = 1000 * (System.currentTimeMillis() / 1000);


and the following tests
tu.azzert(st.creationTime.getTime() >= start);
tu.azzert(st.creationTime.getTime() <= end);

at least on Windows these tests fail because end is wrong. It should rather be:
final long end = 1000 * ((System.currentTimeMillis() / 1000) + 1);

see testProps where you obviously had similar issues.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On Windows tests following either testReadAsync or testWriteAsync fail, because both do not close the file at the end of the operation. UNIX and Windows file system semantics are known to be different here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What changed? It's really hard to tell with this diff... I doubt Tim will merge this like that, see his comment on another pull request: https://github.com/vert-x/vert.x/pull/201#issuecomment-6274953
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In DefaultHttpServerResponse is a variable headWritten, but it's private.
Please add a method to DefaultHttpServerResponse for checking if the headers are allready sent to the client.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please add a method in JsonObject to expose the internal map clear method, this way we can use it to "reset" the JsonObject to make it reusable, you are giving us removeField already but it is a tedious task to remove all fields if needed.
Thank you in advance!
Edit: This is for the Java Lang Api.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello!
I've found an issue about sharing files (js libraries) for modules. Here is my structure:
vert.x-app
|-- mods/
|   |-- mymod/
|      |-- mod.json
|      |-- mymod.js
|-- lib/
|   |-- lib1.js
|   |-- lib2.js
|-- conf/
|-- app.js

Some custom modules use the same libraries.
In modules I include library this way: load("lib/jsuri.js")
On linux it works fine, but on windows it doesn't work. But if i put library in module's folder then it works fine. Where is the problem? Why on linux module can see lib folder in application path but on windows it can't? May be there is a better solution with sharing libraries?
Thank you!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How does this address #250?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Tim,
Java 7 has a WatchService API. I am building a module that would like to reload a file if the file changes, and I don't think this is currently possible at the moment (according to the documentation). Would be nice if this could be added in =)
http://docs.oracle.com/javase/tutorial/essential/io/notification.html
Edit: I'm adding extra suggestions to this issue.
Regards,
Daryl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I really really wanted to get this working and submit it as a pull request, but I have spent about half a day trying to debug the Gradle build scripts to no avail.  So I am just going to describe what I was trying to do here.
Mozilla offers a GUI Debugger for Rhino.  Adding the ability to launch in Vert.x would a Good Thingtm, nor is it hard to do at all.
I created a new class called RhinoDebugContextFactory which attaches the Rhino debugger to the ContextFactory.  Then in RhinoVerticleFactory I checked an environment variable in the static initialization block, to decide which factory to use.
Then when the ContextFactory is used the GUI debugger will launch, allowing you to load JS files, set breakpoints, etc.
I have run this ball most of the way down the field.  I just need you (or someone who understands Gradle far better than I) to pick up the ball and finish.
A note on why I gave up:
To someone just coming in to try and make a quick change, the directory structure and scripts feel, frankly, needlessly complex. Nor is Gradle the most clear system in the world.
I was able to add the dependency for the Rhino debugger to the build.gradle file in vertx--lang-rhino directory.  I could see that Gradle was correctly pulling it down and installing it, but somehow it wasn't being added to the classpath.  I spent four hours trying to debug that issue, and could not spare any more time since there was no solution in sight.
Source:
RhinoDebugContextFactory:
public class RhinoDebugContextFactory extends org.mozilla.javascript.tools.shell.Main.shellContextFactory {
  RhinoDebugContextFactory() {
    // Note: This code is based on code found in this google group post:
    //   https://groups.google.com/forum/?fromgroups=#!msg/mozilla.dev.tech.js-engine.rhino/pNJlUd_2ueg/GBc2std9czEJ
    // This code is mostly copied from
    // org.mozilla.javascript.tools.debugger.Main#mainEmbeddedImpl. The
    // difference is that we do not call main.doBreak(), which would cause
    // the debugger to stop on the first line of code that it executes.
    Main main = new Main("JS Debugger");
    main.setExitAction(new Runnable() {
      public void run() {
        System.exit(0);
      }
    });

    main.attachTo(contextFactory);
    main.setScopeProvider(new ScopeProvider() {
      public Scriptable getScope() {
        throw new UnsupportedOperationException();
      }
    });

    main.pack();
    main.setSize(600, 460);
    main.setVisible(true);  
  }

  protected void onContextCreated(Context cx) {
    super.onContextCreated(cx);
    cx.getWrapFactory().setJavaPrimitiveWrap(false);
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a good idea, but I would prefer not to have two new scripts for debug which are mainly duplicates of the old scripts (these might diverge).
Instead I would prefer to see some kind of env variable set in the current script which defaults to false
e.g RHINO_DEBUG=false
and if true the script will set the system property (-Dvertx.debugRhino=true) when invoking java.
In order to enable debugging the user can edit the script or (preferably) set the env var in their shell, or invoke vertx with the ENV command.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is embarrassing, I forgot to fork my code so I could submit another pull request.  However since the change is self contained I am going to supply it here in a gist for your approval
The -jars option
The gist contains an enhancement to Starter.java to add a new command line option: -jars.
This option is an attempt to address one aspect of classpath hell the need to constantly update the -cp option as new jars are added (or removed) from a project.  The option specifies a single directory where jar files associated with the project live.  At startup tile, Vert.x scans the directory, and adds any files ending with ".jar" to the classpath.
Internally this change is quite simple.  Since Vert.x already has it's -cp option for adding things to the classpath, the -jars options just adds the jar files to the classpath before they are parsed into the urls[] array and passed into deployVerticle()
The Gist Of It:
The gist for this feature: https://gist.github.com/3682515
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fix the small whitespace error before "Ensure", please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In vertx.py, lines [129:146] :
def set_timer(delay, handler):
    """Sets a one-shot timer that will fire after a certain delay.
    This method will accept either a Proc or a block.

    Keyword arguments:
    @param delay: the delay, in milliseconds
    @param handler: a block representing the code that will be run after the delay the unique id of the timer
    """
    java_vertx().setTimer(delay, TimerHandler(handler))

def set_periodic(delay, handler):
    """Sets a periodic timer.

    Keyword arguments:
    @param delay: the period of the timer, in milliseconds
    @param handler: a block representing the code that will be when the timer fires the unique id of the timer
    """
    java_vertx().setPeriodic(delay, TimerHandler(handler))

Missing the return statements : cancel_timer function is useless without it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx.deployVerticle("myscript.coffee") tries to load the script as JS. However, running vertx run myscript.coffee from the shell works as expected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use vertx.eventBus().send(address, msg, replyHandler) send a message to another Handler, if that destination handler don't reply that message, the reply handler will exists forever, this could be a memory leak.
I suggest change send method to return a reply handler address, or add release handler mechanism when reply handler's  timeout reaching.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to solve that to automatically redeploy a vert.x module if I save a Java class in my IDE (NetBeans). The compile on save feature of NetBeans compiles the class to the target/classes directory (it's a maven based project), so I symlinked the root package of the classes dir to the module dir. When I save my Java file, the class file is updated but Vert.x doesn't redeploy the module. It does work if the classes are not symlinked.
It tried it on Ubuntu 12.04 with ext4 filesystem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
It seems that EventBus is blocking messages with an assigned "sessionID" eventhough authorization is turned off. This makes testing more difficult since it imposes that authorization is fully configured if session is required.

Cheers
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm not sure if this is a conscious design decision, but currently when you call deployVerticle, the script inherits the working directory of the verticle that deployed it. Can deployVerticle be updated to allow me to specify a particular directory as the working directory for the deployed verticle? Or is this not recommended behavior?
Regards,
Daryl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
update conf/gradle.properties
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using Vert.x in an embedded fashion, there is no way to shut down the org.vertx.java.core.Vertx instance without stopping the JVM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I can't auto merge this one - can you rejig it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
It would be nice if we could specify the placement of the logging.properties as a command line option.
This is, if we specify in the command line: -Djava.ut.logging.config.file=/path/to/logging.properties
the startup script should nop try to put it's own (fixed to /conf/logging.properties, and allow that one to be used.
This way deployment can be easier as each one can use its logging config.
Kidn regards
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TCCL is not set in all places in vert.x. It should be.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ease of use:
Provide a property like request.absolute_uri that contains the absolute URI of the request.
and while we are at it. request.base_uri would be great as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-includes can be specified when using vertx run, it allows the resources of a set of modules to be added to the classpath of the vertile
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This issue comes from a mailing-list topic: https://groups.google.com/d/topic/vertx/hfgdwnUo_rU/discussion
If the vertx support for a language is still experimental it is better if the language-support is in a module instead of the vertx core. Also if two modules need two different versions of the same language, ie because one of the modules was programmed  for an older version of the language it is necessary to load the language support from the verticle's classloader instead having it in core.
A general approach would be that if there is no suitable VerticleFactory on the main-classpath the VerticleManager looks up based on the file-extension given in the verticles name a VerticleFactory in the verticle's classpath (instead of the core-classpath)  and uses that VerticleFactory for the creation of the verticle.
For this lookup a  either a) a configuration-file which maps file-extensions to VerticleManager class-names can be used or b) (my suggestion) a default classname ie: 'org.vertx.java.deploy.impl.{extension}.{uppercase-extension}VerticleFactory' (alternative b would save the configuration file).
My proposal for parsing the name would be the regex '^.+.([a-z0-9]+)$' so that the extension is only lowercase which differntiates it from normal fully qualified java class names.
Maybe this could be baked directly into VerticleManager after normal resolution before JavaVerticleFactory fallback.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This will allow direct WebSocket connectivity.
Connecting to SockJS without the client


Any SockJS server complying with 0.3 protocol does support a raw WebSocket url.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why not just set umask to 022? That's what I always do.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
following the example here:
http://vertx.io/core_manual_python.html#extracting-parameters-from-the-path
I tried adding some params to the routematcher
rm = RouteMatcher
rm.get('/user/:user_uuid', matched)
This did not match as expected. I expected a GET to '/user/foo' would match and params['user_uuid'] would contain foo. However the only pattern that would match was "/user/user_uuid" and instead of "user_uuid" in params there was an index of params['user'] = 'user' It seems the underscore caused an issue.
When I removed the underscore, everything worked as expected
rm = RouteMatcher
rm.get('/user/:uuid', matched)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
http://vertx.io/core_manual_python.html#routing-http-requests-with-pattern-matching
import vertx
-from core.http import RouterMatcher
+from core.http import RouteMatcher

-server = vert.create_http_server()
+server = vertx.create_http_server()

route_matcher = RouteMatcher()

-server.request_Handler(route_matcher).listen(8080, 'localhost')
+server.request_handler(route_matcher).listen(8080, 'localhost')
http://vertx.io/core_manual_python.html#specifying-matches
-server = vert.create_http_server()
+server = vertx.create_http_server()
http://vertx.io/core_manual_python.html#extracting-parameters-from-the-path
-server = vert.create_http_server()
+server = vertx.create_http_server()
http://vertx.io/core_manual_python.html#extracting-params-using-regular-expressions
-server = vert.create_http_server()
+server = vertx.create_http_server()
http://vertx.io/core_manual_python.html#catching-exceptions-on-the-net-client
import vertx

client = vertx.create_net_client()

@client.exception_handler
def exception_handler(ex):
    print 'Cannot connect since the host does not exist!'

def connect_handler(sock):
-    print 'this won't get called'
+    print "this won't get called"

client.connect(4242, 'host-that-doesnt-exist', connect_handler)
I've found the docs easy to follow and concise. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Any plan to add middleware concept into the library in a pure Java form? Not really rocket science but in other languages, we often have a good lib to handle some basic stuff like handling headers...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Memory leak was occurring with non websockets transports resulting in sessions not being timed out and therefore building up in memory.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The trouble is the examples won't run if you do this.
As well as supporting compiled Java classes, Vert.x allows you to write lightweight verticles as straight .java files without manually having to compile them. Only the default package is supported when doing this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
EventBusBridge.java
Line 142 :
if (checkMatches(false, address, msg.body, false)) {
It would be interesting to handle auth requirement for outbound messages (server to client broadcasting/publishing) so only authed socket (i.e. socket with a session ID attached) can receive the messages.
Simple mod :
if (checkMatches(false, address, msg.body, sockAuths.get(sock) != null && !sockAuths.get(sock).isEmpty())) {
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I like the idea, but your current implementation is inefficient since it does the lookup twice.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I already fixed this locally, but thanks anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
note:  I hit this on a fork of a fork.  I don't think this has been fixed in main, but I'm not 100% sure.  apologies if this is already fixed.

Windows 7 Enterprise

Get vertx source
install jython
set JYTHON_HOME to jython install directory (not the /bin dir)
open windows cmd shell
cd to vertx source dir (where wmk.bat is)
run:  wmk.bat -x yard install

expected
a successful build
actual
build fails with
:vertx-lang-jython:pydoc
FAILURE: Build failed with an exception.

What went wrong:
Execution failed for task ':vertx-lang-jython:pydoc'.

A problem occurred starting process 'command 'C:\programs\jython2.5.3/jython''



Caused by: java.io.IOException: Cannot run program "C:\programs\jython2.5.3/jython" (in directory "C:\Dev\Git\vert.x\vertx-lang\vertx-lang-jython"): CreateProcess error=2
, The system cannot find the file specified
I "fixed" this by modifying
/vertx-lang/vertx-lang-jython/build.gradle
to include the '.bat' file extension to "/jython" @ l.47.  After my "fix", It seems like there's still an error in the build step, but it's non-fatal. Sorry I don't have time to really fix it :(
full stack trace:

Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':vertx-lang-jython:pydoc'.
at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:68)
at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:34)
at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter$1.run(CacheLockHandlingTaskExecuter.java:34)
at org.gradle.cache.internal.DefaultCacheAccess$2.create(DefaultCacheAccess.java:200)
at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:172)
at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:198)
at org.gradle.cache.internal.DefaultPersistentDirectoryStore.longRunningOperation(DefaultPersistentDirectoryStore.java:137)
at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.longRunningOperation(DefaultTaskArtifactStateCacheAccess.java:83)
at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter.execute(CacheLockHandlingTaskExecuter.java:32)
at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:55)
at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:57)
at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:41)
at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:51)
at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:52)
at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:42)
at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:247)
at org.gradle.execution.DefaultTaskGraphExecuter.executeTask(DefaultTaskGraphExecuter.java:192)
at org.gradle.execution.DefaultTaskGraphExecuter.doExecute(DefaultTaskGraphExecuter.java:177)
at org.gradle.execution.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:83)
at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:36)
at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter$1.run(TaskCacheLockHandlingBuildExecuter.java:31)
at org.gradle.cache.internal.DefaultCacheAccess$1.create(DefaultCacheAccess.java:111)
at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:126)
at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:109)
at org.gradle.cache.internal.DefaultPersistentDirectoryStore.useCache(DefaultPersistentDirectoryStore.java:129)
at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.useCache(DefaultTaskArtifactStateCacheAccess.java:79)
at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter.execute(TaskCacheLockHandlingBuildExecuter.java:29)
at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)
at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:155)
at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:110)
at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:78)
at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:38)
at org.gradle.launcher.exec.InProcessGradleLauncherActionExecuter.execute(InProcessGradleLauncherActionExecuter.java:39)
at org.gradle.launcher.exec.InProcessGradleLauncherActionExecuter.execute(InProcessGradleLauncherActionExecuter.java:25)
at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:50)
at org.gradle.launcher.cli.ActionAdapter.execute(ActionAdapter.java:30)
at org.gradle.launcher.cli.ActionAdapter.execute(ActionAdapter.java:22)
at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:200)
at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:173)
at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169)
at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:138)
at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
at org.gradle.launcher.Main.doAction(Main.java:48)
at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
at org.gradle.launcher.Main.main(Main.java:39)
at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:50)
at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:32)
at org.gradle.launcher.GradleMain.main(GradleMain.java:26)
at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:33)
at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:124)
at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:53)
Caused by: org.gradle.process.internal.ExecException: A problem occurred starting process 'command 'C:\programs\jython2.5.3/jython''
at org.gradle.process.internal.DefaultExecHandle.setEndStateInfo(DefaultExecHandle.java:195)
at org.gradle.process.internal.DefaultExecHandle.failed(DefaultExecHandle.java:325)
at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:90)
at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
Caused by: java.io.IOException: Cannot run program "C:\programs\jython2.5.3/jython" (in directory "C:\Dev\Git\vert.x\vertx-lang\vertx-lang-jython"): CreateProcess error=2
, The system cannot find the file specified
at org.gradle.process.internal.ExecHandleRunner.run(ExecHandleRunner.java:71)
... 1 more
Caused by: java.io.IOException: CreateProcess error=2, The system cannot find the file specified
... 2 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To see a test case that demonstrates the motivations for this please see:  https://github.com/vert-x/vert.x/issues/325
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please also consider looking at this soon, as it was submitted about 3 months ago, I know I have seen people asking for this feature. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please also consider looking at this soon, as it was submitted about 3 months ago, I know I have seen people asking for this feature. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are some good points here, but this is a big change and we'd really have to update the APIs in other languages too.
I think I'd therefore like to postpone this to Vert.x 2.0 (which I want to start working on soon)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When the Handler is part of a RouteMatcher, sendFile doesn't seem to resolve the dependencies of a html-file (like javascript-, css-tags).
for example, this one works fine:
vertx.createHttpServer().requestHandler(new Handler<HttpServerRequest>() {
  public void handle(HttpServerRequest req) {
    req.response.sendFile("webroot/index.html");
  }
}).listen(3001);
this one doesn't, it only loads the html-file:
HttpServer server = vertx.createHttpServer();
RouteMatcher routeMatcher = new RouteMatcher();
routeMatcher.get("/", new Handler<HttpServerRequest>() {
  public void handle(HttpServerRequest req) {
    req.response.sendFile("webroot/index.html");
  }
});
server.requestHandler(routeMatcher).listen(3001);
bug or intended?
I am using 123final embedded.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is probably going to be a lot of work.
I would like the Handler class to accept a "Error" parameter in the handle method. Every callback mechanism that could possibly end in an error should therefore pass through the error to the calling source.
Use Case:
I call deployModule, but deployModule fails silently (aside from the default vertx exception that is logged). There isn't a way for me to capture the exception that caused it (for example, IllegalStateException).
Having the error parameter in Handler is probably the easiest solution that I could think of. The alternative would be each functionality having 2 Handlers for Done and Error. The former solution I propose might change how people deal with the handlers (as now the handler gets called regardless of success). The latter will minimise that, but requires more work in the core.
Edit: turns out there is a AsyncResultHandler class. However, this does not work with deployModule. Thus deployModule needs to use AsyncResultHandler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Performance will be bad when setDisableUsingOccupiedConnections=true since this effectively means no pipelining takes place, so performance will be limited by the latency of the connection.
Other comments.. when benchmarking let the JIT warm up for several minutes first, and discard results from that period.
You also need to run for much, much longer to get reliable results, e.g. to minimise non-determinism due to GC.
I recommend running for several minutes (in which time many thousands of requests will be sent).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add cookies() support to all langs and add section in docs about this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
container.deployModule("BusMod A", conf, instanceNr, deployedHandler) causes an half initialized BusMod A if the BusMod A has to deploy other BusMods. The deployHandler callback is called and does indicate a successful load of BusMod A, while actually A has not loaded all its depended BusMods.
This behaviour of deplyModule() causes unnecessary wait code and might get a heavy problem if BusMods are deployed during runtime, because the deploying Verticle cannot be sure when his depolyed BusMod is really ready for usage.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The following tests are currently failing on Windows. I even created a new clone to make sure everything is clean. Since gradle test output is really poor (and obviously can't be changed easily), no additional infos beyond "java.lang.IllegalStateException: Timed out waiting for event" are available. All these tests passed before Christmas.
GroovyHttpTest.testCONNECTSSL
GroovyHttpTest.testCONNECTSSLChunked
GroovyHttpTest.testDELETESSL
GroovyHttpTest.testDELETESSLChunked
GroovyHttpTest.testGetSSL
GroovyHttpTest.testGetSSLChunked
GroovyHttpTest.testHEADSSL
GroovyHttpTest.testHEADSSLChunked
GroovyHttpTest.testOPTIONSSSL
GroovyHttpTest.testOPTIONSSSLChunked
GroovyHttpTest.testPATCHSSL
GroovyHttpTest.testPATCHSSLChunked
GroovyHttpTest.testPOSTSSL
GroovyHttpTest.testPOSTSSLChunked
GroovyHttpTest.testPUTSSL
GroovyHttpTest.testPUTSSLChunked
GroovyHttpTest.testTRACESSL
GroovyHttpTest.testTRACESSLChunked
JavaHttpTest.testTLSClientCertNotRequired
JavaHttpTest.testTLSClientCertRequired
JavaHttpTest.testTLSClientTrustAll
JavaHttpTest.testTLSClientTrustServerCert
JavaScriptHttpTest.testCONNECTSSL
JavaScriptHttpTest.testCONNECTSSLChunked
JavaScriptHttpTest.testDELETESSL
JavaScriptHttpTest.testDELETESSLChunked
JavaScriptHttpTest.testGetSSL
JavaScriptHttpTest.testGetSSLChunked
JavaScriptHttpTest.testHEADSSL
JavaScriptHttpTest.testHEADSSLChunked
JavaScriptHttpTest.testOPTIONSSSL
JavaScriptHttpTest.testOPTIONSSSLChunked
JavaScriptHttpTest.testPATCHSSL
JavaScriptHttpTest.testPATCHSSLChunked
JavaScriptHttpTest.testPOSTSSL
JavaScriptHttpTest.testPOSTSSLChunked
JavaScriptHttpTest.testPUTSSL
JavaScriptHttpTest.testPUTSSLChunked
JavaScriptHttpTest.testTRACESSL
JavaScriptHttpTest.testTRACESSLChunked
PythonHttpTest.test_connect_ssl
PythonHttpTest.test_connect_ssl_chunked
PythonHttpTest.test_delete_ssl
PythonHttpTest.test_delete_ssl_chunked
PythonHttpTest.test_get_ssl
PythonHttpTest.test_get_ssl_chunked
PythonHttpTest.test_head_ssl
PythonHttpTest.test_head_ssl_chunked
PythonHttpTest.test_options_ssl
PythonHttpTest.test_options_ssl_chunked
PythonHttpTest.test_patch_ssl
PythonHttpTest.test_patch_ssl_chunked
PythonHttpTest.test_post_ssl
PythonHttpTest.test_post_ssl_chunked
PythonHttpTest.test_put_ssl
PythonHttpTest.test_put_ssl_chunked
PythonHttpTest.test_trace_ssl
PythonHttpTest.test_trace_ssl_chunked
RubyHttpTest.test_connect_ssl
RubyHttpTest.test_connect_ssl_chunked
RubyHttpTest.test_delete_ssl
RubyHttpTest.test_delete_ssl_chunked
RubyHttpTest.test_get_ssl
RubyHttpTest.test_get_ssl_chunked
RubyHttpTest.test_head_ssl
RubyHttpTest.test_head_ssl_chunked
RubyHttpTest.test_options_ssl
RubyHttpTest.test_options_ssl_chunked
RubyHttpTest.test_patch_ssl
RubyHttpTest.test_patch_ssl_chunked
RubyHttpTest.test_post_ssl
RubyHttpTest.test_post_ssl_chunked
RubyHttpTest.test_put_ssl
RubyHttpTest.test_put_ssl_chunked
RubyHttpTest.test_trace_ssl
RubyHttpTest.test_trace_ssl_chunked
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Janne,
When I create a module where the main is a Java source file in a package, it fails with the following:
tim@tim-laptop ~/projects/vert-x/vert.x/vertx-examples/src/main/java/sourcemod $ ../../vertx-dev runmod test-mod-v1.0
Failed to create verticle
java.lang.RuntimeException: Package structure does not match directory structure: org != foo
at org.vertx.java.deploy.impl.java.JavaSourceContext.(JavaSourceContext.java:50)
at org.vertx.java.deploy.impl.java.CompilingClassLoader.(CompilingClassLoader.java:52)
at org.vertx.java.deploy.impl.java.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:48)
at org.vertx.java.deploy.impl.VerticleManager$10.run(VerticleManager.java:778)
at org.vertx.java.core.impl.Context$2.run(Context.java:119)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:453)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:330)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:35)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:102)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
at java.lang.Thread.run(Thread.java:722)
I've added the example in master in vertx-examples/src/main/java/sourcemod
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Any chance you can collect & squash them?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With :
msg.reply([list:((1..2).collec t{ [name:"source $it"] })])
I send (reply) :
[list:[[name:source 1], [name:source 2]]]
I receive :
[list:[[name:[values:[1], strings:[source , ], valueCount:1]], [name:[values:[2], strings:[source , ], valueCount:1]]]]

Now with "as String" :
msg.reply([list:((1..2).collec t{ [name:"source $it" as String] })])
I receive :
[list:[[name:source 1], [name:source 2]]]

Original message : https://groups.google.com/d/msg/vertx/rDaWWs38Xrw/lYDnwVm3_fkJ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using vert.x-1.3.0.final with groovy on Win7-x64 with JDK7u10-x64 (client) and Ubuntu-x64 with JDK7u9-x64 (server)
I have a client that sends a file to a server, which sends back another file.
Client:
package upload

import static org.vertx.groovy.core.streams.Pump.createPump

def config = container.config
def filename = config["filename"];
def fs = vertx.fileSystem

def req = vertx.createHttpClient(port: 8888).put("/someurl") {
  resp -> println "Response ${resp.statusCode}"
  fs.open("bigfile.bin") { x ->
    def file = x.result
    def ws = file.writeStream
    def pump = createPump(resp, ws)
    resp.endHandler { 
      file.close() {
        println "Received ${pump.bytesPumped} bytes as bigfile.bin"
        container.exit()
      }
    }
    pump.start()
  }
}

fs.props(filename) { ares ->
  def props = ares.result
  println "props is ${props}"
  def size = props.size
  req.headers["filename"] = filename
  req.headers["content-length"] = size

  fs.open(filename) { ares2 ->
    def file = ares2.result
    def rs = file.readStream
    def pump = createPump(rs, req)
    rs.endHandler { 
      req.end() 
    }
    pump.start()
  }
}
Server:
package upload

import static org.vertx.groovy.core.streams.Pump.createPump

vertx.createHttpServer().requestHandler { req ->
  req.pause()
  def filename = "upload/" + req.headers["filename"]
  vertx.fileSystem.open(filename) { ares ->
    def file = ares.result
    def pump = createPump(req, file.writeStream)
    req.endHandler {
      file.close {
        println "Uploaded ${pump.bytesPumped} bytes to $filename"
        req.response.sendFile "bigfile.bin"
      }
    }
    pump.start()
    req.resume()
  }
}.listen(8888)
The transfer from client to server (8436350 bytes in my case) works fine.
The transfer back however loses bytes!
On the server, bigfile.bin is 40902656 bytes.
After I start the server and leave it running, this is what the client prints:
1st run: Received 40901632 bytes as bigfile.bin
2nd run: Received 40901677 bytes as bigfile.bin
3rd run: Received 40901677 bytes as bigfile.bin
Neither the client code, nor the server code, nor bigfile.bin have changed. In fact, the server wasn't even stopped, and yet the response vary.
All returned files are corrupt.
1st run: 1024 bytes missing
2nd run: 979 bytes missing
3rd run: 979 bytes missing
This makes the sendfile functionality currently unusable for me, as data corruption is not an option.
Cheers
Axel
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Btw, this is no longer required when using Rhino 1.7R4 as it can split code into smaller chunks to avoid JVM 64k method size limit.
context.setOptimizationLevel(-1); // Without this, Rhino hits a 64K bytecode limit and fails
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reproducible by running Groovy SockJS example https://github.com/vert-x/vert.x/blob/master/vertx-examples/src/main/groovy/sockjs/index.html 
Modify the index.html to limit to xhr-streaming:
var sock = new SockJS('http://localhost:8080/testapp', {}, {protocols_whitelist: ['xhr-streaming']});

Serve this file from a different host and run the demo, you will get a CORS error in the browser.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Janne - Any chance you could resubmit this against the mod-lang-rhino project?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For cases when
long n <= Integer.MAX_VALUE
do the following:
JsonObject config = new JsonObject();
...
config.putNumber("my_config", nL);
or
config.putNumber("my_config", Long.valueOf(n));
....
getOptionalLongConfig("my_config", 10000L) in BusModBase throws
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long
at org.vertx.java.busmods.BusModBase.getOptionalLongConfig(BusModBase.java:109)
...
at org.vertx.java.deploy.impl.VerticleManager$10.run(VerticleManager.java:803)
at org.vertx.java.core.impl.Context$2.run(Context.java:119)
at org.vertx.java.core.impl.Context$1.run(Context.java:108)
at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
Not really an issue, but I was thinking that it would be great if we can have sticky sessions enabled at Vertx level.
The idea is that based on some criteria (maybe params or url pattern or cookies) Vertx should send similar requests to the same worker so that that worker can initialize a local cache in order to deal with those requests.
The use-case of this can be seen in the case of implementing rate-limit on an API. If all the requests with the same parameter (api_key) are sent to the same worker, we should be able to initialize a local cache to store the current rate limit and easily accept or deny a request. With this strategy we can simply remove a lot of complexity of an external storage. I think there would be a lot more use cases like this.
Just I am just wondering if we have this functionality in place or if this can be considered a feature.
Regards,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a HTTP HEAD response gives a "Content-length" different from 0, the callback is never called, createHttpClient.head(uri, callback). As defined in HTTP Specification, HEAD response must not have content even if Content-Length is defined in the headers.
The problem is that in vert.x the HttpResponseDecoder class is used but Netty handle the specific case of HEAD in a super class HttpClientCodec.
Note that CONNECT may also suffer from this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The existing ThreadPoolExecutor implementations do not expose their metrics.
Provide a custom ThreadPoolExecutorFactory that simplifies this and exposes the metrics, in preparation for the addition of JMX support.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It should be possible to increase (and decrease) the number of instances of a deployed verticle at runtime, (without starting a new verticle bound to the same server instance).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just like it says on the tin.
-Dvertx.langs.foo=org.vertx.FooLangFactory
Will override the properties loaded from the langs.properties file.
This will make test configuration and language implementation dev easier.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Moving the language tests to each language implementations test source set will make it easier for contributors to see the requirements for developing a language implementation.
It may also mean that builds of the project can run faster through Gradle's parallelisation features.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks, applied manually.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've downloaded the 1.3.1.final release and it seam that the sockjs examples fallback doesn't work properly on IE8.
I've tried the javascript and the java samples with the same result :
on Chrome (latest) and Safari (latest) it work fine because it uses websocket connection.
On IE 8  there's not fallback as expected (the close method is immediately called on the socket in the browser)
I've tried adding whitelist protocols but it's not better
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Java version 1.7.0 (JRE/JDK)
I did follow as per the instruction but getting error:


I have downloaded vert.x.1.3.1.final to d:\vertx. (Windows 7) and unziped (contains folder --> lib (vertx jsrs), examples, conf, client, bin, api-docs).


added d:\vertx\bin to System path and tested in the command prompt if I run vertx, it give all the option.


CD to d:\vertx\examples\java and then executed command "vertx run http\ServerExample.java (also without java ext).
Error without .java ext:   Cannot find verticle ServerExample
Error with .java ext:


Failed to create verticle
java.lang.RuntimeException: Compilation failed
at org.vertx.java.deploy.impl.java.CompilingClassLoader.(CompilingClassLoader.java:75)
at org.vertx.java.deploy.impl.java.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:48)
at org.vertx.java.deploy.impl.VerticleManager$10.run(VerticleManager.java:777)
at org.vertx.java.core.impl.Context$2.run(Context.java:119)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:454)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:331)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:35)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:102)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
at java.lang.Thread.run(Unknown Source)
Caused by: java.lang.NullPointerException
at org.vertx.java.deploy.impl.java.CompilingClassLoader.(CompilingClassLoader.java:57)
... 11 more
The strange part is I able to run Javascript version   but Java version is failing 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
duplicate issue
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello.
Thank you very much for this incredible product.
I would like to extend mod-auth-mgr to add role-based authorizations.
I think it should be interesting to add "address" to the parameters in
Before: protected void doAuthorise(Message message);
After: protected void doAuthorise(String address, Message message);
Best regards,
Paco Hernndez.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jackson is into the 2.1 series already. Presumably there's some benefit in upgrading, investigate/test to find out...
http://jackson.codehaus.org/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Right now, the test suites rely on messages via the eventbus to know when a module really is deployed (sends a message to "test-handler" when all async operations in start() are done).
There should be a built-in construct to be able to tell at verticle deployment when a verticle and all of its dependencies are loaded/started, which might be problematic since you can do async operations inside the start method.
A proposal for Java would be to have a second start method:
protected void start(SimpleHandler whenDone) { start(); whenDone.handle(); }
Which the developer should overwrite in case of async operations in his start method and call the whenDone.handle() after everything is loaded.
For scripting languages, this could be a little more complex. The starter could return a boolean true at the end to make Vert.x aware, that it will call a method to show that it's finished (proposal: vertx.startedAsync()). If it doesn't return a boolean true, it will behave as the standard start() method right now (not considering async operations inside it).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wouldn't it be better to have Gradle set the version inside this file when building?
Edit: Sorry, didn't see the mailing list post, when I posted this -.-
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I realize this may simply be because the language loading for groovy just isn't done yet, but figured it couldn't hurt to report it.
This report is based on vert.x master (g17a47c3) and mod-lang-groovy master (18fb958b)
With a simple main app in groovy, and a hand-rolled groovy module called monitor.
Main App
import org.vertx.groovy.core.http.RouteMatcher

def server = vertx.createHttpServer()
def rm = new RouteMatcher()
def config = ["prefix":"/eventbus"]

rm.get("/") { req ->
    req.response.sendFile "web/index.html"
}
rm.get("/vertxbus.js") { req ->
    req.response.sendFile "web/js/vertxbus.js"
}

server.requestHandler(rm.asClosure());
vertx.createSockJSServer(server).bridge(config, [[:]],[[:]]) 

container.deployModule('vertx.mongo-persistor-v1.2') { deploymentID ->
  println "mongo deployed $deploymentID"
}

container.deployModule('com.example.monitor-v1.0',[ : ],1) { deploymentID ->
  println "monitor deployed $deploymentID"
}
//container.deployModule('com.example.jsmon-v1.0',["some-var" : "hello"],1) { deploymentID ->
//  println "monitor deployed $deploymentID"
//}

server.listen(9000);
Module
In <app-dir>/mods/com.example.monitor-v1.0
monitor.groovy
def eb = vertx.eventBus

eb.registerHandler("monitor") { message ->
  println message
}

mod.json
{
  "main": "monitor.groovy"
}
Deployment of the groovy module from the app results in this. (but if you instead load the JS module that is commented out, it works)
$ vertx run app.groovy 
Failed to create verticle monitor.groovy in org.vertx.groovy.platform.impl.GroovyVerticleFactory 
java.lang.IllegalStateException: Circular dependency in module includes.
    at org.vertx.java.platform.impl.ModuleClassLoader.checkAlreadyWalked(ModuleClassLoader.java:136)
    at org.vertx.java.platform.impl.ModuleClassLoader.getResources(ModuleClassLoader.java:201)
    at java.lang.ClassLoader.getResources(ClassLoader.java:1172)
    at org.codehaus.groovy.transform.ASTTransformationVisitor.doAddGlobalTransforms(ASTTransformationVisitor.java:198)
    at org.codehaus.groovy.transform.ASTTransformationVisitor.addGlobalTransforms(ASTTransformationVisitor.java:190)
    at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:154)
    at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:196)
    at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:119)
    at groovy.lang.GroovyClassLoader.createCompilationUnit(GroovyClassLoader.java:432)
    at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:267)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)
    at groovy.lang.GroovyClassLoader$parseClass.call(Unknown Source)
    at org.vertx.groovy.platform.impl.GroovyVerticleFactory.createVerticle(GroovyVerticleFactory.groovy:53)
    at org.vertx.java.platform.impl.DefaultPlatformManager$11.run(DefaultPlatformManager.java:1059)
    at org.vertx.java.core.impl.Context$1.run(Context.java:150)
    at org.jboss.netty.channel.socket.nio.AbstractNioSelector.processTaskQueue(AbstractNioSelector.java:366)
    at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:290)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:88)
    at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
    at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
    at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
    at java.lang.Thread.run(Thread.java:722)

monitor deployed null
mongo deployed deployment-e3ffbd8d-2668-49fc-b84c-f1aab3d95aee
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to use msg.reply(jsonObject) in a workerVerticle on a cluster with one maschine running the http verticle and another running the worker. I'm using this code for deployment:
container.deployWorkerVerticle("de.isogmbh.ad.verticle.DatabaseWorker", new JsonObject(), config.getInteger("vertx.db.instances"), new Handler<String>() {  
    @Override
    public void handle(String arg0) {
        container.getLogger().info("Database Worker Deployed");
        container.getLogger().info("Deploy finished");

    }
});
container.deployVerticle("de.isogmbh.ad.verticle.HttpServer", new JsonObject(), config.getInteger("vertx.http.instances"), new Handler<String>() {
    @Override
    public void handle(String arg0) {
        container.getLogger().info("Http Server Deployed");
    }
});
when I'm running this with 4http instances and 4 worker instances on one maschine everything works fine.
when running on two maschines with one 0http 4worker and another 4http 0worker, this exception is thrown:
Exception in Java verticle script
java.lang.IllegalStateException: Cannot be used in a worker application
        at org.vertx.java.core.net.impl.DefaultNetClient.<init>(DefaultNetClient.java:60)
        at org.vertx.java.core.impl.DefaultVertx.createNetClient(DefaultVertx.java:123)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus.sendRemote(DefaultEventBus.java:509)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus.sendOrPub(DefaultEventBus.java:378)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus.sendReply(DefaultEventBus.java:310)
        at org.vertx.java.core.eventbus.impl.BaseMessage.reply(BaseMessage.java:53)
        at org.vertx.java.core.eventbus.Message.reply(Message.java:58)
        at de.isogmbh.ad.verticle.DatabaseWorker.handle(DatabaseWorker.java:71)
        at de.isogmbh.ad.verticle.DatabaseWorker.handle(DatabaseWorker.java:1)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus$7.run(DefaultEventBus.java:592)
        at org.vertx.java.core.impl.Context$2.run(Context.java:119)
        at org.vertx.java.core.impl.Context$1.run(Context.java:108)
        at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
        at java.lang.Thread.run(Thread.java:722)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the server test code (server.js):
load('vertx.js');

vertx.createHttpServer().requestHandler(function (req) {
  req.response.end("something");
}).listen(8080);

Started with: vertx run server.js
Now running:
curl -G http://localhost:8080/    # works
curl -G http://localhost:8080//   # doesn't work
curl -G http://localhost:8080///  # works

Tested with Vert.x 1.3.1.final.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems that vertxbus.js was removed from webapp/web/js folder, causing errors on loading.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is there a reason the readyState on the eventBus is not a property ?
See https://github.com/vert-x/vert.x/blob/master/src/dist/client/vertxbus.js#L92
Folks that are familiar with WebSocket (or SockJS), would expect it to be a property...
Now - with vertx - the following does not really work:
myCon.readyState === OPEN

For vert.x it would need to be written like:
myCon.readystate() === ...

which is a bit different/odd
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
I figured out that you can't delete an element in a JavaScript array.
f.e.:
load('vertx.js');

var elements = [1,2,3,4]

elements.forEach(function(element){
    if(element == 3){
        delete element;
    }
});

console.log(elements.length);
That will print out 4
Thanks,
CodeChiller
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Websokcet bridge - can this be enhanced so that we're not forced to use JSONObject, but can say use String directly instead?
See #172 as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unfortunately the code has diverged too much to apply this, so closing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
Just want to test out the classloader in Vertx master branch.
As in the wiki https://github.com/vert-x/vert.x/wiki/Vert.x-2.0-tasks
Classloader refactoring - DONE
Each module/verticle type has its own classloader, not a classloader per instance
See Vert.x 2.0 plan for more information

Since a Verticle has its own classloader (not per instance) I would think that I can create an singleton class (connection pool) and reuse it between instances. I wrote a very simple example here:
https://github.com/phungleson/vertx-classloader/tree/master/src/main/java/vertx/classloader
If my theory is correct when I run https://github.com/phungleson/vertx-classloader/blob/master/start with -instances 2 it should display only one line of Singleton constructor but somehow the results are 2 lines, meaning Singleton class is loaded twice.
Not sure if my understand is correct or I need to enable something or it is the way it should react and no more changes will be done in terms of classloader in Vertx 2?
Regards,
Son.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When installing a module on windows through the maven resolver I get following exception:
[vertx] Schwerwiegend: Failed to move module
[vertx] java.nio.file.InvalidPathException: Illegal char <:> at index 51: C:\programmierung\myprojects\yeti\yvertx\mods\maven:com.github.chrisichris:yvertx-module:0.9
NAPSHOT
[vertx]     at sun.nio.fs.WindowsPathParser.normalize(Unknown Source)
[vertx]     at sun.nio.fs.WindowsPathParser.parse(Unknown Source)
[vertx]     at sun.nio.fs.WindowsPathParser.parse(Unknown Source)
[vertx]     at sun.nio.fs.WindowsPath.parse(Unknown Source)
[vertx]     at sun.nio.fs.WindowsFileSystem.getPath(Unknown Source)
[vertx]     at java.nio.file.Paths.get(Unknown Source)
[vertx]     at org.vertx.java.core.file.impl.DefaultFileSystem.moveInternal(DefaultFileSystem.java:349)
[vertx]     at org.vertx.java.core.file.impl.DefaultFileSystem.moveSync(DefaultFileSystem.java:75)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.unzipModule(DefaultPlatformManager.java:913)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.doInstallMod(DefaultPlatformManager.java:814)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.loadIncludedModules(DefaultPlatformManager.java:690)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.doDeploy(DefaultPlatformManager.java:1059)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.doDeployMod(DefaultPlatformManager.java:650)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager.access$100(DefaultPlatformManager.java:53)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager$1.action(DefaultPlatformManager.java:147)
[vertx]     at org.vertx.java.platform.impl.DefaultPlatformManager$1.action(DefaultPlatformManager.java:143)
[vertx]     at org.vertx.java.core.impl.BlockingAction$1.run(BlockingAction.java:51)
[vertx]     at org.vertx.java.core.impl.Context$1.run(Context.java:126)
[vertx]     at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.run(OrderedExecutorFactory.java:90)
[vertx]     at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
[vertx]     at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
[vertx]     at java.lang.Thread.run(Unknown Source)
[vertx] Mr 05, 2013 12:22:22 PM org.vertx.java.core.logging.impl.JULLogDelegate error
[vertx] Schwerwiegend: Failed to load module: maven:com.github.chrisichris:yvertx-module:0.9.8-SNAPSHOT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the 'main' name of a groovy class verticle starts with the language prefix "groovy:".  This causes a nullpointer when deploying modules programmatically from a groovy class verticle.
Failed to deploy verticle
java.lang.NullPointerException
at java.util.concurrent.ConcurrentHashMap.hash(ConcurrentHashMap.java:332)
at java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1124)
at org.vertx.java.core.impl.ConcurrentHashSet.add(ConcurrentHashSet.java:74)
at org.vertx.java.platform.impl.ModuleClassLoader.addParent(ModuleClassLoader.java:50)
at org.vertx.java.platform.impl.DefaultPlatformManager.doDeployMod(DefaultPlatformManager.java:635)
at org.vertx.java.platform.impl.DefaultPlatformManager.access$100(DefaultPlatformManager.java:53)
at org.vertx.java.platform.impl.DefaultPlatformManager$1.action(DefaultPlatformManager.java:147)
at org.vertx.java.platform.impl.DefaultPlatformManager$1.action(DefaultPlatformManager.java:143)
at org.vertx.java.core.impl.BlockingAction$1.run(BlockingAction.java:51)
at org.vertx.java.core.impl.Context$1.run(Context.java:126)
This can be fixed by adding making the following change to DefaultPlatformManager.java at line 455.  Not sure if this is the best fix, or if its already sorted in another way.
essentially, remove "groovy:" from the main "groovy:classname"
String enclosingModName = getEnclosingModuleName();
String mainName = main;
if (main.contains(":")) {
mainName = main.split(":")[1];
}
String moduleKey = (enclosingModName == null ? depName : enclosingModName) + "." + mainName;
at org.vertx.java.core.impl.OrderedExecutorFactory$OrderedExecutor$1.

Thanks.
Please see google groups discussion topic
https://groups.google.com/forum/?hl=en&fromgroups=#!topic/vertx/_NrFhX7CGBw
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This definitely applies to DefaultAsyncFile; I'm assuming it applies to other WriteStream implementations, too.
When a drainHandler is invoked, its reference is set to null.  This means that I have to set the handler every time the write queue fills up.  I should be able to set the drainHandler once and be notified every time it triggers.  The current behavior isn't documented, is confusing, and makes more work for the developer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As far as I can tell all examples was ported by now.. So we can just close it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To support multiple hosts/ports
Take into account https://github.com/vert-x/vert.x/pull/482
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is this the ASL version?
I believe Jackson has a weird licensing policy ASL and LGPL.
We wouldn't be able to use the LGPL version in Vert.x
Just want to confirm first that this is the ASL 2.0 version we're using....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unfortunately the master branch has diverged so much since this PR was submitted it's impossible to apply. So closing. Sorry!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Whould be nice improvement if the Json.decodeValue (see https://github.com/vert-x/vert.x/blob/master/vertx-core/src/main/java/org/vertx/java/core/json/impl/Json.java#L53) would use generics, e.g. like:
 public static <T> T decodeValue(String str, Class<?> clazz) throws DecodeException;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Session implementation of the SockJSSocket keeps track of the write queue's size with messagesSize. This variable grows when the write queue is given a new message (Session.java#L89), but never shrinks when the write operation is performed. The drainHandler will never be called once messagesSize grows passed maxQueueSize / 2 (Session.java#212).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there any API that allows to restart (or at least just stop) Vert.x from inside a verticle.
If not, please add it.
Especially for "admin" related verticles that any production ready solution needs, this would be a must.
regards.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When something "unexpected" happens in my Java-based Vert.x server, I see this sort of output in stdout:
Exception in Java verticle script 
java.lang.NullPointerException
  at java.net.URLEncoder.encode(URLEncoder.java:205)
  at locationserver.editor.Editor.getEditorData(Editor.java:80)
  <snip>
  at locationserver.Server.handle(Server.java:1)
  at org.vertx.java.core.http.impl.ServerConnection.handleRequest(ServerConnection.java:122)
  at org.vertx.java.core.http.impl.ServerConnection.processMessage(ServerConnection.java:245)
  at org.vertx.java.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:94)
  at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler.messageReceived(DefaultHttpServer.java:537)
  at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:75)
  <snip>
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
  at java.lang.Thread.run(Thread.java:722)

Is there any way for me to programmatically handle uncaught exceptions like these?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
After switching to the latest vert.x version (2.0.0-SNAPSHOT with netty 4.0.0.CR1) I've got this error:

org.elasticsearch.transport.RemoteTransportException: nextOutboundMessageBuffer() called from outside the eventLoop
Caused by: org.elasticsearch.transport.ResponseHandlerFailureTransportException: nextOutboundMessageBuffer() called from outside the eventLoop
Caused by: java.lang.IllegalStateException: nextOutboundMessageBuffer() called from outside the eventLoop
at io.netty.channel.DefaultChannelHandlerContext.nextOutboundMessageBuffer(DefaultChannelHandlerContext.java:648
)
at io.netty.channel.DefaultChannelPipeline.outboundMessageBuffer(DefaultChannelPipeline.java:930)
at io.netty.channel.AbstractChannel.outboundMessageBuffer(AbstractChannel.java:286)
at org.vertx.java.core.http.impl.AbstractConnection.queueForWrite(AbstractConnection.java:39)
at org.vertx.java.core.http.impl.DefaultHttpServerResponse.write(DefaultHttpServerResponse.java:345)
at org.vertx.java.core.http.impl.DefaultHttpServerResponse.write(DefaultHttpServerResponse.java:136)
at org.vertx.java.core.http.impl.DefaultHttpServerResponse.end(DefaultHttpServerResponse.java:171)
at org.vertx.java.core.http.impl.DefaultHttpServerResponse$end.call(Unknown Source)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
at org.vertx.groovy.core.http.HttpServerResponse.end(HttpServerResponse.groovy:209)
at app.FooRestApi$_closure3_closure16_closure17.doCall(FooRestApi.groovy:87)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:487)
at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
at groovy.lang.Closure.call(Closure.java:411)
at groovy.lang.Closure.call(Closure.java:427)
at app.db.FooDbHelper$2.onResponse(FooDbHelper.groovy:76)

The error is triggered by this code:

FooDbHelper.findAlFoos(dbClient, { List fooList ->
Buffer buffer =  new Buffer(toBytes(fooList)
request.response.end(buffer) // this line throws the exception
})

where FooDbHelper.findAlFoos do this:

static void findAlFoos(Client client, Closure success) {
SearchRequestBuilder requestBuilder = prepareSearch()
requestBuilder.execute(new ActionListener() {
@OverRide
void onResponse(SearchResponse response) {
List fooList = decodeFooList(response)
success.call(fooList)
}
})
}

Any help, please?
Thanks,
Mihai
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x can't be built on windows if the system is behind a proxy (like 99% or corporate workstations) !
Maven, wget, curl, node, everything works can "find route to host", except vert.x
Following stacktrace is displayed:
d:\temp1\vert.x>gradlew
Downloading http://services.gradle.org/distributions/gradle-1.4-bin.zip

Exception in thread "main" java.net.NoRouteToHostException: No route to host: connect
        at java.net.TwoStacksPlainSocketImpl.socketConnect(Native Method)
        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:157)
        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:391)
        at java.net.Socket.connect(Socket.java:579)
        at java.net.Socket.connect(Socket.java:528)
        at sun.net.NetworkClient.doConnect(NetworkClient.java:180)
        at sun.net.www.http.HttpClient.openServer(HttpClient.java:378)
        at sun.net.www.http.HttpClient.openServer(HttpClient.java:473)
        at sun.net.www.http.HttpClient.<init>(HttpClient.java:203)
        at sun.net.www.http.HttpClient.New(HttpClient.java:290)
        at sun.net.www.http.HttpClient.New(HttpClient.java:306)
        at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:995)
        at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:931)
        at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:849)
        at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1299)
        at org.gradle.wrapper.Download.downloadInternal(Download.java:63)
        at org.gradle.wrapper.Download.download(Download.java:49)
        at org.gradle.wrapper.Install.createDist(Install.java:51)
        at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:129)
        at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:48)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See: https://github.com/vert-x/vert.x/blob/master/vertx-core/src/main/java/org/vertx/java/core/json/JsonObject.java#L75
when putting in the null ref. for the value, you hit a NPE, because of an (unchecked) access of value.list
Not sure if it makes sense to pass in null... but the NPE was a bit odd...
In an example like here:
{
  "name": "John",
  "options" : null
}

the get for options would return null anyways - so I think it's debatable to allow null... but the NPE was/is odd...
Having this (Jackson):
User u1 = new User();
u1.setName("John");
u1.setOptions(null);

ObjectMapper mapper = new ObjectMapper();
System.out.println(mapper.writeValueAsString(u1));

the output is {"name":"John","options":null} - but that's slightly different...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry no pull request for this, but I was working on a custom vertxbus.js and found the following issue:
https://github.com/vert-x/vert.x/blob/master/src/dist/client/vertxbus.js
See line 148
delete replyHandlers[replyAddress];
Should be
delete replyHandlers[address];
I'm nearly sure of this, but please double check my thinking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
During the handshake headers are being sent to server (the same way like in HTTP).
The support should be probably added the through [Java/Groovy] getHeaders() method on WebSocket object.
Here is a sample code usage:
vertx.createHttpServer().websocketHandler { ws ->
  if(ws.headers["Authorization"] {
    ws.dataHandler { data -> ws.writeTextFrame(data.toString()) }
  } else {
    ws.reject()
  }
}.listen(8080)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hazelcast/hazelcast#81 (comment)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you explain why this information is needed? It's not clear to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In DefaultHttpServer when an UPGRADE request is received a DefaultWebSocket is constructed. It seems however that only the path segment of the URI is passed on as context. Ie:
theURI = new URI(request.getUri());
...
DefaultWebSocket ws = new DefaultWebSocket(vertx, theURI.getPath(), wsConn, connectRunnable);

It would be nice to have the entire URI (for example to retrieve query arguments) or even the entire request to see what headers were passed in the initiating request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Need to add maven archetype and plugin into the GH repository from https://github.com/sramki/vertx-maven.
Also, automate deployment of archetype and plugin to sonatype repository on every commit or like vertx frequency.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the attached gist, I'm testing both DefaultHttpServerRequest.pause() and DefaultHttpClientResponse.pause().
https://gist.github.com/lance/62c3ce661fa063c16d9d
The test creates an HTTP server, pauses for 100 msec when a request is received, then resumes and then the server's data handler is called. That looks good.
But the client seems to have a problem. In the client, I open a request to the server, then pause for 100 msec and then resume. But this time the data handler and end handler aren't called after we resume, which leads me to think the data event is occurring even when the client is paused.
There's a lot of debug output so we can see what's going on and when.  This test is adapted from node.js' pause and resume test here: https://github.com/joyent/node/blob/master/test/simple/test-http-pause.js
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See the node.js API here http://nodejs.org/api/fs.html#fs_class_fs_stats
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@yatindra merged in... thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In sendfile if the file is not found
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I miss this: https://github.com/vert-x/vert.x/blob/db6a23ba35e8768022dc0adbec3894f28a16f3bd/vertx-core/src/main/java/org/vertx/java/core/net/NetSocket.java#L79
Is there any way for me to be notified when a write has completed?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When embedding using PlatformManager, the stop() method only calls the redeployer.stop() method, but doesn't call also call manager.vertx.stop() as expected.
manager.stop() should call manager.vertx.stop() after calling redeployer.close()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Given the underlying data structure is a CHM, what was the thinking here?
I understand the performance benefits (IME, continual iterations of CHM generates a tremendous amount of garbage under high write loads), but if this is the only reason it might make more sense to provide explicit read only forms of the view methods, ie. "readOnlyEntrySet" or vertx.sharedData().readOnlyMap("foo") for example.
Either way, this should be explicitly documented at the code and user level as this behavior effectively breaks the "backed by the map" contract of the parent interfaces.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Groovy :
def rm = new RouteMatcher()
rm.post('/upload/'){ req->
 req.uploadHandler { upload ->
      upload.exceptionHandler { cause ->
        req.response.end(">>>>>>>>>>Upload failed");
      }

      upload.endHandler {
        println ">>>>>>>>>upload ok!"
            req.response.end("Upload successful, you should see the file in the server directory");
      }
      upload.streamToFileSystem(upload.filename);
      println "upload handle>>>"

}

}
but error (not always):
Exception in Groovy verticle
java.lang.UnsupportedOperationException
at io.netty.buffer.DefaultCompositeByteBuf.nioBuffer(DefaultCompositeByt
eBuf.java:1029)
at io.netty.buffer.SlicedByteBuf.nioBuffer(SlicedByteBuf.java:262)
at io.netty.buffer.AbstractByteBuf.nioBuffer(AbstractByteBuf.java:946)
at org.vertx.java.core.file.impl.DefaultAsyncFile.write(DefaultAsyncFile
.java:125)
at org.vertx.java.core.file.impl.DefaultAsyncFile.write(DefaultAsyncFile
.java:45)
at org.vertx.java.core.streams.Pump$2.handle(Pump.java:99)
at org.vertx.java.core.streams.Pump$2.handle(Pump.java:97)
at org.vertx.java.core.http.impl.DefaultHttpServerFileUpload.receiveData
(DefaultHttpServerFileUpload.java:162)
at org.vertx.java.core.http.impl.DefaultHttpServerRequest$NettyFileUploa
d.addContent(DefaultHttpServerRequest.java:344)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.readFile
UploadByteMultipartStandard(HttpPostRequestDecoder.java:1591)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.readFile
UploadByteMultipart(HttpPostRequestDecoder.java:1617)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.getFileU
pload(HttpPostRequestDecoder.java:1150)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.decodeMu
ltipart(HttpPostRequestDecoder.java:818)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.parseBod
yMultipart(HttpPostRequestDecoder.java:726)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.parseBod
y(HttpPostRequestDecoder.java:424)
at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.offer(Ht
tpPostRequestDecoder.java:369)
at org.vertx.java.core.http.impl.DefaultHttpServerRequest.handleData(Def
aultHttpServerRequest.java:273)
at org.vertx.java.core.http.impl.ServerConnection.handleChunk(ServerConn
ection.java:182)
at org.vertx.java.core.http.impl.ServerConnection.processMessage(ServerC
onnection.java:287)
at org.vertx.java.core.http.impl.ServerConnection.handleMessage(ServerCo
nnection.java:96)
at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler.doMessa
geReceived(DefaultHttpServer.java:631)
at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler.doMessa
geReceived(DefaultHttpServer.java:533)
at org.vertx.java.core.http.impl.VertxHttpHandler.messageReceived(VertxH
ttpHandler.java:84)
at io.netty.channel.ChannelHandlerUtil.handleInboundBufferUpdated(Channe
lHandlerUtil.java:60)
at org.vertx.java.core.http.impl.VertxHttpHandler.inboundBufferUpdated(V
ertxHttpHandler.java:53)
at io.netty.channel.DefaultChannelHandlerContext.invokeInboundBufferUpda
ted(DefaultChannelHandlerContext.java:944)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d0(DefaultChannelHandlerContext.java:912)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d(DefaultChannelHandlerContext.java:892)
at io.netty.handler.stream.ChunkedWriteHandler.inboundBufferUpdated(Chun
kedWriteHandler.java:163)
at io.netty.channel.DefaultChannelHandlerContext.invokeInboundBufferUpda
ted(DefaultChannelHandlerContext.java:964)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d0(DefaultChannelHandlerContext.java:912)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d(DefaultChannelHandlerContext.java:892)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.j
ava:441)
at io.netty.handler.codec.ByteToMessageDecoder.inboundBufferUpdated(Byte
ToMessageDecoder.java:69)
at io.netty.channel.ChannelInboundByteHandlerAdapter.inboundBufferUpdate
d(ChannelInboundByteHandlerAdapter.java:46)
at io.netty.channel.DefaultChannelHandlerContext.invokeInboundBufferUpda
ted(DefaultChannelHandlerContext.java:944)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d0(DefaultChannelHandlerContext.java:912)
at io.netty.channel.DefaultChannelHandlerContext.fireInboundBufferUpdate
d(DefaultChannelHandlerContext.java:892)
at io.netty.channel.DefaultChannelPipeline.fireInboundBufferUpdated(Defa
ultChannelPipeline.java:826)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(Abstra
ctNioByteChannel.java:116)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.jav
a:429)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.ja
va:392)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:322)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThread
EventExecutor.java:114)
at java.lang.Thread.run(Thread.java:722)









upload ok!









and the file was uploaded, but file data is incorrect!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Framework like Atmosphere are passing information as query string when opening a websocket. With Vert.x version 1.3.x, the ServerWebSocket is constructed using uri.getPath, which trim the query string and make quite hard to get that information unless I use reflection :-)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Extend module reloader so it can watch configurable set of project dirs, e.g. IDEA/Eclipse out dirs
Change platformmanager runmod so it can take a -classpath parameter. If specified then it will look on classpath for a mod.json and set the module classpath to be the specified classpath.
Change module reloader so it watches all the file urls in the classpath
Then user can just do vertx runmod -classpath out/test -auto-reload=true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The DefaultHttpServerRequest juri() method (https://github.com/vert-x/vert.x/blob/master/vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServerRequest.java#L134) throws an IllegalArgumentException when a uri has a query string that is not correctly URI encoded.
For example: http://localhost:8080/?a=b=c|d=e
  URI juri() {
    if (juri == null) {
      try {
        juri = new URI(uri());
      } catch (URISyntaxException e) {
        throw new IllegalArgumentException("Invalid uri " + uri()); //Should never happen
      }
    }
    return juri;
  }
The comment //Should never happen implies this is not the expected behavior.
Either the comment should be removed, or the code should be patched to handle bad URI encoding.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using Dojo Toolkit RestStore the first GET request to list all items sends the following headers (source mode):
GET http://localhost:8080/persons/ HTTP/1.1
Accept: application/javascript, application/json
Referer: http://localhost:8080/index.html
X-Requested-With: XMLHttpRequest
X-Range: items=0-24
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Ubuntu Chromium/25.0.1364.160 Chrome/25.0.1364.160 Safari/537.22
Range: items=0-24
Content-Type: application/x-www-form-urlencoded
As you can see Dojo decided to send the content-type header with "application/x-www-form-urlencoded". Since this is a GET request it does not contain a body and Vert.x crashes.
I think that on DefaultHttpServerRequest.java the decoder should be enabled if the content type is present AND the method is anything other than GET or HEAD.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When trying to chain functions on my request object, I get a "cannot call method 'end' of undefined" if I try to chain something after .chunked(true). If I separate them out into distinct calls, it works fine.
Not working code (assume gnClient is a properly-declared vertx.createHttpClient() object):
var request = gnClient.get('/v1/users/me/stream', function(resp) {
        resp.bodyHandler(function(body) {
                        /**** redacted body handler code ****/
        });
    }).putHeader('Authorization', '/**redacted**/')
        .putHeader('Accept-Encoding', 'gzip, deflate')
        .chunked(true)
                .end();
    gnClient.close;
Working code:
var request = gnClient.get('/v1/users/me/stream', function(resp) {
        resp.bodyHandler(function(body) {
                        /**** redacted body handler code ****/
        });
    }).putHeader('Authorization', '/**redacted**/')
        .putHeader('Accept-Encoding', 'gzip, deflate')
        .chunked(true);
        request.end();
    gnClient.close;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The default way Dojo Toolkit uses REST stores with sorted queries is by adding to the request path the following query:
?sort(+fieldName,-otherFieldName)

So if i use Dojo and request all the persons on my database sorted by name, Dojo makes the following request (in source mode):
GET /persons/?sort(+name) HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: application/javascript, application/json
X-Requested-With: XMLHttpRequest
X-Range: items=0-24
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Ubuntu Chromium/25.0.1364.160 Chrome/25.0.1364.160 Safari/537.22
Range: items=0-24
Content-Type: application/x-www-form-urlencoded
Referer: http://localhost:8080/index.html
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US,en;q=0.8
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3
DNT: 1

However on Vert.x side when getting the request parameters i get:
sort( name)

The expected value would be a + and not a space.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
beta3
@OverRide
public void handle(HttpServerRequest req) {
final String name = req.params().get("name");
final String dirName = path ;
        vertx.fileSystem().mkdir(dirName + req.params().get("name"), true, new Handler<AsyncResult<Void>>() {

            @Override
            public void handle(AsyncResult<Void> event) {
                if (event.succeeded()) {
                    container.logger().info("create dir succes" + name);
                } else {
                    log.info("create dir " + event.result());                       
                }

            }
        });

        req.response().end("File create succed"+req.params().get("name"));
    }
  });

create only null dir
on beta2 create correct
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this also fixes distZip on a mac...please incorporate this change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Bumping nodyn to beta4 causes this error: https://gist.github.com/lance/e7b859a5bbc7f3646469
If I checkout 06f9d62 - the commit just before the classloader changes - and build vert.x locally, the problems go away.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Playing with the new -cp option I encounter a NPE:
java.lang.NullPointerException
        at java.util.concurrent.ConcurrentHashMap.hash(ConcurrentHashMap.java:332)
        at java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1124)
        at org.vertx.java.core.impl.ConcurrentHashSet.add(ConcurrentHashSet.java:74)
        at org.vertx.java.platform.impl.ModuleClassLoader.addParent(ModuleClassLoader.java:41)
        at org.vertx.java.platform.impl.DefaultPlatformManager.deployModuleFromModJson(DefaultPlatformManager.java:694)
        at org.vertx.java.platform.impl.DefaultPlatformManager.deployModuleFromCP(DefaultPlatformManager.java:756)
        at org.vertx.java.platform.impl.DefaultPlatformManager.access$100(DefaultPlatformManager.java:53)
        at org.vertx.java.platform.impl.DefaultPlatformManager$10.run(DefaultPlatformManager.java:329)
        at org.vertx.java.platform.impl.DefaultPlatformManager$11.run(DefaultPlatformManager.java:342)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
        at java.lang.Thread.run(Thread.java:722)

It occur if the main module deploys module (like mongo-persistor), and the main module is redeployed. Only happens at about 30% of the redeploys.
I can reproduce it with the gradle template, by making these changes:
--- a/src/main/java/com/mycompany/myproject/PingVerticle.java
+++ b/src/main/java/com/mycompany/myproject/PingVerticle.java
@@ -20,6 +20,7 @@ package com.mycompany.myproject;
 import org.vertx.java.core.Handler;
 import org.vertx.java.core.eventbus.Message;
 import org.vertx.java.platform.Verticle;
+import org.vertx.java.core.json.JsonObject;

 /*
 This is a simple Java verticle which receives `ping` messages on the event bus and sends back `pong` replies
@@ -28,6 +29,12 @@ public class PingVerticle extends Verticle {

   public void start() {

+        JsonObject config = new JsonObject();
+        config.putString("address", "ethics.persistor");
+        config.putString("db_name", "ethics");
+
+        container.deployModule("io.vertx~mod-mongo-persistor~2.0.0-beta2", config);
+

     vertx.eventBus().registerHandler("ping-address", new Handler<Message<String>>() {
       @Override
diff --git a/src/main/resources/mod.json b/src/main/resources/mod.json
index f33f620..a4a23a2 100644
--- a/src/main/resources/mod.json
+++ b/src/main/resources/mod.json
@@ -1,5 +1,6 @@
 {
   "main":"com.mycompany.myproject.PingVerticle",
+  "auto-redeploy":true,

   // If your module is going to be registered in the Vert.x module registry you will also need the following
   // mandatory fields
and running this command.
vertx runmod  com.mycompany~my-module~1.0.0-SNAPSHOT -instances 1 -cp build/classes/main:build/resources/main/

and in another window run a series of
 touch  build/resources/main/xxx

Adding System.out DefaultPlatformManager I can see that enclosingModID in deployModuleFromModJson() is normally "com.mycompanymy-module1.0.0-SNAPSHOT" when the redeploy works, but occasionally it is set to "io.vertxmod-mongo-persistor2.0.0-beta2" and the parentRef is null -> NPE.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Given the simple SockJS server below, I seem to not be getting reliable notification that a connection's been closed.
To reproduce the issue, perform the following steps (given the code below):

Run the server.
Navigate to localhost:8080
Note that the server prints "Open: ..." and the client prints "open". Everyone's happy.
Now stop the server. The client will print "close" and start trying to reconnect.
Restart the server. After a couple of seconds, the client will happily reconnect.
Now close the client. Note that the server prints no "End: ..." message.

Note that if you do this without restarting the server, everything behaves as expected. Also note that I'm doing this in Chrome. It may be different in other browsers, depending upon the vagaries of how their network stacks close websocket connections.
For a more detailed discussion of the underlying problem, and at least one possible solution, see this thread: https://groups.google.com/forum/?fromgroups#!topic/vertx/187O6EQXt3c
SockJSExample.java
public class SockJSExample {

  public static void main(String[] args) throws Throwable {
    Vertx vertx = VertxFactory.newVertx("0.0.0.0");
    HttpServer server = vertx.createHttpServer();

    server.requestHandler(new Handler<HttpServerRequest>() {
      public void handle(HttpServerRequest req) {
        if (req.path().equals("/")) {
          req.response().sendFile("index.html");
        }
      }
    });

    SockJSServer sockServer = vertx.createSockJSServer(server);
    sockServer.installApp(
      new JsonObject().putString("prefix", "/testapp"),
      new Handler<SockJSSocket>() {
        public void handle(final SockJSSocket sock) {
          System.out.println("Open: " + sock);

          sock.dataHandler(new Handler<Buffer>() {
            @Override public void handle(Buffer data) {
              System.out.println("> " + data.toString());
              sock.write(data);
            }
          });

          sock.exceptionHandler(new Handler<Throwable>() {
            @Override public void handle(Throwable e) {
              System.out.println("Exception: " + e.getMessage());
            }
          });

          sock.endHandler(new Handler<Void>() {
            @Override public void handle(Void _) {
              System.out.println("Close: " + sock);
            }
          });
        }
      }
    );

    server.listen(8080);
  }
}

index.html
<!DOCTYPE html>
<html>
<head>
  <title>SockJS Test</title>
  <script src="http://cdn.sockjs.org/sockjs-0.2.1.min.js"></script>
</head>
<body>

<script>
  var sock;

  function openSock() {
    sock = new SockJS('http://localhost:8080/testapp');

    sock.onopen = function() {
      console.log('open');
    };
    sock.onmessage = function(e) {
      console.log('message', e.data);
      alert('received message echoed from server: ' + e.data);
    };
    sock.onclose = function() {
      setTimeout(function() { openSock(); }, 1000);
      console.log('close');
    };
  }

  function send(message) {
    if (sock && sock.readyState == WebSocket.OPEN) {
      console.log("sending message")
      sock.send(message);
    } else {
      console.log("The socket is not open.");
    }
  }

  openSock();
</script>
<form onsubmit="return false;">
  <input type="text" name="message" value="Hello, World!"/>
  <input type="button" value="Send SockJS data" onclick="send(this.form.message.value)"/>
</form>
</body>
</html>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After making a project with the maven archetype I just wanted to run it from the generated .zip file in the target/ directory.
I got this exception
$ cd target/
$ vertx runzip dummy-server-0.1-SNAPSHOT.zip
java.lang.IllegalArgumentException: Invalid module identifier: __vertx_tmp#dummy-server-0.1-SNAPSHOT#__vertx_tmp. Should be of form owner~name~version
at org.vertx.java.platform.impl.ModuleIdentifier.createException(ModuleIdentifier.java:65)
at org.vertx.java.platform.impl.ModuleIdentifier.<init>(ModuleIdentifier.java:39)
at org.vertx.java.platform.impl.DefaultPlatformManager$8.run(DefaultPlatformManager.java:286)
at org.vertx.java.platform.impl.DefaultPlatformManager$9.run(DefaultPlatformManager.java:320)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at java.lang.Thread.run(Thread.java:722)
java.lang.IllegalArgumentException: Invalid module identifier: __vertx_tmp#dummy-server-0.1-SNAPSHOT#__vertx_tmp. Should be of form owner~name~version 

I tried it with 2.0-beta3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to create a simple HTTP proxy using Pump. I wonder why the following code doesn't work (tested on both 1.3.1 and 2.0.0 beta2 - the following code is for 2.0.0 beta2):
package test;

import org.vertx.java.core.Handler;
import org.vertx.java.core.http.HttpClient;
import org.vertx.java.core.http.HttpClientRequest;
import org.vertx.java.core.http.HttpClientResponse;
import org.vertx.java.core.http.HttpServerRequest;
import org.vertx.java.core.streams.Pump;
import org.vertx.java.platform.Verticle;

public class Server extends Verticle {

    @Override
    public void start() {
        vertx.createHttpServer().requestHandler(new Handler<HttpServerRequest>() {

            @Override
            public void handle(final HttpServerRequest request) {
                System.out.println("Proxing request");
                HttpClient httpClient = vertx.createHttpClient().setHost("host.com").setPort(80);
                HttpClientRequest clientRequest = httpClient.request(request.method(), request.uri(), new Handler<HttpClientResponse>() {

                    @Override
                    public void handle(HttpClientResponse clientResponse) {
                        Pump.createPump(clientResponse, request.response()).start();
                    }

                });
                Pump.createPump(request, clientRequest).start();
            }
        }).listen(9000);
        System.out.println("Proxy started");
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The issue is that there are either no messages going to the second module or the reply doesn't find its way back.
Clone the repo of this file to check the difference between beta3 and beta4-SNAPSHOT:
https://github.com/Narigo/vertx-gradle-template/blob/strange-behaviour/src/test/java/com/mycompany/myproject/test/integration/java/ModuleIntegrationTest.java
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Google Groups topic here
The ability to catch all incoming requests before they hit individual route matches would be excellent for code DRYness, as it would allow common functionality like authentication to occur inside this handler as opposed to inside each route handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys! I've the same issue as it described in closed ticket (see #504)

vertx run Server.java
Failed to create verticle
java.lang.RuntimeException: Compilation failed
at org.vertx.java.deploy.impl.java.CompilingClassLoader.(CompilingClassLoader.java:75)
at org.vertx.java.deploy.impl.java.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:48)
at org.vertx.java.deploy.impl.VerticleManager$10.run(VerticleManager.java:777)
at org.vertx.java.core.impl.Context$2.run(Context.java:119)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.processEventQueue(AbstractNioWorker.java:454)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:331)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:35)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:102)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
at java.lang.Thread.run(Unknown Source)
Caused by: java.lang.NullPointerException
at org.vertx.java.deploy.impl.java.CompilingClassLoader.(CompilingClassLoader.java:57)
... 11 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems that python's working directory is not the module's directory as it is described in the modules manual.
If I'm getting started with gradle:
git clone https://github.com/vert-x/vertx-gradle-template hello-module
cd hello-module/
./gradlew test
# ====> BUILD SUCCESSFUL
I have a module which I can populate with a trivial python main class:
cat > src/main/resources/hello.py <<EOF
import sys
print "hello! %r" % sys.path
EOF
sed -i 's/com.mycompany.myproject.PingVerticle/hello.py/' src/main/resources/mod.json
./gradlew runMod
# ====> hello! ['/tmp/hello-module/build/mods/io.vertx~lang-jython~2.0.0-beta3/lib/Lib', '/tmp/hello-module/build/mods/io.vertx~lang-jython~2.0.0-beta3/lib/jython-standalone-2.5.3-adapted.jar/Lib', '__classpath__', '__pyclasspath__/']
When I extend this main class to import another python class, which is located relative to my main class, then it will fail to load it:
echo 'import hello2' > src/main/resources/hello.py
echo 'print "this is hello2' > src/main/resources/hello2.py
./gradlew runMod
# ====> ImportError: No module named hello2
If I try to put that to-be-imported class into the relative directory __pyclasspath__/, which can be found in the output of the first hello.py above, then it won't be found either:
mkdir src/main/resources/__pyclasspath__
mv src/main/resources/hello2.py src/main/resources/__pyclasspath__/
./gradlew runMod
# ====> ImportError: No module named hello2
But if I move the __pyclasspath__ to my current working directory, then it works:
mv src/main/resources/__pyclasspath__ .
./gradlew runMod
# ====> this is hello2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The JavaScript request.response.sendFile() serves files from the current working directory instead of the module directory. From the JavaScript API Manual I cannot figure if that's the expected behavior or a bug.
When creating a simple module:
mkdir -p /tmp/hello/my/mod
echo '{"main":"index.js"}' > /tmp/hello/my/mod/mod.json
cat > /tmp/hello/my/mod/index.js <<EOF
require('vertx').createHttpServer().requestHandler(function(request) {
    request.response.sendFile('hello.txt')
}).listen(7777)
EOF
echo 'hello!' > /tmp/hello/my/mod/hello.txt
and running it from /tmp/hello:
cd /tmp/hello
vertx runmod my~hello~0 -cp my/mod
I'll get an 404:
curl -vsS http://localhost:7777
# ====>
# HTTP/1.1 404 OK
# <html><body>Resource not found</body><html>
When I change the request handler to:
 function (request) {request.response.sendFile('my/mod/hello.txt')}
I get the the desired 200:
curl -vsS http://localhost:7777
# ====>
# HTTP/1.1 200 OK
# hello!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a Ruby thing not a Python thing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Run command
vertx
See section on -instances:
-instances  specifies how many instances of the verticle
will be deployed. Defaults to 1
Default is vert-x.github.com/vertx-mods
"Default is vert-x.github.com/vertx-mods" is not supposed to be there.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[main] INFO io.netty.util.internal.PlatformDependent - You don't have Javassist in your class path or you don't have enough permission to load dynamically generated classes.  Please check the configuration for better performance.

Reproduction

Setup a new Gradle project (create build.gradle), pull in vertx-platform as dependency.
Create new main class (e.g. Main.java)
Import into Eclipse as Gradle project
try to run Main from Eclipse using Run
Error is displayed in eclipse console.

https://gist.github.com/darylteo/5795320
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using the auto-redeploy feature in beta6 (and it is great, really great) I sometime get an exception like this:
INFO: Module dk.bckfnn~mymod~1.0.0-SNAPSHOT has changed, reloading it.
jun 17, 2013 10:06:46 AM io.netty.util.concurrent.SingleThreadEventExecutor$2 run
WARNING: An event executor terminated with non-empty task queue (2)
Exception in thread "vert.x-eventloop-thread-1" jun 17, 2013 10:06:48 AM org.vertx.java.core.logging.impl.JULLogDelegate error
SEVERE: Failed to run task
java.util.concurrent.RejectedExecutionException: event executor terminated
        at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:702)
        at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:295)
        at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:690)
        at io.netty.util.concurrent.SingleThreadEventExecutor.schedule(SingleThreadEventExecutor.java:793)
        at io.netty.util.concurrent.SingleThreadEventExecutor.schedule(SingleThreadEventExecutor.java:721)
        at org.vertx.java.core.impl.DefaultVertx.scheduleTimeout(DefaultVertx.java:244)
        at org.vertx.java.core.impl.DefaultVertx.setTimer(DefaultVertx.java:158)
        at org.vertx.java.platform.impl.Redeployer.setTimer(Redeployer.java:77)
        at org.vertx.java.platform.impl.Redeployer.checkForChanges(Redeployer.java:225)
        at org.vertx.java.platform.impl.Redeployer.access$000(Redeployer.java:32)
        at org.vertx.java.platform.impl.Redeployer$1.run(Redeployer.java:52)
        at org.vertx.java.platform.impl.Redeployer$3.run(Redeployer.java:233)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
        at java.lang.Thread.run(Thread.java:722)

The exception is rare, much less than 1% of the reloads, so it does not prevent the use of redeploy.
I can not reproduce it but it have occured a couple of times.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As it is, auto-redeploy can only be true for top-level modules. However, I believe there are possible use cases for auto-redeploy to be enabled for lower-level modules.
Scenario 1
Module A deploys Module B.
When Module A changes, Module A correctly undeploys all children and redeploys itself.
When Module B changes, no redeploy takes place.
Suggested behaviour: Module B should detect the change, and Module A should treat that as a change in itself, and redeploy.
Scenario 2
A module I am writing allows devs to create a configuration file that tells the module which modules to deploy depending on various things (environment, id etc.). However, this module itself does not need to redeploy, but the lower-level modules should redeploy independently of each other.
Suggested behaviour: Module A should not redeploy if Module B changes, however we should be able to allow Module B to be redeployed on its own.
Suggested Enhancement

Allow "auto-redeploy" to be deployed on any levels.
if auto-redeploy is configured on a module, it should detect any changes within itself, in addition to any lower-level modules that it deploys, and treat that as a change in itself.
in order to avoid ambiguity, lower-level modules should not be able to disable auto-redeploy if it is enabled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I believe this problem was introduced during a recent refactoring for Netty:
https://groups.google.com/forum/?fromgroups=#!topic/vertx/SPRV0Yd4WQU
Basically what was happening, is the DefaultEventBus had a static buffer which is what using for the PONG packet, and was writing that for every pong, but after the first write Netty actually wrote nothing.
Probably the underlying Netty ByteBuf needs resetting after writing. We need to support users writing Buffers more than once.
I have added a test case to demonstrate this issue JavaNetTest.testWriteSameBufferMoreThanOnce
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@matasaru did you sign the CLA yet ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be very nice if you could install vertx with homebrew. Is there any plan of using any type of package manager?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Came across a small issue in runzip command. The API for sending files (req.response.sendFile("webroot/index.html") for example, seems to be giving me Resource not found at runtime. It works perfectly when I use runmod though.
I had started working on creating a pull request, but ran out of time last night.
Please let me know if a pull request would be helpful and I'll try again tonight.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Tim
I find a bug (maybe) that receiveBufferSize parameter is invalid.
my data are sent by NetServer and NetClient is more than 1024B,
so i set receiveBufferSize 2048, but i find it don't work.
finally, i found reason at line of 102  in TCPSSLHelper.java
if (tcpReceiveBufferSize != null) {
options.put(prefix + "receiveBufferSize", tcpReceiveBufferSize);
// We need to set a FixedReceiveBufferSizePredictor, since otherwise
// Netty will ignore our setting and use an adaptive buffer which can
// get very large
options.put(prefix + "receiveBufferSizePredictor", new FixedReceiveBufferSizePredictor(1024));
}
FixedReceiveBufferSizePredictor always is 1024.
it's mean that user space size of buffer is 1024, but kernel of OS size is tcpReceiveBufferSize. i changed parameter of FixedReceiveBufferSizePredictor to tcpReceiveBufferSize, it work fine...
i don't test in vertx2, since i will plan translate project to 2 in two weeks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If I run the JavaScript webapp example with CR1 the page fails to render in Chrome, but if I run it with a previous version it renders OK.
When running with older Vert.x, change the versions of the modules in app.js to beta1 from CR1.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Julien, that's better.
One thing that strikes me still is it looks a bit washed-out - I think it could do with a bit more colour. Wdyt? One more colour somewhere?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a verticle serving simple files living in the root of my packed zip module with req.response().sendFile("index.html");
It works fine if I run the application setting the VERTX_MODS variable pointing to the exploded structure of my compiled module (as I'm using the maven archetype it is target/mods); but if I use the runZip command, the same code returns "Resource not found" in the browser.
I'm under checking it against current master @ bcfcb33
update: the described behavior was using 2.0.0-CR1, in bcfcb33 it always return 'Resource Not Found'
update2: here is the source code of a simple module for testing this behavior.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've implemented this slightly differently - it will look first for the -mod suffix and then without.
I've also updated the local maven resolution which needs to be done too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As of bcfcb33 all file systems operations are relative to the working directory of the calling process instead of the module directory.
When running a module after a successful ./gradlew like this:
cd build
vertx runmod mycompany~mymodule~0.0.0-SNAPSHOT
Then following JavaScript snippet (from a file loaded with require()):
vertx.fileSystem.readDir('.', '.*', function(err, res) {
  if (!err) {
    for (var i = 0; i < res.length; i++) {
      console.log(res[i]);  
    }
  }
});
Produces this output:
/tmp/mymodule/build/classes
/tmp/mymodule/build/dependency-cache
/tmp/mymodule/build/mods
/tmp/mymodule/build/resources

Whereas using the parent commit 70b630d produces the desired output:
/tmp/mymodule/build/mods/mycompany~mymodule~0.0.0-SNAPSHOT/mod.json
[...]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
First, it's awesome to have an Eclipse project on GitHub!
I'm not sure if this is the case, but if contributors to vert.x now need to sign the Eclipse CLA, it would be helpful for every would-be contributor to know that as early as possible.
If you add contributing guidelines in a CONTRIBUTING.md file, we'll add a link to that  file when a contributor creates an Issue or opens a Pull Request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The latest Netty version is needed in order to make the ssl tests pass, but it breaks the websockets tests :(
So basically I can't find a Netty version to use that lets me run the main test suite through....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be useful to provide configuration for a verticle in the VerticleFactory before a Verticle is created & returned.
A straw man example: if one wished to constrain the number of instances of a given Verticle, an annotation could be applied:
@Config(maxInstances=5)
class MyVerticle {
  ...
}

And in the VerticleFactory:
Map<String, Integer> instanceCountMap;

public Verticle createVerticle(String main) throws Exception {

  Class<?> c = loader.loadClass(main);
  Config c = c.getAnnotation(Config.class);
  int max = c.maxInstances();
  if (max > instanceCountMap.get(main)) {
    ... // increment count & return verticle
  }
  else {
    throw new TooManyVerticlesException();
  }
}

In Java, properties of an Annotation on the class can be discovered before instantiating the class, but this is not portable across all language implementations.
An Annotation is sometimes converted to a Map of its properties, there might be a way to provide enable a language-feature conversion to a map for each implementation, but configuration through JSON would also achieve the same thing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
since vertex base on netty, i think it would be cool, if we could use a lot kind of decoder or encoder class which in netty packages..
now, i have a scene, that use NetServer and NetClient send/receive message with Buffer. i wanna en/de coder these buffer in JSON/Object.
this could be ? ^ ^
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm currently debugging an issue I have with a shared map. It might be due to a misunderstanding on my part. If so, I'm sorry for the noise. Below is a minimal test case that demonstrates the problem. In the Putter verticle, I add a new map entry, and in the Getter verticle I

Print the keySet().
Print the result of containsKey() with the inserted key.

But for some reason the two don't agree on the contents of the map. E.g. I get the output:
[gameId: 1, playerId: 4]
false

So I'm guessing there's some concurrency issue at play here.
I ran this test case with:
$ javac -cp "/home/estan/Projekt/dynastica/client-proxy/lib/vert.x-1.3.1.final/lib/*" *.java
$ /home/estan/Projekt/dynastica/client-proxy/lib/vert.x-1.3.1.final/bin/vertx run Starter
$ telnet 6000
$ telnet 6001
The last two commands are just to trigger the Putter and Getter to do their jobs, respectively.
Best regards,
Elvis Stansvik
Test case:
Starter.java
import org.vertx.java.deploy.Verticle;

public class Starter extends Verticle {
    @Override
    public void start() {
        container.deployVerticle("Putter");
        container.deployVerticle("Getter");
    }
}
Putter.java
import org.vertx.java.core.Handler;
import org.vertx.java.core.net.NetServer;
import org.vertx.java.core.net.NetSocket;
import org.vertx.java.deploy.Verticle;

import java.util.concurrent.ConcurrentMap;

public class Putter extends Verticle {
    private ConcurrentMap<ClientId, Integer> map;

    public void start() {
        map = vertx.sharedData().getMap("map");

        NetServer server = vertx.createNetServer();
        server.connectHandler(new Handler<NetSocket>() {
            @Override
            public void handle(final NetSocket socket) {
                map.put(new ClientId(1, 4), 3);
            }
        });
        server.listen(6000);
    }
}
Getter.java
import org.vertx.java.core.Handler;
import org.vertx.java.core.net.NetServer;
import org.vertx.java.core.net.NetSocket;
import org.vertx.java.deploy.Verticle;

import java.util.concurrent.ConcurrentMap;

public class Getter extends Verticle {
    private ConcurrentMap<ClientId, Integer> map;

    public void start() {
        map = vertx.sharedData().getMap("map");

        NetServer server = vertx.createNetServer();
        server.connectHandler(new Handler<NetSocket>() {
            @Override
            public void handle(final NetSocket socket) {
                System.out.println(map.keySet());
                System.out.println(map.containsKey(new ClientId(1, 4)));
            }
        });
        server.listen(6001);
    }
}
ClientId.java
import org.vertx.java.core.shareddata.Shareable;

public class ClientId implements Shareable {

    private final int playerId;
    private final int gameId;

    public ClientId(int gameId, int playerId) {
        this.playerId = playerId;
        this.gameId = gameId;
    }

    public int getPlayerId() {
        return playerId;
    }

    public int getGameId() {
        return gameId;
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        final ClientId that = (ClientId) o;
        if (playerId != that.playerId)
            return false;
        if (gameId != that.gameId)
            return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = playerId;
        result = 31 * result + gameId;
        return result;
    }

    @Override
    public String toString() {
        return "gameId: " + gameId + ", playerId: " + playerId;
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Related to #533.  keepAlive is never used to configure the connection.
https://github.com/vert-x/vert.x/blob/v1.3.1.final/vertx-core/src/main/java/org/vertx/java/core/net/impl/TCPSSLHelper.java#L93
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Run the simpleform example in vertx-examples. Output is this:
Got attr name : foo
Got attr foo : myfoo
Got attr name : bar
Got attr bar : mybar
Got attr name : quux
Got attr quux : myquux
Should be:
Got attr foo : myfoo
Got attr bar : mybar
Got attr quux : myquux
Netty shouldn't be adding extra attributes with name "name"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Run the ws_perf Java example in vertx-examples.
In one console:
vertx run wsperf/PerfServer.java
In another:
tim@tim-laptop ~/projects/vert-x/vertx-examples/src/raw/java $ vertx run wsperf/PerfClient.java
Starting perf client
Received data on all conns
LEAK: ByteBuf was GC'd before being released correctly.
io.netty.util.ResourceLeakException: io.netty.buffer.UnpooledUnsafeDirectByteBuf@6f83405f
at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.(ResourceLeakDetector.java:158)
at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
at io.netty.buffer.UnpooledUnsafeDirectByteBuf.(UnpooledUnsafeDirectByteBuf.java:72)
at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:49)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:130)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:121)
at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:58)
at io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder.decode(WebSocket08FrameDecoder.java:259)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:356)
at io.netty.handler.codec.ByteToMessageDecoder.messageReceived(ByteToMessageDecoder.java:138)
at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
at io.netty.channel.DefaultChannelPipeline.fireMessageReceived(DefaultChannelPipeline.java:786)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:120)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:489)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:358)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
at java.lang.Thread.run(Thread.java:722)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
every time I run a zip, it's extracted in my /tmp directory, executed and left there forever.
Now, since ideally I don't reboot a production server very often, the temp folder is going to grow indefinitely whenever I start/stop my vert.x modules.
We use volatile EC2 instances (no EBS mass storage volumes attached), so the space on disk is running low and most of it is used in /tmp/vertx-zip-mods.
Shouldn't Vert.x cleanup the unzipped modules on shutdown?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When calling vertx.fileSystem.readFile with a relative path a java.nio.file.InvalidPathException is thrown because a prepended "/" is added in windows.  IE: c:\temp\abc.html is turned into /c:/temp/abc.html
This issue started on the v2.0.0-CR1 - tagging release we weren't seeing this in beta5.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, can you take a look at CONTRIBUTING.md please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you take a look at CONTRIBUTING.md before submitting a patch?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently Vertx (as of 2.0.0) is tied into using Hazelcast to manage members and subscriptions.
If this was made pluggable then we could replace this with another clustering technology such as Oracle Coherence (or even to downgrade/upgrade the Hazelcast version being used). These plugins could be then developed as external modules, and supported by the community.
For many companies, being able to switch out Hazelcast for a commercially (or internally) supported product is an important box they need to tick before adopting a technology such as vertx. The reason for this is that although Hazelcast isn't used for a great deal in Vertx, some knowledge of it is required for setting up and maintaining a distributed cluster, and it has its "features" which people need to get used to and learn how to work around (e.g. the split-braining). In addition, (please note this is not my opinion), Hazelcast hasn't got a great reputation around the industry, and I have been told of several projects which needed to be rearchitected due to stability issues with it.
For me personally, I would like to see this made pluggable so that I can carry on using the existing version of Hazelcast (2.4.1) that we are currently using, so that I can add Vertx 2.0.0 components to the existing event bus (Hazelcast doesn't allow for different minor versions to join the same cluster).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Gonna close this as it's not processable
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
duplicate
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using an uptodate CR3-SNAPSHOT, absolute paths fail with a
java.nio.file.InvalidPathException: Illegal char <:> at index 2: /D:/vertx/project/target/classes/views

url is file:/D:/vertx/project/target/classes/views/link.hbs
sfile is /D:/vertx/project/target/classes/views/link.hbs
removing the initial / avoids the InvalidPathException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just to check - you've signed the Eclipse CLA?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An exception during multipart/form-data parsing with a  field.
Seems to occur consistently on the first fileupload. Further uploads does not cause exception.
WARNING: LEAK: ByteBuf was GC'd before being released correctly.
io.netty.util.ResourceLeakException: io.netty.buffer.DefaultCompositeByteBuf@27914270
        at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:158)
        at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
        at io.netty.buffer.DefaultCompositeByteBuf.<init>(DefaultCompositeByteBuf.java:80)
        at io.netty.buffer.Unpooled.wrappedBuffer(Unpooled.java:301)
        at io.netty.buffer.Unpooled.wrappedBuffer(Unpooled.java:238)
        at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.offer(HttpPostRequestDecoder.java:363)
        at org.vertx.java.core.http.impl.DefaultHttpServerRequest.handleData(DefaultHttpServerRequest.java:279)
        at org.vertx.java.core.http.impl.ServerConnection.handleChunk(ServerConnection.java:185)
        at org.vertx.java.core.http.impl.ServerConnection.processMessage(ServerConnection.java:291)
        at org.vertx.java.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:99)
        at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler.doMessageReceived(DefaultHttpServer.java:639)
        at org.vertx.java.core.http.impl.DefaultHttpServer$ServerHandler.doMessageReceived(DefaultHttpServer.java:541)
        at org.vertx.java.core.http.impl.VertxHttpHandler.messageReceived(VertxHttpHandler.java:56)
        at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
        at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
        at io.netty.channel.ChannelInboundHandlerAdapter.messageReceived(ChannelInboundHandlerAdapter.java:98)
        at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
        at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
        at io.netty.handler.codec.ByteToMessageDecoder.messageReceived(ByteToMessageDecoder.java:187)
        at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
        at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
        at io.netty.channel.DefaultChannelPipeline.fireMessageReceived(DefaultChannelPipeline.java:786)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:120)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:489)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:358)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
        at java.lang.Thread.run(Thread.java:722)

Using up-to-date CR3-SNAPSHOT.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Eclipse reports the following "Build Path Problem" when is imported a branch folder of vert.x from into some workspace using Import facility of Eclipse.
Two Build Path Problem:

vertx-core: A cycle was detected in the build path of project 'vertx-core'. The cycle consists of projects {vertx-core, vertx-platform}
vertx-platform: A cycle was detected in the build path of project 'vertx-platform'. The cycle consists of projects {vertx-core, vertx-platform}

Both way lead to the same result:

% gradlew eclipse
then import into eclipse's ws
import as gradle project into eclipse's ws.

I understand not why, the bunch of vertx-core's src/test is dependent on the bunch of vertx-platform's src/main, but the bunch of vertx-core's src/main isn't dependent on the bunch of vertx-platform's src/main,
So, it may be not easy to resolve the cycle consists.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you provide some tests for this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Some testcases have wrong package in vertex-testsuite.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using a Godaddy SSL certificate it doesn't look like vertx is properly returning to the browser the Godaddy gd_bundle.crt or the godaddy intermediate certificate.  This is causing Android devices to hang and time out waiting for the intermediate certificate and Firefox to raise a not trusted website screen.  I've validated that both our godaddy UCC cert and the bundle have been properly added to the jks using the keytool utility.
Steps to reproduce

Buy a SSL cert that requires an intermediate certificate (Godaddy)
Use the java keytool to import your domain's cert
Use the java keytool to import the Godaddy bundle
Use the createHttpServer method with the proper keystore chained methods.  We used javascript & just copied & pasted the example from https://github.com/vert-x/vertx-examples/blob/master/src/raw/javascript/https/https_server.js
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When starting multiple instances of the same module/verticle type concurrently, and where the verticle does a require(), this can result in failures because require() in the shared ruby runtime is not threadsafe.
We can fix this by overriding the require() method with a version that synchronizes access to the original version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Some language implementations (Ruby, Python,...) share a runtime instance amongst all verticles/modules of the same type in order to reduce RAM and permgen overhead to allow more verticle instances to run.
The isolation provided in this case between verticle instances is usually good enough but not 100% perfect.
For users who require better isolation guarantees at the expense of more RAM overhead we should allow a switch to be provided so each verticle instance has it's own runtime.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a web browser using the EventBus bridge doesn't disconnect cleanly (for example, its WiFi connection dies or perhaps the user puts the machine to sleep), Vert.x will continue to pile up pending writes until all memory is exhausted.  Full report here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
groovy code, simple and standard:
upload from browser like chrome, everything is ok!
but if upload from a  phonegap app, nothing happened!
so I think the  reason is that uploadHandler can  not recognize upload file data from phonegap( data encode a little differently ).
req.uploadHandler { upload ->
upload.exceptionHandler { cause ->
req.response.end(">>>>>>>>>>Upload failed");
}
      upload.endHandler {
        println ">>>>>>>>>upload ok!"
        req.response.end("Upload successful!");
      }

      upload.streamToFileSystem(upload.filename);   
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Have you signed the Eclipse CLA, if so what username did you use?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
example of a failed module:
ashertarnovertx-memcached2.1.0
(target file on bintray: http://dl.bintray.com/ashertarno/vertx-mods/vertx-memcached/vertx-memcached-2.1.0.zip )
attempts to push it return an error saying that bintray returned status 302
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx version
2.0.0-CR3-SNAPSHOT
I'm having troubles with formAttributes here is content of my form-data :
--xYzZY
Content-Disposition: form-data; name="content"
status: open
id: ticket/396
--xYzZY--
and here is how the MultiMap parsed it (problem with dash and eventually other special char) :
[content=status: open
id: ticket/396
]
And after add function on the MultiMap here is the result :
req.formAttributes.add("id", "ticket/"+newId)
[content=status: open
id: ticket/397
, id=ticket/884]
It doesn't erase the old value because of character misparsing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So, not super-simple to replicate but:
a) checkout, mvn install: https://github.com/bobmcwhirter/vertx-activemq-module
b) checkout mvn install: https://github.com/bobmcwhirter/vertx-jmsclient-module
c) checkout: https://github.com/bobmcwhirter/vertx-activemq-jmsclient-module
c-1) If you attempt mvn test on the 3rd project, it will fail with a ClassCastException due to some ActiveMQ classes getting loaded strangely across multiple tests
c-2) Running each test individually will work without a ClassCastException:
mvn test -Dtest=JMSBridgeVerticleBufferTest
XOR
mvn test -Dtest=JMSBridgeVerticleJSONTest

So it seems that undeploying a module (in TestVerticle's own stop()) isn't completely wiping classloader space, and the deployment of the module isn't isolated enough perhaps.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to reproduce.

Create non-runnable module with class to share

public class AwesomeLibrary {

    public String doIncredibleThings() {
        return "wow";
    }
}


In runnable module, include non-runnable

{
  // Java verticle
  "main":"com.test.TestVerticle1",
  "includes": "com.test~nonrunnable-mod~1.0-SNAPSHOT"
}


The main verticle in the runnable can access classes from the non-runnable, but additional verticles deployed cannot.

public class TestVerticle1 extends Verticle {

    public void start() {

        AwesomeLibrary lib = new AwesomeLibrary();
        container.logger().info("Awesome library says: " + lib.doIncredibleThings());
        container.logger().info("TestVerticle1 started");

        //Problems when we deploy sub-verticles that want to access the
        //AwesomeLibrary from the non-runnable
        container.deployVerticle(TestVerticle2.class.getName());

        //My initial problem was deploying a verticle that extended
        // a base class from the non-runnable, just included for completeness
        container.deployVerticle(TestVerticle3.class.getName());

    }
}

$ vertx version
2.0.0-CR3 (built 2013-07-09 17:11:24)

$ vertx runmod com.test~runnable-mod~1.0-SNAPSHOT
Awesome library says: wow 
TestVerticle1 started 
Exception in Java verticle 
java.lang.NoClassDefFoundError: com/test/AwesomeBaseVerticle
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:791)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at org.vertx.java.platform.impl.ModuleClassLoader.doLoadClass(ModuleClassLoader.java:93)
    at org.vertx.java.platform.impl.ModuleClassLoader.loadClass(ModuleClassLoader.java:77)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    at org.vertx.java.platform.impl.java.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:55)
    at org.vertx.java.platform.impl.DefaultPlatformManager$18.run(DefaultPlatformManager.java:1262)
    at org.vertx.java.core.impl.DefaultContext$3.run(DefaultContext.java:171)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:353)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:365)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
    at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.ClassNotFoundException: com.test.AwesomeBaseVerticle
    at org.vertx.java.platform.impl.ModuleClassLoader.loadClass(ModuleClassLoader.java:79)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    ... 19 more

Exception in Java verticle 
java.lang.NoClassDefFoundError: com/test/AwesomeLibrary
    at com.test.TestVerticle2.start(TestVerticle2.java:9)
    at org.vertx.java.platform.Verticle.start(Verticle.java:82)
    at org.vertx.java.platform.impl.DefaultPlatformManager$18.run(DefaultPlatformManager.java:1271)
    at org.vertx.java.core.impl.DefaultContext$3.run(DefaultContext.java:171)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:353)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:365)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
    at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.ClassNotFoundException: com.test.AwesomeLibrary
    at org.vertx.java.platform.impl.ModuleClassLoader.loadClass(ModuleClassLoader.java:79)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
    ... 8 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi !
In 2.0.0-CR3 (and may be previous version) the exit() function on the vertx/container element doesn't seems to works.
Simple example:
[code]
var console     = require('vertx/console');
var container   = require('vertx/container');
console.log("Start");
container.exit();
console.log("Bug !");
[/code]
The server stop working but the message "Bug !" appear !
Regards,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry, I'm not sure this is an issue, but I don't where to parse my problem. I created a maven project using vertx-maven archetype, pakaging the project into zip. Using vertx runzip {zipfile}, the message was printed after running that command:
java.lang.IllegalArgumentException: 'other' has different root
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Happens on release v2.0.0-final. Java version:
$ java -version
java version "1.7.0_25"
Java(TM) SE Runtime Environment (build 1.7.0_25-b15)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)

On Mac OS X 10.8.4.

Check out tag v2.0.0-final
./gradlew dist
cd build/vert.x-2.0.0-final/bin
Uncomment the following line in the vertx script: # JMX_OPTS="-Dcom.sun.management.jmxremote -Dvertx.management.jmx=true -Dhazelcast.jmx=true"
touch empty.js
./vertx run empty.js -cluster

Exception:
$ ./vertx run empty.js -cluster
Starting clustering... 
No cluster-host specified so using address 192.168.0.11 
Exception in thread "main" java.lang.NullPointerException
        at org.vertx.java.core.impl.management.ManagementRegistry.registerEventBus(ManagementRegistry.java:44)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus.<init>(DefaultEventBus.java:91)
        at org.vertx.java.core.eventbus.impl.DefaultEventBus.<init>(DefaultEventBus.java:82)
        at org.vertx.java.core.impl.DefaultVertx.<init>(DefaultVertx.java:86)
        at org.vertx.java.platform.impl.DefaultPlatformManager.<init>(DefaultPlatformManager.java:96)
        at org.vertx.java.platform.impl.DefaultPlatformManagerFactory.createPlatformManager(DefaultPlatformManagerFactory.java:33)
        at org.vertx.java.platform.impl.cli.Starter.createPM(Starter.java:159)
        at org.vertx.java.platform.impl.cli.Starter.runVerticle(Starter.java:192)
        at org.vertx.java.platform.impl.cli.Starter.<init>(Starter.java:76)
        at org.vertx.java.platform.impl.cli.Starter.main(Starter.java:56)

We have found that this fixes it:
trayio@72d7fb8
Let us know if you'd like us to submit a pull request (I have signed the contributor agreement).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This includes perf work for all supported protocols :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a connection exception (e.g. connection reset by peer) occurs on an http client connection, then the the client close handler is not called resulting in the connection pool not knowing the connection was closed.
https://groups.google.com/forum/?fromgroups#!topic/vertx/pW5R23zIfS8
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the DefaultHttpClient the same context is used for all handlers. This isn't really appropriate in am embedded situation where the instance can be shared by multiple contexts.
Also check DefaultHttpServer and Net clients and servers
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@lance fixed in master via e66f518 ... Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to write a very basic proxy server, but it is generating an exception from the buffer.  The example code is here: https://gist.github.com/lance/7a3acb09eda46425a79e
It's entirely possible that I'm doing something wrong, and obviously this is a naive proxy implementation. But, if you could take a look that'd be great.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See mailing list for more information:
https://groups.google.com/d/msg/vertx/oyEeTWNKwWk/KcuLjyUUfnIJ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox please review ... Related to: https://bugs.eclipse.org/bugs/show_bug.cgi?id=425958
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why would you add Vert.x modules as provided/test/compile dependencies in pom.xml?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ALRubinger could you make sure you fill the CLA and also sign the commit :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What'S this about ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@nscavell looks good... @purplefox wdyt ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
Can you make sure you:

Signed the Eclipse CLA
Signed your commits
Specified your github id in your Eclipse account settings

as explained in CONTRIBUTING.MD
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox wdyt ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
related to https://bugs.eclipse.org/bugs/show_bug.cgi?id=415407
@purplefox please review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hmm, seems that my amend to change the email address to the one I registered in Eclipse still left some references to my other email address. I will create another pull, hopefully with the right email this time.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Andre - if you resubmit another PR with the changes as discussed on the BZ, I will merge it. Thanks for your efforts anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Before thinking about solutions, could someone provide an explanation of the problem, and how we can get into this situation. I think I need to understand that part first :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think the package name was right already: org.vertx.java.spi.cluster.impl.hazelcast
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks. Have you signed the Eclipse CLA?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I will fix this to use my eclipse account email
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi John, I think this PR is now not applicable after my recent changes, so closing it. Thanks anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ah shit sorry, didn't see this PR, but I did it manually anyway
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox this is a workaround for the condition in PooledByteBufAllocator which I showed you yesterday. Working on a proper fix too, but thought a workaround can't harm for now too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox ok to merge in ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks. Can you please sign the commits as explained in CONTRIBUTING.MD?
Also.. have you signed the Eclipse CLA?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey Steve,
Agreed docs could be better - I'm going to add a note for Vert.x 3.0 to improve the docs about the events.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox any feedback ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zaytsev thanks... merged
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+1
This would be nice to be able to determine Binary vs Text frames separately. Our existing application uses this functionality pretty extensively.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sounds legit....
@purplefox I think this is fine... any comments ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@larrytin could you please sign the CLA and sign your commit as explained here: https://github.com/eclipse/vert.x/blob/master/CONTRIBUTING.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also forgot to mention, but I believe the location header should be escaped, hence the use of getRawPath and getRawQuery but couldn't find a definitive answer in my short googling. Maybe there's a better solution for the usecase in which it isn't ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are some fairly critical problems with the version of Hazelcast that vertx relies on. http://hazelcast.org/docs/latest/manual/html-single/hazelcast-documentation.html#fixes
We have run into these. The Vertx/Hazelcast uses the ServiceLoader http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html, which means the changes for clustering are really isolated. I don't see the point in waiting for version 3. There is no technical reason. (Forgive the earlier version of this comment. Turns out. I needed some coffee.)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zdanek could you sign the commit and also sing the CLA like explained here:
https://github.com/eclipse/vert.x/blob/master/CONTRIBUTING.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@ddossot merged... thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ooops, I forgot to sign the commit, I'm going to commit it again.
Closing this PR...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@LostInBrittany thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zdanek merged... thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@tobias thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Already did it :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't see any tests for DefaultPlatformManager in vertx-testsuite... what's the preferred testing pattern for this class?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, Can you make sure you've signed the Eclipse CLA and signed off your commits as described in CONTRIBUTING.MD?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, Can you make sure you've signed the Eclipse CLA and signed off your commits as described in CONTRIBUTING.MD?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox please check.. This caused the race reported here:
https://bugs.eclipse.org/bugs/show_bug.cgi?id=434064#add_comment
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have experienced this OOM problem and I would expect that vertx could include some protection like the one you propose.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox because of this bug a NPE can be thrown when someone calls EventBus.registerHandler(...) later. As in my case the windows firewall was the cause that the startup was not successful.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Gonna leave this until Vert.x 3.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks.
I wonder... as part of codegen validation maybe we could check that the @options class provides a constructor that takes a JsonObject and fail if not...?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
withdrawing for now : need also to handle java.math.BigDecimal created by Groovy...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks. I will apply this manually as it is so simple and the commit isn't signed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks, I will apply this manually as the commit isn't signed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry this is old manual. Added changes to master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wouldn't it be even better to just remove TestUtils.buffersEqual and just use assertEquals(expectedBuffer, actualBuffer)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 2.x is currently in maintenance mode and we're not adding new features, just fixing bugs.
If you want to add an Enum to JsonObject/JsonArray just to convert it to a string before you add it and convert it back to an Enum after:
json.putString("foo", myEnum.toString();
MyEnum myEnum = MyEnum.valueOf(json.getString("foo"));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Applied manually as commit isn't signed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 2.x is currently in maintenance mode and we're not adding new features, just fixing bugs.
If you want to add an Enum to JsonObject/JsonArray just to convert it to a string before you add it and convert it back to an Enum after:
json.putString("foo", myEnum.toString();
MyEnum myEnum = MyEnum.valueOf(json.getString("foo"));
Tim Fox
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just setting statusCode() without setting statusMessage() should reset in the default status message being used. There is a test JavaHttpTest::testDefaultOther() which tests this.
As far as I can tell it's all working as expected already, but if you are seeing an issue can you provide a simple test case and I will investigate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks, I'll apply this manually as it's a small change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Jared. Could you provide [a|some] tests[s] too?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks! Will take a look shortly
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Bartek,
If you want to have a module running at the command line and reloading when you change things in the IDE, it should work if you just do:
mvn vertx:runMod
You shouldn't do package first.
This is explained more in the docs: http://vertx.io/dev_guide.html#run-your-module-and-see-your-changes-immediately
Is this not working for you?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I reverted the previous changes, manually merged the changes with the original RouteMatcher and recommitted. I had accidentally reformatted the original code so it appeared that every line had changed. A compare should now only show the actual changes and additions. I also added additional tests to make sure every method was fully covered. I did find and fix a bug with removing multiple paths in the previous implementation. I also remembered to sign the commit this time around. Hopefully it should be good to go now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Technically the try/finally should surround the for loop in the removeMatchingBindings method otherwise any concurrent route additions or concurrent removeMatchingBindings might cause ConcurrentModificationException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is vestigial code and JMX is not supported in Vert.x 2.x anyway... You can prevent it by not turning JMX on in the vertx script
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think it's correct that an exception is thrown if an attempt to write a frame > max frame size.
If you want to write a websocket message > max frame size then it should be up to the user to write that message as multiple frames. This is the approach we take in the Vert.x 3.0 API.
So, I'm going to close this, as changing it to work the Vert.x 3.0 way would be a new feature, and Vert.x 2.1 is in bug fix only mode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I merged this into master on a local branch and test suite reliably fails:
Tests run: 182, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 16.294 sec
Results :
Failed tests:
LocalEventBusTest.lambda$testSendRegisterSomeUnregisterOne$217:166->AsyncTestBase.fail:213 Should not receive message
LocalEventBusTest.lambda$testRegisterUnregister$210:86->AsyncTestBase.fail:213 Should not receive message
Tests run: 934, Failures: 2, Errors: 0, Skipped: 0
Tests pass fine on unmerged master
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good. I think this belongs in the ext stack though, not the core project. https://github.com/vert-x3/ext
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Need a VertxOptions test for this :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fixed the tostring method to match the one from 2.x, updated unit test to use MultiMap instead of the class for the test variable, added whitespace to fix checkstyle errors
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ooops! Thanks for bringing this to my attention. I will fix it and make another release today.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks. Have you signed the eclipse CLA?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @davidphan thanks for the report. Vert.x 2.x is in bug fix only mode now as it has been superseded by 3.0, but thanks anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is this failure caused by my change of scala version? The module worked for me so it shouldn't cause issues.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why the pull request did not pass Eclipse validation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why the merge request always failed?They need to be validate?Do you know? I'm with the same problem.  #988
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks Nick!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @zhanghappy - we are not going to add any new features in the 2.x branch, and 3.0 already has idle timeout functionality. But thank you anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
another one signed is provided
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you rebase this with master? Has conflicts
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Yes, I have signed the Eclipse CLA
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I fixed this in a somewhat different way. But thanks anyway :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox  can you review these changes please ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good to me
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pretty straightforward this one. Basically removed VertxSPI as Vertx.executeBlocking can now be used directly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Update: this applies for each message sent through the EventBus bridge to an endpoint that requires authentication (basically everything processed by org.vertx.java.core.sockjs.EventBusBridge#doSendOrPub )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you review it @purplefox ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Interesting, I signed the CLA just a few minutes ago. Seems that it requires some time to synchronize...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox please review Tim
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj ping :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj ping :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj ping :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jeremy,
DeploymentTest is probably a good place :)
Also, can you two spaces for tabs, not four?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks, I will deal with this manually as it needs a manual merge.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
anything else needed on this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks Andy, I will fix this manually
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry for the confusion, I see where it is called.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good to me :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks ok to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj  is this one ok to merge now?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi folks, was this updated to take into account @felfert 's comments?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The contextData map is a plain HashMap and is accessed by different threads, it requires some kind of synchronization.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is it ok for merge @purplefox ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what's your email Lars ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox can you review please ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
just added a fix for the issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I assume this is superseded by the later PR so closing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do I still need to provide any test code for epoll?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, can you add a unit test for this please in HttpTest ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox You can review.
I will also add examples to https://github.com/vert-x3/vertx-examples once merged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just had a look. Everything fine for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj I can update the version to 6 the build runs smoothly with those libraries, however I can revert the netty version to 4.0.25. Would that work?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Does this mean you're not going to merge it to the master ?
I'm not the only one who worked on a similar thing
https://github.com/eclipse/vert.x/pull/991/commits
So I guess that is something the community wants.
Can you let me know why it was closed ?
Thank you.
Patrick.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @vietj @cescoffier @pmlopes
could someone review this please?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good to me
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I squash 3 commit in this patch, commit operational confusion. So I re-fork project, and create this new pull request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Clement - for Eclipse core unfortunately commits need to be signed unless you're a comitter to the core project.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Really no need for a PR for this, it's a small change that you can do direct in master :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj @cescoffier @pmlopes please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add some helper methods for sending websocket final frames.
See https://bugs.eclipse.org/bugs/show_bug.cgi?id=469870
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
:+1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Issue tracker reference:
https://bugs.eclipse.org/bugs/show_bug.cgi?id=469623
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj @cescoffier @pmlopes please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox @vietj @cescoffier please merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I already had an Eclipse account and I thought my CLA was still valid. But it my pull request still not pass Eclipse validation
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I already had an Eclipse account and I thought my CLA was still valid. But it looks like they invalidate it after some time... I've signed it again. Not sure what can trigger a new CLA validation process.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
code looks fine, built locally and re-run redis tests and i can report that the stacktrace does not show anymore and tests still pass :)
Good to merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm going to close this as it is superseded by Clement's recent work on Starter/CLI refactoring that we're going to merge very soon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just a small cosmetic comment. Looks good to me otherwise.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
everything fine.
I wonder if we should document the new property (setting the cache base directory) in the manual.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Alright for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Everything fine for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm going to close this as it doesn't seem to contain the JSON changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes https://groups.google.com/d/msg/vertx/0aR54K-_RBg/aQ76BZx7JUQJ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These changes are breaking the API compatibility. It should keep the previous method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Everything fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Bartek, I already fixed this in master the other day, but thanks anyway.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj you asked for it... please review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Everything fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sounds good, gotta merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Gonna close this and re-submit because of the IP validation check. Whatever I do doesn't seem to fix it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what about bundleresource? why is this not extensible?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good, but could you please amend the tests in HttpTest where the options are tested?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good to me, will check with vertx-shell and merge it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@cescoffier @vietj @pmlopes pls review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Alex, could you explain the reasoning behind this change?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Going to close this as it's a breaking API change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Related to vert-x3/issues#70
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm a bit confused - is this a reproducer or does it also contain a fix?
It appears to include changes to HAManager behaviour, I'd expect a reproducer to only include a test and no changes to Vert.x itself, otherwise you're reproducing the issue against something that's not the released Vert.x version....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good, but can you just fix your indentation?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi, the event bus recently had an interceptor addition that one can use to build similar things, could you check that feature to see if that could be built using it ? if not, perhaps we can improve the eventbus interceptors to achieve it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
please sign your commit and agree to CLA.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
would be nice to have a test case exhibiting the issue
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Stampy,
Unfortunately we can't do it this way as it would involve an incompatible change on a public API (we must maintain backwards compatibility in minor or point releases).
A different way to do this and which would preserve backwards compatibility would be to keep the signature of the body end handler the same but to expose a new method bytesWritten() which could called from inside the bodyEndHandler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I haven't checked, do you know if the issue applies to DatagramSocketMetrics as well?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
there is not test for this feature.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Replaced by #1202 (same implementation, with a few tests).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@purplefox any chance you'll be able to look over this soon? Right now I have my version in our maven repo until this is merged. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just did a rebase and excluded the generated asciidoc to avoid conflicts.
Ping @vietj
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok for me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@kjim could you please sign the Eclipse CLA:
https://www.eclipse.org/legal/CLA.php
And then re-submit this PR and don't forget to sign-off the commit:
git commit -s "comment"
This way you comply to the IP rules and your commit can be merged.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpServerRequestImpl.java, line no. 360:
          decoder.offer(new DefaultHttpContent(data.getByteBuf().duplicate()));

but data.getByteBuf() itself invokes buf.duplicate ()
This is in the latest released version 3.1.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Vert.x 2 there was an option to limit the size of HttpClient waiting connection queue made in this PR - #849 (discussion in #845). Apparently, in Vert.x 3, due to the refactoring, this functionality wasn't included.
See https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/http/impl/ConnectionManager.java#L95
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The functionality was added to Vert.x 2.x but was not carried forward into the 3.x code base.  If using keepalive connections and the server sends back an 'Connection: close' header then the client should close it's connection and not continue using it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
shouldn't you reduce the scope of synchronization to only += statement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
In order to contribute you must have signed the eclipse CLA: http://www.eclipse.org/legal/CLA.php
And then re-submit the PR and don't forget to commit and sign-off:
git commit -s -a -m "Grammatical fixes in README"

You only need to sign the CLA once for all Eclipse projects :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
that would allow to trace the flow propagation (i.e when a context schedules the execution of a context and its later execution, etc...)
Vert.x Unit could use that to be aware of failures and somehow get rid of TestContext , for instance:
@Test
public void testSomething(TestContext ctx) {
  long now = System.currentMillis();
   vertx.setTimer(50, v -> {
      ctx.assertTrue(System.currentMillis() - now <= 50);
   });
}

could be pretty much like:
@Test
public void testSomething() {
  long now = System.currentMillis();
   vertx.setTimer(50, v -> {
      assertTrue(System.currentMillis() - now <= 50);
   });
}

the AssertionError would be caught by Vert.x Unit and make the test fail.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If HttpClient is not running inside a verticle/container. For example, it's running as a HTTP client application. HttpClientRequest.write()/end() are supposed to be called from outside vert.x event loop. When doing so, write() will be re-invoked in vert.x event loop but end() will not be. Therefore, complete flag may be set to "true" before all the write() calls are invoked. In such case, the request may end before it sends out all of its data.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If an HttpClientRequest get's in a state where it is no longer receiving data from a server and a request timeout fires then Vertx should force the connection to close so that it can be freed up so another request can be processed.   Most likely since the connection is in an unknown state it shouldn't be reused if keepalive is enabled.
This issue combined with issue #1212 can easily cause an OOM or stalled HTTPClient situation on high throughput servers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a request goes into the HTTPClient wait queue and times out before being processed it will still cause an http connection to be opened and closed in a non-keepalive case.  This has the side effect of causing a large number of TIME_WAIT sockets on the local host and extra load on the server and network for no value.
If a waiting request times out it should be ignored rather than cause an interaction with the connection pool.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fixed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From a server perspective, there is no handler which is guaranteed to be called when a request finishes. HttpServerResponse.bodyEndHandler is only called if the request ends properly. If a socket is closed by either side, it may not be called. Another option is to use closeHandler but it will not be called when the request is ended either.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Based on the code in HttpClientRequestImpl#handleTimeout and the test testRequestTimeoutExtendedWhenResponseChunksReceived it would indicate that the request timeout is supposed to be canceled at the end of the response with some grace period applied as long as data is being received.
The current code doesn't actually work in that manner and I question whether a sliding timeout window is desired behavior either.
Currently, the timeout is canceled in handleResponse which is called when the underlying connection handler receives the Status-Line of the response in HttpClientImpl.ClientHandler#doMessageReceived.  Since this is the first packet of the response it means that the time it takes to receive the body, and the implied chunk handling timeout extension, is never included in the request timeout time.  A test that would illustrate the problem would be to set a requestTimeout, have the server send headers but delay the body for more than the timeout.  You should see that the timeout never fires as it was already canceled once the server sent the initial response packet.
It seems like the preferred behavior would be to cancel the requestTimeout timer in ClientConnection#handleResponseEnd and remove the sliding window implied by the chunk handling or make it optional.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How to accept this Agreement
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For instance the NetSocket handlers, that would allow the Metrics SPI to distinguish them easily.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have an issue when a server send a response with too large headers, when debugging I  see that Netty has put the status "decodeResult: failure(io.netty.handler.codec.TooLongFrameException: HTTP header is larger than 8192 bytes.)" on the DefaultHttpResponse but Vert.x HttpClient does not check this status and handle normally the response which has incomplete headers.
For example the initial content-length header is not present in the headers and that breaks the processing of the response. Processing that should not be done as Netty has failed decoding the response.
Can you fix this problem?
I have a second issue, I effectively have some big headers but the  "HttpClientCodec" parameters are not configurable, I will open a second issue for this point.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add some options to HttpClientOptions and HttpServerOptions to let users customize the netty HttpClientCodec/HttpRequestDecoder options (maxHeaderSize/maxChunkSize).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LocationAwareLogger l = (LocationAwareLogger) logger;
  l.log(null, FQCN, level, msg, null, t);

Should pass params as the second last parameter
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm writing non-blocking HTTP proxy server and faced with the issue: after several benchmark iterations my server stop handling requests. As I see pooled connections are in CLOSE_WAIT state (according to netstat) which means that remote server has closed them, but vert.x http client still keeps them for sending data. I suppose when new request arrives vert.x acquires one of them to pass the request and then hangs.
My environment:
Vert.x 3.1.0
JDK 1.8
OS X 10.9.5
Code sample (Kotlin):
val clientOptions =
                HttpClientOptions()
                        .setDefaultHost("$BUCKET.s3.amazonaws.com")
                        .setMaxPoolSize(1000)

        val client = vertx.createHttpClient(clientOptions)

        val serverOptions =
                HttpServerOptions()
                .setAcceptBacklog(1000)

        vertx.createHttpServer(serverOptions)
                .requestHandler { request ->
                    val path = request.path()

                    when (request.method()) {                        
                        HttpMethod.GET -> {
                            client.get(path) { s3Response ->
                                if (s3Response.statusCode() != 200)
                                    request.response().setStatusCode(s3Response.statusCode()).end()
                                else {
                                    val response =
                                            request.response()
                                                    .putHeader(LENGTH_HEADER, s3Response.getHeader(LENGTH_HEADER))

                                    val pump = Pump.pump(s3Response, response)

                                    s3Response.endHandler { response.end() }

                                    pump.start()
                                }
                            }
                            .putHeader("Date", "...") // put required headers
                            .end()
                        }
                        else ->
                            request.response().setStatusCode(400).end("Unsupported HTTP verb")
                    }
                }
                .listen(8080) { result ->
                    if (result.succeeded())
                        future.complete()
                    else
                        future.fail(result.cause())
                }

...

@JvmStatic fun main(args: Array<String>) {
            Launcher.main(arrayOf("run", MyVerticle::class.java.name))
}
The issue looks similar to #1218 but differs in closing connection trigger - my case is a remote server closes connection explicitly. I suppose that http client should close it in order and remove from pool.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Client request metrics callback in the metrics SPI:

when a request is enqueued in the connection manager
when it gets the client connection
when a request time outs

that would allow the metrics SPI implementation to report client statistics like connection pool dimensions, request queuing statistics, etc.....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add to the metrics SPI details about the current worker pool.

max size
current size
queue size
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This happens in Vert.x 3.2. In thread 5717, we hold the lock on HttpClientImpl.close (lock #1) and then we try to acquire a lock on ClientConnection.close (lock #2). In thread 7035, we hold a lock #2 in ClientConnection.handleClosed and try to hold a lock #1 at HttpClientImpl.checkClosed. And boom, we get a deadlock.
I don't have a good repro now since it's quite hard to reproduce consistently. But I can demonstrate from the stack trace:
Thread 5717: (state = BLOCKED)
 - io.vertx.core.http.impl.ClientConnection.close() @bci=0, line=352 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientImpl.close() @bci=46, line=642 (Interpreted frame)

Thread 7035: (state = BLOCKED)
 - io.vertx.core.http.impl.HttpClientImpl.checkClosed() @bci=0, line=791 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientImpl.doRequest(io.vertx.core.http.HttpMethod, java.lang.String, int, java.lang.String, io.vertx.core.MultiMap) @bci=23, line=782 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientImpl.request(io.vertx.core.http.HttpMethod, int, java.lang.String, java.lang.String) @bci=7, line=338 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientImpl.get(int, java.lang.String, java.lang.String) @bci=7, line=348 (Interpreted frame)
          . 
          .
          .
 - io.vertx.core.http.impl.HttpClientRequestImpl.lambda$exceptionHandler$78(io.vertx.core.Handler, java.lang.Throwable) @bci=6, line=262 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientRequestImpl$$Lambda$21.handle(java.lang.Object) @bci=12 (Interpreted frame)
 - io.vertx.core.http.impl.HttpClientRequestImpl.handleException(java.lang.Throwable) @bci=21, line=384 (Interpreted frame)
 - io.vertx.core.http.impl.ClientConnection.handleClosed() @bci=59, line=307 (Interpreted frame)
 - io.vertx.core.net.impl.VertxHandler$$Lambda$43.run() @bci=4 (Interpreted frame)
 - io.vertx.core.impl.ContextImpl.lambda$wrapTask$16(boolean, io.vertx.core.impl.ContextTask, io.vertx.core.Handler) @bci=167, line=333 (Compiled frame)
 - io.vertx.core.impl.ContextImpl$$Lambda$15.run() @bci=16 (Compiled frame)
 - io.vertx.core.impl.ContextImpl.executeFromIO(io.vertx.core.impl.ContextTask) @bci=17, line=225 (Compiled frame)
 - io.vertx.core.net.impl.VertxHandler.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=37, line=99 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive() @bci=8, line=218 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive() @bci=20, line=204 (Interpreted frame)
 - io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=1, line=75 (Interpreted frame)
 - io.netty.handler.timeout.IdleStateHandler.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=6, line=257 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive() @bci=8, line=218 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive() @bci=20, line=204 (Interpreted frame)
 - io.netty.handler.codec.ByteToMessageDecoder.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=86, line=332 (Interpreted frame)
 - io.netty.handler.codec.http.HttpClientCodec$Decoder.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=2, line=212 (Interpreted frame)
 - io.netty.channel.CombinedChannelDuplexHandler.channelInactive(io.netty.channel.ChannelHandlerContext) @bci=5, line=132 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive() @bci=8, line=218 (Interpreted frame)
 - io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive() @bci=20, line=204 (Interpreted frame)
 - io.netty.channel.DefaultChannelPipeline.fireChannelInactive() @bci=4, line=828 (Interpreted frame)
 - io.netty.channel.AbstractChannel$AbstractUnsafe$7.run() @bci=10, line=625 (Interpreted frame)
 - io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(long) @bci=26, line=358 (Compiled frame)
 - io.netty.channel.nio.NioEventLoop.run() @bci=106, line=357 (Compiled frame)
 - io.netty.util.concurrent.SingleThreadEventExecutor$2.run() @bci=13, line=112 (Compiled frame)
 - java.lang.Thread.run() @bci=11, line=745 (Compiled frame)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This does not behave as I expected where the callback of HttpClient called inside event loop is not guaranteed to be called back in the same event loop due to the connection from another event loop is reused in another event loop.
package io.vertx.test.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpServer;
import org.junit.Test;

import java.util.concurrent.CountDownLatch;

public class HttpDeadlockTest extends HttpTestBase {

    @Test
    public void testDeadlock() throws Exception {
        CountDownLatch latch = new CountDownLatch(4);
        client = vertx.createHttpClient();
        HttpClient localClient = vertx.createHttpClient();
        vertx.deployVerticle(new TestVerticle(), x -> latch.countDown());
        vertx.deployVerticle(new TestVerticle(), x -> latch.countDown());
        vertx.deployVerticle(new TestVerticle(), x -> latch.countDown());
        vertx.deployVerticle(new TestVerticle(), x -> latch.countDown());
        latch.await();
        CountDownLatch latch1 = new CountDownLatch(100);
        for (int i = 0; i < 100; i++) {
            localClient.getNow(19009, "localhost", "/", res -> {
                latch1.countDown();
                assertEquals(200, res.statusCode());
            });
        }
        latch1.await();
        localClient.close();
    }

    private class TestVerticle extends AbstractVerticle {

        @Override
        public void start(Future<Void> startFuture) throws Exception {
            HttpServer httpServer = vertx.createHttpServer();
            httpServer.requestHandler(x -> {
                Thread serverThread = Thread.currentThread();
                HttpClientRequest req = client.get(80, "load.s3.amazonaws.com", "/pixel.gif");
                req.handler(res -> {
                    Buffer buf = Buffer.buffer();
                    res.endHandler(v -> {
                        Thread clientThread = Thread.currentThread();
                        if (clientThread != serverThread) {
                            x.response().setStatusCode(500);
                        } else {
                            x.response().setStatusCode(200);
                        }
                        x.response().end();
                    });
                    res.handler(buf::appendBuffer);
                });
                req.end();
            });
            httpServer.listen(19009, x -> startFuture.complete());
        }

        @Override
        public void stop(Future<Void> stopFuture) throws Exception {
            super.stop(stopFuture);
        }
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Not much credit to me, most of the code was copied from a PR of @ddimensia (for some reason I was not able to make this PR working and merged just before 3.2 so I preferred to revert) , I modified it a bit, the tests are provided by @alexlehm .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If I send an HTTP/1.0 request to a (Ceylon) Vert.x http server with Vert.x 3.2.0 like
GET / HTTP/1.0

.. then the server responds with:
HTTP/1.0 200 OK

However the response version should indicate the capabilities of the server. Since Vert.x supports 1.1 as well it should instead respond with:
HTTP/1.1 200 OK

This way the client becomes aware that the server also supports HTTP/1.1. It does not however change the semantics of the response - the server still has to send a response that complies with HTTP/1.0 semantics since the client has indicated the maximum version it can use.
The only required change to implement this is thus to always write "HTTP/1.1" in the response. All the logic on setting response headers and closing connections etc should work as before, i.e. use the version from the request to decide semantics.
Some references for more information:

https://bugs.php.net/bug.php?id=42779
http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.1 - "The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying out vert.x 3.2.0, the live redeploy option appears to be broken:
john@vbox:~/wokspace/vertx/cae$ $ vertx run -cp target/classes --redeploy="*/.class" io.mytest.HelloWorld
Starting the vert.x application in redeploy mode
Starting vert.x application...
c7dc08f2-693e-4dfe-8312-62c17d0595a7-redeploy
java.lang.ClassNotFoundException: run
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at io.vertx.core.impl.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:42)
at io.vertx.core.impl.DeploymentManager.createVerticles(DeploymentManager.java:186)
at io.vertx.core.impl.DeploymentManager.lambda$doDeployVerticle$153(DeploymentManager.java:159)
at io.vertx.core.impl.FutureImpl.checkCallHandler(FutureImpl.java:135)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:100)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:132)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:104)
at io.vertx.core.impl.DeploymentManager.deployVerticle(DeploymentManager.java:92)
at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:546)
at io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer.deploy(VertxIsolatedDeployer.java:46)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at io.vertx.core.impl.launcher.commands.ClasspathHandler.deploy(ClasspathHandler.java:160)
at io.vertx.core.impl.launcher.commands.RunCommand.deploy(RunCommand.java:373)
at io.vertx.core.impl.launcher.commands.RunCommand.run(RunCommand.java:247)
at io.vertx.core.impl.launcher.VertxCommandLauncher.execute(VertxCommandLauncher.java:230)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:365)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:328)
at io.vertx.core.Launcher.main(Launcher.java:48)
Dec 21, 2015 11:03:45 AM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
SEVERE: Failed in deploying verticle
java.lang.ClassNotFoundException: run
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at io.vertx.core.impl.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:42)
at io.vertx.core.impl.DeploymentManager.createVerticles(DeploymentManager.java:186)
at io.vertx.core.impl.DeploymentManager.lambda$doDeployVerticle$153(DeploymentManager.java:159)
at io.vertx.core.impl.FutureImpl.checkCallHandler(FutureImpl.java:135)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:100)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:132)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:104)
at io.vertx.core.impl.DeploymentManager.deployVerticle(DeploymentManager.java:92)
at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:546)
at io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer.deploy(VertxIsolatedDeployer.java:46)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at io.vertx.core.impl.launcher.commands.ClasspathHandler.deploy(ClasspathHandler.java:160)
at io.vertx.core.impl.launcher.commands.RunCommand.deploy(RunCommand.java:373)
at io.vertx.core.impl.launcher.commands.RunCommand.run(RunCommand.java:247)
at io.vertx.core.impl.launcher.VertxCommandLauncher.execute(VertxCommandLauncher.java:230)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:365)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:328)
at io.vertx.core.Launcher.main(Launcher.java:48)
java.lang.ClassNotFoundException: run
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at io.vertx.core.impl.JavaVerticleFactory.createVerticle(JavaVerticleFactory.java:42)
at io.vertx.core.impl.DeploymentManager.createVerticles(DeploymentManager.java:186)
at io.vertx.core.impl.DeploymentManager.lambda$doDeployVerticle$153(DeploymentManager.java:159)
at io.vertx.core.impl.FutureImpl.checkCallHandler(FutureImpl.java:135)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:100)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:132)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:104)
at io.vertx.core.impl.DeploymentManager.deployVerticle(DeploymentManager.java:92)
at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:546)
at io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer.deploy(VertxIsolatedDeployer.java:46)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at io.vertx.core.impl.launcher.commands.ClasspathHandler.deploy(ClasspathHandler.java:160)
at io.vertx.core.impl.launcher.commands.RunCommand.deploy(RunCommand.java:373)
at io.vertx.core.impl.launcher.commands.RunCommand.run(RunCommand.java:247)
at io.vertx.core.impl.launcher.VertxCommandLauncher.execute(VertxCommandLauncher.java:230)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:365)
at io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(VertxCommandLauncher.java:328)
at io.vertx.core.Launcher.main(Launcher.java:48)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Eclipse need the launcher-class
It should give a complete example with Gradle and Maven.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It is useful when dealing with unit tests that involve multiple vert.x especially if the name is used as part of the threads created by vert.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a route that tries to retrieve if the request is an http or https request.
private void handleAddEvent(RoutingContext routingContext) {
routingContext.request.netSocket().isSsl();
response.end();
}
The call the isSsl seems to stop the verticle to accept any new http request.
I use Vert.x 3.2.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to utilize vertx-codegen to generate code, somehow it always picks up codegen from vertx-core instead of my own's. Would be great if you guys can just move it out of final release
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This happens in Vert.x 3.2.
On start-up a vertx-web-fat-JAR on a path with whitespace i get a internall server error.
Example -> ok:
Working dir: C:\Users*Max*\git\Project\target
Start-CMD: java -jar webapp.jar
Example -> failed:
Working dir: C:\Users*Max Mustermann*\git\Project\target
Start-CMD: java -jar webapp.jar
500 C:\Users\Max%20Mustermann\git\Project\target\webapp.jar (Das System kann den angegebenen Pfad nicht finden)

    java.io.FileInputStream.open0(Native Method)
    java.io.FileInputStream.open(Unknown Source)
    java.io.FileInputStream.(Unknown Source)
    java.io.FileInputStream.(Unknown Source)
    io.vertx.core.impl.FileResolver.toZipInputStream(FileResolver.java:171)
    io.vertx.core.impl.FileResolver.unpackFromJarURL(FileResolver.java:180)
    io.vertx.core.impl.FileResolver.resolveFile(FileResolver.java:121)
    io.vertx.core.impl.VertxImpl.resolveFile(VertxImpl.java:657)
    io.vertx.core.file.impl.FileSystemImpl$6.perform(FileSystemImpl.java:517)
    io.vertx.core.file.impl.FileSystemImpl$6.perform(FileSystemImpl.java:514)
    io.vertx.core.file.impl.FileSystemImpl.propsBlocking(FileSystemImpl.java:150)
    io.vertx.ext.web.handler.impl.StaticHandlerImpl.lambda$getFileProps$4(StaticHandlerImpl.java:264)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
handleException is called for each request of the connection, this is necessary as there could be several requests made in the current connection (keepalive or pipeline).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj test added
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I know this is a tricky subject, but the problem is real. Here is my scenario. I'm implementing an API method that allows the client to update a server resource with a new content PROVIDED the resource is already known on the server. A nice way of doing it is to have the client wait for 100-Continue before sending in the update stream itself which can be quite large.  Since the URL contains the resource ID the server can look it up first, and only if exists signal the client to proceed. However, if the resource does not exist, the server would reply with an error status and the client would not send the update. The connection can remain open and ready for the next request.
However, with vert.x this is apparently not possible...
Here is what I'm doing at a bit lower level:

In httpserverconfig I use handle100ContinueAutomatically = false
Upon receiving request, the server extracts the resource ID from the URL and checks for the resource availability status.
If resource available, do

               if (isExpect100Continue())
                    response.writeContinue();

then proceed with setting up request handler as usual.
4. If resource is not available, do
response.setStatusCode (404).end ("some error message);

What I see:
In the case of resource being available, everything works as expected.
In the case of resource being not available, the connection becomes unusable and all subsequent client requests arriving on that connection simply time out. In that state, the following is what I see in my log (in my code I log these states after invoking "request.end()"):
request.isEnded()=false, rc.response.ended()=true, rc.response.bytesWritten()=65

This clearly shows that request is not 'ended' since really the client did not send any data expecting 100-continue but instead getting 404 (btw, I'm using standard apache http client and it behaves flawlessly in the scenario above)
This may lead to a bigger question: perhaps the right answer is to expose 'drainAndEnd ()' method on the request to ensure that nothing remains in the request pipeline and forcing the end state? Http/2 has this feature built-in.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if (...)
   pipeline.addLast("log", new LoggingHandler())

Those who ever needed to debug Netty know that LoggingHandler is one of the first instruments.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj, @pmlopes  please review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You will need to update. Except that +1.
(BTW it includes changes coming from other PR).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An HttpClient should not be shared between different Verticles or Context. It should be documented and when the client detects a different context, it should print a warn on the console to make the user aware of this situation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have 2 Verticles :a sender and a receive.Sometimes - with sending-receiving first message ,i see that My Receive can not  handle first message -but ok with all other messages after it.So i have 2 assumptions: i have sent message when Receive haven't deployed completed ,or Message didn't send successfully.How can i fix it???
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I know the platform is very JSON oriented but I think this is not that same. MultiMap obtain used as the "request header" which style is like KEY=VALUE;. Otherwise, I just followed familiar Java toString() style of Collection of HashSet.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add a new option for HttpClientOptions where we should set a DefaultExceptionHandler for all HttpClientRequest created by that HttpClient.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi, this seems to be interesting but we didn't have time to include it in 3.3.0 - will look for 3.3.1 instead
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
endHandler callback handler is not called when the HttpClientRequest.end() is called. However, it is called when it receives a HttpClientResponse which is quite unexpected. And worse, it is also called after the handler for HttpClientRequest.handler(Handler<HttpClientResponse>) being called. I would expected it to be called when the entire data has been written to.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current implementation of this method in MessageProducerImpl will always return a value of true.    At least for my use case it would be preferable if it returned true only if the producer is out of credit and has started to place messages in its pending queue.  It looks like this may have been the intent (since the code checks the pending queue size), but the check is current pending.size() >= 0 when I think it should be pending.size() > 0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If we add registration support, it would be good to have the unregister no ?
We would need unit tests, before integrating this feature.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Initial ticket: Encryption for EventBus #574:
For being able to run a vertx-cluster on a LAN, where other nodes are present (they should not be able to read the event bus communication) encryption for the server node traffic is necessary.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
Issue hazelcast/hazelcast#5220 had been closed in October, we should upgrade to the latest stable build 3.5.4 (http://hazelcast.org/download/ ) .
see https://github.com/vert-x3/vertx-hazelcast/blame/master/pom.xml#L44
and then we can remove the workaround here:
https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/impl/VertxImpl.java#L431
kind regards
Gabriel
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm wondering how this works as ByteOrder is not an enum and not code generated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Logging with SLF4J enabled (vertx.logger-delegate-factory-class-name = io.vertx.core.logging.SLF4JLogDelegateFactory) does not use all the log arguments.
for example:
LoggerFactory.getLogger(Foo.class).info("test {}", "param")
outputs:
"test {}"

instead of expected output:
"test param"

This is easily fixable in io.vertx.core.logging.SLF4jLogDelegate.java#log:
-      l.log(null, FQCN, level, msg, null, t);
+      l.log(null, FQCN, level, msg, params, t);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj @pmlopes please review.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mergeIn function overwrite previos value of JsonObject.
for example:
JsonObject origin = new JsonObject().put("key", new JsonObject("foo","bar"));
origin.mergeIn(new JsonObject().put("key", new JsonObject("fooo","barr")));
outputs:
{"key":{"fooo": "barr"}}
instead of expected output:
{"key":{"foo": "bar", "fooo": "barr"}}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think it's good to support epoll transport, but it shouldn't be the default.
We had a similar PR some time back and I did a performance comparison between native and standard nio and the native was actually slower!
I think a better way of doing this would be a config setting to choose the transport in the options class.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current implementation returns / leaks a java.util.ArrayList<?> in case of a JsonArray or a Map in case of a JsonObject. It should check for these implementations and return a JsonArray or JsonObject wrapper.
See https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/json/JsonArray.java#L482
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
should be fixed but not in 3.2.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@xkr47 you forgot to sign-off your commit
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The general idea is:

execute in an worker verticle
instantiate a countdown latch
use executeBlocking( { eventbus.send(...., { latch.countdown() } , false /* unordered */  )
wait for countdown latch.

From my observations the eventbus.send finish execution however nothing happens on the eventbus. The target does not get any message.
I tracked a bit the problem inside EventBus.send and it leads me to HazelcastAsyncMultiMap.get implementation which does an executeBlocking which is ordered with the caller.
The body of execute blocking in HazelcastAsyncMultiMap.get is never executed.
This is strange however because the eventbus.send is executed by another worker thread than the caller.
Is this the expected behavior? Seems to me like a problem.
Some code:
https://github.com/mstanescu/vertx-hazelcast/blob/master/src/main/java/io/vertx/spi/cluster/hazelcast/impl/HazelcastAsyncMultiMap.java
You can see the implementation of the awaitResult that i am using here.
https://github.com/mstanescu/thread-test/blob/master/src/main/java/com/qnective/qtalkng/Sync.java
And how i use it here:
https://github.com/mstanescu/thread-test/blob/master/src/main/java/com/qnective/qtalkng/SerializedRequester.java
Sorry but the project is not compileable as a standalone but you can just copy this class. Will notify when i make the project work as a standalone project.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi I write the below code
    public static void main(String... args) {
        Vertx vertx = Vertx.vertx();
        vertx.eventBus().consumer("test", event -> {

            LinkedHashMap<String, Object> map = new LinkedHashMap<>();
            map.put("grecery", "grecery");
            map.put("location", "location");
            map.put("posNo", "posNo");
            map.put("totalCount", 0L);

            JsonObject jsonObject = new JsonObject(map).put("todayCount", 0L);
            System.out.println("SENDING: ");
            System.out.println(jsonObject.encode());    // {"grecery":"grecery","location":"location","posNo":"posNo","totalCount":0,"todayCount":0}
            event.reply(jsonObject);
        });
        Router router = Router.router(vertx);
        router.get().handler(ctx -> {
            vertx.eventBus().send("test", null, (AsyncResult<Message<JsonObject>> event) -> {
                JsonObject body = event.result().body();
                System.out.println("RECEIVED: ");
                System.out.println(body.encode());  // {"location":"location","todayCount":0,"grecery":"grecery","posNo":"posNo","totalCount":0}

                ctx.response().end(body.encodePrettily());
            });
        });
        HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(8055);
    }


The key order is not retaining in the json object got from the message body. Please fix this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
WebSockets behind AWS Elastic Load Balancers will lose Client IP information since TCP load-balancing must be used instead of Layer 7 where it injects a HTTP header such as 'X-Forwarded-For'. In this environment and other similar load balanced environments the Proxy Protocol is used which was designed by HAProxy. Amazon AWS ELB supports it and is the recommended way of dealing with load-balancing WebSockets while retaining the Client IP and allowing the WebSocket connection to remain open indefinitely. Netty implements the decoder and is named HAProxyMessageDecoder. The dependency is netty-codec-haproxy. It would be ideal if HttpServerImpl could support this Decoder when setting up Netty internally as part of the ChannelInitializer. Perhaps it could be added as a flag on HttpServerOptions (i.e. boolean proxyProtocol). Essentially this option opens up the world of scalable load-balanced WebSocket servers with the simplicity of running just vert.x based HTTP server directly behind a cluster of load-balancers such as AWS ELB.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See : http://shipilev.net/blog/2016/arrays-wisdom-ancients/
Sounds like an optimization we could have for free.
I took a look and can send a PR that's a very limited change (in core, at least). But @vietj pointed out we should have some microbenchmarks to rely on before doing such kind of things.
How should we do it ?
Proposal :

create a repo within the vertx organization holding benchmarks
initializing this repo with the benchmarking structure (using : jmh). So that layout is good to go
creating a very simple "sample" benchmark people can use as a pattern on to add new bechmarks
let the community add benchmarks through PRs

Maybe @purplefox has thoughts (or even already-tested benchmarks) to share ?
What do you guys think ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JULLogDelegateFactory can be configured through a system property and a file vertx-default-jul-logging.properties. I wonder if it would make sense to also make LoggerFactory configurable through the system property vertx.logger-delegate-factory-class-name as well as a file (probably called vertx-logger-factory.properties with a single property vertx.logger-delegate-factory-class-name) or through the Java service mechanism maybe.
This would make it easier to pre-configure the required logger by placing a file in the classpath. This would even work in a fat jar where system properties can only be set by the caller.
What do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried to run gradle-verticles example. I followed a README, but after build and run, no verticle listens on the port.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fatjar it creates perf issues when unpacking resources because it went from ZipFile#entries() (that is basically a lookup in the Zip dir structure) to ZipFileInputStream that performs a scan of the Zip file.
See this commit : 29000c6#diff-4f1620acdced3de97ebe522db0fd106a
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi all,
deployVerticle can perform asynchronous computations.
Given the code below on error case the handler is called synchronously when closed is true.

  public void deployVerticle(Verticle verticle, DeploymentOptions options, Handler<AsyncResult<String>> completionHandler) {
    boolean closed;
    synchronized (this) {
      closed = this.closed;
    }
    if (closed) {
      completionHandler.handle(Future.failedFuture("Vert.x closed"));
    } else {
      deploymentManager.deployVerticle(verticle, options, completionHandler);
    }
  }

My suggestion is to always invoke completionHandler asynchronously.
This would simplify caller code a lot if this method will always invoke the handler asynchronously. In this way the caller can embrace declarative style programming without having to worry about results coming synchronously while declarative code executes.
This should be applied to all APIs which might mix them.
I am trying to write this kind of code:
AsyncJoin
    .join(h->deployVerticle(x,h))
    .onCompleted(lambda).

And because of the described problem i am forced to do the one below otherwise the AsyncJoin might be complete before onCompleted was registered and since is a declarative construct the order should not matter.
AsyncJoin
     .join(
             h->runInContext(
                     ()->deployVerticle(x,h)
             ))
     .onCompleted(lambda).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to user Rxfied Buffer.buffer(byte[] bytes) but it seems not available
Any alternative solution !?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vertx 3.2.1.
Sometimes EventLoop thread blocked on Vertx.clusteredVertx().
Method Vertx.clusteredVertx() called on the main java thread on application startup.
Stacktrace:
19:30:48.633 [vertx-blocked-thread-checker] WARN  i.v.core.impl.BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5660 ms, time limit is 2000
io.vertx.core.VertxException: Thread blocked
    at java.lang.Object.wait(Native Method) ~[na:1.8.0]
    at com.hazelcast.spi.impl.operationservice.impl.InvocationFuture.pollResponse(InvocationFuture.java:299) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.spi.impl.operationservice.impl.InvocationFuture.waitForResponse(InvocationFuture.java:247) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.spi.impl.operationservice.impl.InvocationFuture.get(InvocationFuture.java:224) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.spi.impl.operationservice.impl.InvocationFuture.get(InvocationFuture.java:204) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.map.impl.proxy.MapProxySupport.invokeOperation(MapProxySupport.java:456) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.map.impl.proxy.MapProxySupport.putInternal(MapProxySupport.java:417) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.map.impl.proxy.MapProxyImpl.put(MapProxyImpl.java:97) ~[hazelcast-3.5.2.jar:3.5.2]
    at com.hazelcast.map.impl.proxy.MapProxyImpl.put(MapProxyImpl.java:87) ~[hazelcast-3.5.2.jar:3.5.2]
    at io.vertx.core.impl.HAManager.<init>(HAManager.java:145) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.VertxImpl.lambda$new$270(VertxImpl.java:152) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.VertxImpl$$Lambda$3/852445367.handle(Unknown Source) ~[na:na]
    at io.vertx.core.impl.FutureImpl.checkCallHandler(FutureImpl.java:158) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:100) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.ContextImpl.lambda$null$16(ContextImpl.java:305) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.ContextImpl$$Lambda$7/299713639.handle(Unknown Source) ~[na:na]
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$18(ContextImpl.java:335) ~[vertx-core-3.2.1.jar:na]
    at io.vertx.core.impl.ContextImpl$$Lambda$8/977225900.run(Unknown Source) ~[na:na]
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:358) ~[netty-common-4.0.33.Final.jar:4.0.33.Final]
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357) ~[netty-transport-4.0.33.Final.jar:4.0.33.Final]
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112) ~[netty-common-4.0.33.Final.jar:4.0.33.Final]
    at java.lang.Thread.run(Thread.java:744) ~[na:1.8.0]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj @pmlopes ready for review
@vietj it adds two 'provided' dependencies - not sure if we need to open CQ for these.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
related to #1255
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As discussed on the mailing list.  Bumping the versions in core introduces no breakages on core but may conflict with child 'modules' as Vert.x has a flat Classpath.  I'll shortly post a possible Maven plugin detection solution for checking this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
that's something you cannot do on your own with an exception handler ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj Didn't help this time :-( Any suggestion on who I should reach out to?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 3.2.1:
The else block of the completer() method does not make sense to me. It calls failed() on AsyncResult which returns a boolean indicating if the result failed or not. If the else block had been omitted altogether, the result of completer() would have been the same.
I was expecting the else block to mark the future as failed.
  default Handler<AsyncResult<T>> completer() {
    return ar -> {
      if (ar.succeeded()) {
        complete(ar.result());
      } else {
        ar.failed();
      }
    };
  }

Am I missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@pmlopes @cescoffier or any other Vert.x committer please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When starting clustered vetx instance:
Vertx.clusteredVertx(
        new VertxOptions()
            .setClustered(true)
            .setClusterHost("127.0.0.1")
            .setClusterPort(9999),
        result ->
        {
            System.out.println("Cluster started");
        }
    );
if it cannot bind to the address it prints the exception:
io.vertx.core.impl.VertxImpl SEVERE: Failed to start event bus
java.net.BindException: Address already in use
        at sun.nio.ch.Net.bind0(Native Method)
        at sun.nio.ch.Net.bind(Net.java:433)
        at sun.nio.ch.Net.bind(Net.java:425)
        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)
        at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)
        at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:125)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:485)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1089)
        at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:440)
        at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:425)
        at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:903)
        at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:198)
        at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:348)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:358)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
        at java.lang.Thread.run(Thread.java:745)

and the result handler is never called.
The problem seems to be in io.vertx.core.impl.VertxImpl.createAndStartEventBus() where only error is logged and the resultHandler is not called:
} else {
  log.error("Failed to start event bus", ar2.cause());
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@circlespainter you need to sign the Eclipse CLA and sign-off your commit
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HA mode the documentation states the following: "Please note that cleanly closing a Vert.x instance will not cause failover to occur, e.g.CTRL-C or kill -SIGINT"
Can this behavior become a user setting allowing to choose if CTRL-C or kill -SIGINT induces a failover or not?
I have the following use case: At some point in time I want to do maintenance on my Vert.x nodes by taking them offline in a round robin fashion. I am running a verticle that is receiving messages on the event bus that are being storied in an ElasticSearch database using bulk inserts. These bulk inserts run in a separate thread that needs to be stopped cleanly otherwise I run the risk that some events will not be stored. Since executing kill -SIGTERM simply kills the process my custom shutdown hook for finalizing the bulk inserts is not called introducing the risk of data loss.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
tl;dr:  Following the "golden rule" during application startup and initialization may be unimportant.  Therefore please provide a way to disable warnings until application is fully deployed and started.
The reason I am requesting this is because my company has a large vert.x 2 ruby application (ported from rails/sinatra) that is being upgraded to vert.x 3.  We do a lot of pre-loading during application startup, and it would be difficult to make all of that asynchronous or wrapped with execute_blocking.  We're getting the multiple warnings and large stacktrace during application startup.
But during application startup, I don't mind blocking the event loop, because there's no other work the application could be doing that's being blocked.  Once verticles are started and accepting requests, I do want to see the warnings.
Therefore, I'd like to have some mechanism to disable event loop warnings/stacktraces until the application has been fully deployed.
A few ideas for how this could be done:

Add more general disableBlockedThreadWarnings and enableBlockedThreadWarnings methods to Vertx.  Those would call new setter on BlockedThreadChecker to set value on a final AtomicBoolean.  Within the timer task run() method, check value before logging.  I like this solution the best.
Add a ready() (for example) method to Vertx, along with a new option to disable warnings until ready() is called.  Less flexible, but same effect during application startup.
Extract the 4 options that affect this (blockedThreadCheckInterval, maxEventLoopExecuteTime, maxWorkerExecuteTime, warningExceptionTime) into their own class, and provide a static instance with defaults.  Provide a way to replace the instance at runtime.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CompositeFuture.any(f1, f2).setHandler(handler)

The handler is not called when f2 or f2 succeeds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
We forget to add credit header in MessageProducer when we set it with deliveryOptions.
As a result the drain handler will never be call.
Modification:
Add credit header when we set delivery options.
Result:
The drain handler will be call in every situation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@Override
  public void deployVerticle(Verticle verticle, DeploymentOptions options, Handler<AsyncResult<String>> completionHandler) {
    boolean closed;
    synchronized (this) {
      closed = this.closed;
    }
    if (closed) {
      completionHandler.handle(Future.failedFuture("Vert.x closed"));
    } else {
      deploymentManager.deployVerticle(verticle, options, completionHandler);
    }
  }

This method is called with null argument for completionHandler by at least 2 other VertxImpl methods. However, there is no check for null when calling completionHandler when Vertx is closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice to handle this kind of error during registration:
eb.addInterceptor(null);
 @Override
  public EventBus addInterceptor(Handler<SendContext> interceptor) {
   //require interceptor to be != null
    interceptors.add(interceptor);
    return this;
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In case where a worker thread is used to run a a business function, it would be useful if the worker could communicate with existing vertices in a blocking fashion.
Here's an example where a result from a reply handler is received (via an event thread) and passed to the worker thread (which calls the proposed vertx.runOnEventLoop method)
JsonObject result = vertx.runOnEventLoop(future -> { 
    vertx.eventBus().send("thop", cmd, reply -> {
        System.out.println(reply);
        if (reply.succeeded()) {
            JsonObject value = (JsonObject) reply.result().body();
            future.complete(value);
        } else {
            future.completeExceptionally(reply.cause());
        }
    });
});

runOnEventLoop would use any available event thread to run the lambda and then wait for the future to complete (and there might be variant with a timeout).
The dangers with respect to concurrency are somewhat limited: Control of runOnEventLoop only returns when the provided future is complete, so the original worker thread can't change state while it waits for the result.
However, the lambda calling future.complete could change state afterwards, which is potentially a bad thing.
Advantages:

From the perspective of the worker thread it remains trivial to maintain state in a single-threaded fashion. There's no need to declare it a multi-threaded worker verticle, which would also look drastically different.
the worker thread can participate in message exchanges on the event bus

Disadvantages:

no guarantee that the event code can't change state in the worker thread after future.complete has been called.

Implementation:
This has been implemented using a secondary thread pool (a work stealing executor).
Those short-lived threads are used to pass the torch to an existing (or newly created) event loop.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Because a primitive int value is used as the flag to compute the composite status of all the component futures, and because an arbitrary number of futures can be passed using the variants that accept an arbitrarily-sized List, if a List with more than 32 Futures is passed in, the implementations will not function correctly and issue no errors.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The various tests in LauncherTest create Vertx instances (in commands) which are not garbaged.
The Vert.x instances should be cleaned up as the underlying file descriptors needs to be garbaged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks good to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This has been done in #1397.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I got this exception from time to time when trying to call HttpClientResponse#netSocket() while the data is streaming using Vert.x 3.2.1. I cannot create a consistent reproduction yet.
 io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.IllegalStateException: Invalid object UnpooledUnsafeHeapByteBuf(ridx: 0, widx: 8192, cap: 8192)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:911)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:847)
    at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$20(VertxHttpHandler.java:80)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$18(ContextImpl.java:333)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
    at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
    at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:428)
    at io.netty.handler.codec.ByteToMessageDecoder.handlerRemoved(ByteToMessageDecoder.java:216)
    at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.remove0(CombinedChannelDuplexHandler.java:595)
    at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.remove(CombinedChannelDuplexHandler.java:580)
    at io.netty.channel.CombinedChannelDuplexHandler.handlerRemoved(CombinedChannelDuplexHandler.java:173)
    at io.netty.channel.DefaultChannelPipeline.callHandlerRemoved0(DefaultChannelPipeline.java:517)
    at io.netty.channel.DefaultChannelPipeline.callHandlerRemoved(DefaultChannelPipeline.java:511)
    at io.netty.channel.DefaultChannelPipeline.remove0(DefaultChannelPipeline.java:343)
    at io.netty.channel.DefaultChannelPipeline.remove(DefaultChannelPipeline.java:315)
    at io.netty.channel.DefaultChannelPipeline.remove(DefaultChannelPipeline.java:298)
    at io.vertx.core.http.impl.ClientConnection.createNetSocket(ClientConnection.java:396)
    at io.vertx.core.http.impl.HttpClientResponseImpl.netSocket(HttpClientResponseImpl.java:263)
                                .
                                    .
                                    .
    at io.vertx.core.http.impl.HttpClientResponseImpl.handleChunk(HttpClientResponseImpl.java:220)
    at io.vertx.core.http.impl.ClientConnection.handleResponseChunk(ClientConnection.java:283)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:876)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:847)
    at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$20(VertxHttpHandler.java:80)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$18(ContextImpl.java:333)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
    at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
    at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:428)
    at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:276)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:354)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
    at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:243)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:840)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
    at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I want to terminate the request early, I made a call to  HttpClientResponse.netSocket().close(). It seems to close the connection properly but it never seems to remove the connection from the pool. It eventually cause the connection pool to exhaust. I will try to find whether it's easy to create a repro.
It looks like createNetSocket() does not hook closeHandler(). Therefore, when a connection is closed, the connection manager never removes it from the connection queue and thus the connection leak without having a connection lying around.
@vietj What do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
should integrate with #1255 where event loop, accept thread should be named as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My vertx client cannot connect to an HTTP server via TLS. The server delivers a trusted certificate and the client does not trust the server, because the client connects to the server using "localhost". In my case it works as expected because client and server are running on the same machine and the certificate is trusted for a different domain name (other than "localhost"). Therefore I tried to solve the problem using the easiest solution first:
httpClientOptions.setTrustAll(true);
But this leads to the following exception:
ERROR [vert.x-worker-thread-15] [i.v.c.http.impl.HttpClientImpl] - javax.net.ssl.SSLHandshakeException: Failed to create SSL connection
I expect that httpClientOptions.setTrustAll(true); makes the client trust both untrusted certificates and trusted certificates which get delivered from a different domain name than the certificate is targeted for.
Yet I haven't tried other solutions like adding the server certificate to the truststore of the client or to change the virtual host file of the OS to simulate that the client connects to a domainserver. (Hint: My router doesn't support NAT Loopbacks). But why does setTrustAll not work as expected?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
WebSocket spec defines optional reason codes and text when closing a websocket connection: https://tools.ietf.org/html/rfc6455#section-5.5.1
ServerWebSocket however just provides a simple close() method without any parameters (internally Nettys new CloseWebSocketFrame(1000, null) will be called). Also websocket client's closeHandler has no way to access reason data. Please provide support for that, as we need to signal the client the concrete close reason!
In the meanwhile: Is there any simple way to hook into the close process and override the reason code?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
All Vert.x command line operations currently always return a "0" exit value, even if it is known the command did not run successful.
For automated deployment tooling (e.g. puppet scripts) it is very useful to return a non-zero exit value. This will allow tooling to check the exit value, stop executing when one command fails, and provide better feedback on which step a failure occurs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Vert.x stop command currently does not check if the underlying native commands complete successful. E.g. when the "kill" process fails due to a "Operation not permitted" failure, the vertx stop command does not report this problem. Instead, it reports the Vert.x application has been stopped (but it would likely still be running).
Native commands executed during the stop command should be checked for the exit value. When a failure occurs, any output of native processes should be shown in the vertx command process output to get more feedback on why the command did not run successful.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks usefull thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sorry, had to redo the last few commit msgs since I forgot the signed-off footer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Test ClusteredEventBusTest.testDefaultCodecReplyExceptionSubclass is incorrect because event can be sent before consumer will be registered on all nodes of the cluster.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Note: I've grown uncomfortable with @author tags over the years, I don't think it encourages participation and rather delimit territories within projects.
I think Vert.x would benefit from removing @author tags, hence this pull-request to open the discussion. Feel-free to use it as a basis for debates.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ClusterWideMapTest.java don't have test method for AsyncMap<X,Buffer>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/http/impl/MimeMapping.java
see: vert-x3/vertx-web#340
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The on-redeploy switch on Windows fails with (for example):
Error while executing the on-redeploy command : 'gradlew classes'
java.io.IOException: Cannot run program ""gradlew classes"": CreateProcess error=2, The system cannot find the file specified
This happens with any command that has arguments (e.g. 'classes' or 'shadowJar' for gradlew). I tried to pass only gradlew, without arguments, but this also fails unless I specify the extension as well gradlew.bat. Funny enough, executables can be passed with or without extension (e.g. java OR java.exe) but always without arguments (java -version fails similarly to gradlew classes)
I believe the problem is in how the command string is built in io.vertx.core.impl.launcher.commands.Watcher.executeUserCommand line 268
Either the cmd string should be passed as is into the ProcessBuilder OR it should be added to the command list similarly to how it is done for non-Windows systems, i.e. prepending cmd /c ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Thanks !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks Alex
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please sign the Eclipse CLA in order for your PR to be accepted.
see: https://github.com/eclipse/vert.x/blob/master/CONTRIBUTING.md
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As it is right now, passing something like --redeploy="src/**/*.java" has no effect on Windows machines, i.e. no file is ever matched against this pattern since the pattern tokenizer fails to break the pattern into tokens due to the fact that / is not a file separator on Windows.
Rather than modifying either the tokenizer or the matching algorithm, a possible solution would be to store the patterns (called includes, see io/vertx/core/impl/launcher/commands/Watcher.java  line 77) after converting between *nix and Windows file separator char, if needed.
I believe a better solution would be to enforce a file separator char on the pattern, i.e. refuse to accept something like --redeploy="src\**\*.java", only accept path patterns separated by / and then replace this with the correct OS file separator, if needed.
Ant has / as its default file separator character but allows you to change it. I don't think this is necessary. An "enforce and convert" should be all that is needed in this case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using Vert.x 3.2.1 and according to "http://vertx.io/docs/vertx-dropwizard-metrics/java/#_http_client_metrics" the id should match "vertx.http.clients.@" (e.g. vertx.http.clients.@3b773558.get-requests.max), but it is "vertx.http.clients." (e.g. vertx.http.get-requests.max).
Was this change on purpose?
If yes, documentation should be updated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello @cescoffier,
I see that you fixed #1415 but may I suggest to have a look at my code since I take care of allowing OS/X and *nix to pass Windows style path (it might be important in mixed environments where developers write scripts in either systems) but more importantly I do not check for case sensitivity in Windows files/folders when the Watcher tries to match a change. Also I wrote a couple of tests for those cases.
Regards,
Mirco
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this is a nice addition, however it should be added in the main documentation that exit codes are now meaningful.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there!
Here is an example of calling a function with a json data type parameter: https://gist.github.com/zadoff/f5a33398ff81ba75a06cedf93fa97de8
If I use text data type instead of json it works well.
Could you please add support for this type?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do you think that it could be useful to have another handler when the connection is released from the request/response?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
myverticle.groovy
void vertxStart() {
println("\u4f60\u597d")
println " starting"
}
void vertxStop() {
println "stopping"
}
$ vertx run myverticle.groovy

 starting
Succeeded in deploying verticle
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A question from our team:
Should Future.failedFuture always return a failed future?
At present failedFuture(null) returns a succeeded future.
Agree that we should never call failedFuture with null, but it can happen by accident ... and depending on the complexity of the system, finding the root cause can take some time.
Also perhaps, calling Future.fail(null) should really set the cause to NoStackTraceThrowable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I have a problem possible bug with multiple deployed instances of a verticle that is used as a REST endpoint. The service will receive every request and sanitize the payload. Then the next matching route (router.next()) will be called.
The Sanitizer verticle do something like this:
this.router.post("/*").handler(routingContext -> { // do something routingContext.next(); }
This Sanitizer verticle is deployed several times:
deploymentOptions.setInstances(5); this.vertx.deployVerticle(verticleName, deploymentOptions);
We use for all verticles the same router to go through all matching routes with routingContext.next(). For every request our Sanitizer is called, but it is called 5 times because it is deployed 5 times. Vert.x didn't notice, thats the same verticle which is called multiple times. I want that the Sanitizer verticle is only called once and then the next route (e.g. /test/test).
Is this a bug in vert.x or should I handle the router in a different way?
Example of verticle (The Runner.mainRouter is initialized once in Runner class):
`public class App extends AbstractVerticle {
public static void main(final String[] args) {
    Runner.run(App.class);
}

@Override
public void start() {

    Runner.mainRouter.get("/rest/*").handler(rc -> {
        System.out.println("sanitizer " + this);
        rc.next();
    });

    vertx.createHttpServer().requestHandler(Runner.mainRouter::accept).listen(8090);
}

}`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I have some problems with the logging of vertx. When using the default logging framework everything works fine. But when using SLF4J with logback some of vertx loggins don't appear in the log.
Classes like 'io.vertx.core.impl.launcher.commands.RunCommand' or 'io.vertx.ext.web.impl.RoutingContextImplBase' are logging as expected and the log entry is available in the log file.
The class 'io.vertx.core.impl.ContextImpl' (line 338 of vertx 3.2.1) logs if an error occurred but this log entry never appears in the log file. The reason so far is unknown.
Slf4J is set this way:
private static final String LOGGER_DELEGATE_FACTORY_CLASS_NAME_PROPERTY = "vertx.logger-delegate-factory-class-name";
private static final String LOGGER_DELEGATE_FACTORY_CLASS_NAME = "io.vertx.core.logging.SLF4JLogDelegateFactory";
static {
    System.setProperty(LOGGER_DELEGATE_FACTORY_CLASS_NAME_PROPERTY, LOGGER_DELEGATE_FACTORY_CLASS_NAME);
}

Could you please have a look? Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was actually thinking at something simpler that allows you to come up with your specific use case and allow others to do their own if they want to : https://github.com/eclipse/vert.x/tree/keystore-load-refactor
please have a look and check that it allows you to do so.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there:
We just encounter a problem and it is difficult to reproduce.
For example, if we use Future future = Future.future(); and then send the http request
and if one of the request fails very fast like got connection refused instantly
and then we set the future.fails(url+" request failed");
and then interesting thing is
CompositeFuture.all(...)/any(...) method some times execute without receiving other responses.
the difficulty of reproduce is not every time it happens, but happened in few tests
Our guess is when one of the future fails and it successfully registered in the compositeFuture and the other future has not registered successfully yet, thus the size of compositeFuture list/set is only 1 and the only 1 fails then the rest would fail also, not sure about the logic but it happens
We will continue test this problem and maybe later submit our code
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
like the ClusterManager on VertxOptions
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using HttpClient to invoke a third party REST API. Using a curl on the resource in question gives the following:
HTTP/1.1 204 No Content
Transfer-Encoding: chunked

Vert.x doesn't like the combination of chunked and "no content", which can be reproduced with the test below:
public class VertxTest {
    public static void main(String[] args) {
        Vertx vertx = Vertx.vertx();
        vertx.createHttpServer().requestHandler(r -> {
            r.response().setChunked(true).setStatusCode(204).end();
        }).listen(9888, (status) -> {
            vertx.createHttpClient().postAbs("http://localhost:9888").handler(r -> {
                System.out.println(r);
            }).end();

        });
    }
}

The following exception is thrown.
SEVERE: Unhandled exception
java.lang.IllegalStateException: No response handler
    at io.vertx.core.http.impl.ClientConnection.handleResponse(ClientConnection.java:275)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:869)
    at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:847)
    at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$20(VertxHttpHandler.java:80)
    at io.vertx.core.http.impl.VertxHttpHandler$$Lambda$21/288971877.run(Unknown Source)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$18(ContextImpl.java:333)
    at io.vertx.core.impl.ContextImpl$$Lambda$9/752209249.run(Unknown Source)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
    at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
    at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
    at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:276)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:263)
    at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
    at java.lang.Thread.run(Thread.java:745)

Switching setChunked to false fixes the problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vert.x could support socket.io?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The service loading of VerticleFactory's does not work when starting Vert.x with Maven's exec:java target. When using the ServiceVerticleFactory the verticles are not started as a service but as a regular verticles. This means that the service descriptor is ignored (without any warning) and the worker verticles are started as non-worker verticles instead (resulting in blocking event threads).
A quick fix is to supply the correct class loader to the SeviceLoader in the DeploymentManager. I will open a PR for that.
PR: #1438
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@cescoffier thoughts ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
At the moment the HttpClient proxy configuration uses CONNECT for non SSL HttpClient and instead it should do a straight connection with a target requestURI, i.e
client.get(80, "www.google.com", resp -> {});

should be equivalent to:
client.get(80, "the-proxy", "http://www.google.com", resp -> {}).host("www.google.com:80");

so we do have request like:
GET http://www.google.com HTTP/1.1
Host: www.google.com

while the client connects to the-proxy host.
Note: this does not affect NetClient that will always continue to create a tunnel using CONNECT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I get a NoClassDefFoundError when stopping a small application:
2016-07-06 15:49:19,770 [vert.x-eventloop-thread-1] WARN  io.vertx.core.impl.ContextImpl - Failed to run close hooks
java.lang.NoClassDefFoundError: io/netty/channel/group/ChannelMatchers
    at io.netty.channel.group.DefaultChannelGroup.close(DefaultChannelGroup.java:226)
    at io.vertx.core.http.impl.HttpServerImpl.actualClose(HttpServerImpl.java:506)
    at io.vertx.core.http.impl.HttpServerImpl.close(HttpServerImpl.java:420)
    at io.vertx.core.impl.ContextImpl.runCloseHooks(ContextImpl.java:148)
    at io.vertx.core.impl.DeploymentManager$DeploymentImpl.lambda$null$2(DeploymentManager.java:532)
    at io.vertx.core.impl.FutureImpl.checkCallHandler(FutureImpl.java:158)
    at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:111)
    at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:116)
    at my.example.RestServerVerticle.stop(RestServerVerticle.java:51)
    at io.vertx.core.impl.DeploymentManager$DeploymentImpl.lambda$doUndeploy$3(DeploymentManager.java:547)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$3(ContextImpl.java:359)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:339)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:393)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.ClassNotFoundException: io.netty.channel.group.ChannelMatchers
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    ... 15 common frames omitted
2016-07-06 15:49:20,977 [vert.x-acceptor-thread-0] WARN  i.n.c.AbstractChannelHandlerContext - An exception was thrown by a user handler's exceptionCaught() method while handling the following exception:
java.lang.NoClassDefFoundError: io/netty/buffer/ByteBufUtil$HexUtil
    at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:123)
    at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:240)
    at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:385)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.forceClose(ServerBootstrap.java:260)
    at io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.channelRead(ServerBootstrap.java:254)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:326)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1320)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:905)
    at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:563)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:504)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:418)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:385)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.ClassNotFoundException: io.netty.buffer.ByteBufUtil$HexUtil
    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    ... 21 common frames omitted
2016-07-06 15:51:19,725 [Thread-3] ERROR i.v.c.i.l.commands.RunCommand - Timed out waiting to undeploy all

my.example.RestServerVerticle is a simple verticle spinning up an http-server:
    @Override
    public void start(Future<Void> startFuture) {
        log.info("Starting {}...", name);

        int port = port();
        Router router = router();

        vertx.createHttpServer(new HttpServerOptions())
                .requestHandler(router::accept)
                .listenObservable(port)
                .toSingle()
                .subscribe(server -> {
                    log.info("Started {} on port {}", name, server.actualPort());
                    startFuture.complete();
                }, startFuture::fail);
    }

    @Override
    public void stop(Future<Void> stopFuture) {
        log.info("stopped {}", name);
        stopFuture.complete();
    }

I am using the maven-shade-plugin to build  a fat jar.
Any guidance on this is highly appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While the toJson() method on a data object is optional IMHO the 'vertx-provided' data objects should be feature-complete by default and contain this method.
Also when referring to the service-proxies documentation (section on Proxy creation):

Generally, service interface contains a createProxy static method to create the proxy. But this is not required

But then this code leads to an error in code generation:
static MyService createProxy(Vertx vertx, String address, DeliveryOptions options) {
    return ProxyHelper.createProxy(MyService.class, vertx, address, options);
}
Error:
error: Could not generate model for createProxy(io.vertx.core.Vertx,java.lang.String,io.vertx.core.eventbus.DeliveryOptions): type io.vertx.core.eventbus.DeliveryOptions does not have a valid 'public JsonObject toJson()' method.
    static MyService createProxy(Vertx vertx, String address, DeliveryOptions options) {
                     ^

If agreeing with this change, I'll create a PR.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I'm enjoying the new implementation of socks proxy support in vertx but it looks like I'm not able to handle a few exceptions related to io with the proxy server.
Jul 07, 2016 5:41:29 PM io.vertx.core.http.impl.HttpClientRequestImpl
SEVERE: java.net.ConnectException: Connection refused: no further information:
I get that when using an invalid proxy.
I was also getting another exception in netty that I cannot reproduce right now. It was a unhandled netty exception coming from the channel pipeline.
I'm looking for a fix that would allow me to put my own exception handlers on the pipeline for netty through vertx.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
In the latest releases of Vertx, 3.3.1 and 3.3.0, the pausedChunk is now stored in ClientConnection. We see an issue with this when re-using an HttpClient and pausing to read the response. The pausedChunk will continue to get appended to with each new response body once the client hits its maxPoolSize and starts re-using connections. Before this didn't happen when it was stored on the HttpClientResponse.
Is this intentional, meaning that an HttpClient is not meant to be re-used for pausing and reading multiple response bodies?
We created a simple runnable fat jar that demonstrates this here.
https://github.com/ef-labs/vertx-client-connection-test

Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello Vert.x,
I'm getting an error when I'm running play service with vertx 3.3.0
If  I remove vertx dependency, Play service running fine.
I didn't have this problem with vertx 3.2.1
Thanks,
Effi
Here is the exception stack trace
--- (Running the application, auto-reloading is enabled) ---
io.netty.channel.ChannelException: Unable to create Channel from class class io.netty.channel.socket.nio.NioServerSocketChannel
at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:41)
at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:318)
at io.netty.bootstrap.AbstractBootstrap.doBind(AbstractBootstrap.java:282)
at io.netty.bootstrap.AbstractBootstrap.bind(AbstractBootstrap.java:246)
at play.core.server.NettyServer.bind(NettyServer.scala:139)
at play.core.server.NettyServer.play$core$server$NettyServer$$bindChannel(NettyServer.scala:224)
at play.core.server.NettyServer$$anonfun$1.apply(NettyServer.scala:216)
at play.core.server.NettyServer$$anonfun$1.apply(NettyServer.scala:216)
at scala.Option.map(Option.scala:146)
at play.core.server.NettyServer.(NettyServer.scala:216)
at play.core.server.NettyServerProvider.createServer(NettyServer.scala:279)
at play.core.server.NettyServerProvider.createServer(NettyServer.scala:278)
at play.core.server.DevServerStart$$anonfun$mainDev$1.apply(DevServerStart.scala:225)
at play.core.server.DevServerStart$$anonfun$mainDev$1.apply(DevServerStart.scala:61)
at play.utils.Threads$.withContextClassLoader(Threads.scala:21)
at play.core.server.DevServerStart$.mainDev(DevServerStart.scala:60)
at play.core.server.DevServerStart$.mainDevHttpMode(DevServerStart.scala:50)
at play.core.server.DevServerStart.mainDevHttpMode(DevServerStart.scala)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at play.runsupport.Reloader$.startDevMode(Reloader.scala:234)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.devModeServer$lzycompute$1(PlayRun.scala:74)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.play$sbt$run$PlayRun$$anonfun$$anonfun$$anonfun$$devModeServer$1(PlayRun.scala:74)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.apply(PlayRun.scala:100)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.apply(PlayRun.scala:53)
at scala.Function1$$anonfun$compose$1.apply(Function1.scala:47)
Caused by: java.lang.NoSuchMethodError: io.netty.channel.DefaultChannelId.newInstance()Lio/netty/channel/DefaultChannelId;
at io.netty.channel.AbstractChannel.newId(AbstractChannel.java:105)
at io.netty.channel.AbstractChannel.(AbstractChannel.java:77)
at io.netty.channel.nio.AbstractNioChannel.(AbstractNioChannel.java:87)
at io.netty.channel.nio.AbstractNioMessageChannel.(AbstractNioMessageChannel.java:42)
at io.netty.channel.socket.nio.NioServerSocketChannel.(NioServerSocketChannel.java:84)
at io.netty.channel.socket.nio.NioServerSocketChannel.(NioServerSocketChannel.java:70)
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
at java.lang.Class.newInstance(Class.java:442)
at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:39)
at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:318)
at io.netty.bootstrap.AbstractBootstrap.doBind(AbstractBootstrap.java:282)
at io.netty.bootstrap.AbstractBootstrap.bind(AbstractBootstrap.java:246)
at play.core.server.NettyServer.bind(NettyServer.scala:139)
at play.core.server.NettyServer.play$core$server$NettyServer$$bindChannel(NettyServer.scala:224)
at play.core.server.NettyServer$$anonfun$1.apply(NettyServer.scala:216)
at play.core.server.NettyServer$$anonfun$1.apply(NettyServer.scala:216)
at scala.Option.map(Option.scala:146)
at play.core.server.NettyServer.(NettyServer.scala:216)
at play.core.server.NettyServerProvider.createServer(NettyServer.scala:279)
at play.core.server.NettyServerProvider.createServer(NettyServer.scala:278)
at play.core.server.DevServerStart$$anonfun$mainDev$1.apply(DevServerStart.scala:225)
at play.core.server.DevServerStart$$anonfun$mainDev$1.apply(DevServerStart.scala:61)
at play.utils.Threads$.withContextClassLoader(Threads.scala:21)
at play.core.server.DevServerStart$.mainDev(DevServerStart.scala:60)
at play.core.server.DevServerStart$.mainDevHttpMode(DevServerStart.scala:50)
at play.core.server.DevServerStart.mainDevHttpMode(DevServerStart.scala)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at play.runsupport.Reloader$.startDevMode(Reloader.scala:234)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.devModeServer$lzycompute$1(PlayRun.scala:74)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.play$sbt$run$PlayRun$$anonfun$$anonfun$$anonfun$$devModeServer$1(PlayRun.scala:74)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.apply(PlayRun.scala:100)
at play.sbt.run.PlayRun$$anonfun$playRunTask$1$$anonfun$apply$2$$anonfun$apply$3.apply(PlayRun.scala:53)
at scala.Function1$$anonfun$compose$1.apply(Function1.scala:47)
[trace] Stack trace suppressed: run 'last compile:run' for the full output.
error java.lang.reflect.InvocationTargetException
[error] Total time: 1 s, completed 12:30:48 09/07/2016
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256M; support was removed in 8.0
Process finished with exit code 1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cross posted issue
vert-x3/vertx-web#412
I apologize, initially i posted this to vertx-web, as i suspected the issue was in  CookieHandler code, but now I'm sure the issue is in vertx core code, as http headers parsing is done by vertx-core
Version

vert.x core: 3.3.0
vert.x web: 3.3.0
SSL and ALPN with netty-tncnative: 1.1.3
netty: 4.1.1

Context
If a client got multiple cookies to send in a request, and ALPN is on and the request is issued with HTTP/2, the vert.x server cannot read correctly the cookie header nor the CookieHandler works fine.
It gets just one Cookie of many (a random one as they're sent in random order by browser as per specs)
This is due to the fact that Http/2 sends cookies in multiple COOKIE headers and not anymore in a single semicolon separated field.
Please add conversion in a single ; separated header using Netty's  HttpConversionUtil as Netty's  has already provided that solution to this issue, see: netty/netty#4457
Steps to reproduce

Enable HTTPS and ALPN on a Vert.x server
Use latest version of google chrome and ensure you're negotiating http/2 (e.g. check with 'http/2 and spdy indicator extension')
Using the 'cookie inspector extension' or whatever, add some cookie name-value pairs to simulate a request with multiple cookies set
Refresh the test page and debug if you can get all the test cookie pairs at server using a CookieHandler or with a raw logger.info("All headers "+  new JsonArray(request.headers().entries()).encodePrettily());
You'll get just 1 cookie of the many, if you repeat the request or delete some cookie you can have it in random rotation, but never more than one cookie  per request is readable to vert.x

Extra
This issue can cause authentication/session issues too
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please configure the default SSL settings to remove following cipher suites or give us some documentation on how to disable ciphers
Testing a vert-x server with https://www.ssllabs.com/ssltest/ had this result:
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The documentation of LocalMap states:
The map only allows immutable keys and values in the map, OR certain mutable objects such as {@link io.vertx.core.buffer.Buffer}
https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/shareddata/LocalMap.java
However the implementation in:
https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/shareddata/impl/Checker.java
Has only a whitelist of allowed Types. Immutable objects are refused.
Not sure whether this is an implementation or documentation problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I know it's not so cool, now that http/2 has replaced spdy, but in some real cases advertising and supporting also the spdy protocol can give good benefits, as http/2 is not yet supported by many mobile browsers (my vertx apps are webapps accessed from mobile devices) especially android webviews.
The very same thing I'm asking for here, was just implemented by cloudflare for nginx, so you can agree... it can help in some real cases; check following post and the comments:
https://blog.cloudflare.com/open-sourcing-our-nginx-http-2-spdy-code/
PS. SPDY and NPN are implemented by Netty, check SpdyServer.java example in netty repository.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While proxying though the Vertx HTTP client, the Host header that goes as a part of CONNECT request (as only https targets are supported by Vert.x right now) is not appropriate as defined in the spec.
Host header should contain the host:port of the target server, but currently it is populated with that of proxy server. Thus, some proxy servers / web applications might dishonor the request due to this discrepancy.
Reproducer is hard to implement, but below should explain the problem.
Target url: https://www.google.com
Proxy server: proxyhost.com:8888
Expected request at the proxy:
CONNECT www.google.com:443
Host: www.google.com
Actual request at the proxy:
CONNECT www.google.com:443
Host: proxyhost.com:8888
Spec: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When connecting with NetClient using upgradeToSsl (which is for example used in mail STARTTLS), the cert name is matched against the resolved ip address, which fails.
https://gist.github.com/alexlehm/8b609f70c848453ab7da5b360b740db0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Problem:
Setting the environment vertx.disableFileCaching to true does not disable file caching.
Cause:
FileResolver statically initialises ENABLE_CACHING
Environment:
Eclipse with dynamic reload:
run main.WebVerticle --redeploy="src/*/.java" --launcher-class=io.vertx.core.Launcher -conf src/resources/conf/config.json -Dvertx.disableFileCaching=true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@cescoffier @pmlopes are you OK with this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Thank you for taking your time to read my entry. Last night while work was being done on the environments, we got this error:
java.lang.UnsupportedOperationException: null
        at java.util.AbstractMap.put(AbstractMap.java:209) ~[na:1.8.0_45]
        at io.vertx.core.impl.AddressResolver.<init>(AddressResolver.java:115) ~[jar-with-dependencies.jar:na]
        at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:152) ~[jar-with-dependencies.jar:na]
        at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:119) ~[jar-with-dependencies.jar:na]
        at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:115) ~[jar-with-dependencies.jar:na]
        at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:34) ~[jar-with-dependencies.jar:na]
        at io.vertx.core.Vertx.vertx(Vertx.java:80) ~[jar-with-dependencies.jar:na]
        at com.something.something.Main.main(Main.java:108) ~[jar-with-dependencies.jar:na]

We suspect that it is due to the following:
In the AddressResolver class on line 109 (https://github.com/eclipse/vert.x/blob/HEAD/src/main/java/io/vertx/core/impl/AddressResolver.java#L109) the parseSilently returns a Collections.emptyMap() as it probably has trouble finding the hosts file. Then, on line 115 (https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/impl/AddressResolver.java#L115) an attempt is made to put a value into this map, which is not a supported action.
So, the issue is caused by attempting to put a value in a map that does not support puts
Extra:

Vertx 3.2.1
rhel7

I might have missed some information, if so, please request and I'll do my best to provide it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at the API of WriteStream#drainHandler it says:

If the write queue is full, then the handler will be called when the write queue has been reduced to maxSize / 2

Implementations differ in the sense that they call it either only once the queue has been reduced or every time the queue has been reduced.
This looks suspicious to me and I wonder what is correct.
NetSocketImpl is calling the handler every time:
  private synchronized void callDrainHandler() {
    if (drainHandler != null) {
      if (!writeQueueFull()) {
        drainHandler.handle(null);
      }
    }
  }

MessageProducerImpl is calling the handler only once (by setting it to null):
  private synchronized void doReceiveCredit(int credit) {
    /* .... */
    final Handler<Void> theDrainHandler = drainHandler;
    if (theDrainHandler != null && credits >= maxSize / 2) {
      this.drainHandler = null;
      vertx.runOnContext(v -> theDrainHandler.handle(null));
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For debugging clustered event bus networking problems, it would be useful if ClusteredEventBus logged a message whenever it can't deliver a message.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Netty has a bunch of codecs (namely codec-smtp and codec-mqtt) which I'd like to use from within Vert.x. Is there any way I can plug them directly into a NetServer so that they encode/decode Buffers or do I have to "manually" handle encoding/decoding using these (which seems to be hard enough as encode/decode methods are protected inside final classes)?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I updated the Vertx version, this code stopped working:
context.vertx().sharedData().getLock("core.list." + microservice + "." + listId, lockRes -> {
        if(lockRes.failed()) {
                ...
        }
        Lock lock = lockRes.result();
        ...
        lock.release();
});

It only executes the code at the first time, but the lock is not released. The execution reaches the release point. What can be the problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
at least from my point of view, strange  StaticHandler behavior observed.
Instead to serve "webroot/loginpage" file,
it calculated that it should serve "webroote" file.
In this use case I wanted to protect all static served files with username and password.
Of course i excluded  loginpage, loginhandler and logout routes from RedirectAuthHandler.
Please check code and logs below.
vert.x version: 3.3.0
It looks that issue is in
io.vertx.ext.web.impl.Utils#pathOffset
called from
io.vertx.ext.web.handler.impl.StaticHandlerImpl#getFile
Regards,
N.
public class Server extends AbstractVerticle {


    @Override
    public void start() throws Exception {

        AuthProvider authProvider = ShiroAuth.create(vertx, ShiroAuthRealmType.PROPERTIES, new JsonObject());

        Router router = Router.router(vertx);

        // We need cookies, sessions and request bodies
        router.route().handler(CookieHandler.create());
        router.route().handler(BodyHandler.create());
        router.route().handler(SessionHandler.create(LocalSessionStore.create(vertx)));
        router.route().handler(UserSessionHandler.create(authProvider));

        StaticHandler staticHandler = StaticHandler.create();

        router.route("/loginpage").handler(staticHandler);
        router.route("/loginhandler").handler(FormLoginHandler.create(authProvider));

        router.route("/logout").handler(context -> {
            context.clearUser();
            context.response().putHeader("location", "/").setStatusCode(302).end();
        });

        router.route().handler(RedirectAuthHandler.create(authProvider, "/loginpage"));
        router.route().handler(staticHandler);


        vertx.createHttpServer().requestHandler(router::accept).listen(8080);
    }

}

22:59:29.935 [vert.x-eventloop-thread-0] TRACE i.v.core.http.impl.HttpServerImpl - Server received request: /
22:59:29.935 [vert.x-eventloop-thread-0] TRACE io.vertx.ext.web.impl.RouterImpl - Router: 7068351 accepting request GET http://localhost:8080/
22:59:29.935 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.CookieHandlerImpl@180e96 failureHandler:null order:0 methods:[]]@15095698
22:59:29.935 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.BodyHandlerImpl@ba893 failureHandler:null order:1 methods:[]]@22596832
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.SessionHandlerImpl@14806fb failureHandler:null order:2 methods:[]]@27069873
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.936 [vert.x-eventloop-thread-0] WARN  i.v.e.w.h.impl.SessionHandlerImpl - Using session cookies without https could make you susceptible to session hijacking: http://localhost:8080/
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.UserSessionHandlerImpl@4f9b06 failureHandler:null order:3 methods:[]]@11298098
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.RedirectAuthHandlerImpl@bc6ed9 failureHandler:null order:6 methods:[]]@2505993
22:59:29.936 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.949 [vert.x-eventloop-thread-0] TRACE i.v.core.http.impl.HttpServerImpl - Server received request: /loginpage
22:59:29.949 [vert.x-eventloop-thread-0] TRACE io.vertx.ext.web.impl.RouterImpl - Router: 7068351 accepting request GET http://localhost:8080/loginpage
22:59:29.949 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.CookieHandlerImpl@180e96 failureHandler:null order:0 methods:[]]@15095698
22:59:29.949 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.949 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.BodyHandlerImpl@ba893 failureHandler:null order:1 methods:[]]@22596832
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.SessionHandlerImpl@14806fb failureHandler:null order:2 methods:[]]@27069873
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.950 [vert.x-eventloop-thread-0] WARN  i.v.e.w.h.impl.SessionHandlerImpl - Using session cookies without https could make you susceptible to session hijacking: http://localhost:8080/loginpage
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:null pattern:null handler:io.vertx.ext.web.handler.impl.UserSessionHandlerImpl@4f9b06 failureHandler:null order:3 methods:[]]@11298098
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Route matches: Route[ path:/loginpage pattern:null handler:io.vertx.ext.web.handler.impl.StaticHandlerImpl@19a19f1 failureHandler:null order:4 methods:[]]@21032606
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.impl.RoutingContextImplBase - Calling the  handler
22:59:29.950 [vert.x-eventloop-thread-0] TRACE i.v.e.w.h.impl.StaticHandlerImpl - File to serve is webroote
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I meet a problem, the API doc said that "host can be a valid host name or IP address.". But when I pass a IP such as 1.2.3.4 in NetClient.connect, it still try to resolve this as a host name. When I use this method in a domain such as "company.com", NetClient.connect(80, "1.2.3.4", new FakeHandler()), it will connect failed and resolve the IP to "/1.2.3.4.company.com".
Could you help me?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when using the netty resolver code (https://github.com/eclipse/vert.x/tree/netty-4.1.3.Final)
the resolution of "localhost" does not have the hostname set in the InetAddr object so that getHostName() returns the ip address. This breaks some unit tests using localhost and expecting "localhost" as hostname (e.g. tls cert check).
I will create a netty issue for that, since their resolver code creates the object, but it would be good to implement a test and a fix inside vert.x as well, when the netty code is fixed, we can take out the fix in vert.x again (that mostly depends on what comes first, the next vert.x version or the next netty version and whether the netty people decide the fix is valid)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have issues to run a webserver connected to a redis server with Vert.x 3.3.2 in a docker environment. I get the following error:
webserver               | java.net.UnknownHostException: failed to resolve 'my-redis.home'. Exceeded max queries per resolve 3
webserver               |   at io.vertx.core.dns.impl.fix.DnsNameResolverContext.finishResolve(DnsNameResolverContext.java:435)
webserver               |   at io.vertx.core.dns.impl.fix.DnsNameResolverContext.tryToFinishResolve(DnsNameResolverContext.java:362)
webserver               |   at io.vertx.core.dns.impl.fix.DnsNameResolverContext$2.operationComplete(DnsNameResolverContext.java:160)
webserver               |   at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:518)
webserver               |   at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:492)
webserver               |   at io.netty.util.concurrent.DefaultPromise.notifyListenersWithStackOverFlowProtection(DefaultPromise.java:431)
webserver               |   at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:420)
webserver               |   at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:99)
webserver               |   at io.vertx.core.dns.impl.fix.DnsQueryContext.setSuccess(DnsQueryContext.java:197)
webserver               |   at io.vertx.core.dns.impl.fix.DnsQueryContext.finish(DnsQueryContext.java:180)
webserver               |   at io.vertx.core.dns.impl.fix.DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:680)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:326)
webserver               |   at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:326)
webserver               |   at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1320)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
webserver               |   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334)
webserver               |   at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:905)
webserver               |   at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93)
webserver               |   at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:563)
webserver               |   at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:504)
webserver               |   at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:418)
webserver               |   at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:390)
webserver               |   at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
webserver               |   at java.lang.Thread.run(Thread.java:745)

It works perfectly with Vert.x 3.2.1.
I made a repoducer:
https://github.com/poiuytrez/vertx-redis-issue-reproducer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today my iOS mobile browser Safari 9 produced a lot of mystifying requests to the same URL which produces the following stacktrace:
`2016-07-20 20:59:39,496 INFO [vert.x-eventloop-thread-2] [n.v.WebserverAndSockJsServer] - --------- Node request: http://mathias-lenovo/loginpage
2016-07-20 20:59:39,502 INFO [vert.x-eventloop-thread-2] [n.v.WebserverAndSockJsServer] - --------- Node request: http://mathias-lenovo/loginpage
2016-07-20 20:59:39,510 INFO [vert.x-eventloop-thread-2] [n.v.WebserverAndSockJsServer] - --------- Node request: http://mathias-lenovo/loginpage
2016-07-20 20:59:39,512 ERROR [vert.x-eventloop-thread-2] [i.v.e.w.i.RoutingContextImplBase] - Unexpected exception in route io.vertx.core.VertxException: java.nio.file.FileSystemException: .vertx\file-cache-872f340f-a24a-4479-9037-925e7ef96eb7\login.html: Der Prozess kann nicht auf die Datei zugreifen, da sie von einem anderen Prozess verwendet wird.
at io.vertx.core.impl.FileResolver.unpackFromFileURL(FileResolver.java:153)
at io.vertx.core.impl.FileResolver.resolveFile(FileResolver.java:119)
at io.vertx.core.impl.VertxImpl.resolveFile(VertxImpl.java:657)
at io.vertx.core.http.impl.HttpServerResponseImpl.doSendFile(HttpServerResponseImpl.java:437)
at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:334)
at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:52)
at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:275)
at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:262)
at node.verticles.WebserverAndSockJsServer.lambda$1(WebserverAndSockJsServer.java:266)
at node.verticles.WebserverAndSockJsServer$$Lambda$85/502338848.handle(Unknown Source)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at node.verticles.WebserverAndSockJsServer$1.handle(WebserverAndSockJsServer.java:207)
at node.verticles.WebserverAndSockJsServer$1.handle(WebserverAndSockJsServer.java:1)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at io.vertx.ext.web.handler.impl.FaviconHandlerImpl.handle(FaviconHandlerImpl.java:161)
at io.vertx.ext.web.handler.impl.FaviconHandlerImpl.handle(FaviconHandlerImpl.java:33)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at io.vertx.ext.web.impl.RouterImpl.accept(RouterImpl.java:79)
at node.verticles.WebserverAndSockJsServer$$Lambda$108/1751816372.handle(Unknown Source)
at io.vertx.core.http.impl.ServerConnection.handleRequest(ServerConnection.java:274)
at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:392)
at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:134)
at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:471)
at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:420)
at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$5(VertxHttpHandler.java:80)
at io.vertx.core.http.impl.VertxHttpHandler$$Lambda$129/1172179503.run(Unknown Source)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$3(ContextImpl.java:333)
at io.vertx.core.impl.ContextImpl$$Lambda$13/1656168062.run(Unknown Source)
at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:276)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:263)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
at java.lang.Thread.run(Thread.java:745)

Caused by: java.nio.file.FileSystemException: .vertx\file-cache-872f340f-a24a-4479-9037-925e7ef96eb7\login.html: Der Prozess kann nicht auf die Datei zugreifen, da sie von einem anderen Prozess verwendet wird.
at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
at sun.nio.fs.WindowsFileCopy.copy(WindowsFileCopy.java:165)
at sun.nio.fs.WindowsFileSystemProvider.copy(WindowsFileSystemProvider.java:278)
at java.nio.file.Files.copy(Files.java:1274)
at io.vertx.core.impl.FileResolver.unpackFromFileURL(FileResolver.java:149)
... 50 common frames omitted

2016-07-20 20:59:39,513 INFO [vert.x-eventloop-thread-2] [n.v.WebserverAndSockJsServer] - --------- Node request: http://mathias-lenovo/loginpage
2016-07-20 20:59:39,516 INFO [vert.x-eventloop-thread-2] [n.v.WebserverAndSockJsServer] - --------- Node request: http://mathias-lenovo/loginpage
2016-07-20 20:59:39,518 ERROR [vert.x-eventloop-thread-2] [i.v.e.w.i.RoutingContextImplBase] - Unexpected exception in route io.vertx.core.VertxException: java.nio.file.FileSystemException: .vertx\file-cache-872f340f-a24a-4479-9037-925e7ef96eb7\login.html: Der Prozess kann nicht auf die Datei zugreifen, da sie von einem anderen Prozess verwendet wird.
at io.vertx.core.impl.FileResolver.unpackFromFileURL(FileResolver.java:153)
at io.vertx.core.impl.FileResolver.resolveFile(FileResolver.java:119)
at io.vertx.core.impl.VertxImpl.resolveFile(VertxImpl.java:657)
at io.vertx.core.http.impl.HttpServerResponseImpl.doSendFile(HttpServerResponseImpl.java:437)
at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:334)
at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:52)
at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:275)
at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:262)
at node.verticles.WebserverAndSockJsServer.lambda$1(WebserverAndSockJsServer.java:266)
at node.verticles.WebserverAndSockJsServer$$Lambda$85/502338848.handle(Unknown Source)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at node.verticles.WebserverAndSockJsServer$1.handle(WebserverAndSockJsServer.java:207)
at node.verticles.WebserverAndSockJsServer$1.handle(WebserverAndSockJsServer.java:1)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at io.vertx.ext.web.handler.impl.FaviconHandlerImpl.handle(FaviconHandlerImpl.java:161)
at io.vertx.ext.web.handler.impl.FaviconHandlerImpl.handle(FaviconHandlerImpl.java:33)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:221)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:93)
at io.vertx.ext.web.impl.RouterImpl.accept(RouterImpl.java:79)
at node.verticles.WebserverAndSockJsServer$$Lambda$108/1751816372.handle(Unknown Source)
at io.vertx.core.http.impl.ServerConnection.handleRequest(ServerConnection.java:274)
at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:392)
at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:134)
at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:471)
at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:420)
at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$5(VertxHttpHandler.java:80)
at io.vertx.core.http.impl.VertxHttpHandler$$Lambda$129/1172179503.run(Unknown Source)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$3(ContextImpl.java:333)
at io.vertx.core.impl.ContextImpl$$Lambda$13/1656168062.run(Unknown Source)
at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:276)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:263)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
at java.lang.Thread.run(Thread.java:745)

Caused by: java.nio.file.FileSystemException: .vertx\file-cache-872f340f-a24a-4479-9037-925e7ef96eb7\login.html: Der Prozess kann nicht auf die Datei zugreifen, da sie von einem anderen Prozess verwendet wird.
at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
at sun.nio.fs.WindowsFileCopy.copy(WindowsFileCopy.java:165)
at sun.nio.fs.WindowsFileSystemProvider.copy(WindowsFileSystemProvider.java:278)
at java.nio.file.Files.copy(Files.java:1274)
at io.vertx.core.impl.FileResolver.unpackFromFileURL(FileResolver.java:149)
... 50 common frames omitted`

The exception occurs while executing the following line of code in WebserverAndSockJsServer.java:266
routingContext.response().sendFile("login.html"); and it leads to an parsing error on Safari.
Any ideas why a lot of requests are producing this exception?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There appears to be no way to disable file caching.
System.setProperty("vertx.disableFileCaching", "true");

has no effect. Using the vertx launcher with the following arguments
run {verticle} -conf {conf} -Dvertx.disableFileCaching=true

also has no effect. I'm having to restart the server each change.
I note issue #1514 and the fix but it seems like command switch should work even with a static initializer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Follow up to the thread https://groups.google.com/forum/#!topic/vertx/Lh7uc4s_pOg
Please note that i have gone through few of posts like
https://groups.google.com/forum/#!searchin/vertx/cluster$20eventbus/vertx/RisJt07-_IE/Cij3VeALCQAJ
and
https://groups.google.com/forum/#!searchin/vertx/cluster$20eventbus/vertx/UWS0WAwHO6k/NQfkErPVAwAJ
and few more. So this issue is not related to port being blocked by firewall...
Now coming to the issue if we use vertx as API and try to use it in cluster creating vertx object using
Vertx.clusteredVertx(options, handler)
Then if the cluster host is not set on the VertxOptions it defaults to "localhost" even if the cluster is enabled. Thus the only interface its listening on is localhost and two separate machines cannot send/publish messages to each other over eventbus.
If we want to listen on all interfaces and set clusterhost as "0.0.0.0" then too the eventbus send/publish is not working. The reason being in "ClusteredEventBus"
the "serrverId" is created with combination of host, port. On both the machines it would end up with same values ("0.0.0.0" : )
With this configuration when we do send/publish a message in ClusteredEventBus -> sendToSubs we have a check if the serverID is same as current nodes serverid
if (!sid.equals(serverID)) {  //We don't send to this node
This is true for as all nodes which have been configured with cluster host as "0.0.0.0". So the message would never be propagated to the remote host/nodes
May be we can use a unique ID auto generated or some other mechanism to get the "serverid" to keep it unique across a cluster configured to listen on all interfaces.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It looks like, there is possible concurrency issue in Event Bus, when we're adding and removing local registrations.
addLocalRegistration: https://github.com/eclipse/vert.x/blob/5338f6353a49a4e7e9a6350e4878bcc5f11028a0/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java#L232
removeLocalRegistration: https://github.com/eclipse/vert.x/blob/5338f6353a49a4e7e9a6350e4878bcc5f11028a0/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java#L277
There is very very little possibility (but non 0), that when we're removing last handler in one thread and adding the new one for the same address in another, we can lost handlers list for that address.
Is this real issue or not, because of it's very little possibility, or I'm missing some additional synchronization?
Topic in user group: https://groups.google.com/forum/#!topic/vertx/T3F3CuG1n3w
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As discussed in this thread on the Vert.x forum there is a need for an additional set of overloaded static members of bothCompositeFuture.all() and CompositeFuture.any() that have the same behaviour, except that the composite feature completes when all of its constituent futures have completed (regardless of their outcome). The current behaviour has the composite future complete on the first success or failure.
The new method overloads have an additional parameter collectResults with a value of true.
The existing members will not be changed so as not to break backwards-compatibility and will defer to the composite future implementation with a default value of false for collectResults.
I will create a PR shortly that will implement this design and provide unit tests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am afraid I need help getting the remaining commits to be CLA signed. I tried amending the remaining commits, but the changes do not come through and the 'Merge branch' commits have no Id. Now spending almost the same time to signing as to development :(
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After reading some similar cases for it (in when.js) that provides similar behavior for all/any, I'm leaning toward using rather a new join method that seems to describe more the intent we have in this use case. It would wait for the components to be completed, the returned CompositeFuture would never fail, always succeeds when all components have been completed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I've implemented a reverse HTTP proxy with vert.x-ceylon version 3.2.0. I have now several times found the app in deadlock state, after which it does not respond to new conncetion attempts anymore. Here is an example:
Found one Java-level deadlock:
=============================
"vert.x-eventloop-thread-0":
  waiting to lock monitor 0x00007f81f4171048 (object 0x0000000771caaea8, a io.vertx.core.http.impl.ClientConnection),
  which is held by "vert.x-eventloop-thread-1"
"vert.x-eventloop-thread-1":
  waiting to lock monitor 0x00007f81f416bbb8 (object 0x00000007718aadb0, a io.vertx.core.http.impl.ServerConnection),
  which is held by "vert.x-eventloop-thread-0"

Java stack information for the threads listed above:
===================================================
"vert.x-eventloop-thread-0":
        at io.vertx.core.http.impl.HttpClientResponseImpl.resume(HttpClientResponseImpl.java:171)
        - waiting to lock <0x0000000771caaea8> (a io.vertx.core.http.impl.ClientConnection)
        at io.vertx.ceylon.core.http.HttpClientResponse.resume(HttpClientResponse.java:66)
        at io.vertx.ceylon.core.http.HttpClientResponse.resume(HttpClientResponse.java:21)
        at org.otherone.vhostproxy.vertx.MyPump$1.$call$(run.ceylon)
        at org.otherone.vhostproxy.vertx.MyPump$1.$call$(run.ceylon)
        at io.vertx.ceylon.core.http.HttpServerResponse$4.handle(HttpServerResponse.java:101)
        at io.vertx.ceylon.core.http.HttpServerResponse$4.handle(HttpServerResponse.java:99)
        at io.vertx.core.http.impl.HttpServerResponseImpl.handleDrained(HttpServerResponseImpl.java:538)
        - locked <0x00000007718aadb0> (a io.vertx.core.http.impl.ServerConnection)
        at io.vertx.core.http.impl.ServerConnection.handleInterestedOpsChanged(ServerConnection.java:296)
        - locked <0x00000007718aadb0> (a io.vertx.core.http.impl.ServerConnection)
        at io.vertx.core.http.impl.HttpServerResponseImpl.lambda$drainHandler$46(HttpServerResponseImpl.java:245)
        at io.vertx.core.http.impl.HttpServerResponseImpl$$Lambda$26/1183493945.handle(Unknown Source)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$3(ContextImpl.java:335)
        at io.vertx.core.impl.ContextImpl$$Lambda$13/1679198612.run(Unknown Source)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:358)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
        at java.lang.Thread.run(Thread.java:745)
"vert.x-eventloop-thread-1":
        at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:583)
        - waiting to lock <0x00000007718aadb0> (a io.vertx.core.http.impl.ServerConnection)
        at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:271)
        at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:52)
        at io.vertx.ceylon.core.http.HttpServerResponse.write(HttpServerResponse.java:84)
        at io.vertx.ceylon.core.http.HttpServerResponse.write(HttpServerResponse.java:20)
        at org.otherone.vhostproxy.vertx.MyPump.dataHandler$priv$(run.ceylon:60)
        at org.otherone.vhostproxy.vertx.MyPump.access$000(run.ceylon:58)
        at org.otherone.vhostproxy.vertx.MyPump$2.$call$(run.ceylon:91)
        at io.vertx.ceylon.core.http.HttpClientResponse$4.handle(HttpClientResponse.java:87)
        at io.vertx.ceylon.core.http.HttpClientResponse$4.handle(HttpClientResponse.java:85)
        at io.vertx.core.http.impl.HttpClientResponseImpl.handleChunk(HttpClientResponseImpl.java:220)
        - locked <0x0000000771caaea8> (a io.vertx.core.http.impl.ClientConnection)
        at io.vertx.core.http.impl.ClientConnection.handleResponseChunk(ClientConnection.java:283)
        at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:876)
        at io.vertx.core.http.impl.HttpClientImpl$ClientHandler.doMessageReceived(HttpClientImpl.java:847)
        at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$7(VertxHttpHandler.java:80)
        at io.vertx.core.http.impl.VertxHttpHandler$$Lambda$18/1592881354.run(Unknown Source)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$3(ContextImpl.java:333)
        at io.vertx.core.impl.ContextImpl$$Lambda$13/1679198612.run(Unknown Source)
        at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:225)
        at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:80)
        at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:124)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
        at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:266)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
        at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:276)
        at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:354)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
        at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:318)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:304)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
        at java.lang.Thread.run(Thread.java:745)
The org.otherone.vhostproxy.vertx.MyPump class in the middle of both traces is a customized version of the standard PumpImpl class which adds just some logging after the write() call. It does not hold any locks when calling vert.x apis.
I strongly assume both threads are processing tasks related to the same request, since they lock against the same connection object, and in HTTP/1 only one response can be streaming data at once.
To me it seems the deadlock arises because in both HttpServerResponseImpl and HttpClientResponseImpl the methods involved in the deadlock all hold locks while calling both upstream and downstream methods. By downstream I mean the pump calling HttpServerResponseImpl.write() and HttpClientResponseImpl.resume(), and by upstream I mean HttpServerResponseImpl.handleDrained() and HttpClientResponseImpl.handleChunk() calling the pump.  The pump is located at the "top", coordinating traffic between two downstream connections. As can be seen all four vertx http methods hold or attempt to hold locks. Having written numerous proxy, router and gateway software products in the past I have learned that this locking model is not deadlock-safe. One robust solution to this is to decide on a locking model where locks are allowed to be held a) only while calling downstream code or b) only while calling upstream code. Locking-while-calling-downstream has seemed sensible to me so that's what I have used.
So if one would decide not to allow locks during upstream calls, the solution (where there is state that actually needs protection) is to introduce state instead. So for example HttpClientResponseImpl.handleChunk() that wants to deliver new stream data upstream, instead of doing (pseudocode):
  private void handleChunk(byte[] data) {
    synchronized (lock) {
      dataHandler.handleData(data);
    }
  }

  private void doSomethingElse() {
    synchronized (lock) {
      // here we can assume a handleData call is not in progress and
      // don't need to worry about that situation
      ...
    }
  }
.. one could instead do:
  enum State { IDLE, DATA };

  private State state = State.IDLE;

  private void handleChunk(byte[] data) {
    DataHandler dataHandlerSnapshot;
    synchronized(lock) {
      state = State.DATA;
      dataHandlerSnapshot = dataHandler;
    }
    dataHandlerSnapshot.handleData(data);
    synchronized (lock) {
      state = State.IDLE;
    }
  }

  private void doSomethingElse() {
    synchronized (lock) {
      // here we might need to take into account that a handleData
      // call is in progress and decide what to do if so
      ...
    }
  }
Introducing state variables typically makes the classes more complex as they may need to check whether they are "in the middle of something", but this should avoid deadlocks as long as it is clear what is upstream and what downstream. And in case it is not, don't hold locks when calling other components at all and use state in all cases..
To further visualize what I'm trying to say here, here's before & after sequence diagrams - arrows towards the pump are upstream calls and arrows away from te pump are downstream calls:


I would be interested in hearing what you think. I am considering looking deeper into the HTTP classes and see if I can get some pull requests going myself..
BR,
xkr47
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if the Vert.x participated with SystemD's status info (starting, started, successful vertical deployment, etc)
and watchdog functions (e.g. add a ping/handle event on the event loops to notify the watchdog, add hooks for the application to do additional checks [on watchdog ping function]),
It is easy to detect when a daemon is under the control of systemd, as certain environment variables are set, stating the location of a communication socket that can be written to, to notify the system of the process state.
This has an advantage with other external processes that can use systemd service status to determine the health of an instance (e.g. Linux-HA).
The systemd commands are listed here:
http://0pointer.de/public/systemd-man/sd_notify.html
An example of interacting with the socket and configuration without pulling in this dependency is here:
https://github.com/antirez/redis/blob/0a628e51025c4307c70cb00094dff9cdd1732f31/src/server.c
See redisSupervisedSystemd
An example of watchdog (in config files and being consumed in python is here:
https://gist.github.com/Spindel/1d07533ef94a4589d348
Discovering the ping interval
def watchdog_period():
    """Return the time (in seconds) that we need to ping within."""
    val = os.environ.get("WATCHDOG_USEC", None)
    if not val:
        return None
    return int(val)/1000000


Pinging on the configured interval
def watchdog_ping(address, sock):
    """Helper function to send a watchdog ping."""
    message = b"WATCHDOG=1"
    return sd_message(address, sock, message)

Service configuration
[Service]
Type=notify
Environment=PROBABILITY=0.1
ExecStart=/tmp/1d07533ef94a4589d348/watchdogged.py

Restart=always
RestartSec=30
WatchdogSec=1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I would rather not merge this as it can be done easily:
Handler<Buffer> h1 = ...
Handler<Buffer> h2 = ...
req.bodyHandler(body -> h1.handle(body); h2.handle(body));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since Vert.x 3.3 allready exposes  WorkerExecutor, RxHelper should have a convenient method to let RX to run on the custom workerexecutor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
WorkerExecutor should accept custom function to create ExecutorService. This will help customize the policy on the thread pool. For example, we might want to have a policy such that if the queue is full, it should reject the request rather than continuing to enqueue that.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@alexlehm one commit does not pass the CLA check
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
currently or with the new resolver code, the exception about dns failure mentions the hostname with a search suffix appended, e.g.
resolution of hostname.unknown.internal.mydomain.com failed, I this it would be better to put the original hostname from the resolver call into the error message
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The code sample in the paragraph Async coordination in the Vert.x Core java manual seems to be incorrect:
FileSystem fs = vertx.fileSystem();

Future<Void> fut1 = Future.future();

fs.createFile("/foo", fut1.completer());

fut1.compose(v -> {
  // When the file is created (fut1), execute this:
  Future<Void> fut2 = Future.future();
  fs.writeFile("/foo", Buffer.buffer(), fut2.completer());
  return fut2;
}).compose(v -> {
  // When the file is written (fut2), execute this:
  fs.move("/foo", "/bar", startFuture.completer());
},
    // mark the start future as completed when all the chain has been completed,
    // or mark it as failed if any step fails.
    startFuture);
The text below is referring to a different code structure. I haven't used this yet, but presumably it should be more like this:
Future<Void> startFuture = Future.future();

FileSystem fs = vertx.fileSystem();
Future<Void> fut1 = Future.future();
fs.createFile("/foo", fut1.completer());

fut1.compose(v -> {
  // When the file is created (fut1), execute this:
  Future<Void> fut2 = Future.future();
  fs.writeFile("/foo", Buffer.buffer(), fut2.completer());
  return fut2;
}).compose(v -> {
  // When the file is written (fut2), execute this:
  Future<Void> fut3 = Future.future();
  fs.move("/foo", "/bar", fut3.completer());
},
    // mark the start future as completed when all the chain has been completed,
    // or mark it as failed if any step fails.
    startFuture);
If this is indeed how it should be I can create a PR.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Push promise should trigger a flush. When serving the request we delay the flush after the request is handled to flush one time. Otherwise we flush after writing the push promise
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
please review this feature
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
new pr replacing #1540
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closing, repo not picking up my gpg-signed commit
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
BodyEndHandlers registered on the HttpServerResponse can be executed on the EventLoop thread after the response has been wholly received.
This is not-consistent with what the javadocs have written

Add a handler that will be called just before the response body has been completely written. This gives you a hook where you can write any extra data to the response before it has ended when it will be too late.

Here is a test case that demonstrates this:
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpServer;
import io.vertx.ext.web.Router;
import org.apache.http.client.fluent.Content;
import org.apache.http.client.fluent.Request;
import org.assertj.core.api.Assertions;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * {@link io.vertx.core.http.HttpServerResponse#bodyEndHandler(Handler)} is called afer the response has been written
 * to the channel. There's no guarentee it will occur before the client has consumed the request fully.
 */
public class VertxBugDemonstrateIT {

    private Vertx vertx;

    @BeforeClass
    public void beforeClass() {
        vertx = Vertx.vertx();
    }

    @AfterClass
    public void afterClass() {
        if (vertx != null) {
            vertx.close();
        }
    }

    @Test
    public void testDemonstrateBodyEndHandler() throws Exception {
        String message = "Hello World!";
        AtomicBoolean bodyEndHandlerHit = new AtomicBoolean();
        Router router = Router.router(vertx);
        router.route().handler(context -> {
            context.addBodyEndHandler(v -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Assertions.fail("Interrupted exception");
                }
                bodyEndHandlerHit.set(true);
            });
            context.response().end(message);
        });

        CountDownLatch serverStartedLatch = new CountDownLatch(1);
        final HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(0, event -> {
            serverStartedLatch.countDown();
        });
        serverStartedLatch.await();

        int port = server.actualPort();

        bodyEndHandlerHit.set(false);
        //Blocking call
        Content context = Request.Get(String.format("http://localhost:%s", port)).execute().returnContent();
        Assertions.assertThat(context.asString()).isEqualTo(message);
        Assertions.assertThat(bodyEndHandlerHit.get()).isTrue();
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
DatagramSocket copies the direct buffer to an pooled heap buffer - it should use an unpooled heap buffer instead.
Workaround : use -Dio.netty.allocator.type=unpooled
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This operation is like the CompositeFuture#all method, except that it always wait until all its futures are completed and will not fail as soon as one of its futures fails.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@grossws can you add a small test for this feature ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When Netty uses its GlobalEventExecutor thread and propagates into Vertx, EventLoopContext#executeFromIO does not expect such thread and fails to execute the task:
for instance:
An exception was thrown by io.vertx.core.net.impl.ChannelProvider$$Lambda$62/807291119.operationComplete() 
java.lang.IllegalStateException: Uh oh! Event loop context executing with wrong thread! Expected null got Thread[globalEventExecutor-1-2,5,FailOnTimeoutGroup]
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:303)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:190)
    at io.vertx.core.net.impl.NetClientImpl.failed(NetClientImpl.java:250)
    at io.vertx.core.net.impl.NetClientImpl.lambda$connect$5(NetClientImpl.java:225)
    at io.vertx.core.net.impl.ChannelProvider.lambda$connect$0(ChannelProvider.java:42)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
    at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
    at io.netty.util.concurrent.DefaultPromise.access$000(DefaultPromise.java:34)
    at io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:438)
    at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:233)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
    at java.lang.Thread.run(Thread.java:745)

This can happen if the creation of a Bootstrap fails, in this case the promise is created with the GlobalEventExecutor (see AbstractBootstrap#initAndRegister())
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When upgrading from Vert.x 3.2.0 to 3.3.3, we've been noticing that the following error is logged when shutting down Vert.x:
io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.IllegalStateException: Result is already complete: succeeded
    at io.vertx.core.impl.FutureImpl.checkComplete(FutureImpl.java:164)
    at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:108)
    at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:135)
    at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:23)
    at io.vertx.core.eventbus.impl.EventBusImpl.lambda$callCompletionHandlerAsync$2(EventBusImpl.java:340)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:316)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:440)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
    at java.lang.Thread.run(Thread.java:745)

This happens when Vert.x is shut down, and an event bus has been started. When the event bus is stopped manually before shutting down Vert.x, the error is not thrown. The following test shows this difference in error logging only:
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import org.junit.Test;

public class VertxCloseTest {

    @Test
    public void startStopTestWithEventbusLogsError() {
        startStopTest(TestVerticle.class);
    }

    @Test
    public void startStopTestWithEventbusClosedManuallyDoesNotLogError() {
        startStopTest(TestStopsEventBusVerticle.class);
    }

    private void startStopTest(Class<?> verticleClass) {
        Vertx vertx = Vertx.vertx();
        vertx.deployVerticle(verticleClass.getName());
        try {
            Thread.sleep(500L);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
        vertx.close();
        try {
            Thread.sleep(500L);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }

    public static class TestVerticle extends AbstractVerticle {

        @Override
        public void start() {
            getVertx().eventBus().<JsonObject>consumer("test", message -> System.out.println("Hello: " + message));
        }
    }

    public static class TestStopsEventBusVerticle extends AbstractVerticle {

        @Override
        public void start() {
            getVertx().eventBus().<JsonObject>consumer("test", message -> System.out.println("Hello: " + message));
        }

        @Override
        public void stop(Future<Void> stopFuture) throws Exception {
            getVertx().eventBus().close(handler -> {
                System.out.println("close event bus manually");
                stopFuture.complete(null);
            });
        }
    }
}
We are not sure what part of the code triggers the error, but it is introduced somewhere between 3.2.1 (does not occur) and 3.3.0 (first version when problem occurs).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current HttpClientRequest only apply when the request is connected, which potentially can buffer more than expected:
  public boolean writeQueueFull() {
    synchronized (getLock()) {
      checkComplete();
      return stream != null && stream.isNotWritable();
    }
  }

Before connecting it would be good to apply back-pressure and return true when pendingChunks.length() > pendingMaxSize.
Note: when the request obtains the connection, it should check it was not paused to call the drain handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Calling HttpServerResponse.sendFile produces the following exception:
Oct 04, 2016 11:07:27 AM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-3,5,main] has been blocked for 8059 ms, time limit is 2000
io.vertx.core.VertxException: Thread blocked
        at com.sun.crypto.provider.GHASH.update(GHASH.java:167)
        at com.sun.crypto.provider.GaloisCounterMode.doLastBlock(GaloisCounterMode.java:362)
        at com.sun.crypto.provider.GaloisCounterMode.encryptFinal(GaloisCounterMode.java:419)
        at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1025)
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:984)
        at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:479)
        at javax.crypto.CipherSpi.bufferCrypt(CipherSpi.java:776)
        at javax.crypto.CipherSpi.engineDoFinal(CipherSpi.java:730)
        at javax.crypto.Cipher.doFinal(Cipher.java:2416)
        at sun.security.ssl.CipherBox.encrypt(CipherBox.java:396)
        at sun.security.ssl.EngineOutputRecord.write(EngineOutputRecord.java:300)
        at sun.security.ssl.EngineOutputRecord.write(EngineOutputRecord.java:225)
        at sun.security.ssl.EngineWriter.writeRecord(EngineWriter.java:186)
        at sun.security.ssl.SSLEngineImpl.writeRecord(SSLEngineImpl.java:1280)
        at sun.security.ssl.SSLEngineImpl.writeAppRecord(SSLEngineImpl.java:1251)
        at sun.security.ssl.SSLEngineImpl.wrap(SSLEngineImpl.java:1166)
        at javax.net.ssl.SSLEngine.wrap(SSLEngine.java:509)
        at io.netty.handler.ssl.SslHandler.wrap(SslHandler.java:700)
        at io.netty.handler.ssl.SslHandler.wrap(SslHandler.java:526)
        at io.netty.handler.ssl.SslHandler.flush(SslHandler.java:501)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:762)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:754)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:735)
        at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:762)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:754)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:735)
        at io.netty.handler.stream.ChunkedWriteHandler.doFlush(ChunkedWriteHandler.java:310)
        at io.netty.handler.stream.ChunkedWriteHandler.flush(ChunkedWriteHandler.java:138)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:762)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:754)
        at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:735)
        at io.netty.channel.ChannelDuplexHandler.flush(ChannelDuplexHandler.java:117)
        at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:762)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:788)
        at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:800)
        at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:780)
        at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:817)
        at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1011)
        at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:289)
        at io.vertx.core.net.impl.ConnectionBase.writeToChannel(ConnectionBase.java:117)
        at io.vertx.core.http.impl.ServerConnection.writeToChannel(ServerConnection.java:184)
        at io.vertx.core.net.impl.ConnectionBase.sendFile(ConnectionBase.java:248)
        at io.vertx.core.http.impl.ServerConnection.sendFile(ServerConnection.java:393)
        at io.vertx.core.http.impl.HttpServerResponseImpl.doSendFile(HttpServerResponseImpl.java:468)
        at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:336)
        at io.vertx.core.http.impl.HttpServerResponseImpl.sendFile(HttpServerResponseImpl.java:54)
        at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:275)
        at io.vertx.core.http.HttpServerResponse.sendFile(HttpServerResponse.java:262)

Given there is no indication that this is blocking I did not expect the call to execute the write on the current thread. And given the documentation on the similar method says:
``The actual serve is asynchronous and may not complete until some time after this method has returned`
This seems to be inaccurate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A lot of libraries offer the opportunity to use JsonPath to query json data. It's becoming quite a standard, like XPath, GPath, etc. (main inspiration for opening this issue comes from gatling)
In my opinion it could be a nice addition to the JsonObject / JsonArray implementations especially for testing (maybe for http clients, too).
Use-case :
Double firstBookPriceInclTaxes =  json.getJsonArray("books").getJsonObject(0).getJsonObject("pricing").getDouble("inclTaxes");
Double firstBookPriceInclTaxes = json.getByPath("$.books[0].pricing.inclTaxes");
Or even better
Collection<Double> allBookPricesInclTaxes = json.getJsonArray("books").stream().map(o -> ((JsonObject)o).getJsonObject("pricing").getDouble("inclTaxes")).collect(Collectors.toList());
Collection<Double> allBookPricesInclTaxes = json.getByPath("$.books[*].pricing.inclTaxes");
Relevant :

a Java implementation
a discussion in the Google Group

Questions before trying to give the implementation a try :

Do you think the feature is needed (if so, please upvote this issue) ? Or not.
Should we rely on a third-party library (and thus not reinvent the wheel but add a library to the fatJars, maybe not needed for a lot of clients).

Difficulties :

mapping onto objects / typing may be very difficult : json.getByPath("$.items[*].id") will return a collection of Integers (or JsonArray ?) whereas json.getByPath("$.items[0]") will return a JsonObject : this might be very tricky
dealing with errors ?
...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you give a thorough explanation of the issues you encountered and how this change solves it ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
First of - I'm am more than willing to code this myself through a pull-request. Question is only: has this been already discussed to death? Would there be any demand? Would this be in-line with your design?
Justification: Sending huge immutable/threadsafe objects over the EventBus is currently an unnecessary chore, both for the programmer himself, and the server (potentially introducing many irrelevant de/encodings and allocations). Simply allowing the programmer to declare "I hereby solemnly swear I know what I'm doing" by implementing a mixin interface, and enabling him/her to explicitly pass such a reference on a LocalEventBus (or predefined channel of the "normal" EventBus) would vanish the issue.
There already exists a LocalMap that accomplishes virtually the same effect, arguably in a much less "vertexy" way, resulting in less elegant APIs. So no new risks would be introduced, and due to the "opt-in" nature the programmer would have only himself to blame if hell freezes over ;)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When sent a json object using some tools(like RestClient firefox) to server throw exception on convert body of request to jsonobject because json sent with some characters like "\n" and JsonObject can not convert this String to JsonObject but "org.json" has not this problem and can convert this string to JSONObject.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the Eclipse ECA and sign-off the pull request ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See vert-x3/vertx-infinispan#3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you have a look at this one too? Thx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
2016-10-11 21:45 GMT+02:00 Julien Viet notifications@github.com:

please review
You can view, comment on, or merge this pull request online at:
#1671
Commit Summary

JsonObject copy() preserves LinkedHashMap - fixes #1611

File Changes

M src/main/java/io/vertx/core/json/JsonObject.java
https://github.com/eclipse/vert.x/pull/1671/files#diff-0 (7)
M src/test/java/io/vertx/test/core/JsonObjectTest.java
https://github.com/eclipse/vert.x/pull/1671/files#diff-1 (23)

Patch Links:

https://github.com/eclipse/vert.x/pull/1671.patch
https://github.com/eclipse/vert.x/pull/1671.diff


You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
#1671, or mute the thread
https://github.com/notifications/unsubscribe-auth/ABbltjCZVg9AqqpwB5zQqveNucN5IZ3Yks5qy-dzgaJpZM4KUBtO
.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
useNormalisedPath should be able to be turned off by default (probably per Router basis). I find that we have to turn this feature off most of the time especially when we have to deal with wide range of inputs including special characters.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Am using vertx 3.3.2.
httpClient.exceptionHandler is throwing compilation error.
Whether its removed in this version and how to handle connection exceptions.
Could anyone please help on this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Netty already supports DomainSockets/DomainChannels, so I was hoping it might be possible to implement support (via HttpOptions/SocketOptions) to support UNIX Domain sockets (AF_UNIX)??? We do this quite often for secured APIs across docker containers. We mount the socket file as a volume in the container and then the different applications communicate via the UNIX Domain socket. We have also taken to communicating with the Docker daemon itself in this manner instead of exposing the Docker HTTP API.
My suggestion for implementation would be one of the following:
Add an overloaded method for Vertx.create(Net/Http)(Client/Server) which could take a "Path" object to point to the location for the UNIX domain socket..
Add logic to the Net/HTTP Client/Server implementations to parse a URL of the format "unix+http://" or "unix+socket://"
Probably many more questions to be answered, but that should be a good start.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm not against having shortcut method like you added to the interface, however I find confusing the fact to have more than one handler in the implementation, i.e
default void setSuccessHandler(Handler<T> handler) {
  setHandler(ar -> {
    if (ar.succeeded()) {
      handler.handle(ar.result());
    }
  });
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wrong source file to edit documentation. Will submit a new PR with the fix on the correct source file.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cookies are not specific from the web framework and if one is doing a HTTP server just with core it would be nice not to re-invent the API.
I'd like to propose to move:
https://github.com/vert-x3/vertx-web/blob/master/vertx-web/src/main/java/io/vertx/ext/web/Cookie.java
to core.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When send json to server using some plugins like restful client Firefox get this exception.
The problem is converting String to JsonObject. I test org.json.JSONObject and didn't get this exception.
The problem is by some characters like "\n" which will be added to json string in receiving in server side and JsonObject class can not convert to JsonObject but JSONObject didn't has this problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I tried to develop a server receiving and sending UDP packets (see code snippet below). The issue is that the reply packets don't have the correct source port, that is, the port the server listens on.
public class VerticleUdp extends AbstractVerticle {

    public static final int RECEIVER_PORT = 5000;
    public static final String RECEIVER_HOST = "0.0.0.0";

    @Override
    public void start(Future<Void> fut) {
        // Starting listening on specific socket
        DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
        socket.listen(RECEIVER_PORT, RECEIVER_HOST, asyncResult -> {
            if (asyncResult.succeeded()) {
                socket.handler(packet -> {
                    Buffer buffer = Buffer.buffer(new String("HELLO").getBytes());
                    // Send a Buffer
                    socket.send(buffer, packet.sender().port(), packet.sender().host(), isSent -> {
                        if(isSent.succeeded()){
                        }
                    });
                });
                fut.complete();
                System.out.println("Verticle UDP deployed");
            } else {
                fut.fail( asyncResult.cause());
                System.err.println("VerticleUdpReceiver : Cannot listen port");
            }
        });
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Vert.x websocket client doesn't set a Host header. I'm not sure this can be considered a bug, but I do see other clients behaving different. This is a problem for most load balancer configurations which makes it bit of a usability issue.
A workaround is easy though by passing the header manually:
httpClient.websocket(443,"mydomain.com", "/", MultiMap.caseInsensitiveMultiMap().add("Host", "mydomain.com"), ws -> {
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@pmlopes looks like you forgot to read the part about commit signoff 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi everybody!
When not specifying a Port - using the Vert.x websocket client - results in connecting to port 80 in both cases - http and https. I think it makes sense to default to port 443 on https connections.
Greets, Markus
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cross posted on: netty/netty#5943
Please read this article:
https://letsencrypt.org/2016/10/24/squarespace-ocsp-impl.html
Please focus on:

Our extension is a standalone library but we could equally well fold it into the netty-tcnative library itself. If there is interest, we can contribute it upstream as part of Nettys next API-breaking development cycle.

hoping you'll show that there's interest!

Anyway it think in any case vert.x should wrap this feature ( once it's ready ) in the HttpServer implementation for this reason I'm opening a ticket also here...
And I hope also, that even if Netty will not show interest, VertX can do that, and embed that implementation itself...
It can reduce the ssl performance bottleneck that still require me to use nginx reverse proxy in front of some VertX as you know that even with tncnative we're not as good as nginx on https, maybe most of the bottleneck it's due to the missing ocsp stapling support, and it may be also a visibility opportunity for this project itself as letsencrypt can feature it too.
It's reactive!
My 2 cents
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it seems it only fit well with the Future<Void> for which complete() is for.
it would not fit well for a Future<String> for which the provider of the future would expect a non value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I am trying to use vertx with rxjava in web router like:
private void registerTooRoute(Router router) {

    ObservableHandler<RoutingContext> handler = RxHelper.observableHandler();

    handler
        .doOnNext(ctx -> ctx.response().putHeader("content-type", "text/html"))
        .subscribe(ctx -> {
          ctx.response().end("Hello");
        });

    router.get(API_TOO).handler(handler.toHandler());
  }

The first request to the server, I've got the result Hello as expected. But further request to the server, I've got only sandwatch from the browser.
It seems to be, that is an error in vertx rxjava conversion.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj I don't know what is wrong!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have read the doc, but I don't understand how to use the api, this is my code
public class Server extends AbstractVerticle {
    @Override
    public void start() throws Exception {
        CLI cli = CLI.create("copy")
                .setSummary("A command line interface to copy files.")
                .addOption(new Option()
                        .setLongName("directory")
                        .setShortName("R")
                        .setDescription("enables directory support")
                        .setFlag(true))
                .addArgument(new Argument()
                        .setIndex(0)
                        .setDescription("The source")
                        .setArgName("source"))
                .addArgument(new Argument()
                        .setIndex(0)
                        .setDescription("The destination")
                        .setArgName("target"));

        StringBuilder builder = new StringBuilder();
        cli.usage(builder);
    }

}

I created a stage but where can I entering the command like "copy [-R] source target" to tell my program to do sth ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I wasn't sure if this should be put in ClientOptionsBase instead, since I think it only makes sense for clients. But I came to the conclusion that I liked it better along with other ssl options.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using HTTP_2 from a verticle deployed as a worker verticle causes an internal NullPointerException . The following code throws an exception unless

the MyOtherVerticle is deployed with setWorker(false)
or the setProtocolVersion(HttpVersion.HTTP_2) line is removed

public class MyRawMainVerticle extends AbstractVerticle {

    @Override
    public void start(Future<Void> fut) throws Exception {

        Future<Integer> server = Future.future();
        vertx.createHttpServer()
            .requestHandler(r -> r.response().end("helo"))
            .listen(0, l -> server.complete(l.result().actualPort()));

        server.setHandler(port -> {
            JsonObject config = new JsonObject().put("port", port.result());
            vertx.deployVerticle(new MyOtherVerticle(), new DeploymentOptions()
                .setWorker(true).setConfig(config), done -> fut.complete());
        });
    }

    class MyOtherVerticle extends AbstractVerticle {

        private Logger logger = LoggerFactory.getLogger(MyOtherVerticle.class);

        @Override
        public void start(Future<Void> fut) throws Exception {

            HttpClient httpClient = vertx.createHttpClient(new HttpClientOptions()
                .setProtocolVersion(HttpVersion.HTTP_2)
                .setDefaultHost("localhost")
                .setDefaultPort(config().getInteger("port")));

            httpClient.get("/", response -> {
                response.bodyHandler(body -> {
                    logger.info("received: " + body.toString());
                });
            }).exceptionHandler(ex -> {
                logger.error(ex);
            }).end();

            fut.complete();
        }
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Allowing Vert.Xers to cofigure their webserver deflater compression level.
Inspired by the nginx equivalent: http://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip_comp_level
Usage example:
HttpServerOptions()
                .setCompressionSupported(true)
                .setCompressionLevel(1) /* valid range 1-9 (1: fastest, less compression - 9 slower, best (pedantic) compression )*/
Note:
Before this PR the .setCompressionSupported(true) was enabling the netty's HttpCompressor default compression level that is 6.
In my proposal i  set the default compression level to 1 (fastest, not the best size saver but anyway very good compression the modern web usage case (in my experience), less cpu cylce wasting, less http requests stucking in 'waiting state')
Why this PR?

Making vert.x flexible in this configuration too cause in order to demonstrate we have nothing to envy to other webservers like nginx ;)
Saving server resource usage (less cpu time for compression = more cpu time for the event loop, less overwarming ;) )
Reducing latency TTFB for static assets when compression is enabled

A bit more  rationale:
A best practice suggested by any moder site 'speed test' is to enable compression, but - as a drawback - enabling it we consume more cpu cycles at server end, and if we tune up it uncarefully we can end up - paradoxically - to get a worst time-to-first-Byte (TTFB) and even a worst total request time with compression enabled compared to no compression at all.
A best pratice to avoid such issue and achieve the better performance compromise, is to tune  compressor to do the 'bare minimal' work and don't overkillig, in other words, remembering that our target is reducing latency at the very minimum level and not really reducing 'file size'.
From my personal experience with nginx and apache too, and confirmed by many online guides, the best value for gzip compression level is 1 or 2 for a web server. Going higher that than just saves some bits, but pay back it hardly in server resource usages and processing latency (when compression is not cached but done on-the-fly)
Bonus: a further performance improvement can be to implement a compression cache layer in vertx but this is uncommon and complex also in other webservers so not a priority.
See also discussion on closed PR: #1576 (closed due to CLA and master branch  git commit history sync issues)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Now both Http and Http2 is working, with JUnit tests  for compression (check for string equals after http serving compressed and httpclient decompress) and check for byte size (checking if compression level_1 size > compression level_9 size > 0 ), the previous HttpCompressionTest was in my opinion not really checking if compression was working but just the presence of the header in the request
@vietj  Please take another look
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've hit a subtle issue that doesn't allow me to delay a response to the client.
In the real code (this is a simplification) I'm using the RxJava extensions to wait for a particular condition before sending a response to the client, but the problem happen also with the following code.
        // RxJava - vertx
        HttpServer server = vertx.createHttpServer();

        server.requestStream().toObservable()
                //.delay(1, TimeUnit.MILLISECONDS)
                .subscribe(req -> {
                    req.handler(data -> logger.info("RECEIVED " + data)); // Important
                    req.response().setStatusCode(200).setChunked(true).write("Hello World").end();
                });

        server.listen(9000);
The code above works perfectly if you comment the delay. When sending GET or POST requests to port 9000 the body is printed to the console (in the case of POST requests, I'm sending them using Postman) and the message "Hello World" is returned to the client.
If you just put a delay into the observable (any amount of time causes the problem), the issue appears:
Exception in thread "RxComputationScheduler-1" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
	at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:57)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: rx.exceptions.OnErrorNotImplementedException: Request has already been read
	at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)
	at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)
	at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:152)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)
	at rx.exceptions.Exceptions.throwOrReport(Exceptions.java:205)
	at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:139)
	at rx.internal.operators.OperatorDelay$1$3.call(OperatorDelay.java:87)
	at rx.internal.schedulers.EventLoopsScheduler$EventLoopWorker$2.call(EventLoopsScheduler.java:189)
	at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
	... 7 more
Caused by: java.lang.IllegalStateException: Request has already been read
	at io.vertx.core.http.impl.HttpServerRequestImpl.checkEnded(HttpServerRequestImpl.java:426)
	at io.vertx.core.http.impl.HttpServerRequestImpl.handler(HttpServerRequestImpl.java:206)
	at io.vertx.rxjava.core.http.HttpServerRequest.handler(HttpServerRequest.java:74)
	at io.kubeless.server.VertxBug.lambda$start$1(VertxBug.java:41)
	at rx.internal.util.ActionSubscriber.onNext(ActionSubscriber.java:39)
	at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)
	... 10 more

The problem happens on the first GET request. If I send only POST requests, the problem happens on the second request, while the first works.
The offending line seems to be the one marked as "important" (i.e. reading the content of the request and logging it or doing anything else with it).
I think that this should be solved, but I'm looking also for a workaround (eg. is there a way to buffer the request content to be able to read it multiple times without errors?).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jo5ef can you also test the executeBlocking case ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See: https://github.com/vert-x3/wiki/wiki/Vert.x-code-style-guidelines

We recommend that all repos should have a .editorconfig in the root folder with at least the following content:


root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
trim_trailing_whitespace = true
end_of_line = lf
insert_final_newline = true


Why not add it in the root of this repo, so forks can follow rules automatically?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I made a reproducer using IntelliJ:
https://github.com/leolux/vertx3-issue-accessexception
The exception looks like this:
Nov 10, 2016 12:58:28 PM node.StartupInstance
SCHWERWIEGEND: Uuups: io.vertx.core.file.FileSystemException: java.nio.file.FileSystemException: .vertx\file-cache-f9ed8a3e-fd6b-4ff6-905d-b1b48ed2e71c\cert\wild.vertx.io.jks: Der Prozess kann nicht auf die Datei zugreifen, da sie von einem anderen Prozess verwendet wird.

It means that vertx tries to access a cached filed which is currently blocked by some other process wherease file caching is disabled.
The reproducer shows that FileSystemException or FileAccessException occurs when the the WebServer gets deployed twice or more AND when file caching gets disabled AND when the program gets executed by IntelliJ or Eclipse IDE (by running the main() method of StartupInstance). Executing the fat-jar works without issues.
I tried to solve the issue without success. I changed my file permissions Windows 10 for the .vertx folder and I tried several changes in IntelliJ like disabling indexing, disabling auto compiling, disabling framework detection, adding filter paths for the compiler, cleaning the project, running IDEA as administrator, but nothing helped. I also tried to get information about the process blocking the file using the Sysinternals Process Explorer (procexp). But procexp didn't find any handle or dll for this file.
As the issue occurs only within the IDE there needs to be some influcence from the development environment to the .vertx folder. But the strange thing is that the issue disappears when I change the DeploymentOptions from 2 instances to 1 instance. The IDE cannot be the root cause anymore in my eyes.
Does the reproducer show the same issue on your IDE?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, JsonObject has multiple getXXX methods for the basic data types (Integer, Long, String...).
public Integer getInteger(String key)
// Default returned when no value present for key
public Integer getInteger(String key, Integer def)

There currently isn't a method to check whether a value holds the expected data type. It can be done by using above methods and catching the ClassCastException, but it seems better to provide methods like:
// Unchanged
public Integer getInteger(String key)

public boolean isInteger(String key)
// Default returned when no value present for key OR value is of different type
public Integer getInteger(String key, Integer def)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JsonObject obj = new JsonObject();
obj.put("hello", new JsonObject().put("a", 0));

JsonObject obj2 = new JsonObject();
obj2.put("hello", new JsonObject().put("b", 1));

obj.mergeIn(obj2);

System.out.println(obj.toString());
// Output: {"hello":{"b":1}}
// Expected output : {"hello":{"a":0, "b":1}}

One can argue about how to deal with lists, but I would also merge those.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
would you mind to redo a clean PR please @paulbakker thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ClassCastException occurs during startup of my app. I'm using Vert.x 3.3.3.
Exception in thread "main" java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType
        at io.vertx.core.cli.impl.ReflectionUtils.getComponentType(ReflectionUtils.java:63)
        at io.vertx.core.cli.annotations.CLIConfigurator.createOption(CLIConfigurator.java:116)
        at io.vertx.core.cli.annotations.CLIConfigurator.define(CLIConfigurator.java:78)
        at io.vertx.core.spi.launcher.DefaultCommandFactory.define(DefaultCommandFactory.java:59)
        at io.vertx.core.impl.launcher.VertxCommandLauncher.register(VertxCommandLauncher.java:127)
        at java.util.ArrayList.forEach(Unknown Source)
        at io.vertx.core.impl.launcher.VertxCommandLauncher.load(VertxCommandLauncher.java:122)
        at io.vertx.core.impl.launcher.VertxCommandLauncher.<init>(VertxCommandLauncher.java:112)
        at io.vertx.core.impl.launcher.VertxCommandLauncher.<init>(VertxCommandLauncher.java:101)
        at io.vertx.core.Launcher.<init>(Launcher.java:41)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running vert.x from CLI using command like:
java -cp $MY_CP start  -id e8b0342b-7a65-495a-a58f-88071421e07c org.vertx.demo.SimpleVerticle --launcher-class io.vertx.core.Launcher
The application is refusing to start saying no command by name org.vertx.demo.SimpleVerticle.. but when I do start with same set of options via Launcher.main(args)  form a custom main program from an IDE things run well.
Using vert.x v3.3.3
where $MY_CP is custom classpath which has jars/classes directory etc.,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Would you see any problems in extending HttpServerResponse.sendFile() with a flag boolean autoEnd or similar that would allow one to do:
response.sendFile("file", false, (t) -> {
    if (t == null) {
        response.end("\r\nThis file was brought to you by vert.x");
    }
});
? One would naturally have to take care of setting the Content-Length header oneself in this case.
Right now, sendFile() automatically ends the response and trying to write anything in the callback (rightfully) throws an exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried streaming music to a music player from vertx using sendFile(), but the connection is closed after the time given idleTimeout (I have 60 seconds) set in HttpServerOptions has passed after the request started.
I tracked the socket closing down and it seems this triggers the closing:
channelIdle(ctx, event); in io.netty.handler.timeout.IdleStateHandler.AllIdleTimeoutTask. I guess some other piece of code forgets to mark the connection "busy" while sendFile is active..
vert.x 3.3.3, netty 4.1.1.Final
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When starting vert.x application using run with redeploy the arguments with quotes for the option values are treated literally without ignoring the quotes that are passed by the shell.
e.g. when you run a command like io.vertx.core.Launcher run org.vertx.demo.SimpleVerticle --redeploy="target/classes/**/*" --launcher-class="io.vertx.core.Launcher"
the redeploy patterns target/classes/**/* is parsed as literal string with " and application is not able to do the redeploy as needed.
The same command when run without quotes for --redeploy works as expected.
This could be a potential issue when passing paths with spaces or may be in some other scenarios.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Happens sometimes

build	23-Nov-2016 10:05:48	    java.lang.StackOverflowError
build	23-Nov-2016 10:05:48	    	at java.util.HashSet.(HashSet.java:118)
build	23-Nov-2016 10:05:48	    	at io.vertx.core.impl.DeploymentManager$DeploymentImpl.doUndeploy(DeploymentManager.java:504)
build	23-Nov-2016 10:05:48	    	at io.vertx.core.impl.DeploymentManager$DeploymentImpl.doUndeploy(DeploymentManager.java:518)
build	23-Nov-2016 10:05:48	    	at io.vertx.core.impl.DeploymentManager$DeploymentImpl.doUndeploy(DeploymentManager.java:518)
build	23-Nov-2016 10:05:48	    	at io.vertx.core.impl.DeploymentManager$DeploymentImpl.doUndeploy(DeploymentManager.java:518)

public synchronized void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> completionHandler) {
  if (undeployed) {
    reportFailure(new IllegalStateException("Already undeployed"), undeployingContext, completionHandler);
    return;
  }
  if (!children.isEmpty()) {                 <------ a concurrent HashMap does not guarantee consistency
    final int size = children.size();
    AtomicInteger childCount = new AtomicInteger();
    boolean undeployedSome = false;
    for (Deployment childDeployment: new HashSet<>(children)) {   
      undeployedSome = true;               <------- never reached because isEmpty said false although it is actually empty
      childDeployment.doUndeploy(undeployingContext, ar -> {
        children.remove(childDeployment);
        if (ar.failed()) {
          reportFailure(ar.cause(), undeployingContext, completionHandler);
        } else if (childCount.incrementAndGet() == size) {
          // All children undeployed
          doUndeploy(undeployingContext, completionHandler);
        }
      });
    }
    if (!undeployedSome) {
      // It's possible that children became empty before iterating
      doUndeploy(undeployingContext, completionHandler);  <------------------- infinite recursion here
    }
  } 

Some excerpt from the ConcurrentHashMap documentation:


Bear in mind that the results of aggregate status methods including
{@code size}, {@code isEmpty}, and {@code containsValue} are typically
useful only when a map is not undergoing concurrent updates in other threads.
Otherwise the results of these methods reflect transient states
that may be adequate for monitoring or estimation purposes, but not
for program control.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
like we do have on HttpServer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I added @CacheReturn since I thought it would make sense (they were annotated so also in the NetSocket interface).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version

vert.x core: 3.3.3

Context
If a request is made where the initial line is longer than the max initial line length, an empty reply is returned instead of a 414 response code.  Haven't even been able to find any particular way to implement this myself; best I've been able to do is register an exception handler on the HttpConnection to log it.
Do you have a reproducer?

https://gist.github.com/robkid/65db0cc92c68d7c45d7c751c76a1ce87

Steps to reproduce

Run the main class in the gist
Use curl (or equivalent) to issue a get request to the server that is longer than 4096 bytes (e.g. curl "http://localhost:8080/foo?a=<string of 4096+ characters>").
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Maybe I overlooked something, but why not use the information that the exceptions from Jackson provides? Especially the JsonMappingException gives useful information about the json format (e.g. missing/invalid params), which is useful feedback to provide consumers of a REST api.
For now it seems,  that I have to manually go through the json object to see if the all the params needed are present and valid for a given endpoint.
It would help a lot if the DecodeException contained easy accessible information about the path to the invalid/missing parameters.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you amend your commit to sign it off?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As of 3.3.3, you can deploy multiple instances of a verticle, and leverage load balancing for HTTP servers and TCP servers.
However, deploying multiple instances of a verticle creating a datagram listener will result in a java.net.BindException: Address already in use.
You can avoid the exception by enabling address reuse:
vertx.createDatagramSocket(new DatagramSocketOptions().setReuseAddress(true))
But only one verticle instance will handle the messages.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj force updated to resolve conflicts
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I followed the example, but an error occurred.
An error does not occur in 3.2.1 but an error occurs in 3.3.3.

build.gradle

plugins {
    id 'application'
    id 'com.github.johnrengelman.shadow' version '1.2.3'
}


repositories {
    jcenter()
}

version = '1.0-SNAPSHOT'
sourceCompatibility = '1.8'
mainClassName = 'io.vertx.core.Launcher'

def vertxVersion = '3.3.3'
def mainVerticleName = 'com.prographer.exam.HelloWorldVerticle'
def watchForChange = 'src/**/*'
def doOnChange = './gradlew classes'

dependencies {
    compile "io.vertx:vertx-core:$vertxVersion"
    compile "io.vertx:vertx-rx-java:$vertxVersion"
    testCompile "io.vertx:vertx-unit:$vertxVersion"
    testCompile "junit:junit:4.12"
}

shadowJar {
    classifier = 'fat'
    manifest {
        attributes "Main-Verticle": mainVerticleName
    }
    mergeServiceFiles {
        include 'META-INF/services/io.vertx.core.spi.VerticleFactory'
    }
}

run {
    args = ['run', mainVerticleName, "--redeploy=$watchForChange", "--launcher-class=$mainClassName", "--on-redeploy=$doOnChange"]
}

task wrapper(type: Wrapper) {
    gradleVersion = '3.1'
}


ServerVerticle.java  code

public class ServerVerticle extends AbstractVerticle {
    @Override
    public void start() throws Exception {
        HttpServer server = vertx.createHttpServer();

        server.requestHandler(request -> {

            // This handler gets called for each request that arrives on the server
            HttpServerResponse response = request.response();
            response.putHeader("content-type", "text/plain");

            // Write to the response and end it
            response.end("Hello World!");
        });

        server.listen(8080);
    }
}


Exception

$ vertx run ServerVerticle.java 
Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2398 ms, time limit is 2000 
Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 3403 ms, time limit is 2000 
Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 4404 ms, time limit is 2000 
Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5407 ms, time limit is 2000 
io.vertx.core.VertxException: Thread blocked
        at java.lang.Throwable.fillInStackTrace(Native Method)
        at java.lang.Throwable.fillInStackTrace(Throwable.java:783)
        at java.lang.Throwable.<init>(Throwable.java:287)
        at java.lang.Exception.<init>(Exception.java:84)
        at java.lang.ReflectiveOperationException.<init>(ReflectiveOperationException.java:75)
        at java.lang.ClassNotFoundException.<init>(ClassNotFoundException.java:82)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:217)
        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:186)
        at com.prographer.exam.ServerVerticle.start(ServerVerticle.java:14)
        at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:111)
        at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.java:434)
        at io.vertx.core.impl.DeploymentManager$$Lambda$24/33563464.handle(Unknown Source)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:316)
        at io.vertx.core.impl.ContextImpl$$Lambda$25/756936249.run(Unknown Source)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:440)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
        at java.lang.Thread.run(Thread.java:745)


It takes a long time here.https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/net/impl/SSLHelper.java#L109
Is this a JDK issue? my jdk version is 1.8.0_73
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Have you signed the Eclipse CLA ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry, not sure why old changes were picked up here. Closing this, will try again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj There may need to be some discussion here as to whether the fields need to be public or not to be (de)serialized (or have public getters/setters), depending on how the object mapper is configured.
Also, I'm guessing that the Java class being deserialized needs to have a public default constructor so that it can be instantiated by Jackson.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As evident in https://github.com/eclipse/vert.x/blob/868595511d8c63a6589a260da7cdea585219f20c/src/main/java/io/vertx/core/impl/VertxImpl.java#L165
if the clusterManager.join() call returns a failure, the resultHandler submitted to the VertxImpl constructor is never called (neither success nor failure) resulting in the handler never completing and the caller getting stuck with an unresponsive stack.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could you add a test to your PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj rebased on master, can you have a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We've been using OpenSSL via netty-tcnative-boringssl-static (1.1.33.Fork23), mostly because ALPN doesn't work with JdkSsl. When trying vertx 3.4.0.Beta1, the following exception is thrown when using OpenSSLEngineOptions with HttpClient:
java.lang.NoSuchMethodError: org.apache.tomcat.jni.SSLContext.setCACertificateBio(JJ)Z
	at io.netty.handler.ssl.ReferenceCountedOpenSslServerContext.newSessionContext(ReferenceCountedOpenSslServerContext.java:162)
	at io.netty.handler.ssl.OpenSslServerContext.<init>(OpenSslServerContext.java:349)
	at io.netty.handler.ssl.OpenSslServerContext.<init>(OpenSslServerContext.java:334)
	at io.netty.handler.ssl.SslContext.newServerContextInternal(SslContext.java:414)
	at io.netty.handler.ssl.SslContextBuilder.build(SslContextBuilder.java:402)
	at io.vertx.core.net.impl.SSLHelper.createContext(SSLHelper.java:282)
	at io.vertx.core.net.impl.SSLHelper.getContext(SSLHelper.java:417)
	at io.vertx.core.net.impl.SSLHelper.validate(SSLHelper.java:431)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:258)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:230)

The latest netty-tcnative (2.0.0.Beta1) has the same problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In eclipse/vert.x/src/main/java/io/vertx/core/impl/ContextImpl.java
        log.error("Unhandled exception", t);
should be
        log.error("Unhandled exception" + t);
Otherwise the exception is not logged - which seems to be the point of the original code.
So in my logs I currently see
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception
Feb 07, 2017 5:42:32 PM io.vertx.core.impl.ContextImpl SEVERE: Unhandled exception

which is not as useful as having a message for each exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In eclipse/vert.x/src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java in method deliver there is a catch block which could be improved slightly.
It has been advantageous to me to see the address of the message handler which has failed (for whatever reason)
    } catch (Exception e) {
      log.error("Failed to handleMessage ", e);
      metrics.endHandleMessage(metric, e);
      throw e;

      if (message != null) {
        log.error("Failed to handleMessage '" + message.address() + "'", e);
      } else {
        log.error("Failed to handleMessage ", e);
      }

So now if my event handler "service.releaseaccount" has a failure I am told so by name, which could be quite useful
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
These types are leftover of Vert.x 2 and was useful because of the lack of lambdas in Java 7.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ServerWebSocketStream
WebSocketStream
HttpServerRequestStream
NetSocketStream
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current a server can be paused, i.e stop accepting requests, by closing new connections when they arrive.
It would be best if that was done at HandlerManager level : pausing a connection would remove the handler from the list and thus it would work best with redeployments that wants to stop accepting requests and delegate them to other handlers using server scaling.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closing as we'll update codetrans to skip those methods.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We would like to send and receive large text responses over websockets from our vertx server.  Since the message may be too large for the default websocket frame, the vertx library should split it into multiple frames.
io.vertx.core.http.WebSocketBase already supports sending large binary messages with the writeBinaryMessage function, so I would like to add a new function writeTextMessage.
This would be required to resolve issue 521 in vertx-web (vert-x3/vertx-web#521).  In the pull request (vert-x3/vertx-web#520) for that issue, it was identified that making some changes to WebSocketBase in vertx-core would be the best way forward.
This is similar to Issues #932 and #964.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
something on top of my mind with unicode chars : string.length() != string.getByte().length
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
OK, Github editing doesn't play nice with Eclipse CLA checker. I'm going to trash this and try again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In VertxImpl.createSharedWorkerExecutor the poolSize check is performed against maxExecutionTime, likely by mistake.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do you guys want a unit test with that ? It seems trivial to me, but let me know.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at the JavaDocs for Vertx.createSharedWorkerExecutor , it appears that the max execution time for a task is measured in milliseconds, but BlockedThreadChecker compares this value to VertxThread.startTime() that returns a value in nanoseconds, and indeed, BlockedThreadChecker divides that value by 1000000 to get at a milliseconds value.
All the other entities in the chain from Vertx.createSharedWorkerExecutor to BlockedThreadChecker don't document the meaning of the max execution time value, so I'm not sure which is correct, and I've also failed to locate where that value is being acted upon other than to issue warnings to the logs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
like the title.i am use httpclient to get file from some server.the server use nginx to be the web server.but,recently i found that if some rqeuest always timeout.
then,i try to find the reason.i found that if httpclient timeout sometimes for one server.httpclient will always timeout even though this server is normal now.when i restart my app,it will be normal.
my core code is:
HttpClientOptions options = new HttpClientOptions().setKeepAlive(false);
		options.setConnectTimeout(2 * 1000);
		options.setPipelining(true);
		options.setKeepAlive(true);
		options.setReceiveBufferSize(64 * 1024);
		httpClient = this.vertx.createHttpClient(options);

httpclient.get(ip,url,res->{
//do something
})..exceptionHandler(t -> {
			LOGGER.error("connect client failed,ip:" + ip + ",url:" + url + ",error:" + t.getMessage());
			serverResponse.setStatusCode(500).putHeader("Content-Type", "text/html").end(Config.SERVER_ERROR + ": Connect Storage failed.");
		}).setTimeout(10 * 1000).end();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my app locked today,then i print the stack log:
Found one Java-level deadlock:
=============================
"vert.x-eventloop-thread-47":
  waiting to lock monitor 0x000000001a182748 (object 0x00000000da863a70, a io.vertx.core.http.impl.HttpClientRequestImpl),
  which is held by "vert.x-eventloop-thread-0"
"vert.x-eventloop-thread-0":
  waiting to lock monitor 0x000000001e851bb8 (object 0x00000000ff6253f8, a io.vertx.core.http.impl.ClientConnection),
  which is held by "vert.x-eventloop-thread-47"

Java stack information for the threads listed above:
===================================================
"vert.x-eventloop-thread-47":
	at io.vertx.core.http.impl.HttpClientRequestImpl.getLock(HttpClientRequestImpl.java:440)
	- waiting to lock <0x00000000da863a70> (a io.vertx.core.http.impl.HttpClientRequestImpl)
	at io.vertx.core.http.impl.HttpClientRequestBase.handleException(HttpClientRequestBase.java:106)
	at io.vertx.core.http.impl.HttpClientRequestImpl.handleException(HttpClientRequestImpl.java:50)
	at io.vertx.core.http.impl.ClientConnection.handleClosed(ClientConnection.java:410)
	- locked <0x00000000ff6253f8> (a io.vertx.core.http.impl.ClientConnection)
	at io.vertx.core.net.impl.VertxHandler$$Lambda$229/1136370131.run(Unknown Source)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:314)
	at io.vertx.core.impl.ContextImpl$$Lambda$9/868737467.run(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:190)
	at io.vertx.core.net.impl.VertxHandler.channelInactive(VertxHandler.java:97)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:234)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelInactive(CombinedChannelDuplexHandler.java:417)
	at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:360)
	at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:325)
	at io.netty.handler.codec.http.HttpClientCodec$Decoder.channelInactive(HttpClientCodec.java:256)
	at io.netty.channel.CombinedChannelDuplexHandler.channelInactive(CombinedChannelDuplexHandler.java:220)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:234)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1329)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:255)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:241)
	at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:908)
	at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:744)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:440)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
	at java.lang.Thread.run(Thread.java:745)
"vert.x-eventloop-thread-0":
	at io.vertx.core.net.impl.ConnectionBase.writeToChannel(ConnectionBase.java:113)
	- waiting to lock <0x00000000ff6253f8> (a io.vertx.core.http.impl.ClientConnection)
	at io.vertx.core.http.impl.ClientConnection.writeHeadWithContent(ClientConnection.java:476)
	at io.vertx.core.http.impl.HttpClientRequestImpl.writeHeadWithContent(HttpClientRequestImpl.java:700)
	at io.vertx.core.http.impl.HttpClientRequestImpl.connected(HttpClientRequestImpl.java:656)
	- locked <0x00000000da863a70> (a io.vertx.core.http.impl.HttpClientRequestImpl)
	at io.vertx.core.http.impl.HttpClientRequestImpl.access$100(HttpClientRequestImpl.java:50)
	at io.vertx.core.http.impl.HttpClientRequestImpl$2.handleStream(HttpClientRequestImpl.java:600)
	at io.vertx.core.http.impl.ConnectionManager$ConnQueue.deliverStream(ConnectionManager.java:258)
	at io.vertx.core.http.impl.ConnectionManager$ConnQueue.lambda$getConnection$0(ConnectionManager.java:218)
	at io.vertx.core.http.impl.ConnectionManager$ConnQueue$$Lambda$209/2008704175.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:316)
	at io.vertx.core.impl.ContextImpl$$Lambda$9/868737467.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:440)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
	at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.

my vertx version is 3.3.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When adding TrustOptions with a TrustManagerFactory, the factory is never instantiated by Vert.x despite the init method present.
Relevant forum thread here. Information here: https://groups.google.com/forum/#!topic/vertx/V25r0zc_wPc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Apologies - Was trying to get the 'signed-off' section in the commit message
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you have a look? The problem in CI is not related to fix, so I've implemented the test differently. Sorry for the round-trips.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@domhauton so looking at it, the TrustOptions should itself initialize the TrustManagerFactory in the getTrustManagerFactory method. That's what the other implementation do. For instance KeyStoreHelper#getTrustMgrFactory:
  public TrustManagerFactory getTrustMgrFactory(VertxInternal vertx) throws Exception {
    TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    KeyStore ts = loadStore(vertx);
    fact.init(ts);
    return fact;
  }

They should do it, because the TrustOptions implementation is supposed to have access to the KeyStore and can do it. The SSLHelper cannot.
I will update the documentation to mention that the returned factory is assumed to be initialized.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
this is more suggestion for new feature.
These days I was working with OpenShift (Kubernetes) and I noticed quite nice feature called named certificates. You can specify more key/cert pairs and they are used accordingly request target hostname (Server Name Indication, similar to virtual hosting).
This can be quite handy when one need to expose SSL service on multiple endpoints (for example behind multiple load balancers). Also this allows certificate composition instead of regenerating one with alternative subject name.
One key/cert pair should be considered as default and vertx should fall back to this one if request target hostname does not match to any other key/cert pair hostname.
Regards,
N.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Long road to test this :-)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I should have seen it too!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation
Future completion methods throw an IllegalStateException when the future is already completed. Vert.x itself does not rely on this behavior.
When a future might be completed several times (for instance a close or a timeout), Vert.x takes the necessary steps with the idiom, in order to propagate the event correctly.
if (!f.isComplete()) {
  f.complete();
}

This change allows to simplify the existing code and use complete the future directly and keep the ability to remain aware of whether the Future was actually completed by the method call or not.
Changes
Future completion returns a boolean indicating whether the Future was completed or not by the method call instead of throwing an exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

But you have to rebase first.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
It is actually possible to turn a Future<T> into an Handler<AsyncResult<T>> using Future#completer() method. This is actually the polyglot method to achieve it as AsyncResult<T> might not be mapped correctly sometimes (like in JS or Ruby).
The implementations of Future actually implements Handler<AsyncResult<T>> and return this in the completer() method.
When using java-ish languages like Java, Kotlin or Groovy, it should be possible to use directly the represented Future type directly as an Handler<AsyncResult>.
Resolution:
This patch makes Future<T> extend Handler<AsyncResult<T>> (in addition of AsyncResult<T>) and the handle(AsyncResult<T>) is annotated with @GenIgnore.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this method relies on this commit https://github.com/vert-x3/vertx-codegen/tree/tolerate-extend-handler-async-result
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Allows to write an expression:
return Future.future(f -> server.listen(8080, f));

instead of the three statements:
Future<Void> fut = Future.future();
server.listen(8080, fut);
return fut;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@rmelick can you review this PR ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
pom version:

io.vertx
vertx-core
3.3.3


io.vertx
vertx-dropwizard-metrics
3.3.3


io.vertx
vertx-auth-jwt
3.3.3

-------------function-------------
`private void handleHttpAppList(HttpServerRequest req, HttpServerResponse response) {
    String r = "{\"code\":0,\"data\":[{\"password\":\"xx\",\"mobile\":\"db\",\"nickname\":\"\",\"usertype\":\"app\",\"username\":\"db\"},{\"password\":\"xx\",\"mobile\":\"system\",\"nickname\":\"\",\"usertype\":\"app\",\"username\":\"system\"}]}";

    response.putHeader("Content-Length", "" + r.length());
    System.out.println("ResponseString:" + r);
    response.write(r);
    response.end();
}`

-------log on console----
ResponseString:{"code":0,"data":[{"password":"xx","mobile":"db","nickname":"","usertype":"app","username":"db"},{"password":"xx","mobile":"system","nickname":"","usertype":"app","username":"system"}]}
-------response on postman------
{"code":0,"data":[{"password":"xx","mobile":"db","nickname":"","usertype":"app","username":"db"},{"password":"xx","mobile":"system","nickname":"","usertype":"app","use
---------- problem description----
response.write(UrlEncoder.encode(r,"utf-8")),  no response data was truncated
otherwise, the data was truncated.
anyone can help on this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
a recent contribution added Future#recover(Function<Throwable, Future<T>) method, similar to the Future#compose(Function<T, Future<U>>).
compose has a synchronous version : Future#map(Function<T, U>) . Future#map(U), recover currently does not have one.
Changes:
added an orElse method that is the synchronous version of recover : orElse(Function<Throwable,T> / orElse(T). This method is added to AsyncResult and Future like map is.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
anyone for reviewing ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
currently the ServerWebSocket and HttpServerRequest close handlers are called under synchronized lock of the connection. This can create deadlocks in SockJSSocket because a SockJSSocket may uses different request/websocket (reconnects) and event loops.
Change:
when processing a Netty close event, call the close handlers in the next tick (i.e scheduled to run on context).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The JSON File from --conf should be read with the UTF-8 Charset (JSON default encoding) and not with the underlying platform's default charset.
In our case we have problems with Verticle's which we are deploying with a json config file (encoded in utf-8). Some characters are not decoded correctly because the default charset of the platform ist not utf-8.
A workaround is to set the default encoding via -Dfile.encoding to utf-8. But this could have other implications in existing code.
The Problem lies in the class io.vertx.core.impl.launcher.commands.RunCommand and possibly other locations.
The Scanner should use UTF-8 as default encoding. Perhaps you could add an option to specify the encoding along the --conf option too.
protected JsonObject getConfiguration() {
    JsonObject conf;
    if (config != null) {
      try (Scanner scanner = new Scanner(new File(config)).useDelimiter("\\A")) {
        String sconf = scanner.next();
        try {
          conf = new JsonObject(sconf);
        } catch (DecodeException e) {
          log.error("Configuration file " + sconf + " does not contain a valid JSON object");
          return null;
        }
      } catch (FileNotFoundException e) {
        try {
          conf = new JsonObject(config);
        } catch (DecodeException e2) {
          // The configuration is not printed for security purpose, it can contain sensitive data.
          log.error("The -conf option does not point to an existing file or is not a valid JSON object");
          e2.printStackTrace();
          return null;
        }
      }
    } else {
      conf = null;
    }
    return conf;
 }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
not really needed there is no performance issue here
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
resubmitted as #1839
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
currently the HttpServerResponse#closeHandler is called only if the response is closed abruptly for HTTP/1 and is called whenever the corresponding stream closes for HTTP/2. The behavior is not consistent and also it seems that a new endHandler that will be always called to allow cleanup after the response is disposed in a consistent manner.
Changes:
A new response end handler is added and it is called whenever the current HttpServerResponse becomes unused, wether it is on purpose (i.e calling response end() method) or because the transport (connection for HTTP/1.x and stream for HTTP/2) is closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
If you create a HttpClient with the maxWaitQueueSize set to a positive number,
and then
if the wait queue fills up, (poolSize for the HttpClient is also a fixed number)
and then
if, subsequently, one or more of the HttpClientRequests being executed in the pool time-out, owing to no response from the server after their set timeout value, I see a strange behavior that all subsequent requests will receive a "Connection pool reached max wait queue size"
Here is a small standalone reproducer:
https://github.com/kpachar/other-issues
Thanks..
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
or anyone else can review too :-)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you have a look? When we're fine with the changes, I'll update the other cluster managers as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In certain network configuration, the DNS server can be located remotely. Therefore, it might be susceptible to a packet drop. When that happens, AddressResolver seems to fail to resolve the DNS name. I would prefer that we have some DNS retry mechanism rather than letting the request fails.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Netty 4.1.X, https://netty.io/4.1/api/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.html is added so that it can perform the load balancing more properly. It would be nice if we have a mechanism to plug in a different implementation into Vert.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public PrivateKey loadPrivateKey() throws Exception { if (keyValue == null) { throw new RuntimeException("Missing private key path"); } byte[] value = loadPems(keyValue.get(), "**PRIVATE KEY**").get(0); KeyFactory rsaKeyFactory = KeyFactory.getInstance("RSA"); return rsaKeyFactory.generatePrivate(new PKCS8EncodedKeySpec(value)); }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
A few synthetic type extending WriteStream have been introduced because code generation only supported type variables as type argument declarations. Since 3.4 we removed that limitation and now we can remove these useless types: PacketWriteStream so far.
Change:
Removal of io.vertx.core.datagram.PacketWriteStream
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
currently the dns resolver is configured to use the first server from the list and the others for failover. By using instead a rotational server list we can provide round robin.
Changes:
provide configuration to configure the dns server list to be rotational for dns server selection
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation:
currently the default number of dns max queries is 3. By default the resolver will send 2 queries : A and AAA. When the server does not respond, there is one query left and in case of failover, only the A query is sent. Increasing the value to 4 allow to send A and AAA when failover occurs.
Change:
The default number of max queries is 4 instead of 3.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think there are different cases for RoundRobin. RoundRobinDnsAddressResolverGroup actually returns different ip addresses in a round robin fashion if multiple IN A record exists. AFAIK, Your implementation seems to pick a different DNS servers in a round robin fashion instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On Oracle JVM, I think it is much simpler to use sun.net.dns.ResolverConfiguration to find the DNS configuration. Look at http://dnsjava.org/dnsjava-current/org/xbill/DNS/ResolverConfig.java for an example.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation: timers are scheduled by the event loop and executed on its context, during the time between a timer callback is scheduled and its actual execution, the timer cannot be cancelled although it could still be. Such situation can happen easily with worker contexts where timer tasks can be delayed due to blocking.
change: uses an atomic boolean cancelled to allow a timer to be cancelled when it has been scheduled for execution on the context. The atomic boolean guarantees the visibility across threads and also the timer can be marked as cancelled once.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think it would be quite valuable to support an overloaded method for the EventBus consumer to allow specifying the type of the message:
EventBus eb = vertx.eventBus();
eb.consumer(address, Type<? extends Serializable>, handler);

This would allow for type-safe message handling and allow for matching different consumers to different types. I'll try to look into what it would take to make this possible. It obviously wouldn't easily apply to some of the dynamic languages though...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the length of the buffer does not match the initialized size.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From David Klotz on the forum
Hi, 

I'm currently a bit confused by the differing behavior of event bus interceptors in a non-clustered and a clustered vert.x environment (currently on 3.2.1, can test again in 3.4.x if something in that area has changed since then). When run in a non-clustered environment, the interceptor has access to both the message body and the message headers, but when run in a clustered environment, the message body is always null. Is this behavior by design or a bug?

Cheers, 
David
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the new version 3.4.1, I get the following exception when I send an email through an non-shared client and a AWS SES server:
java.lang.NullPointerException
io.vertx.core.net.impl.NetClientImpl$1.handleMsgReceived(NetClientImpl.java:197)
io.vertx.core.net.impl.VertxNetHandler.lambda$channelRead$0(VertxNetHandler.java:64)
io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:335)
io.vertx.core.impl.TaskQueue.lambda$new$0(TaskQueue.java:60)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
java.lang.Thread.run(Thread.java:745)

I think the problem is this: in the line 197 of NetClientImpl, the attribute conn can be null because of the method removeConnection has been called in the VertxNetHandler, so it causes a null pointer exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you have a look again? I've reverted the ClusteredMessage#body changes and added SendContext#sentMessage
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, Ive seen during my tests, that if I send a HTTP request that is timed out, and after that I send another one which gets a response, and then the connection on the server side is closed  then the first request (the one that timed out) calls its exceptionHandler with a VertxException with a message Connection was closed.
EDIT: I am seeing this behaviour with Vert.x 3.4.1.
At first I thought that it is due to the client trying to keepAlive its connections and reacts with an exception when closed from outside   but then the exception should rather be thrown on the vertx object itself, not on a request that supposedly finished time ago. And then it seems it does not matter if I set setKeepAlive(true) or setKeepAlive(false).
Here is a gist with a test replicating this behaviour.
And here is a log I get from that test:
11:38:52.629 [vert.x-eventloop-thread-0] INFO  VertxHttpClientTimeoutTest - Sending request 0.
11:38:52.965 [vert.x-eventloop-thread-0] INFO  VertxHttpClientTimeoutTest - Exception thrown for request 0.
java.util.concurrent.TimeoutException: The timeout period of 300ms has been exceeded while executing GET /test for host localhost
	at io.vertx.core.http.impl.HttpClientRequestBase.timeout(HttpClientRequestBase.java:183) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.http.impl.HttpClientRequestBase.handleTimeout(HttpClientRequestBase.java:168) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.http.impl.HttpClientRequestBase.lambda$setTimeout$0(HttpClientRequestBase.java:126) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.impl.VertxImpl$InternalTimerHandler.handle(VertxImpl.java:803) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.impl.VertxImpl$InternalTimerHandler.handle(VertxImpl.java:774) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337) ~[vertx-core-3.4.1.jar:?]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]
11:38:52.971 [vert.x-eventloop-thread-0] INFO  VertxHttpClientTimeoutTest - Sending request 1.
11:38:52.982 [vert.x-eventloop-thread-0] INFO  VertxHttpClientTimeoutTest - Received response, status: 200, msg: OK, headers: [X-Req-Num=1, Content-Length=0]
11:38:53.015 [vert.x-eventloop-thread-0] INFO  VertxHttpClientTimeoutTest - Exception thrown for request 0.
io.vertx.core.VertxException: Connection was closed
	at io.vertx.core.http.impl.ClientConnection.handleClosed(ClientConnection.java:408) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:335) ~[vertx-core-3.4.1.jar:?]
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:193) [vertx-core-3.4.1.jar:?]
	at io.vertx.core.net.impl.VertxHandler.channelInactive(VertxHandler.java:97) [vertx-core-3.4.1.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:232) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:225) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelInactive(CombinedChannelDuplexHandler.java:417) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:360) [netty-codec-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:325) [netty-codec-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.handler.codec.http.HttpClientCodec$Decoder.channelInactive(HttpClientCodec.java:256) [netty-codec-http-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.CombinedChannelDuplexHandler.channelInactive(CombinedChannelDuplexHandler.java:220) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:232) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:225) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1329) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:232) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:908) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:744) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445) [netty-transport-4.1.8.Final.jar:4.1.8.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) [netty-common-4.1.8.Final.jar:4.1.8.Final]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]

Also, if I comment out the 66th line in the gist (closing the HttpServer), and I close HttpClient on line 101 instead, the same issue appears.
I would expect that if the request has already timed out, it is closed and wont call its exception nor response handlers anymore. Am I doing something wrong, understanding something wrong, or is it a bug?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since https://vertx.ci.cloudbees.com/job/vert.x3-core/5477/
java.lang.NullPointerException: null
	at io.vertx.test.core.FutureTest.testCreateFailedWithNullFailure(FutureTest.java:242)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have 1 Verticle which receives HttpRequests. This Verticle sends the data on to a processing verticle which in itself sends it on to a processing verticle  and so on untill all processing is done. At the end I would like to to send a response...
And this is my problem: I cannot send the RoutingContext or the HttpResponse over the EventBus to the next Verticles otherwise I will loose the Vert.X Clustering capabilities since that object is not serializable.
I tried saving the same object to a Apache Ignite Cache with the same result.
In the beginning I had an architecture which involved Orchestrator Objects in order to reply and so always return to the original Rest Verticle, but this is not scalable as I would like.
Any information on such a possibility would be appreciated.
Tim fox wrote in an older response to a similar question the following

You could serialize it to a byte[] and deserialize it at the other end. Vert.x 3.0 supports custom serializers on the event bus, so you could create one for HttpServerRequest.

I would very much like to know how to do this as I am unsuccessful to do this.
Thank you in advance
Yoav
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what format is that :-) !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Clustered vertx, core i7.
The test is about send and reply between verticles and then measure rate.
The test has a bunch of eventloop verticles doing send to a bunch of worker/eventloop consumer verticles. When the senders receive a reply they send again (a kind of async/reactive busy loop)
The observed behavior is that i can never increase the CPU usage to more than 50%. I doubled the number of eventloop pool size and no effect.
Reproducer can be found here: https://github.com/mhstnsc/vertx-tests
Exact test is here: https://github.com/mhstnsc/vertx-tests/blob/master/src/test/java/io/vertx/test/performance/EventBusTest.java
You can run it with:
gradle :test --tests io.vertx.test.performance.EventBusTest.testWorkerConsumer -i
As a control test you can run another test which can load the CPU 100% by doing md5 computations in 200 worker verticles (can also be event loop verticles)
gradle :test --tests io.vertx.test.performance.EventBusTest.testMaxCpuLoad -i
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi all
I am trying to generate a service proxy but it does not work at all.
The code does not get generated.
You can find the project on the attachment.  Please help me.
microservice1.zip
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My primary use case here is that the default way that Jackson serializes/deserializes java.time.Instant is as a BigDecimal for the seconds since epoch plus nanos (or whatever the most accurate clock time it can convert to). Thus, when I try to use JsonObject normally, I can't deserialize what was serialized before without disabling the timestamp as nanos options in Jackson ahead of time.
Adding a gamut of methods like getBigInteger(String) et al. would be useful, too, but I think this would be more appropriately implemented via better dynamic conversion so that, for example, calling json.getBigDecimal("foo") would still work if the foo field was stored as a Double instead. Similarly, calling json.getDouble("foo") would likely call Number::doubleValue or similar to do an auto conversion.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Given a simple test class:
import io.vertx.core.Future;

public class Foo {
    public static void main(String... args) throws Exception {
        Future<Void> fut1 = Future.future();
        attach(fut1, "fut1");
        fut1.complete();

        Future<Void> fut2 = Future.succeededFuture();
        attach(fut2, "fut2");
    }

    private static void attach(Future<Void> fut, String name) {
        fut.setHandler(h1 -> System.out.println(name + " completed h1"));
        fut.setHandler(h2 -> System.out.println(name + " completed h2"));
    }
}
The output is:
fut1 completed h2
fut2 completed h1
fut2 completed h2

Thus, if you call setHandler() multiple times for any reason, directly or indirectly, you can't be sure of whether one or more of the given handlers will be called unless you know for sure when the future will get completed.
In order to not encourage writing code with potentially unpredictable behaviour, I can think of at least the following potential changes to the Future interface:

Allow calling setHandler() just once, throwing IllegalStateException on successive calls.
Replace setHandler() with addHandler() which would allow multiple listeners of a single future. All  map(), compose() etc metods would also start using the new method instead of the old.

What do you think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I create a JsonArray like this:
JsonArray array = new JsonArray(Arrays.asList(new MySuperClass()));
and send this via Event Bus I get java.lang.IllegalStateException: Illegal type in JsonObject: MySuperClass
Here is a part of stacktrace:
at io.vertx.core.json.Json.checkAndCopy(Json.java:125) at io.vertx.core.json.JsonArray.copy(JsonArray.java:561) at io.vertx.core.json.Json.checkAndCopy(Json.java:106) at io.vertx.core.json.JsonObject.copy(JsonObject.java:778) at io.vertx.core.eventbus.impl.codecs.JsonObjectMessageCodec.transform(JsonObjectMessageCodec.java:49) at io.vertx.core.eventbus.impl.codecs.JsonObjectMessageCodec.transform(JsonObjectMessageCodec.java:27) at io.vertx.core.eventbus.impl.MessageImpl.<init>(MessageImpl.java:75) at io.vertx.core.eventbus.impl.MessageImpl.copyBeforeReceive(MessageImpl.java:81) at io.vertx.core.eventbus.impl.EventBusImpl.deliverToHandler(EventBusImpl.java:494) at io.vertx.core.eventbus.impl.EventBusImpl.deliverMessageLocally(EventBusImpl.java:370) at io.vertx.core.eventbus.impl.EventBusImpl.deliverMessageLocally(EventBusImpl.java:347) at io.vertx.core.eventbus.impl.EventBusImpl.sendOrPub(EventBusImpl.java:320) at io.vertx.core.eventbus.impl.EventBusImpl$SendContextImpl.next(EventBusImpl.java:450) at io.vertx.core.eventbus.impl.EventBusImpl.sendOrPubInternal(EventBusImpl.java:418) at io.vertx.core.eventbus.impl.EventBusImpl.send(EventBusImpl.java:94) at io.vertx.core.eventbus.impl.EventBusImpl.send(EventBusImpl.java:89)
I think JsonArray class can either check type of elements in the list or perform JsonObject.mapFrom() automatically under the hood.
BTW it's not reproducible in Clustered Event Bus
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm working on a project, where I have two Vert.x applications which communicate with each other using REST. In one application I'm running an HttpServer and in the other an HttpClient, which connects directly using HTTP/2. When the server crashes, there is an unhandled "an existing connection was closed by the remote host" exception in the client, but the connection does not seem to get removed from the Http2Pool. Thus when the client application tries to make another request, the request.end() method succeeds without any exception and the client application never gets a response or an exception.
I'm using Vert.x 3.4.1 and JDK 8 Update 121.
I have created two demo Maven projects that can be used to reproduce the problem:
VertxHttpClientProblem.zip
Here is the procedure:

Run the server using: java -jar http-server-0.1-SNAPSHOT-combined.jar
Run the client using: java -jar http-client-0.1-SNAPSHOT-combined.jar
Press enter in the client to make the first request.
Stop the server process using Ctrl+C
Press enter in the client process again to make another request (for which no response is received and no exception is thrown).

The code of the demo applications is also here:
HttpServerTest.java:
package test.http.server;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class HttpServerTest extends AbstractVerticle {
	
	public static void main(String[] args) {
		Vertx vertx = Vertx.vertx();
		vertx.deployVerticle(new HttpServerTest());
	}
	
	@Override
	public void start() {
		Router router = Router.router(vertx);
		router.route().handler(BodyHandler.create());
		router.post("/echo").handler(routingContext -> {
			String text = routingContext.getBodyAsString();
			System.out.println("Received: " + text);
			routingContext.response().end(text);
		});
		
		HttpServerOptions serverOptions = new HttpServerOptions();
		serverOptions.setCompressionSupported(true);
		serverOptions.setTcpKeepAlive(true);
		vertx.createHttpServer(serverOptions).requestHandler(router::accept).listen(8080, result -> {
			if (result.succeeded()) {
				System.out.println("HttpServer listening.");
			} else {
				System.out.println("Error starting HttpServer.");
			}
		});
		
	}
}

HttpClientTest.java:
package test.http.client;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpVersion;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.concurrent.Semaphore;

public class HttpClientTest extends AbstractVerticle {
	
	// The HttpClient for the requests.
	private HttpClient httpClient;
	
	// Used only to signal the read console loop on the main thread when to continue.
	private Semaphore semContinue = new Semaphore(0);
	
	public static void main(String[] args) throws IOException, InterruptedException {
		Vertx vertx = Vertx.vertx();
		HttpClientTest verticle = new HttpClientTest();
		vertx.deployVerticle(verticle);
		
		BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			verticle.semContinue.acquire();
			System.out.println("Press enter to make a new HTTP request.");
			input.readLine();
			verticle.context.runOnContext(verticle::makeRequest);
		}
	}
	
	@Override
	public void start() {
		HttpClientOptions clientOptions = new HttpClientOptions();
		clientOptions.setTryUseCompression(true);
		// We use HTTP/2 directly.
		clientOptions.setProtocolVersion(HttpVersion.HTTP_2);
		clientOptions.setHttp2ClearTextUpgrade(false);
		this.httpClient = this.vertx.createHttpClient(clientOptions);
		this.semContinue.release();
	}
	
	private void makeRequest(Void v) {
		HttpClientRequest request = this.httpClient.post(8080, "localhost", "/echo", response -> {
			response.bodyHandler(fullBuffer ->{
				System.out.println("Response: " + fullBuffer.toString());
			});
		});
		request.exceptionHandler(error -> {
			System.out.println(error.toString());
		});
		request.end("Test");
		System.out.println("Request: Test");
		this.semContinue.release();
	}
}

I've tried to debug the client application stepping into the Vert.x code and found out that an infinite loop seems to be created when a new request is made after the server has crashed. ConnectionManager.deliverStream(conn, waiter) calls Http2Pool.createStream(conn), which throws an exception because DefaultHttp2Connection.isClosed() returns true. Thus deliverStream() calls getConnection(waiter), which results in ConnectionManager.deliverStream(conn, waiter) to be added to the context's queue again.
Best regards,
Thomas
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I wonder what's the benefit of using custom Buffer implementation as opposite to default Java's of netty's?
On a first sight seems a bit ineffective as there already many wrappers around exiting wrappers - to deserialise objects etc in many popular libraries. Very often there is a need to convert it to string or use getBytes which is coping operation. Seems like initialisation of BufferImpl itself requires copying.
Is that all really necessary?
I might miss a bigger picture, if I am wrong I apologise in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SelfSignedCertificate is always generated with the "example.com" domain name which is not very useful if we use it in tests where both server and clients are on the "localhost". Hence, unless we provide an option to the HttpClient - setVerifyHost(false) - the client cannot talk to the server using this generated certificate.
I suggest to override the create method in SelfSignedCertificate with domain name as the parameter and pass this FQDN to the underlying Netty implementation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@geh-es can you add a unit test ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could perhaps also have a separate andFinally(Runnable handler) that has no async and no result-modifying capacity for simple cases..
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using vertx for a small web service that should run without disk write access.
Sadly vertx insists in having a writeable cache directory though I set "vertx.disableFileCaching=true":
java.lang.IllegalStateException: Failed to create cache dir
at io.vertx.core.impl.FileResolver.setupCacheDir(FileResolver.java:293)
at io.vertx.core.impl.FileResolver.(FileResolver.java:86)
at io.vertx.core.impl.VertxImpl.(VertxImpl.java:175)
at io.vertx.core.impl.VertxImpl.(VertxImpl.java:142)
at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:42)
at io.vertx.core.Vertx.vertx(Vertx.java:90)
at com.sipgate.litc.HealthService.start(HealthService.java:18)
at com.sipgate.litc.Main.main(Main.java:20)
I had a quick look at FileResolver.java and would expect any cacheFile handling to be skipped when ENABLE_CACHING is false, but as far as I understand the code, the public interface of at least FileResolver would have to change.
Before digging deeper into the code and developing a patch, I would like to know if changing the behaviour to match what I expect, is appreciated.
Do I miss something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I was playing with the fiberHandler example in vertx and I noticed that if two messages are sent on the eventBus (different address, same eventBus) in the same request, then the output is what I would expect it to be from two request.
For example, in this case:
EventBus eb = vertx.eventBus();
    eb.consumer(ADDRESS1).handler(msg -> {
      System.out.println("Waiting");
      // reply after one second
      vertx.setTimer(1000, tid -> msg.reply("wibble"));
    });

    eb.consumer(ADDRESS2).handler(msg -> {
      System.out.println("Waiting");
      // reply after one second
      vertx.setTimer(1000, tid -> msg.reply("wibble"));
    });

    // If you want to do sync stuff in an async handler it must be transformed to a fiber handler
    vertx.createHttpServer().requestHandler(fiberHandler(req -> {

      // Send a message to address and wait for a reply
      Message<String> reply1 = awaitResult(h -> eb.send(ADDRESS1, "blah", h));
      Message<String> reply2 = awaitResult(h -> eb.send(ADDRESS2, "blah", h));

      System.out.println("Got reply: " + reply1.body());
      System.out.println("Got reply: " + reply2.body());

      req.response().end("blah");

    })).listen(8080, "localhost");

The output is
Waiting
Waiting
Got reply: wibble
Got reply: wibble
Waiting
Waiting
Got reply: wibble
Got reply: wibble

but I was expecting
Waiting
Waiting
Got reply: wibble
Got reply: wibble

In general with N sender and N consumer the behaviour seems unpredictable. Not sure if a bug or I'm misusing the constructs awaitResult/fiberHandler.
Any elucidation on the matter will be appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I created another pull request as following to replace this one since it is not signed off
#1934
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@chengenzhao thanks for the PR
Actually, the Asciidoc file is generated from /src/main/java/io/vertx/core/package-info.java. See the How is managed vert.x documentation wiki page for details on the process.
Can you please update this file and then run mvn clean install -DskipTests to generate Asciidoc again ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
looks good, but I think the test should add two different headers value, to make sure the second value overwrites the first one
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have run into the following issue in the past before using Vert.x and now that I am using it as well. I really like the functionality that a Worker Context provides: A separate thread that runs tasks in the order they were submitted to the context to be executed. However this functionality could be even more helpful if the Worker Context would allow the submission of tasks to be executed in order in different queues based on some (defined?arbitrary?) identifier/priority. For example, I have the need to "serialize" the execution of tasks but tasks which have different priorities could be executed in parallel but I still need the "serialization" feature for tasks of the same priority.
Thanks - Juan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Starting test: Http1xTest#testCloseTheConnectionAfterResetBeforePipelinedResponseReceived 
io.vertx.core.VertxException: Connection was closed
java.lang.IllegalStateException: Timed out in waiting for test complete
	at io.vertx.test.core.AsyncTestBase.await(AsyncTestBase.java:131)
	at io.vertx.test.core.AsyncTestBase.await(AsyncTestBase.java:119)
	at io.vertx.test.core.Http1xTest.testCloseTheConnectionAfterResetBeforeResponseReceived(Http1xTest.java:3313)
	at io.vertx.test.core.Http1xTest.testCloseTheConnectionAfterResetBeforePipelinedResponseReceived(Http1xTest.java:3218)

I can reproduce on my machine with @Repeat
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx.deploymentIDs() not updated after vertx.undeploy(verticle)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When sending a vertx.eventBus().send message on a local event bus I am seeing a timeout failure on the reply handler of the vertx.eventBus().consumer Message<T> requestMessage.reply  for successfully replied messages. My consumer code looks something like this.
vertx.eventBus().consumer( address )
				.handler( this::reply );

void reply( Message<SomeObject> requestMessage ) {
	requestMessage.<SomeObject> reply( service.someRequest( requestMessage),
					result -> {
						// result.succeeded() == false
					} 
       );
}

I have had a quick look at HandlerRegistration and see this line of code in the constructor which starts a timed task to call the reply handler with a failure.
 if (timeout != -1) {
      timeoutID = vertx.setTimer(timeout, tid -> {
        metrics.replyFailure(address, ReplyFailure.TIMEOUT);
        sendAsyncResultFailure(ReplyFailure.TIMEOUT, "Timed out after waiting " + timeout + "(ms) for a reply. address: " + address);
      });
    }

This timed task is however stopped by EventBusImpl.deliverMessageLocally that invokes HandlerRegistration.doUnregister which then invokes
if (timeoutID != -1) {
      vertx.cancelTimer(timeoutID);
    }

that should cancel the timed task when successfully replied to.
Since send reply only selects at most one handler I am a bit confused why this is happening? Can anyone with greater knowledge of the EventBus internals explain why this is happening?
Note my vertx.eventBus().send command is one a different Verticle to my vertx.eventBus().consumer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I'm trying to create a WebSocketServer using vertx-rx-java 3.4.1, but I'm facing an issue in my JUnit test.
I created a unit test which sends and receives a message, then closes the client and completes the Async, but still the test does not finish.
I tried to solve it, but after some hours work I just can't find the mistake.
I created a GitHub repo where you can reproduce the test.
https://github.com/RobWin/messaging-proxy
Maybe the log output can help you:
2017-04-13 16:47:49 [main] INFO  c.q.b.messaging.MainVerticleTest - Start Vertx
2017-04-13 16:47:49 [vert.x-eventloop-thread-0] INFO  c.q.backend.messaging.MainVerticle - HttpServer is listening on port 8080
2017-04-13 16:47:49 [vert.x-eventloop-thread-0] INFO  c.q.backend.messaging.MainVerticle - Handle ServerWebSocket
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] INFO  c.q.b.messaging.MainVerticleTest - WebSocket client connected
2017-04-13 16:47:49 [vert.x-eventloop-thread-0] INFO  c.q.backend.messaging.MainVerticle - Message received from client: Hello from client
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] WARN  c.q.b.messaging.MainVerticleTest - Message received from server: Hello world from server
2017-04-13 16:47:49 [vert.x-eventloop-thread-0] INFO  c.q.backend.messaging.MainVerticle - WebSocket closed by client
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] INFO  c.q.b.messaging.MainVerticleTest - WebSocket closed
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] INFO  c.q.b.messaging.MainVerticleTest - Async completed
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] INFO  c.q.b.messaging.MainVerticleTest - Async count 1
2017-04-13 16:47:49 [vert.x-eventloop-thread-1] INFO  c.q.b.messaging.MainVerticleTest - Async count 0

As you can see, the tearDown method is not invoked.
Kind regards,
Robert Winkler
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the latest version of vertx-auth-mongo, an MongoUser object could be something like this:
{"_id":"admin.root","user":"root","db":"admin","credentials":{"SCRAM-SHA-1":{"iterationCount":10000,"salt":"+HmC/o5CWNZtJkMkIYdzcw==","storedKey":"nLfofTgM/THsB8raY7308ilMw+8=","serverKey":"HHQ2IgOcWQIKapoT+0KUDu8zbPM="}},"customData":{"user":"xxx"},"roles":[{"role":"root","db":"admin"}]}
While the method, examinePassword of class MongoAuthImpl, retrieves the encrypted password from a given key ,which assumes it were a String value mapped by that key, but a JsonObject actually.
So i wonder if it supports the  "SCRAM-SHA-1" or "MONGODB-CR" authentication?
It would be better if theres some sample code~
Thx!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ref: https://docs.mongodb.com/manual/reference/mongodb-extended-json/#numberlong
JsonObjectCodec.java  still not support "$numberLong",
when document is
{
  "_id" : "32034ffb-9ab8-4dce-bf95-591053bd53d4",
  "_seqCounter" : {
    "$numberLong" : "7279"
  },

}
That write to MongoDB, it throws java.lang.IllegalArgumentException: Invalid BSON field name $numberLong
But  if I change to
{
 "_id" : "32034ffb-9ab8-4dce-bf95-591053bd53d4",
 "_seqCounter" :  7279

}
That would be stored as BsonType.INT32 not the BsonType.INT64 which my data is Long type !
Note: There is new type $numberDecimal (https://docs.mongodb.com/manual/core/shell-types/#numberdecimal)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I am trying to use the http client in order to access several restful apis through my proxy.
Some of the api providers use https  and some http, therefore I configured the http client to use ssl.
When doing so, the proxy settings is completely ignored when attempting to connect to a non https api.
The following is a simple reproducer:
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.net.ProxyOptions;

public class Reproducor {
    public static void main(String[] args) {
        Vertx v = Vertx.vertx();
        HttpClient c = v.createHttpClient(new HttpClientOptions()
                .setProxyOptions(new ProxyOptions()
                        .setHost("aaaaa")
                        .setPort(5555))
                .setSsl(true));
        c.requestAbs(HttpMethod.GET, "http://ifconfig.co/ip", response -> {
            response.bodyHandler(body -> {
                String str = body.getString(0, body.length());
                System.out.println(str);
            });
        }).end();

    }
}
My expectations was that this reproducer will fail sending the request as the given proxy does not exists. Instead, it works and return my machine ip (which defeat the point of configuring a proxy on the http client)
If I am not configuring the http client with isSsl = true then all the requests to the https-apis are failing with "not an ssl/tls frame" related exceptions
Am I missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
actually resolved
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A code like this not works

But this works.

Anyone can help me?
Thanks.
I am using fiddler to capture this traffic and my vertx version is 3.2.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When we publish an HTTPEndPoint record, we pass an argument named as root. This root is not accessed when we getRecord.
Publishing record:
ServiceDiscovery discovery = ServiceDiscovery.create(vertx, new ServiceDiscoveryOptions()
        .setBackendConfiguration(
                new JsonObject()
                        .put("host", "127.0.0.1")
                        .put("key", "record")
        ));
discovery.publish(HttpEndpoint.createRecord(
        "users",
        "localhost", HTTP_PORT,
        "/v1/api/"),
        ar -> {
            if (ar.succeeded()) {
                System.out.println("Tweets API published");
            } else {
                System.out.println("Unable to publish the Tweets API: " +
                        ar.cause().getMessage());
            }
        });
Getting Record:
HttpEndpoint.getClient(serviceDiscovery, new JsonObject().put("name", "users"), record -> {
                        if(!record.failed()){
                            HttpClient client = record.result();
                            client.get("/v1/api/users", response ->{
                                response.bodyHandler(body -> operation.complete(body.toString()));
                            }).exceptionHandler(operation::fail)
                                    .end();
                        }
                    });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I find that AsyncMap supports TTL, but LocalMap does not support.
Will LocalMap plan to support this feature as AsyncMap?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please add tags to repository, for example: distributed-systems, concurrency , high-performance .
It makes project more popular )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi I new developer in vertx, I develop in Ruby.
I trying to make a social login (facebook and twitter) also try with github but this works.

Facebook:
Code:

# create an OAuth2 provider, clientID and clientSecret should be requested to github
    authProvider = VertxAuthOauth2::FacebookAuth.create(vertx, "xxxxxx", "xxxxxx")

# create a oauth2 handler on our running server
# the second argument is the full url to the callback as you entered in your provider management console.
    oauth2 = VertxWeb::OAuth2AuthHandler.create(authProvider, "http://localhost:8080/callback/facebook")

# setup the callback handler for receiving the GitHub callback
    oauth2.setup_callback(router.route())

# protect everything under /protected
    router.route("/protected/facebook/*").handler(&oauth2.method(:handle))
# mount some handler under the protected zone
    router.route("/protected/facebook/somepage").handler() { |rc|
      rc.response().end("Welcome to the protected resource!")
    }

    router.route("/callback/facebook").handler do |rc|
      puts 'HIII'
      rc.response.end('EEEEE')
    end

Error:
abr 19, 2017 3:14:58 PM io.vertx.ext.web.impl.RoutingContextImplBase
GRAVE: Unexpected exception in route
java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to java.lang.CharSequence
	at io.vertx.core.json.JsonObject.getString(JsonObject.java:108)
	at io.vertx.ext.auth.oauth2.impl.OAuth2API.handleToken(OAuth2API.java:248)
	at io.vertx.ext.auth.oauth2.impl.OAuth2API.lambda$null$1(OAuth2API.java:217)
	at io.vertx.core.http.impl.HttpClientResponseImpl$BodyHandler.notifyHandler(HttpClientResponseImpl.java:301)
	at io.vertx.core.http.impl.HttpClientResponseImpl.lambda$bodyHandler$0(HttpClientResponseImpl.java:193)
	at io.vertx.core.http.impl.HttpClientResponseImpl.handleEnd(HttpClientResponseImpl.java:257)
	at io.vertx.core.http.impl.ClientConnection.handleResponseEnd(ClientConnection.java:361)
	at io.vertx.core.http.impl.ClientHandler.doMessageReceived(ClientHandler.java:80)
	at io.vertx.core.http.impl.ClientHandler.doMessageReceived(ClientHandler.java:38)
	at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$0(VertxHttpHandler.java:71)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:335)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:193)
	at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:71)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:122)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:435)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:267)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:250)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1228)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1039)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:745)


Twitter:
Code:

# create an OAuth2 provider, clientID and clientSecret should be requested to github
    authProvider = VertxAuthOauth2::TwitterAuth.create(vertx, "xxxxx", "xxxxx")

# create a oauth2 handler on our running server
# the second argument is the full url to the callback as you entered in your provider management console.
    oauth2 = VertxWeb::OAuth2AuthHandler.create(authProvider, "http://localhost:8080/callback/twitter")

# setup the callback handler for receiving the GitHub callback
    oauth2.setup_callback(router.route())

# protect everything under /protected
    router.route("/protected/twitter/*").handler(&oauth2.method(:handle))
# mount some handler under the protected zone
    router.route("/protected/twitter/somepage").handler() { |rc|
      rc.response().end("Welcome to the protected resource!")
    }

Error:
Whoa there!
There is no request token for this page. That's the special key we need from applications asking to use your Twitter account. Please go back to the site or application that sent you here and try again; it was probably just a mistake.

Thanks in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using code similar to example. And IndexOutOfBoundsException was observed. After debugging for a while I found a reason of the problem.
In proxy code we have something like:
public void processRequest(HttpServerRequest request) {
  HttpClientRequest destRequest = ...
  request.handler(destRequest::write);
  ...
}
In file HttpClientRequestImpl there is a code:
void write(ByteBuf buf, boolean end) {
  ...
  CompositeByteBuf pending;
  ...
  pending.addComponent(buff).writerIndex(pending.writerIndex() + buff.writerIndex());
  ...
}
And if buff has readerIndex not equal to 0 then call to writerIndex fails with reasonable IndexOutOfBoundsException.
Current workaround is using Buffer.slice() before passing buffer read by http server to http client. But I think that buffers with non 0 readerIndex should be handled properly by HttpClientRequestImpl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice to have a Vertx#deployVerticle(C<? extends Verticle, ...) so one can deploy a class without using classloading
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice to have a Vertx#deployVerticle(Supplier<Verticle>, ...) pretty much like Vertx#deployVerticle(Verticle,...) but that is able to handle multiple instances
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like to nest Vert.x Web Client in Vertx-web and get the results.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If one has setup HttpClient to use http proxy and tries to request FTP resource via it then proxy requests HTTP resource. So the code
HttpClient client = vertx.createHttpClient(new HttpClientOptions().setProxyOptions(...));
client.getAbs("ftp://ftp.example.com/file");
sends following HTTP request to the proxy:
GET http://ftp.example.org/file HTTP/1.1
Host: ftp.example.org


But uri should be ftp://ftp.example.org/file.
From code I can see that http scheme is hardcoded.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the Eclipse CA ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@alexlehm the changes look good to me. However I wonder if we shouldn't update the web-client code as well (there is code there similar to what's in HttpClientImpl.java to determine the actual port)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using vertx 3.4.1 see my thread here: https://groups.google.com/forum/?fromgroups=#!topic/vertx/fjlsWFqMiJk
I looked around: https://github.com/eclipse/vert.x/blob/65a1050b0922de38329cdbe90c5ecd8094a93a04/src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
If I understand it correctly...
If --redeploy then initializeRedeployment() which calls startAsBackgroundApplication
There's a check here
if (systemProperties != null) {
      args.addAll(systemProperties.stream().map(s -> "-D" + s).collect(Collectors.toList()));
    }

But It seems that the properties are null at this point...
Calling System.getProperties().list(System.out); in our own verticle the passed in -D properties are gone only the java one show up. Removing --redeploy everything works as expected.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, can support for these modules be added or at least the Date/Time one?
https://github.com/FasterXML/jackson-modules-java8
When using Json.decodeValue(someString, SomePojo.class) or someJsonObject.mapTo(SomePojo.class) and we have Java 8 Instant type we get an exception.
See here: https://groups.google.com/forum/?fromgroups#!searchin/vertx/Instant%7Csort:relevance/vertx/uKeiQLMOR3I/FZApiU37AwAJ
JsonObject has getInstant() but that does a direct mapping with return new Instant(someDateString);
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/1999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
when validating equality of two instances of HttpServerOptions, if PemTrustOptions with the same values are added to both instances, the assert fails in /io/vertx/core/net/TCPSSLOptions.java at
    if (trustOptions != null ? !trustOptions.equals(that.trustOptions) : that.trustOptions != null) return false;

regardless of the fact that both instances are configured with the same certificate paths.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the class io.vertx.core.impl.AddressResolver of version 3.3.3If I don't set the dnServers in AddressResolverOptions, it will invoke the DnsServerAddresses.defaultAddresses() of netty to get dnsserver
of system. In  the class DnsServerAddresses, after fist time it got dnsservers from sun.net, it will not change dnsserver any more during runtime, because it's final: private static final DnsServerAddresses DEFAULT_NAME_SERVERS.
So if  I change the dnsserver in /etc/resolv.conf (linux) during runtime, the vert.x will not change dnsserver in it's cache, so what do you guys consider about this design, for Asynchronous for performance?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @vietj,
could you give me a short feedback if it's worth for me to put further work into this PR or if my approach is going into the totally wrong direction.
Thanks,
Theo
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mapper.apply(AsyncResult.this.result()); maybe throw Ex, so we must try, but Future extends AsyncResult catch the ex in the Future.map(Function) .


I think AsyncResult.map(Function) implement should try catch Ex, it can help we help happy coding.


It overshadowed the possibility of a program failure when we used AsyncResult.map no try catch Ex, because most AsyncResult object also is Future in Vertx.


I use the util method to solve:


	public static <T, U> AsyncResult<U> map(AsyncResult<T> asyncResult, Function<T, U> mapper) {
		if (asyncResult == null) return null;
		if (mapper == null) throw new NullPointerException();
		
		try {
			return asyncResult.map(mapper);
		} catch (Throwable e) {
			return Future.failedFuture(e);
		}
	}
io.vertx.core.AsyncResult.map(Function<T, U> mapper)
  default <U> AsyncResult<U> map(Function<T, U> mapper) {
    if (mapper == null) {
      throw new NullPointerException();
    }
    return new AsyncResult<U>() {
      @Override
      public U result() {
        if (succeeded()) {
          return mapper.apply(AsyncResult.this.result());
        } else {
          return null;
        }
      }

      @Override
      public Throwable cause() {
        return AsyncResult.this.cause();
      }

      @Override
      public boolean succeeded() {
        return AsyncResult.this.succeeded();
      }

      @Override
      public boolean failed() {
        return AsyncResult.this.failed();
      }
    };
  }
io.vertx.core.Future.map(Function<T, U> mapper)
  default <U> Future<U> map(Function<T, U> mapper) {
    if (mapper == null) {
      throw new NullPointerException();
    }
    Future<U> ret = Future.future();
    setHandler(ar -> {
      if (ar.succeeded()) {
        U mapped;
        try {
          mapped = mapper.apply(ar.result());
        } catch (Throwable e) {
          ret.fail(e);
          return;
        }
        ret.complete(mapped);
      } else {
        ret.fail(ar.cause());
      }
    });
    return ret;
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
shouldn't the <licenses> section in pom.xml contain also MIT license since there's a MIT licensed code in io/vertx/core/http/impl/cgbystrom/ ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you check if there are any Netty errors ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've a Launcher class which extends io.vertx.core.Launcher. In an overridden beforeStartingVertx(VertxOptions) method, I add a DNS address for a Consul server:
@Override
  public void beforeStartingVertx(VertxOptions options) {
    String consulDnsAddress = "127.0.0.1:8600";
    logger.info("Adding consul DNS address: {}", consulDnsAddress);
    options.setAddressResolverOptions(
        new AddressResolverOptions()
            .addServer(consulDnsAddress)
    );
  }

My logs show this is being executed (well, the logging call is anyway!):
2017-07-11 21:49:47,545 755  [main] INFO  uk.ashleybye.microservice.Launcher - Adding consul DNS address: 127.0.0.1:8600

Yet the only DNS resolver entry I see is:
2017-07-11 21:49:47,682 892  [main] DEBUG i.n.resolver.dns.DnsServerAddresses - Default DNS servers: [/192.168.0.1:53, /fdf4:eff8:1c4e:0:7250:afff:fe04:6e78:53] (sun.net.dns.ResolverConfiguration)

If I try to set the location of a server, say a kafka bootstrap server using the vertx-kafka-client, like so (I've a wrapper around the options but if I specify the actual address of the server there is no issue):
options.setBootstrapServers("kafka.service.consul");
// Or http://kafka.service.consul"

Gives me the following exception:
2017-07-11 22:07:35,822 1743 [vert.x-eventloop-thread-0] ERROR u.a.m.m.i.BufferKafkaProducerService - Failed to initialise kafka producer
org.apache.kafka.common.KafkaException: Failed to construct kafka producer
	at org.apache.kafka.clients.producer.KafkaProducer.<init>(KafkaProducer.java:342)
	at org.apache.kafka.clients.producer.KafkaProducer.<init>(KafkaProducer.java:191)
	at io.vertx.kafka.client.producer.impl.KafkaWriteStreamImpl.create(KafkaWriteStreamImpl.java:44)
	at io.vertx.kafka.client.producer.KafkaWriteStream.create(KafkaWriteStream.java:51)
	at io.vertx.kafka.client.producer.KafkaProducer.create(KafkaProducer.java:147)
	at uk.ashleybye.microservice.messaging.impl.BufferKafkaProducerService.lambda$new$0(BufferKafkaProducerService.java:33)
	at uk.ashleybye.microservice.discovery.impl.ConsulServiceImpl.lambda$lookupService$0(ConsulServiceImpl.java:77)
	at io.vertx.ext.consul.impl.ConsulClientImpl.lambda$request$52(ConsulClientImpl.java:616)
	at io.vertx.ext.web.client.impl.HttpRequestImpl.lambda$null$1(HttpRequestImpl.java:238)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)
Caused by: org.apache.kafka.common.config.ConfigException: Invalid url in bootstrap.servers: messaging-service-kafka.service.consul

I have four questions disguised as two:

Why is the DNS resolver that I added not showing up in the logs? Am I correctly adding it?
Without getting into the kafka-client internals, is this the correct way to specify the address and can Vert.x deal with such addresses? Or do I need to format it differently?

Any help or clarification would be hugely appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking through the logs of a Vert.x application, I noticed the following exception when undeploying verticles (it's the same exception for all 3):
    Failed to undeploy netsci.graphservice.verticles.CommandVerticle
    Failed to undeploy netsci.graphservice.verticles.QueryVerticle
    Failed to undeploy netsci.graphservice.verticles.EventVerticle
    java.lang.IllegalStateException: Unknown deployment
    	at io.vertx.core.impl.DeploymentManager.undeployVerticle(DeploymentManager.java:203)
    	at io.vertx.core.impl.VertxImpl.undeploy(VertxImpl.java:616)
    	at microservice.MasterMicroserviceVerticle.undeploySupportingVerticle(MasterMicroserviceVerticle.java:462)
    	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
    	at java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1548)
    	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
    	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
    	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
    	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
    	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
    	at microservice.MasterMicroserviceVerticle.stopSupportingVerticles(MasterMicroserviceVerticle.java:433)
    	at microservice.MasterMicroserviceVerticle.lambda$stop$14(MasterMicroserviceVerticle.java:383)
    	at io.vertx.core.Future.lambda$compose$1(Future.java:270)
    	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:126)
    	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:88)
    	at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:152)
    	at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:23)
    	at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:81)
    	at io.vertx.core.Future.lambda$compose$1(Future.java:275)
    	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:126)
    	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:88)
    	at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:152)
    	at io.vertx.core.impl.FutureImpl.handle(FutureImpl.java:23)
    	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:126)
    	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:133)
    	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:95)
    	at microservice.MasterMicroserviceVerticle.lambda$null$11(MasterMicroserviceVerticle.java:363)
    	at microservice.messaging.impl.BufferKafkaProducerService.lambda$shutdown$2(BufferKafkaProducerService.java:97)
    	at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:81)
    	at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:287)
    	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
    	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
    	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
    	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
    	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
    	at java.lang.Thread.run(Thread.java:748)

However, they are all deployed and have a deployment ID:
    Deployed: 213f1978-a595-4af1-8129-29de872e9907
    Deployed: e46839f1-2dd2-4cce-9e12-66e09677b97a
    Deployed: 8fdfd492-e005-4503-875e-13d73c633b2c

The deployment ID's are stored in a synchronized map, with the verticle class as the key and the the deployment id as the value. When queried, it shows that they are correctly stored:
    class netsci.graphservice.verticles.QueryVerticle: e46839f1-2dd2-4cce-9e12-66e09677b97a
    class netsci.graphservice.verticles.CommandVerticle: 8fdfd492-e005-4503-875e-13d73c633b2c
    class netsci.graphservice.verticles.EventVerticle: 213f1978-a595-4af1-8129-29de872e9907

Prior to the call to endeploy, if I check which verticle is being undeployed, I get can see that the valid deployment ID is being passed into the call to undeploy:
    Undeploying: e46839f1-2dd2-4cce-9e12-66e09677b97a
    Undeploying: 8fdfd492-e005-4503-875e-13d73c633b2c
    Undeploying: 213f1978-a595-4af1-8129-29de872e9907

Here are the relevant bits of code:
    public abstract class MasterMicroserviceVerticle extends MicroserviceVerticle {
    
      private final Map<Class, String> supportingVerticles =
          Collections.synchronizedMap(new HashMap<Class, String>());
    
      ...
    
      private Future<Void> deploySupportingVerticle(Class verticle) {
    
        Future<Void> future = Future.future();
    
        vertx.deployVerticle(
            verticle.getName(),
            new DeploymentOptions().setConfig(config()),
            asyncResult -> {
              if (asyncResult.succeeded()) {
                // Assign deployment ID to verticle map.
                String depId = asyncResult.result();
                System.out.println();
                System.out.println();
                System.out.println("Deployed: " + depId);
                System.out.println();
                System.out.println();
                supportingVerticles.put(verticle, depId);
                healthStatusService.setHealth(verticle.getName(), HealthStatus.PASSING);
                logger.info("Deployed {}", verticle.getName());
                future.complete();
              } else {
                healthStatusService.setHealth(verticle.getName(), HealthStatus.FAILING);
                logger.error("Failed to deploy {}", verticle.getName(), asyncResult.cause());
                future.fail(asyncResult.cause());
              }
            });
    
        return future;
      }
    
      ...
    
      @Override
      public void stop(Future<Void> stopFuture) throws Exception {
    
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        for (Class c : supportingVerticles.keySet()) {
          System.out.println(c + ": " + supportingVerticles.get(c));
        }
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        ...
          return mongoFuture;
        }).compose(handler -> {
          Future<Void> verticlesFuture = Future.future();
    
          stopSupportingVerticles(verticlesFuture.completer());
    
          return verticlesFuture;
        }).compose(handler ->
          logger.info("Undeployed service");
          stopFuture.completer();
        }, stopFuture);
      }
    
      protected void stopSupportingVerticles(Handler<AsyncResult<Void>> handler) {
    
        List<Future> undeployable = supportingVerticles
            .keySet()
            .stream()
            .map(this::undeploySupportingVerticle)
            .collect(Collectors.toList());
    
        CompositeFuture.all(undeployable)
            .setHandler(asyncResult -> {
              if (asyncResult.succeeded()) {
                handler.handle(Future.succeededFuture());
              } else {
                handler.handle(Future.failedFuture(asyncResult.cause()));
              }
            });
      }
    
      private Future<Void> undeploySupportingVerticle(Class verticle) {
    
        Future<Void> future = Future.future();
    
        System.out.println();
        System.out.println();
        System.out.println("Undeploying: " + supportingVerticles.get(verticle));
        System.out.println();
        System.out.println();
        vertx.undeploy(supportingVerticles.get(verticle), asyncResult -> {
          healthStatusService.setHealth(verticle.getName(), HealthStatus.FAILING);
          if (asyncResult.succeeded()) {
            logger.info("Undeployed {}", verticle.getName());
            future.complete();
          } else {
            logger.error("Failed to undeploy {}", verticle.getName(), asyncResult.cause());
            future.fail(asyncResult.cause());
          }
        });
    
        return future;
      }
    }

Please excuse all the System.out.println()'s, I've thrown them in there to help me get a better idea of what's going on and should probably record this info in the logs. But for now, I'd just appreciate any help understanding why Vert.x is saying the deployments are unknown? Whether it's a problem with my code or an actual Vert.x issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The project currently uses Jackson 2.7.4 and I was wondering about the possibility of upgrading to something in the 2.8.x line (e.g. 2.8.9 is the latest as of 7/13). I intended to do a quick poc by cloning the repository; unfortunately, I could not get it to compile (mvn clean install) either at the head of master or on 3.4.2 (latest release) -- w/o any changes.
Thanks!
== 3.4.2 ==
Results :

Failed tests:
  ProxyErrorTest.lambda$expectStatusError$2:90->AsyncTestBase.assertEquals:235 expected:<504> but was:<200>
Tests in error:
  Http1xTest.testResetPipelinedClientRequest:3086->AsyncTestBase.await:119->AsyncTestBase.await:131  IllegalState

Tests run: 3068, Failures: 1, Errors: 1, Skipped: 11

== Master ==
Failed tests:
  HostnameResolutionTest.testSearchDomainWithNdots0:667->AsyncTestBase.awaitLatch:592->AsyncTestBase.assertTrue:372 null
  Http1xTest.lambda$null$275:2882->AsyncTestBase.assertEquals:235 expected:<10> but was:<9>
  ProxyErrorTest.lambda$expectStatusError$2:90->AsyncTestBase.assertEquals:235 expected:<504> but was:<200>
Tests in error:
  NetTest.testNetServerInternal:3063->testNetServerInternal_:3109->AsyncTestBase.await:119->AsyncTestBase.await:131  IllegalState

Tests run: 3156, Failures: 3, Errors: 1, Skipped: 11

== Environment ==
Maven:  3.3.9
JDK: 1.8.0_131
OS: Mac OSX, 10.12.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've a Launcher class which extends io.vertx.core.Launcher that changes the vertx options in beforeStartingVertx(VertxOptions) method including setClusterHost and setClusterPort.
what happens: these settings are ignored and it falls back the host with getDefaultAddress() from BareCommand.java (https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java#L154)
in our cause this is always resulting in choosing the wrong interface
would be nice if it would take the host and port from the options if set before handling null and falling back to the "default address"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you provide a test for this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm on Windows and tried to launch a server.js in command line and in IDE with maven dependencies, but both failed with the same error.
Here is the server:
var Router = require("vertx-web-js/router");
var SockJSHandler = require("vertx-web-js/sock_js_handler");
var router = Router.router(vertx);

var options = {};
var sockJSHandler = SockJSHandler.create(vertx).bridge(options);
router.route("/eventbus/*").handler(sockJSHandler.handle);
The command lines (using vertx 3.4.2 full version):
>java -version
java version "1.8.0_40"
Java(TM) SE Runtime Environment (build 1.8.0_40-b26)
Java HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)

>vertx run server.js
javax.script.ScriptException: TypeError: Cannot call undefined in vertx-web-js/sock_js_handler.js at line number 87
        at jdk.nashorn.api.scripting.NashornScriptEngine.throwAsScriptException(NashornScriptEngine.java:455)
        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:439)
        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptE
ngine.java:401)
       ...

The server is perfectly working until I use .bridge(options);.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
applied thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
generated converters should not be removed from SCM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are currently three methods in CompositeFuture which force you to use raw types:

io.vertx.core.CompositeFuture.all(List<Future>)
io.vertx.core.CompositeFuture.any(List<Future>)
io.vertx.core.CompositeFuture.join(List<Future>)

The causes compiler warnings to appear all over the place:

It should be possible to rewrite the method signature to e.g. io.vertx.core.CompositeFuture.all(List<Future<?>>), which solves the raw types warning, but is not compatible with the previous declaration and this would break compatibility.
However there could be be a set of workarounds. One could be simply adding new methods like e.g. allOf. Or putting everything in a new interface TypedCompositeFuture, which would avoid the collision.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpClient client = vertx.createHttpClient(new HttpClientOptions());

    RequestOptions options = new RequestOptions()
      .setHost("ws.cex.io")
      .setPort(443)
      .setSsl(true)
      .setURI("/ws");

    client.websocket(options, ws -> {
    });
Connection fails with because HTTP upgrade request is sent as clear text.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My project use webclient to make http request.  When under a large number of request running for hours, it's always reach a wrong state at end, that no request will send indeed while always logs with: Connection pool reached max wait queue size.
here is my code:
Node.java
I dumped the stack and found the connCount is equals maxPoolSize while no connect available. so I think maybe the Http1xPool cant create new connection because connCount is not really response to the connection pool size.
here is some stacktrace:
116310 [vert.x-eventloop-thread-2] INFO  org.etagate.app.node.Node - auth, GET http://172.21.9.26:8080/auth/shortstring
116310 [globalEventExecutor-1-1] WARN  i.n.util.concurrent.DefaultPromise - An exception was thrown by io.vertx.core.net.impl.ChannelProvider$$Lambda$85/1186466417.operationComplete()
java.lang.IllegalStateException: Uh oh! Event loop context executing with wrong thread! Expected null got Thread[globalEventExecutor-1-1,5,main]
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:316)
        at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:193)
        at io.vertx.core.http.impl.ConnectionManager$ConnQueue.connectionFailed(ConnectionManager.java:373)
        at io.vertx.core.http.impl.ConnectionManager$ConnQueue.access$1600(ConnectionManager.java:197)
        at io.vertx.core.http.impl.ConnectionManager$ChannelConnector.lambda$connect$2(ConnectionManager.java:549)
        at io.vertx.core.net.impl.ChannelProvider.lambda$connect$0(ChannelProvider.java:42)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:481)
        at io.netty.util.concurrent.DefaultPromise.access$000(DefaultPromise.java:34)
        at io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:431)
        at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:233)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)

The reason cause the fail of create connection.
116230 [vert.x-acceptor-thread-0] WARN  i.n.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in t
he pipeline did not handle the exception.
java.io.IOException: Too many open files
        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)
        at io.netty.util.internal.SocketUtils$5.run(SocketUtils.java:110)
        at io.netty.util.internal.SocketUtils$5.run(SocketUtils.java:107)
        at java.security.AccessController.doPrivileged(Native Method)
        at io.netty.util.internal.SocketUtils.accept(SocketUtils.java:107)
        
The following is my guess.
When call createNewConnection, the connCount++ but the connection create failedthen function connectionFailed was called where connectionClosed() will be executed in context.executeFromIO, so connCount can decrease back.
context.executeFromIO will check the current Thread if not VertxThread cause an exception that may lead to a result: the connectionClose would not be called and connCount can not decrease backThis means that the connCount will increased without add a new connection in the connection pool, at last, no connection can be poll, no connection will be create, all waiter go to the queue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can we get this documented ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As a matter of usability, the HttpClient should let users connect with absolute websocket urls (ws:// or wss://)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it's a small PR, quick to review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have the following usecase for a vert.x aplication:

write a REST handler for a GET request
in this handler copy data from a ReadStream onto the response

This looked straight forward, in the handler I would create the ReadStream and then use a Pump to pipe the stream onto the response (WriteStream).
I noticed however that it can happen that the client closes the HTTP connection to my handler while the pump is still active. In this situation I had expected an exception on the WriteStream instance to occurs. However this is not the case, instead the WriteStream#writeQueueFull method returns "true" which sets the ReadStream into paused mode. It now waits for a drain event, but this event is never sent, because the write connection has been closed. The result is that over time the number of open (paused) ReadStreams grows, eventually generating a leak.
What is the correct way to handle this situation?
The first aspect that looks strange is that there is no exception on the write stream. But even if I were able to figure out the error situation (e.g. by listening on the close event on the response), what am I supposed to do with the ReadStream? It cannot be canceled but it also cannot stay open. The approach I can think of is to pump its content into a nil stream (i.e. consume it but ignore its content).
Overall this makes the complete pumping process pretty complicated.
The example below shows a simple testcase to reproduce the issue. The main method makes a request against a verticle and closed the connection immediately.
On the server (i.e. in the verticle) no exception is triggered, instead the ReadStream is locked in paused state.
The output of the sample code is:
request
false
starting to pipe ... false
response closed: false
writeQueueFull false
closed ...
writeQueueFull true
pause: 1
response is closed

Any suggestions are highly appreciated.

package com.ibm.wps.test.vertx;

import java.io.File;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.concurrent.CompletableFuture;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.file.AsyncFile;
import io.vertx.core.file.OpenOptions;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.streams.Pump;
import io.vertx.core.streams.ReadStream;
import io.vertx.core.streams.WriteStream;

public class CancellationTest {

private static final class ReadStreamProxy implements ReadStream<Buffer> {

	private int countPause;

	private final ReadStream<Buffer> delegate;

	private ReadStreamProxy(final ReadStream<Buffer> aDelegate) {
		delegate = aDelegate;
	}

	@Override
	public ReadStream<Buffer> endHandler(final Handler<Void> endHandler) {
		delegate.endHandler(endHandler);
		return this;
	}

	@Override
	public ReadStream<Buffer> exceptionHandler(final Handler<Throwable> handler) {
		delegate.exceptionHandler(handler);
		return this;
	}

	@Override
	public ReadStream<Buffer> handler(final Handler<Buffer> handler) {
		delegate.handler(handler);
		return this;
	}

	@Override
	public ReadStream<Buffer> pause() {
		countPause++;
		delegate.pause();
		System.out.println("pause: " + countPause);
		return this;
	}

	@Override
	public ReadStream<Buffer> resume() {
		countPause--;
		delegate.resume();
		System.out.println("resume: " + countPause);
		return this;
	}

}

private static final class TestVerticle extends AbstractVerticle {

	private HttpServer server;

	@Override
	public void start(final Future<Void> startFuture) throws Exception {

		final String data = new File(CancellationTest.class.getResource("data.txt").toURI()).getCanonicalPath();
		System.out.println("data " + data);

		server = vertx.createHttpServer();
		server.requestHandler(req -> {
			System.out.println("request");

			final HttpServerResponse resp = req.response();
			System.out.println(resp.closed());
			resp.exceptionHandler(th -> {
				System.out.println("exception from response " + th);
			});
			resp.closeHandler(v -> {
				System.out.println("response is closed");
			});
			resp.setChunked(true);

			vertx.setTimer(100, l -> {
				System.out.println("starting to pipe ... " + resp.closed());

				final OpenOptions opts = new OpenOptions();
				opts.setWrite(false);
				opts.setRead(true);
				vertx.fileSystem().open(data.toString(), opts, fileRes -> {
					final AsyncFile file = fileRes.result();
					file.exceptionHandler(ex -> {
						System.out.println("file exception " + ex);
					});
					file.endHandler(v -> {
						System.out.println("file ended");
					});
					
					System.out.println("response closed: " + resp.closed());

					pipe(file, resp);
				});
			});
		});

		server.listen(8080, result -> {
			if (result.failed()) {
				startFuture.fail(result.cause());
			} else {
				startFuture.complete();
			}
		});
	}
}

private static final class WriteStreamProxy implements WriteStream<Buffer> {

	private final WriteStream<Buffer> delegate;

	private WriteStreamProxy(final WriteStream<Buffer> aDelegate) {
		delegate = aDelegate;
	}

	@Override
	public WriteStream<Buffer> drainHandler(final Handler<Void> handler) {
		delegate.drainHandler(handler);
		return this;
	}

	@Override
	public void end() {
		delegate.end();
	}

	@Override
	public WriteStream<Buffer> exceptionHandler(final Handler<Throwable> handler) {
		delegate.exceptionHandler(handler);
		return this;
	}

	@Override
	public WriteStream<Buffer> setWriteQueueMaxSize(final int maxSize) {
		delegate.setWriteQueueMaxSize(maxSize);
		return this;
	}

	@Override
	public WriteStream<Buffer> write(final Buffer data) {
		delegate.write(data);
		return this;
	}

	@Override
	public boolean writeQueueFull() {
		final boolean result = delegate.writeQueueFull();
		System.out.println("writeQueueFull " + result);
		return result;
	}

}

public static void main(final String[] args) throws Exception {
	
	System.out.println(System.getProperties());


	final CompletableFuture<Void> sync = new CompletableFuture<Void>();

	final Vertx vertx = Vertx.vertx();
	vertx.deployVerticle(new TestVerticle(), result -> {
		try {
			final URL url = new URL("http://localhost:8080/");
			final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.connect();
			final InputStream is = conn.getInputStream();
			is.close();
			conn.disconnect();
			System.out.println("closed ...");
			sync.complete(null);
		} catch (final Throwable th) {
			sync.completeExceptionally(th);
		}
	});

	sync.get();
	vertx.close();
}

private static final void pipe(final ReadStream<Buffer> aRead, final WriteStream<Buffer> aWrite) {
	
	aWrite.exceptionHandler(ex -> {
		new Exception().printStackTrace();
		System.out.println("write stream exception " + ex);
	});

	
	Pump.pump(new ReadStreamProxy(aRead), new WriteStreamProxy(aWrite)).start();
}

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When HttpClientResponseImpl#handleException is called while treating a http response, if an handler was not set, the exception is completely hidden from the user. Please compare
io.vertx.core.http.impl.HttpClientRequestBase#handleException
    synchronized (getLock()) {
      cancelOutstandingTimeoutTimer();
      exceptionOccurred = t;
      if (exceptionHandler != null) {
        exceptionHandler.handle(t);
      } else {
        log.error(t);
      }
    }
  }

with
io.vertx.core.http.impl.HttpClientResponseImpl#handleException
    synchronized (conn) {
      if (exceptionHandler != null) {
        exceptionHandler.handle(e);
      }
    }
  }

please see this repo for a test case:
https://github.com/j040p3d20/vertx-response-handler-test
In our case, after the body handler has completed we continue with another future to do more work but
there is a nullpointer exception and we dont reach that code and couldnt understand why because there was no trace of the exception anywhere.
Other than this, thank you for the great work, we love to work with vertx at Akio.com :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Make the HttpServerResponse#exceptionHandler is called when the response is closed before the end of the stream.
Avoid the HttpClientRequest#exceptionHandler to be notified twice when connection is closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
can you please help me figure out how to increase the number of requests processed in parallel by a particular HTTP handler? In all my tests it seems to be limited to 5 regardless of the size of the event loop or the worker pool.
I have an http server:
public class MyHttpServer {
	
	private static final String DESTINATION = "destination";

	static class MyVerticle extends AbstractVerticle {
		public void start() throws Exception {
			vertx.eventBus().consumer(DESTINATION, message -> {
				try {
					Thread.currentThread().sleep(300);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				message.reply("response to " + message.body());				
			});
		}
	}

	public static void main(String[] args) {
		Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(20));
		
		final DeploymentOptions deploymentOptionsAuth = new DeploymentOptions().setWorkerPoolName("mypool")
	            .setWorkerPoolSize(20).setWorker(true).setMultiThreaded(true);
		vertx.deployVerticle(new MyVerticle(), deploymentOptionsAuth);
		
		Router restAPI = Router.router(vertx);		
		restAPI.get("/*").handler(rc -> {
			System.out.println("sending to event bus");
			vertx.eventBus().send(DESTINATION, rc.request().path(), ar -> {
				System.out.println("received response from event bus");
				rc.response().setStatusCode(200).end("---myhttp-response---" + ar.result().body() + " ** " + rc.request().path() + "---myhttp-response---");
			});			
		});
		vertx.createHttpServer().requestHandler(restAPI::accept).listen(8084);
		System.out.println("listening");
	}
}
When sending many requests in parallel I see that at most 5 of them are dispatched to the verticle via the event bus in parallel. It seems like a first response from the verticle/event bus must be received before the next request will be sent to the event bus/verticle. I.e. I see the output like this:
listening
sending to event bus
sending to event bus
sending to event bus
sending to event bus
sending to event bus
received response from event bus
received response from event bus
received response from event bus
received response from event bus
received response from event bus
sending to event bus
sending to event bus
sending to event bus
sending to event bus
sending to event bus
received response from event bus
sending to event bus

The client used to run the test is like this:
Vertx vertx = Vertx.vertx();
 
final WebClient wc = WebClient.create(vertx,
	new WebClientOptions().setDefaultHost("localhost").setDefaultPort(8084));

for (int i = 0; i < 100; i++) {
	new Thread(() -> {
		System.out.println("sending");
		wc.get("/abc").send(ar -> {
			if (ar.succeeded()) {
				HttpResponse<Buffer> response = ar.result();
				System.out.println(response.bodyAsString());
			} else {
				ar.cause().printStackTrace();
			}				
		});
	}).start();			
}
Thanks a lot in advance
Boris
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you add a note about the deprecation, i.e what the developer should be aware of to migrate from this interface, also please specify when (version) the interface will be removed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should Vert.x use the @Deprecated annotation (in addition to the doclet) ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JsonObjectMessageCodec and JsonArrayMessageCodec use intermediate String for encoding and decoding. They should directly encode to and decode from Buffer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here is some snippet of example code
response.setStatusCode(HttpResponseStatus.NO_CONTENT);
                JsonObject json = new JsonObject();
                json.put("hello", "world");
                response.end(json.encodePrettily());

This seems to make subsequent connections hang or unexpected results.
Vert.x should probably just throw an exception if a body is sent to the response when the status code is NO_CONTENT ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM, @tsegismont WDYT ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Vert.x 3.4.2 with WebClient
I've got issue with using sendStream to forward request to another service. It results in IllegalStateException: Request has already been read
Code to reproduce:
public class Service1 extends AbstractVerticle {
    @Override
    public void start() throws Exception {
        Router router = Router.router(vertx);
        router.post("/").handler(routingContext -> {
            WebClient webClient = WebClient.create(vertx);
            webClient.postAbs("http://localhost:10001/")
                    .sendStream(routingContext.request(), ar -> System.out.println("R: "+ar.result()));
        });
        vertx.createHttpServer()
                .requestHandler(router::accept)
                .listen(10000);
    }
}

Result:
Aug 03, 2017 5:04:23 PM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.IllegalStateException: Request has already been read
 at io.vertx.core.http.impl.HttpServerRequestImpl.checkEnded(HttpServerRequestImpl.java:426)
 at io.vertx.core.http.impl.HttpServerRequestImpl.handler(HttpServerRequestImpl.java:206)
 at io.vertx.ext.web.impl.HttpServerRequestWrapper.handler(HttpServerRequestWrapper.java:42)
 at io.vertx.ext.web.impl.HttpServerRequestWrapper.handler(HttpServerRequestWrapper.java:19)
 at io.vertx.core.streams.impl.PumpImpl.stop(PumpImpl.java:97)
 at io.vertx.core.streams.impl.PumpImpl.stop(PumpImpl.java:42)
 at io.vertx.ext.web.client.impl.HttpRequestImpl.lambda$send$12(HttpRequestImpl.java:342)
 at io.vertx.core.http.impl.HttpServerRequestImpl.handleEnd(HttpServerRequestImpl.java:406)
 at io.vertx.core.http.impl.ServerConnection.handleEnd(ServerConnection.java:297)
 at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:441)
 at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:131)
 at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:673)
 at io.vertx.core.http.impl.HttpServerImpl$ServerHandler.doMessageReceived(HttpServerImpl.java:580)
 at io.vertx.core.http.impl.VertxHttpHandler.lambda$channelRead$0(VertxHttpHandler.java:71)
 at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:335)
 at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:193)
 at io.vertx.core.http.impl.VertxHttpHandler.channelRead(VertxHttpHandler.java:71)
 at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:122)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
 at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293)
 at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:267)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
 at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
 at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
 at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
 at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
 at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
 at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
 at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
 at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
 at java.lang.Thread.run(Thread.java:748)

Link to post at Google Group: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/vertx/srXkOOK8tj0/SXPuo7J8AAAJ
Thanks,
Maciek.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think actually we need a CQ for this contribution
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj reworked after your review. PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation: setting an handler on these objects after they are ended will throw an exception to signal an error, however it can be desirable to set a null handler after completion (for instance stopping a pump will set null handlers) and in this situation we should be more tolerant and accept setting null handlers.
changes: update various handler setter method to accept null values after completion.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello!
I have some Clojure code that I would like to do some basic web stuff with.  I seem to recall in the past Vert.X supported it as a first class citizen...Is there a plan to bring that back?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found it arduous to get the result from a call to CompositeFuture.all.
I've written a class in kotlin which allows me to easily get a result out of a list of futures (similar to scala Future.sequence).  The main feature I wanted here was to be able to call .map(mapper: List<T> -> R) or .compose(mapper: List<T> -> Future<R>) on a future created from a list of Future<T>, rather than  .map(mapper: CompositeFuture -> R).
Is this something for which it would be worthwhile for me formalize, test, convert from kotlin, and create an MR?  I find this functionality extremely useful, but I imagine it may have been intentionally foregone due to performance and memory implications.
source
Kotlin snippet:
class FutureSequence<T>(val futures: List<Future<T>>): Future<List<T>>, Handler<AsyncResult<List<T>>> {
    ...
    init { //mostly copied from CompositeFuture.java
          futures.forEachIndexed { i: Int, f: Future<T> ->
              f.setHandler { ar ->
                  var handler: Handler<AsyncResult<List<T>>>? = null
                  println("completed future $i")
                  if(ar.succeeded())  {
                      synchronized(this) {
                          count ++
                          results.set(i, Option.Some(ar))
                          if(!isComplete && count == futures.size) {
                              handler = setComplete()
                          }
                      }
                  } else {
                      synchronized(this) {
                          if(!isComplete) {
                              handler = setFailed(ar.cause())
                          }
                      }
                  }

                  println("ar $i, succeeded: ${ar.succeeded()}, handler: $handler, completed: $completed")
                  handler?.let{ it.handle(resultsToResult()) }
              }
          }
        if(futures.isEmpty()) {
            setComplete()
        }
    }

    //This method is the real meat
    private fun resultsToResult(): AsyncResult<List<T>>? {
        return results.fold<Option<AsyncResult<T>>, Option<AsyncResult<List<T>>>>(Option.None as Option<AsyncResult<List<T>>>) {
            aggOpt: Option<AsyncResult<List<T>>>, arOpt: Option<AsyncResult<T>> ->
            when(aggOpt) {
                is Option.None -> arOpt.map { it.map { listOf(it)}}
                else -> aggOpt.filter { it.succeeded() }
                        .flatMap { aggRes ->
                            arOpt.filter { it.succeeded()}
                                    .map { ar -> aggRes.map { it + ar.result() } }
                                    .orElse { arOpt.map {it.map{it -> emptyList<T>()}} } }
                        .orElse { aggOpt }

            }
        }.orNull()
    }

    companion object {
        fun <T> noHandler(): Handler<AsyncResult<List<T>>> = Handler { }
    }

    override fun result(): List<T>? {
        return if(completed && cause == null) resultsToResult()?.result() else null
    }
    //most methods copy + paste CompositeFuture besides signature
    ....
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it looks ok to me, however I think we should honour the TTL with a timer and make sure it works correctly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
it could be usefull to retrieve forms attributes before the whole read of the request for doing server side validation.
For exemple if you a html forms whih mixed file and simple field, we need to wait the whole read of the request (field + file) before acces simple field (via getFormAttribute), so if the user upload a big file and for some reason the validation of one field is bad the server need to retrieve the whole file before begin the validation.
i have started a discussion with some example on google groups :
https://groups.google.com/forum/#!topic/vertx/Y8977Oeu14g
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
given url /test?key=v1&Key=v2&KEY=v3 it should return different value as below, but now it all returns v3
rc.request.getParam("key") //should return v1
rc.request.getParam("Key") //should return v2
rc.request.getParam("KEY") //should return v3


6.2.2.1. Case Normalization
When a URI uses components of the generic syntax, the component syntax equivalence rules always apply; namely, that the scheme and host are case-insensitive and therefore should be normalized to lowercase. For example, the URI is equivalent to http://www.example.com/.
The other generic syntax components are assumed to be case-sensitive unless specifically defined otherwise by the scheme (see Section 6.2.3).

The code causing issue is HttpUtils.params , it should not use CaseInsensitiveHeaders
  static MultiMap params(String uri) {
    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(uri);
    Map<String, List<String>> prms = queryStringDecoder.parameters();
    MultiMap params = new CaseInsensitiveHeaders();
    if (!prms.isEmpty()) {
      for (Map.Entry<String, List<String>> entry: prms.entrySet()) {
        params.add(entry.getKey(), entry.getValue());
      }
    }
    return params;
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When launched as a background process, the vertx application cannot be gracefully terminated under Windows. For some reason only killing the process works, but that skips any shutdown hooks. This means that the Launcher start/stop commands cut major parts of the functionality described in the core manual.
The run command allows to gracefully quit the process by issuing ctrl+c within the cmd window it was run from. However, the process spawned by it is also not terminable from outside, e.g. taskkill /pid.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The documentation on AsyncResult.map contains the following passage:

If the {@code mapper} throws an exception, the returned future will be failed with this exception.
When this async result is failed, the failure will be propagated to the returned future and the {@code mapper}     will not be called.

This is simply not true, throwing an exception in the Mapper results in an asyncresult that never completes and therefore breaks the complete flow. This passage should probably be removed from the docs or map should offer the advertised behavior.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Vert.x http client accepts header values that contains LF in it. If a program were to add an extra header based on user input without proper data sanitation this could allow an attacker to perform header injection.
Here is a working example:
@RunWith(VertxUnitRunner.class)
public class TestInjection {

  @ClassRule
  static public RunTestOnContext vertxRule = new RunTestOnContext();

  @Test
  public void testHttpHeader(TestContext context) {
    Vertx vertx = vertxRule.vertx();

    vertx.createHttpServer()
      .requestHandler(request -> {
        System.out.println(request.headers().entries().stream()
          .map(e -> e.getKey() + ": <" + e.getValue() +">").collect(Collectors.joining("\n")));
        request.response().end();
      })
      .listen(0, context.asyncAssertSuccess(server -> {
        Async async = context.async();
        vertx.createHttpClient()
          .getAbs("http://localhost:" + server.actualPort(), request -> async.complete())
          .putHeader("Content-Type", "text/plain\nX-EvilHeader: horrible injection")
          .end();
      }));
  }

}
This will produce the following input:
Content-Type: <text/plain>
X-EvilHeader: <horrible injecton>
Host: <localhost:xxxxx>

It seems that Vert.x does't ask Netty to perform header validation:
https://github.com/eclipse/vert.x/blob/master/src/main/java/io/vertx/core/http/impl/ClientConnection.java#L451
When passing true in the validateHeaders parameter to DefaultHttpRequest's constructor an exception is then raised:
java.lang.IllegalArgumentException: only ' ' and '\t' are allowed after '\n': [...]

Is there any reason why Vert.x is not asking Netty to validate the header of the client request?
If not, I'll create a PR to fix this issue that we consider to be a SSRF vulnerability.
What do think?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using an HttpClient for requests to different IPs with the same host header set, the connection pool only establishes one connection to one IP because the ConnectionKey for pooling only includes the host header (as peerHost). Also see this mailing list conversation.
To allow for connections to multiple IPs using the same host header, the peerHost could be e.g. IP + hostname.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks @mguillet this is now done by default in vertx and there is an system property to disable validation
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If one set NetServer instance to require SSL Client Certificate authentication and client does not send it netty throws exception that vert.x does not handle cleanly even if one registers exception handler for NetSocket.
Initially encountered this issue while writing SSL test cases for vertx-mqtt.
If one changes code snippet to use ClientAuth.REQUEST then you can see openssl's s_client nicely connected.
What I would have expected:

No exception shown in logs
Ability to catch failure case for unit tests
Socket closed is kinda OK but now it was completely invisible for application thus hard to make unit tests for it

Code snippet:
        NetServerOptions netServerOptions = new NetServerOptions()
                .setPfxKeyCertOptions(new PfxOptions()
                        .setPath("server.p12")
                        .setPassword("password"))
                .setTrustOptions(new PemTrustOptions()
                        .addCertPath("ca.crt"))
                .setSsl(true)
                .setClientAuth(ClientAuth.REQUIRED)
                ;
        NetServer server = vertx.createNetServer(netServerOptions);
        server.connectHandler(socket -> {
            socket.closeHandler(v -> {
                System.out.println("The socket has been closed");
            });
            socket.handler(buffer -> {
                System.out.println("I received some bytes: " + buffer.length());
            });
            socket.exceptionHandler(e -> {
                System.out.println("got exception\r\n");
            });
            System.out.println("Client connected: " + socket.remoteAddress() + "\r\n");
            socket.write("Welcome to the Service\r\n");
        });

        server.listen(1234, "localhost", res -> {
            if (res.succeeded()) {
                System.out.println("Server is now listening!");
            } else {
                System.out.println("Failed to bind!");
            }
        });

Test command with openssl:
$ openssl s_client -connect localhost:1234 -tls1
CONNECTED(00000003)
depth=0 /C=FI/O=Something/CN=localhost
verify error:num=20:unable to get local issuer certificate
verify return:1
depth=0 /C=FI/O=Something/CN=localhost
verify error:num=27:certificate not trusted
verify return:1
depth=0 /C=FI/O=Something/CN=localhost
verify error:num=21:unable to verify the first certificate
verify return:1
31628:error:14094412:SSL routines:SSL3_READ_BYTES:sslv3 alert bad certificate:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/ssl/s3_pkt.c:1145:SSL alert number 42
31628:error:1409E0E5:SSL routines:SSL3_WRITE_BYTES:ssl handshake failure:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/ssl/s3_pkt.c:566:

Note: had to add -tls1 otherwise following was generated:
$ openssl s_client -connect localhost:1234
CONNECTED(00000003)
31681:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/ssl/s23_clnt.c:618:

And in log:
Aug 26, 2017 9:10:11 AM io.netty.channel.DefaultChannelPipeline onUnhandledInboundException
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: SSLv2Hello is disabled
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:442)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
...

Test snippet log:
Starting vert.x application...
Aug 26, 2017 12:02:03 AM io.vertx.core.impl.launcher.commands.Watcher
fb9ae8fe-4e51-42f5-9f08-21b375509244-redeploy
INFO: User command terminated with status 0
Aug 26, 2017 12:02:03 AM io.vertx.core.impl.launcher.commands.Watcher
INFO: Redeployment done in 1426 ms.
Server is now listening!
Aug 26, 2017 12:02:03 AM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
Aug 26, 2017 12:03:44 AM io.vertx.core.net.impl.NetServerImpl
SEVERE: Client from origin /127.0.0.1:61390 failed to connect over ssl: javax.net.ssl.SSLHandshakeException: null cert chain
Aug 26, 2017 12:03:44 AM io.netty.channel.DefaultChannelPipeline onUnhandledInboundException
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: null cert chain
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:442)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.net.ssl.SSLHandshakeException: null cert chain
	at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1478)
	at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535)
	at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:813)
	at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
	at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
	at io.netty.handler.ssl.SslHandler$SslEngineType$2.unwrap(SslHandler.java:223)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1117)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1039)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)
	... 15 more
Caused by: javax.net.ssl.SSLHandshakeException: null cert chain
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
	at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1666)
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:304)
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:292)
	at sun.security.ssl.ServerHandshaker.clientCertificate(ServerHandshaker.java:1862)
	at sun.security.ssl.ServerHandshaker.processMessage(ServerHandshaker.java:233)
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1026)
	at sun.security.ssl.Handshaker$1.run(Handshaker.java:966)
	at sun.security.ssl.Handshaker$1.run(Handshaker.java:963)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.security.ssl.Handshaker$DelegatedTask.run(Handshaker.java:1416)
	at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1256)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1169)
	... 17 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LGTM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it looks good from my perspective, I need to make a more thorough review before merging.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Are there instructions on how to install the plugin with the Eclipse IDE?
newb here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The RouterImpl already has a method that would expose vertx() but only to the default classes.  Is there a reason why it was not exposed on the Router level?
The reason I am asking is I am trying to build a simple API that would help me build routes, but I would need vertx on construction to use the executeBlocking for long initialization sequences.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 3.4.2
I am using a verticle to send HTTP GET requests to an endpoint. It seems that the traffic is growing and the requests (when writing the header) are overlapping, causing an exception.
java.lang.IllegalStateException: Connection is already writing a request
	at io.vertx.core.http.impl.ClientConnection.beginRequest(ClientConnection.java:543)
	at io.vertx.core.http.impl.HttpClientRequestImpl.connected(HttpClientRequestImpl.java:756)
	at io.vertx.core.http.impl.HttpClientRequestImpl.access$100(HttpClientRequestImpl.java:51)
	at io.vertx.core.http.impl.HttpClientRequestImpl$2.handleStream(HttpClientRequestImpl.java:719)
	at io.vertx.core.http.impl.ConnectionManager$ConnQueue.deliverStream(ConnectionManager.java:277)
	at io.vertx.core.http.impl.ConnectionManager$ConnQueue.lambda$getConnection$0(ConnectionManager.java:237)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)

public class MyVerticle extends AbstractVerticle {
  private HttpClient client;

  public void start() {
    ...
    client = vertx.createHttpClient(options);
    ...
  }
}
I don't have too much control of this, the question is what to do?

Increase the number of verticle instances? So in this case the client instance will be different, so the race condition will be vanish? Or at least have a lower probability.
Set bigger connection pool that the default of the http client? How can I do that?
Implement queueing of writing request in ClientConnection.

One things is missing for me: if it is happening inside a verticle how it can happen that a request is being written, but another request is coming in? It is a standard verticle, not a worker.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To reproduce, create a JsonParser, switch to object value mode and push a buffer of JSON with at least one floating point value. Parsing fails with UnsupportedOperationException: Not implemented
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I believe AsyncResult.map() must handle exceptions in mapper function.
Also it seems that AsyncResult.succeededAsyncResult() and AsyncResult.failedAsyncResult() static factories will be useful.
If these proposals makes sense I can provide PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the DeploymentManager will be invoked asynchronously by a VerticleFactory and upon resolution the new deployment can throw an exception, this exception should be properly routed to the original deployment completion handler and not to the VerticleFactory itself.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
please only keep the AsyncResult implementation and not add new factory method to not provide two ways of doing the same thing. People are used to the idiom Vertx.succeededFuture() to build an immutable AsyncResult and that's fine this way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
an IllegalStateException occurred when accessing url http://localhost:8080/ .
Unexpected exception in route
java.lang.IllegalStateException: Request has already been read
at io.vertx.core.http.impl.HttpServerRequestImpl.checkEnded(HttpServerRequestImpl.java:426)
at io.vertx.core.http.impl.HttpServerRequestImpl.handler(HttpServerRequestImpl.java:206)
at io.vertx.ext.web.impl.HttpServerRequestWrapper.handler(HttpServerRequestWrapper.java:42)
at io.vertx.ext.web.handler.impl.BodyHandlerImpl.handle(BodyHandlerImpl.java:66)
at io.vertx.ext.web.handler.impl.BodyHandlerImpl.handle(BodyHandlerImpl.java:40)
at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:217)
at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:78)
at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:118)
at io.vertx.ext.web.handler.impl.SessionHandlerImpl.lambda$handle$0(SessionHandlerImpl.java:127)
at io.vertx.ext.web.handler.impl.SessionHandlerImpl.lambda$doGetSession$2(SessionHandlerImpl.java:155)
at io.vertx.ext.web.sstore.impl.ClusteredSessionStoreImpl.lambda$null$0(ClusteredSessionStoreImpl.java:73)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:81)
at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:287)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at java.lang.Thread.run(Unknown Source)
the issue could be reproduced by the following code:
private Future createWebServer() {
Future cwsFuture = Future.future();
    Router router = Router.router(vertx);
    
    router.route().handler(CookieHandler.create());
    **SessionStore ss = ClusteredSessionStore.create(vertx);
    SessionHandler sh = SessionHandler.create(ss);
    router.route().handler(sh);
    router.route().handler(BodyHandler.create());**

    // home page
    router.get("/").handler(this::Index);

    // static resources
    router.route("/public/*").handler(StaticHandler.create("webroot/static"));

    vertx
            .createHttpServer()
            .requestHandler(router::accept)
            .listen(config().getInteger("http.port", 8080), wsRes -> {
                if(wsRes.succeeded()) {
                    LOGGER.info("WebServerVerticle has been started successfully.");
                    cwsFuture.complete();
                }else{
                    LOGGER.error("Failed to createHttpServer.");
                    cwsFuture.fail(wsRes.cause());
                }
            });

    return cwsFuture;
}

private void Index(RoutingContext rc) {
    System.out.println("in index. " + Thread.currentThread().getName());
    rc.response().sendFile("webroot/index.html");
}

please pay attention in above bold code. the web service seems good and could work when I put the router.route().handler(BodyHandler.create()); in front of router.route().handler(CookieHandler.create()); .
the web service works very well, no exception occurs.
is there anyone who could tell me why? I could not find any suggestion in the document that the BodyHandler.create() should be called before calling SessionHandler.create().
thanks in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the MessageProducer#drainHandler only set the drain handler on the producer. It can happen that an application using the producer outside of the event loop sets a drain handler because MessageProducer#writeQueueFull() returned true and concurrently the producer has been fully refund from all its credits before the drain handler is set:
if (producer.writeQueueFull()) {
   // Fully refund in the mean time, drain handler won't be called at all
   producer.drainHandler(v -> { ... });
}

When setting a drain handler on a producer we should call it when the queue is in drained state.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
the shade plugin is giving the following warning when i build my application
[WARNING] vertx-web-common-3.4.2.jar, vertx-web-3.4.2.jar define 3 overlapping classes: 
[WARNING]   - io.vertx.ext.web.package-info
[WARNING]   - io.vertx.groovy.ext.web.VertxPropertiesModuleFactory
[WARNING]   - io.vertx.groovy.ext.web.VertxPropertiesModuleFactory$1
[WARNING] vertx-service-proxy-3.4.2.jar, vertx-service-proxy-3.4.2-processor.jar define 6 overlapping classes: 
[WARNING]   - io.vertx.serviceproxy.ProxyHandler
[WARNING]   - io.vertx.serviceproxy.ServiceExceptionMessageCodec
[WARNING]   - io.vertx.serviceproxy.ServiceException
[WARNING]   - io.vertx.serviceproxy.ServiceProxyProcessor
[WARNING]   - io.vertx.serviceproxy.package-info
[WARNING]   - io.vertx.serviceproxy.ProxyHelper

my dependency tree is like this
[INFO] me.sample:sample-backend:jar:1.0-SNAPSHOT
[INFO] +- io.vertx:vertx-web:jar:3.4.2:compile <-------------------- here
[INFO] |  +- io.vertx:vertx-auth-common:jar:3.4.2:compile
[INFO] |  \- io.vertx:vertx-core:jar:3.4.2:compile
[INFO] |     +- io.netty:netty-common:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-buffer:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-transport:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-handler:jar:4.1.8.Final:compile
[INFO] |     |  \- io.netty:netty-codec:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-handler-proxy:jar:4.1.8.Final:compile
[INFO] |     |  \- io.netty:netty-codec-socks:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-codec-http:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-codec-http2:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-resolver:jar:4.1.8.Final:compile
[INFO] |     +- io.netty:netty-resolver-dns:jar:4.1.8.Final:compile
[INFO] |     |  \- io.netty:netty-codec-dns:jar:4.1.8.Final:compile
[INFO] |     +- com.fasterxml.jackson.core:jackson-core:jar:2.7.4:compile
[INFO] |     \- com.fasterxml.jackson.core:jackson-databind:jar:2.7.4:compile
[INFO] |        \- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile
[INFO] +- com.progressoft.brix.domino.api:domino-api-client:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |  +- com.progressoft.brix.domino.api:domino-api-shared:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |  +- com.progressoft.brix.domino.api:domino-api-shared:jar:sources:1.0-rc.2-SNAPSHOT:compile
[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.25:compile
[INFO] +- com.progressoft.brix.domino.api:domino-api-server:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |  +- com.progressoft.brix.domino:domino-service-discovery:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |  |  +- io.vertx:vertx-service-discovery:jar:3.4.2:compile
[INFO] |  |  +- io.vertx:vertx-web-client:jar:3.4.2:compile
[INFO] |  |  |  \- io.vertx:vertx-web-common:jar:3.4.2:compile <----------------------- here
[INFO] |  |  +- io.vertx:vertx-service-proxy:jar:3.4.2:compile <-------------------- here
[INFO] |  |  |  \- io.vertx:vertx-lang-js:jar:3.4.2:compile
[INFO] |  |  +- io.vertx:vertx-codegen:jar:3.4.2:compile
[INFO] |  |  |  \- org.mvel:mvel2:jar:2.2.8.Final:compile
[INFO] |  |  +- io.vertx:vertx-service-proxy:jar:processor:3.4.2:compile <-------------------------- here
[INFO] |  |  +- io.vertx:vertx-jdbc-client:jar:3.4.2:compile
[INFO] |  |  |  +- io.vertx:vertx-sql-common:jar:3.4.2:compile
[INFO] |  |  |  \- com.mchange:c3p0:jar:0.9.5.2:compile
[INFO] |  |  |     \- com.mchange:mchange-commons-java:jar:0.2.11:compile
[INFO] |  |  +- io.vertx:vertx-redis-client:jar:3.4.2:compile
[INFO] |  |  \- io.vertx:vertx-mongo-client:jar:3.4.2:compile
[INFO] |  |     \- org.mongodb:mongodb-driver-async:jar:3.4.1:compile
[INFO] |  |        +- org.mongodb:mongodb-driver-core:jar:3.4.1:compile
[INFO] |  |        \- org.mongodb:bson:jar:3.4.1:compile
[INFO] |  \- io.vertx:vertx-config:jar:3.4.2:compile
[INFO] +- com.progressoft.brix.domino:domino-remote-logging:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |  +- com.google.gwt:gwt-servlet:jar:2.8.1:compile
[INFO] |  +- com.google.code.gson:gson:jar:2.6.2:compile
[INFO] |  +- org.apache.logging.log4j:log4j-api:jar:2.8.2:compile
[INFO] |  \- org.apache.logging.log4j:log4j-core:jar:2.8.2:compile
[INFO] +- me.sample:logme-backend:jar:1.0-SNAPSHOT:compile
[INFO] |  \- com.progressoft.brix.domino.apt:apt-server:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |     \- com.progressoft.brix.domino.apt:apt-commons:jar:1.0-rc.2-SNAPSHOT:compile
[INFO] |        +- commons-io:commons-io:jar:1.3.2:compile
[INFO] |        \- commons-lang:commons-lang:jar:2.6:compile
[INFO] +- me.sample:logme-shared:jar:1.0-SNAPSHOT:compile
[INFO] |  \- com.google.gwt:gwt-user:jar:2.8.1:compile
[INFO] |     +- com.google.jsinterop:jsinterop-annotations:jar:1.0.1:compile
[INFO] |     +- com.google.jsinterop:jsinterop-annotations:jar:sources:1.0.1:compile
[INFO] |     +- javax.validation:validation-api:jar:sources:1.0.0.GA:compile
[INFO] |     +- javax.servlet:javax.servlet-api:jar:3.1.0:compile
[INFO] |     \- org.w3c.css:sac:jar:1.3:compile
[INFO] +- me.sample:sample-frontend:war:1.0-SNAPSHOT:runtime
[INFO] +- junit:junit:jar:4.12:test
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] +- javax.validation:validation-api:jar:1.1.0.Final:compile
[INFO] +- org.assertj:assertj-core:jar:3.7.0:test
[INFO] \- com.google.auto.service:auto-service:jar:1.0-rc3:provided
[INFO]    +- com.google.auto:auto-common:jar:0.3:provided
[INFO]    \- com.google.guava:guava:jar:19.0:provided


Why do vertx jars have these classes duplication that makes them overlap?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@disparlure the easiest way to get around the individual commits would be to just combine all your changes into a single commit like this:
https://stackoverflow.com/questions/17354353/git-squash-all-commits-in-branch-without-conflicting
it will take the state of this branch, reset to current master leaving all your changes as unstaged. then you can commit them in one commit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Trying to help out. I squashed #2164 for @disparlure - hope the double signing is correct ;)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, each event loop has its own DNS cache when using the DNS address resolver, the current DNS cache implementation is concurrent and can be easily shared between event loop to reduce memory consumption.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/65a1050b0922de38329cdbe90c5ecd8094a93a04/src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java#L258-L260
I'm not sure if this is a bug or a feature.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oct 06, 2017 10:14:49 PM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.NullPointerException
at io.vertx.core.eventbus.impl.clustered.ConnectionHolder.connected(ConnectionHolder.java:125)
at io.vertx.core.eventbus.impl.clustered.ConnectionHolder.lambda$connect$0(ConnectionHolder.java:58)
at io.vertx.core.net.impl.NetClientImpl.lambda$connect$1(NetClientImpl.java:67)
at io.vertx.core.net.impl.NetClientBase.lambda$connected$6(NetClientBase.java:242)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:335)
at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:193)
at io.vertx.core.net.impl.NetClientBase.connected(NetClientBase.java:240)
at io.vertx.core.net.impl.NetClientBase.lambda$doConnect$5(NetClientBase.java:212)
at io.vertx.core.net.impl.ChannelProvider.lambda$connect$0(ChannelProvider.java:40)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:481)
at io.netty.util.concurrent.DefaultPromise.access$000(DefaultPromise.java:34)
at io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:431)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you add a test and sign the commit ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vertx suppot a timeout in the request, but that timeout start as soon as the method i invoked.
I believe that Vertx should support a 'requestTimeout'.
This means the timeout should apply only after the connection is stablished and the request starts.
To illustrate this, the following snipet will describe it:
final HttpClientRequest req = client.request(HttpMethod.GET, 80, "localhost", "/");
        req.connectionHandler(context -> System.out.println("connection id -> " + context.hashCode()));
        req.setTimeout(timeout); // timer started
        vertx.setTimer(timeout * 2, id -> { // waiting before requesting the data to trigger the timeout above
            req.toObservable().
                    flatMap(resp -> {
                        if (resp.statusCode() != 200) {
                            throw new RuntimeException("Wrong status code " + resp.statusCode());
                        }
                        return resp.toObservable();
                    }).
                    subscribe(data -> System.out.println(data.toString()),
                            error -> System.out.println("handled error: " + error.getMessage())); // I except this error in case of a timeout
            req.end();
        });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the SockJSSession uses the transport for write/close operations from any thread. This can cause deadlocks when used from external threads or because the transport thread has changed (for instance a session reconnection with an scaled http server).
It can be fixed by recording the transport context when the transport is associated with the session (register method) and doing a runOnContext when the current context is not the same. This shall also prevent race conditions for instance a write operation is scheduled from a non vertx thread, the register method is called and gives a new transport to the session. In this case the write will be rescheduled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If i create an new NetServer and start it, the server doesnt start and i get the following log:
Okt. 15, 2017 12:15:38 VORM. io.netty.util.internal.PlatformDependent <clinit>
INFORMATION: Your platform does not provide complete low-level API for accessing direct buffers reliably. Unless explicitly requested, heap buffer will always be preferred to avoid potential system unstability.
Okt. 15, 2017 12:15:38 VORM. io.netty.resolver.dns.DnsServerAddresses <clinit>
WARNUNG: Default DNS servers: [/8.8.8.8:53, /8.8.4.4:53] (Google Public DNS as a fallback)
Okt. 15, 2017 12:15:39 VORM. io.netty.channel.DefaultChannelId defaultProcessId
WARNUNG: Failed to find the current process ID from ''; using a random value: 1525904935
Couldnt start network server: java.lang.IllegalStateException: failed to create a new resolver

System Details
Java Version: 1.9
OS: Windows 10
Vert.x Version: 3.4.2 (newest)
Reproduction Code
package com.jukusoft.vertx.server;

import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.net.NetServer;
import io.vertx.core.net.NetServerOptions;

public class Server {

    //vert.x options
    protected VertxOptions vertxOptions = null;

    //instance of vert.x
    protected Vertx vertx = null;

    //vert.x network server
    protected NetServer netServer = null;

    public void start() {
        //create new vertx.io options
        this.vertxOptions = new VertxOptions();

        //create new instance of vertx.io
        this.vertx = Vertx.vertx(this.vertxOptions);

        //create options for TCP network server
        NetServerOptions netServerOptions = new NetServerOptions();

        //TODO: replace this later
        int port = 2200;

        //set port
        netServerOptions.setPort(port);

        //create new instance of TCP network server
        this.netServer = this.vertx.createNetServer(netServerOptions);

        //add connection handler
        netServer.connectHandler(socket -> {
            System.out.println("new connection accepted, ip: " + socket.remoteAddress().host() + ", port: " + socket.remoteAddress().port());

            //TODO: do something with socket, for example send an message
        });

        //start network server
        this.netServer.listen(res -> {
            if (res.succeeded()) {
                System.out.println("ERP Server is now listening on port " + res.result().actualPort());
            } else {
                System.err.println("Couldnt start network server: " + res.cause());
            }
        });
    }

    public void stutdown() {
        //close network server
        netServer.close(res -> {
            if (res.succeeded()) {
                System.out.println("Server was shutdown now.");

                //close vertx.io
                vertx.close();
            } else {
                System.out.println("Server couldnt be closed.");
            }
        });
    }

}

module-info.java:
module erp.server {
    requires java.base;

    //dependencies
    requires vertx.core;

    requires jdk.unsupported;

    //exports
    exports com.jukusoft.erp.server;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the ECA + commit ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SSLHelper has:
  private static final String[] DEFAULT_ENABLED_PROTOCOLS = {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"};

However later builds up the enabled protocol list with:
protocols.retainAll(Arrays.asList(engine.getEnabledProtocols()));

And since netty by default does not enable SSLv2Hello (ref ), SSLv2Hello in fact is not enabled, and I believe it is not possible to enable any protocols other than TLSv1/1.1/1.2.
This could be regarded as a feature as it prevents developers selecting insecure protocols, however is confusing that addEnabledSecureTransportProtocol will only actually work if its  TLSv1/1.1/1.2.
Could be fixed by removing SSLv2Hello from the default list to make it less confusing, and maybe documenting what protocols are available. Or by re-enabling all protocols by changing
protocols.retainAll(Arrays.asList(engine.getEnabledProtocols()));

to
protocols.retainAll(Arrays.asList(engine.getSupportedProtocols()));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to send the same user message to same verticle,can eventbus support message route?
eg:
user a->verticle a
user b->verticle a
user c->verticle b
user d->verticle b
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When the client closes the connection, I can keep on calling HttpServerResponse.write forever without any indication of an error, I don't even get an exception in my exception handler.
It would be better to throw something.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
currently the PR cannot be merged, so you should sign the commit with the right email with a commit --amend and a push --force on your PR branch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The readme file says to build vertx by issuing the following command:
mvn package

However this results in the following error:
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building Vert.x Core 3.5.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[WARNING] The POM for io.vertx:vertx-codegen:jar:3.5.1-SNAPSHOT is missing, no dependency information available
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.825 s
[INFO] Finished at: 2017-10-20T10:45:32+02:00
[INFO] Final Memory: 13M/594M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal on project vertx-core: Could not resolve dependencies for project io.vertx:vertx-core:jar:3.5.1-SNAPSHOT: Failure to find io.vertx:vertx-codegen:jar:3.5.1-SNAPSHOT in https://oss.sonatype.org/content/repositories/snapshots was cached in the local repository, resolution will not be reattempted until the update interval of sonatype-nexus-snapshots has elapsed or updates are forced -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/DependencyResolutionException

I guess there is some step missing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi all,
First of all, Thank you for the amazing work with vertx.
I am testing the Version 3.5.0 with an nginx reverse proxy.
If I turn off the keep-alive functionality, the HttpServerResponseImpl is not answering anything.
You can test using the following HTTP requests:
Not working
GET / HTTP/1.0.
Host: my-server.com
X-Real-IP: 127.0.0.1.
X-Forwarded-For: 127.0.0.1.
Connection: close.
Cache-Control: max-age=0.
Upgrade-Insecure-Requests: 1.
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36.
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8.
Accept-Encoding: gzip, deflate.
Accept-Language: pt-BR,pt;q=0.8,en-US;q=0.6,en;q=0.4.
.

Working
GET / HTTP/1.1.
Host: my-server.com
X-Real-IP: 127.0.0.1.
X-Forwarded-For: 127.0.0.1.
Cache-Control: max-age=0.
Upgrade-Insecure-Requests: 1.
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36.
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8.
Accept-Encoding: gzip, deflate.
Accept-Language: pt-BR,pt;q=0.8,en-US;q=0.6,en;q=0.4.
.

This is because of the Connection: close
After a debug, I found that if HttpServerResponseImpl line 442 keepAlive is false, it is working as expected
    if (!keepAlive) {
      closeConnAfterWrite();
      closed = true;
    }
So I suspect that the closeConnAfterWrite is not working as expected.
I would appreciate if you can take a look on it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh no!  Same issue.  I'm sorry this is being such a pain.   I wonder is it checking the public facing email address for my github account instead of or as well as the one I used in the commit message?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Woo hoo!  I ended up even deleting the fork and re-forking, just to be safe
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I need some type such as java.util.Date . Type conversion is a very painful
thing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't get result for this sql . (PS: I want to get the type)
"update  table set ****     returning  type".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you give an explanation of the change ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
By switching to 3.5 from 3.4.2 on build, when it comes to god generation:
for the
@VertxGen
@ProxyGen
public interface MyService {

Could not generate model for com.my.MyService ...

Could not load template /vertx-js/template/common.templ from template jar:file:/../.m2/repository/io/vertx/vertx-sockjs-service-proxy/3.5.0/vertx-sockjs-service-proxy-3.5.0.jar!/vertx-sockjs-service-proxy/template/proxygen.templ

Was it dramatically modified ? no explanation why it can not load it.
--

org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.0:compile (default-compile) on project my-api: Compilation failure
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)
at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)
at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)
at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.compiler.CompilationFailureException: Compilation failure
at org.apache.maven.plugin.compiler.AbstractCompilerMojo.execute(AbstractCompilerMojo.java:1029)
at org.apache.maven.plugin.compiler.CompilerMojo.execute(CompilerMojo.java:137)
at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)
... 20 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For unit testing code which uses cluster-related APIs (eg io.vertx.core.shareddata.SharedData.getClusterWideMap()) in a non-clustered environment it would be very handy if the class io.vertx.test.fakecluster.FakeClusterManager were exposed. Otherwise there seems to be no way of unit testing such code ("Can't get cluster wide map if not clustered") - except by writing another dummy/local ClusterManager.
This class can be accessed via the dependency 'io.vertx:vertx-core:3.5.0:tests' but it doesn't seem to be documented anywhere, and I imagine that the contents of the tests jar are subject to change.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Following the vertx rx-java 2 documentation, it seems there's a easy way to transform a read stream into a flowable, using the FlowableHelper.toFlowable utility method, but nothing for write streams.
The documentation uses the following example to send data from rx-java to the eventbus:
observable.
    buffer(1, TimeUnit.SECONDS).
    map(samples -> samples.
        stream().
        collect(Collectors.averagingDouble(d -> d))).
    subscribe(heat -> {
      vertx.eventBus().send("news-feed", "Current heat is " + heat);
    });

But if you send messages to the eventbus in the subscribe method, you cannot handle backpressure correctly (I've an example that hangs if I send too many messages, but I don't get any exception to confirm that backpressure is the only problem).
Is there a way to turn a write stream into a Subscriber?
E.g.:
Subscriber<X> subs = FlowableHelper.toSubscriber(vertx.eventBus().publisher("address"));
observable.subscribe(subs);

Or something similar..
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am running a service using Vert.x v3.5.0 with setPreferNativeTransport(true) in VertxOptions. I am seeing periodic warnings in the logs:
2017-10-30 xx:xx:xx,xxx WARN  [vert.x-acceptor-thread-0] ServerBootstrap: Unknown channel option 'io.netty.channel.unix.UnixChannelOption#SO_REUSEPORT' for channel '[id: 0xd5573f68, L:/10.xxx.xxx.xxx:8080 - R:/10.xxx.xxx.xxx:25442]'

Please advise
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After bumping up to Vert.x 3.5.0 I get this error when http server is starting:
2017-10-31 20:31:40 [vert.x-eventloop-thread-1] [ERROR] Server - Unable to create Channel from class class io.netty.channel.socket.nio.NioServerSocketChannel
Any ideas what could've gone wrong?
`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I got NullPointerException, during serving some of requests on vertx 3.5.0
The issue is not occurring on vertx 3.4.2 and 3.3.3.
I am using java 8 (exception occurred on Windows and Linux)
Problem occurred with both ssl enabled and ssl disabled options
The full stack trace is:
java.lang.NullPointerException
	at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:444)
	at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:156)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:661)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:614)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:150)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:342)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:200)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:148)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.HttpServerImpl$Http2UpgradeHandler.channelRead(HttpServerImpl.java:929)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
	at io.netty.handler.codec.MessageToMessageCodec.channelRead(MessageToMessageCodec.java:111)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1336)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1127)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1162)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)

Thanks in advance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I got an error when I have requested url /%7B%channel%%7D on vert.x 3.5.0
nov 01, 2017 2:31:31 PM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.NumberFormatException: For input string: "ch"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at io.vertx.ext.web.impl.Utils.decodeUnreserved(Utils.java:87)
	at io.vertx.ext.web.impl.Utils.normalizePath(Utils.java:145)
	at io.vertx.ext.web.impl.RouteImpl.pathMatches(RouteImpl.java:340)
	at io.vertx.ext.web.impl.RouteImpl.matches(RouteImpl.java:246)
	at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:93)
	at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:120)
	at io.vertx.ext.web.impl.RoutingContextImpl.doFail(RoutingContextImpl.java:452)
	at io.vertx.ext.web.impl.RoutingContextImpl.fail(RoutingContextImpl.java:153)
	at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:107)
	at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:120)
	at io.vertx.ext.web.impl.RouterImpl.accept(RouterImpl.java:79)
	at io.vertx.rxjava.ext.web.Router.accept(Router.java:91)
	at io.github.avkv1.campixy.webrtc.WebRTCServer$start$1.invoke(WebRTCServer.kt:60)
	at io.github.avkv1.campixy.webrtc.WebRTCServer$start$1.invoke(WebRTCServer.kt:22)
	at io.github.avkv1.campixy.webrtc.WebRTCServerKt$sam$Handler$2c62e049.handle(WebRTCServer.kt)
	at io.vertx.rxjava.core.http.HttpServer$1.handle(HttpServer.java:108)
	at io.vertx.rxjava.core.http.HttpServer$1.handle(HttpServer.java:106)
	at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:444)
	at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:156)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:661)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:614)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:150)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:342)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:200)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:148)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.HttpServerImpl$Http2UpgradeHandler.channelRead(HttpServerImpl.java:929)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:49)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:27)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm having problems with starting a webserver on Windows10 since updating to 3.5.0:
[vert.x-eventloop-thread-1 @coroutine#50] DEBUG i.n.r.d.UnixResolverDnsServerAddressStreamProvider - failed to parse /etc/resolv.conf and/or /etc/resolver
    java.lang.IllegalArgumentException: \etc\resolv.conf didn't provide any name servers

Might also be a result of adding coroutine support to my app...
Is this a known issue? Any workaround?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I noticed that turning TRACE for io.vertx outputs HTTP server logs, but unfortunately no HTTP client logs. I am using swagger-codegen to generate clients dynamically and thus would love to see what goes on over the wire -- I currently use a packet analyzer to inspect, but obviously that rules out HTTPS. I created a branch in my fork (https://github.com/myok12/vert.x/tree/tracing_http_client) and can send a pull request (I have signed the ECA) or can have you copy my changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
happens only on osx with the following exception
[WARN] i.n.c.n.NioEventLoop - Unexpected exception in the selector loop. 
java.io.IOException: Invalid argument
    at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
    at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
    at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:117)
    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
    at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
    at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:753)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:409)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
    at java.lang.Thread.run(Thread.java:748)

can be reproduced by the following test
vertx 3.5.0, darwin 16.7.0, oracle jdk 1.8.0_152
  @Test
  public void test10yTimer(final TestContext ctx) {
    final Async async = ctx.async();
    final Vertx vertx = Vertx.vertx();
    vertx.setTimer(1000L * 60 * 60 * 24 * 365 * 10, t -> {
      logger.info("10y timer");
      async.complete();
    });
  }

different behavior on linux systems (as well higher delays are needed for the test)
vertx 3.5.0, linux 4.13.9, openjdk 1.8.0_144
  @Test
  public void test300yTimer(final TestContext ctx) {
    final Async async = ctx.async();
    final Vertx vertx = Vertx.vertx();
    vertx.setTimer(1000L * 60 * 60 * 24 * 365 * 300, t -> {
      logger.info("300y timer");
      async.complete();
    });
  }

the timer immediately triggers without any error or exception
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I was trying to create a simple application with vert.x (version 3.5.0) and Java 9 and encounter a (potential) bug. Steps to reproduce:

Create HTTP server configure a router with handler using method reference (introduced since Java 8).
Access the same route from any HTTP client and it will throw a NPE:

SEVERE: Unexpected exception in route
java.lang.NullPointerException
	at io.vertx.ext.web.impl.RouteImpl.handleContext(RouteImpl.java:223)
	at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:101)
	at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:120)
	at io.vertx.ext.web.impl.RouterImpl.accept(RouterImpl.java:79)
	at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:444)
	at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:156)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:661)
	at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:614)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:150)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:342)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:200)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:148)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.HttpServerImpl$Http2UpgradeHandler.channelRead(HttpServerImpl.java:929)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:49)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:27)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.base/java.lang.Thread.run(Thread.java:844)



Here is my code:
public void run() {
	Vertx vertx = Vertx.factory.vertx();
	HttpServer server = vertx.createHttpServer();
		
	Router restAPI = Router.router(vertx);
	restAPI.post("/msg").handler(controller::handle);
		
	server.requestHandler(restAPI::accept).listen(8080);
}

the handle method is just:
rc.response().end("Hello");

If I don't use method reference, but use lambda directly, like
restAPI.post("/msg").handler(rc -> {
    rc.response().end("Hello");
});

then it will work fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Launcher method beforeStartingVertx gives you an opportunity to modify the supplied VertxOptions instance, but this must be done by modifying the provided options instance directly.  In our Launcher extension we read "override" options from a JSON file and it would be nice to have an easy way to override the existing options settings with the contents of the JSON file.
We used to do this using VertxOptionsConverter.fromJson, but that class is now package private, so that doesn't work anymore.  There are constructors on VertxOptions that allow for the overlay of either JSON or another VertxOptions instance, but those don't work for overlaying an existing instance.
Something along the lines of fromJson or fromOptions as instance methods on VertxOptions would be great.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when I use  version 3.5 vertx,it always appears
java.lang.IllegalArgumentException: \etc\resolv.conf didn't provide any name servers,my system is Windows ,
so I want to ask reason,why?
`
2017-11-09 17:45:33 --> failed to parse /etc/resolv.conf and/or /etc/resolver
---------------------->  at io.netty.util.internal.logging.Slf4JLogger.debug(Slf4JLogger.java:86)
java.lang.IllegalArgumentException: \etc\resolv.conf didn't provide any name servers
at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.(UnixResolverDnsServerAddressStreamProvider.java:98)
at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.(UnixResolverDnsServerAddressStreamProvider.java:124)
at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parseSilently(UnixResolverDnsServerAddressStreamProvider.java:66)
at io.netty.resolver.dns.DnsServerAddressStreamProviders.(DnsServerAddressStreamProviders.java:28)
at io.netty.resolver.dns.DnsNameResolverBuilder.(DnsNameResolverBuilder.java:54)
at io.vertx.core.impl.resolver.DnsResolverProvider$1$1.newNameResolver(DnsResolverProvider.java:137)
at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:86)
at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:73)
at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
at io.vertx.core.impl.resolver.DnsResolverProvider$1.newResolver(DnsResolverProvider.java:184)
at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
at io.vertx.core.impl.AddressResolver.resolveHostname(AddressResolver.java:83)
at io.vertx.core.impl.VertxImpl.resolveAddress(VertxImpl.java:766)
at io.vertx.core.net.impl.AsyncResolveConnectHelper.doBind(AsyncResolveConnectHelper.java:87)
at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:344)
at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:226)
at verticle.MainVerticle.start(MainVerticle.java:15)
at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:111)
at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$10(DeploymentManager.java:481)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:344)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at java.lang.Thread.run(Unknown Source)
`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The context.request().remoteAddress() return is remote ipbut I expect is domain name.
otherwize return the port is not remote http port of the request.
How should I do
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I type the code refer to the web http://vertx.io/docs/vertx-core/java/#_multicast , but when I sent the data buffer to 230.0.0.1 for a test, the MulticastReciver's handler doesn't print the data string.
the Sender class code:
public class McS {
    public static void main(String[] args) throws UnknownHostException, SocketException {
        DatagramSocket socket = Vertx.vertx().createDatagramSocket(new DatagramSocketOptions().setReuseAddress(true).setMulticastNetworkInterface(NetworkInterface.getByInetAddress(InetAddress.getByName("192.168.16.4")).getName()));
        Buffer buffer = Buffer.buffer("content");
        socket.send(buffer, 1234, "230.0.0.1", asyncResult -> {
            System.out.println("Send succeeded? " + asyncResult.succeeded());
        });
    }
}
the Receiver class code:
public class Mc {
    public static void main(String[] args) throws UnknownHostException, SocketException {
        DatagramSocket socket = Vertx.vertx().createDatagramSocket(new DatagramSocketOptions().setReusePort(true).setReuseAddress(true).setMulticastNetworkInterface(NetworkInterface.getByInetAddress(InetAddress.getByName("192.168.16.4")).getName()));
        socket.listen(1234, "192.168.16.4", asyncResult -> {
            if (asyncResult.succeeded()) {
                // join the multicast group
                socket.listenMulticastGroup("230.0.0.1", asyncResult2 -> {
                    System.out.println("Listen succeeded? " + asyncResult2.succeeded());
                });
                socket.handler(packet -> {
                    // Do something with the packet
                    System.out.println("mul+:"+packet.data().toString());
                });
            } else {
                System.out.println("Listen failed" + asyncResult.cause());
            }
        });
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP/2 connection must wait for the first settings frame before being delivered so the max concurrency is known and the client can exceed the number of concurrency streams because they are created with an incorrect max concurrency.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Provide a better implementation of the HttpClient pool: the current pool has a few drawbacks, race conditions , inconsistencies and is tightly coupled to the logic for establishing HTTP connections.
The new pool only retains the logic of managing connections and the HTTP logic has been factored out. The pool is a state machine that reacts to events and tries to progress to satisfy the waiter list based on the connections managed by the pool and the connection provider to create new connections.
The logic for managing effectively connections has been factored out of the pool, leaving room for reusing this pool potentially in other components that would need a pool with similar behavior. This also allow to build establish HTTP connection without the pool (i.e by promoting an existing socket into an HTTP connection).
The pool also clarifies that the connection waiter will always be called on the connection event loop without owning a lock from the pool, to avoid deadlock reentrency with the pool lock.
The fallback from HTTP/2 to HTTP/1 has also be improved, the previous way was switching the HTTP/2 pool by the HTTP/1 pool. The new pool provides instead a way to deal with both at the same time and honour the max pool capacity consistently.
The HTTP/1 pipelining accounting logic has been retrofitted into the pool and is not anymore handled by the HTTP/1 connections, HTTP/1 connections only schedule the pending requests on the connection reactively.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation: currently a verticle that fails its deployment although it has successfully deployment children verticles does not have its children automatically deployed although its close hooks are called. This force the developer to take care of undeploying explicitely the children verticle in this situation.
Change: when a verticle fails its deployment, the deployed children verticle are undeployed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This makes it awkward to use the io.vertx.core.http.HttpHeaders constants, which are CharSequences, with the generated versions (e.g., io.vertx.reactivex).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are observing HttpClient connection leaks due to exceptions in receiving inbound messages in certain conditions.
The leak we are seeing is caused by io.netty.handler.codec.compression.DecompressionException, but there could be other cases that trigger the similar leaking situation.
Some details about the case we are seeing: when a client has tryUseCompression set to true, and a server returns Content-Encoding: gzip in a response header, BUT then returns an invalid gzip response (could simply be some plain texts) for some reasons, DecompressionException is thrown, but the connection is not properly cleaned up.
So far we suspect the direct cause of the issue is that VertxHandler.channelInactive is not fired after a channel is closed by exceptionCaught. But we are not sure the problem is in netty or vertx.
Here is a unit test to reproduce the issue:
https://github.com/brian65535/connection_leak
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a web-static handler in one of my verticle.
It used to work.
@OverRide
public void start(Future startFuture) {
configureHttpServer(startFuture);
...
where
private void configureHttpServer(Future future) {
    int PORT = config().getInteger("http.port");

    // TODO: for tests
    router.route("/*").handler(StaticHandler.create());

    vertx.createHttpServer()
        .requestHandler(router::accept)
        .listen(PORT, ar -> {
            if (ar.failed()) {
                future.fail(ar.cause());
            } else {
                future.complete();
            }
        });
}

Now when I start and try to connect in browser to "/" or "/index.html"
Nov 16, 2017 9:52:29 PM io.vertx.ext.web.impl.RoutingContextImplBase
SEVERE: Unexpected exception in route
java.lang.NullPointerException
at io.vertx.ext.web.handler.impl.StaticHandlerImpl.isFileExisting(StaticHandlerImpl.java:261)
Did I miss something? Should it still work?
in /resources/webroot I have index.html that is used to show some content.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it would be simpler if LocalMapImpl implements directly AsyncMap
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In a project, I started four verticle, is it normal to used 680+M memory?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the following source,the findAny () method returns the first element of the set forever, unable to achieve the load balance.

Do you need to achieve your own load balancing?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a class that can have additional payload field as JsonObject. When i try decode my class i am getting DecodeException. I can avoid this if field are simple Object and my getter return payload like new JsonObject((Map<String, Object>) payload).  JsonObject misses deserializer. Are that intended behavior?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm referring to the securityGroup(String groupName) method in the org.openstack4j.model.network.builder.PortBuilder interface (and subsequently to the only implementing class org.openstack4j.openstack.networking.domain.NeutronPort).
The only parameter is String groupName and this is incorrect and misleading because the underlying OpenStack REST requires security group ID, as is seen in the following link https://developer.openstack.org/api-ref/network/v2/ under the POST /v2.0/ports create Port method.
I believe this is only a naming issue because the method produced a desired result when provided with the group ID instead of a group name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
waiting for CQ resolution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
question 1
I use debian linux, and Let's Encrypt ecc 256 with command:
acme.sh --issue -w /www/demo.com -d demo.com --keylength ec-256

it's should ec-256 (prime256v1, "ECDSA P-256"), but i can not listen port with this cert(but vertx is running without error), code as
package com.example.demo;

import java.util.*;
import io.vertx.core.*;
import io.vertx.core.http.*;
import io.vertx.core.net.*;
import io.vertx.core.json.*;
import io.vertx.ext.web.*;
import io.vertx.ext.web.handler.*;

public class MainVerticle extends AbstractVerticle {

    @Override
    public void start() throws Exception {

        Router router = Router.router(vertx);

        router.route().handler(VirtualHostHandler.create("a.demo.com", req -> {
              req.response().putHeader("content-type", "text/plain").end("a.demo.com");
        }));

        router.route().handler(VirtualHostHandler.create("b.demo.com", req -> {
              req.response().putHeader("content-type", "text/plain").end("b.demo.com");
        }));

        HttpServerOptions options = new HttpServerOptions()
            .setSsl(true)
            .setSni(true)
            .setUseAlpn(true)
            .setOpenSslEngineOptions(new OpenSSLEngineOptions())

            .addEnabledCipherSuite("ECDHE-RSA-AES128-SHA256")
            .addEnabledCipherSuite("ECDHE-RSA-AES128-GCM-SHA256")
            .addEnabledCipherSuite("ECDHE-RSA-AES256-SHA256")
            .addEnabledCipherSuite("ECDHE-RSA-AES256-GCM-SHA256")
            .addEnabledCipherSuite("ECDHE-ECDSA-AES128-SHA256")
            .addEnabledCipherSuite("ECDHE-ECDSA-AES128-GCM-SHA256")
            .addEnabledCipherSuite("ECDHE-ECDSA-AES256-SHA256")
            .addEnabledCipherSuite("ECDHE-ECDSA-AES256-GCM-SHA256")

            //.addEnabledSecureTransportProtocol("TLSv1.1")
            .addEnabledSecureTransportProtocol("TLSv1.2")
            //.addEnabledSecureTransportProtocol("TLSv1.3")

            .setPemKeyCertOptions(new PemKeyCertOptions()
                    .setKeyPaths(Arrays.asList(
                            "/path/to/file.key"
                    ))
                    .setCertPaths(Arrays.asList(
                            "/pat/to/file.cer"
                    )));

        vertx.createHttpServer(options).requestHandler(router::accept).listen(8080);

    }
}

gradle dependencies
def vertxVersion = '3.5.0'

dependencies {
//  compile "io.netty:netty-tcnative:2.0.0.Final:linux-x86_64"
     compile "io.netty:netty-tcnative-boringssl-static:2.0.7.Final"
//  compile "io.netty:netty-tcnative:1.1.33.Fork16"
//  compile "io.netty:netty-tcnative:2.0.0.Final"
     compile "io.vertx:vertx-core:$vertxVersion"
     compile "io.vertx:vertx-web:$vertxVersion"
//  compile "io.vertx.ext.web.handler:$vertxVersion"

  testCompile "junit:junit:4.12"
  testCompile "io.vertx:vertx-unit:$vertxVersion"
}


but, when i not use ecc cert with acme.sh command:
acme.sh --issue -w /www/demo.com -d demo.com

all thing is ok, https 8080 can work.
question 2
openssl can not work, show error "openssl not found"
but netty-tcnative-boringssl-static can work, as gradle dependencies comment.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, it seems the only way is programmatically. It would be very convenient to have system property to enable that
Vertx vertx = Vertx.vertx(new VertxOptions().
  setPreferNativeTransport(true)
);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
DnsResolverProvider loads hosts file when only in constructor of DnsResolverProvider. The problem is that when hosts file is modified, vertx does not recognize it because of no load of hosts file(except in the constructor).
I think there is no way to dynamically load it again while vertx is running. Is there any way to solve it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We recently upgraded to vertx 3.5 and are seeing this exception in our logs
Stack Trace:
java.lang.NullPointerException: null
    at io.vertx.core.http.impl.WebSocketImplBase.handleFrame(WebSocketImplBase.java:266)
    at io.vertx.core.http.impl.ServerConnection.handleWsFrame(ServerConnection.java:336)
    at io.vertx.core.http.impl.ServerConnection.processMessage(ServerConnection.java:452)
    at io.vertx.core.http.impl.ServerConnection.handleMessage(ServerConnection.java:156)
    at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:671)
    at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:614)
    at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:150)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:342)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:200)
    at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:148)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
    at java.lang.Thread.run(Thread.java:745)

We don't have (or need) a pong handler attached to the ServerWebSocket instance but have clients that will send pong frames to our websocket servers, so we see this exception being logged.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vert.x core: 3.5.0
vert.x web: 3.5.0
Description
Intermittent erro generated when  there are too many concurrency connections.
Trace
java.lang.NullPointerException
        at io.vertx.ext.web.handler.sockjs.impl.SockJSSession.writePendingMessages(SockJSSession.java:269)
        at io.vertx.ext.web.handler.sockjs.impl.SockJSSession.lambda$write$1(SockJSSession.java:124)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:344)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There's no way for a user to discover a bind exception occurred, except to crawl through the log.
See line 347 in   io.vertx.core.http.impl.HttpServerImpl.java
344          bindFuture = AsyncResolveConnectHelper.doBind(vertx, SocketAddress.inetSocketAddress(port, host), bootstrap);
345          bindFuture.addListener(res -> {
346            if (res.failed()) {
347              vertx.sharedHttpServers().remove(id);  <-------
348            } else {
If a BindException occurs, the server is removed, but the caller isn't notified.
The exceptionHandler(new BindException(host+":"+port)) should be called.
Yes, a BindException is thrown and caught already,
but there's no way for the caller to discover it...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is no easy way to test that an HTTP header is present and has a given value:
    String value = HttpHeaders.WEBSOCKET.toString();
    boolean upgrade = headers.getAll(HttpHeaders.UPGRADE).stream()
      .anyMatch(val -> val.equalsIgnoreCase(value));
Drawbacks:

Testing a header value is a common task, especially if you write edge services or API gateways
The header value in this example should be tested in a case-insensitive way; so the HttpHeaders constant must be first converted to String (no equalsIgnoreCase on CharSequence)
A list of all headers needs to be created before testing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you please take a look? I split the change so that each commit message explains the motivation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you describe what it fixes ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I found that Vertx HttpClient DEFAULT_HANDLER uses java.net.URI.getQuery instead of getRawQuery when extracts a redirection uri from response location header.
Even Vertx HttpUitls.resolveURIReference uses java.net.URI.getQuery and then redirects it with decoded query.
java.net.URI.getQuery returns decoded query according to documents.
String java.net.URI.getQuery()

Returns the decoded query component of this URI.

The string returned by this method is equal to that returned by the getRawQuery method except that all sequences of escaped octets are decoded.

In my case, there are many cases that location header value includes URIEncoded query because my service covers not only english alphabet but also ascii unsafe language.
Redirection target server still needs URIEncoded query for ascii unsafe language.
I've made a patch for that referring to Apache httpClient where uses getRawQuery and then applied it with HttpClient.setRedirectinHandler.
I guess this issue not only for mine.
I think java.net.URI.getRawQuery is proper rather than getQuery.
Do you have any reason for using getQuery I'm not aware of?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Until in some situation, either the original name or the search domain resolved name was used in a resolution. Now both are always used, the only difference is in the resolution order according to the ndots value. This behavior change comes with Netty 4.1.19.Final version, Vert.x integration tests are updated accordingly to the new behavior.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
to

Netty 4.1.19.Final        : https://dev.eclipse.org/ipzilla/show_bug.cgi?id=15280
Jackson Core 2.9.3        : https://dev.eclipse.org/ipzilla/show_bug.cgi?id=15282
Jackson Databind 2.9.3    : https://dev.eclipse.org/ipzilla/show_bug.cgi?id=15283
Jackson Annotations 2.9.3 : https://dev.eclipse.org/ipzilla/show_bug.cgi?id=15284
Works-with                : https://dev.eclipse.org/ipzilla/show_bug.cgi?id=15285
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm playing around with vertx and vertx-web. I have a simple endpoint that produces a chunked response by endlessly printing "hello" once a second.
How do I detect when the client disconnects? Vertx doesn't seem to throw an exception when attempting to write to a disconnected client, and routingContext.response().closed() keeps returning false long after the client is gone.
Here's a minimal example, I'm using curl as the client:
public static void main(String[] args) {
	Vertx vertx = Vertx.vertx();
	HttpServer server = vertx.createHttpServer();
	Router router = Router.router(vertx);
	router.route("/hello").handler(rc -> {
		rc.response().setChunked(true).putHeader("Content-Type", "text/plain");
		vertx.setPeriodic(1000, l -> {
			if (rc.response().closed()) {
                System.out.println("Stopping"); //Doesn't happen
				vertx.cancelTimer(l);
			}
			try {
				System.out.println("hello"); // Keeps printing long after the client disconnects
				rc.response().write("hello\n");
			} catch (Exception e) {
				e.printStackTrace(); // Doesn't happen
				rc.response().close();
			}
		});

	});
	server.requestHandler(router::accept).listen(8080);
}

I'm using Vert.x 3.5.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The documentation for the "Asynchronous Verticle start and stop" section in the core documentation does not clearly explain what is necessary to make the verticle deloyment work asynchronously making initial use of vertx more frustrating than need be, especially because it uses verticle deployment in the example making it self referencing.
I would suggest adding some vertx.executeBlocking() code to the start method in the example code and referencing the "Running blocking code" section to show how it is done to make it clearer to first time users.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@boliza thanks. Looks good to me but it seems you haven't signed the Eclipse CLA. Can you do it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj PTAL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you signe the Eclipse Contributor Agreement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@wu-lee thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually  I do have code for that and I would like rather for 3.6 (I can push the code I have).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The WebSocket API should allow to set and receive the close frame payload.
ws.close(1000); // Close with a status code
ws.close(1000, "some reason");

Close frame should be propagated on the client, i.e before calling the close handler the websocket should forward a close frame with the status and reason.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/5eb55e8478fbe9ca1cb14aaef783a40857fee602/src/main/java/io/vertx/core/impl/DeploymentManager.java#L384
This line cause incompatibility with Java 9 , when combined with attempt to use isolation group.
Java 9

Java 8

As can bee seen, 8 v 9 uses different classloader while launching jar. Java 8 one is extending URLClassloader, Java 9 one is not
Can be tested by following project
vertx-test.zip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version: 3.5.0
We are using the SockJS support and specifically the part that allows you to send data to an open websocket via an event bus address.  When there is a socket which is under heavy load (lots of data being written over the bus) and that socket is closed, we sometimes see the following exceptions:
23:44:59.237 [vert.x-eventloop-thread-2] ERROR i.v.c.e.impl.HandlerRegistration - Failed to handleMessage. address: 43552bcc-57e8-42fc-91c6-26d5028aaa25
java.lang.IllegalStateException: WebSocket is closed
        at io.vertx.core.http.impl.WebSocketImplBase.checkClosed(WebSocketImplBase.java:253)
        at io.vertx.core.http.impl.WebSocketImplBase.writeBinaryMessage(WebSocketImplBase.java:156)
        at io.vertx.core.http.impl.ServerWebSocketImpl.writeBinaryMessage(ServerWebSocketImpl.java:43)
        at io.vertx.ext.web.handler.sockjs.impl.RawWebSocketTransport$RawWSSockJSSocket.write(RawWebSocketTransport.java:86)
        at io.vertx.ext.web.handler.sockjs.impl.SockJSSocketBase.lambda$new$0(SockJSSocketBase.java:70)
        at io.vertx.core.eventbus.impl.HandlerRegistration.deliver(HandlerRegistration.java:212)
        at io.vertx.core.eventbus.impl.HandlerRegistration.handle(HandlerRegistration.java:189)
        at io.vertx.core.eventbus.impl.EventBusImpl.lambda$deliverToHandler$3(EventBusImpl.java:538)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:344)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at java.lang.Thread.run(Thread.java:745)
23:44:59.237 [vert.x-eventloop-thread-2] ERROR io.vertx.core.impl.ContextImpl - Unhandled exception
java.lang.IllegalStateException: WebSocket is closed
        at io.vertx.core.http.impl.WebSocketImplBase.checkClosed(WebSocketImplBase.java:253)
        at io.vertx.core.http.impl.WebSocketImplBase.writeBinaryMessage(WebSocketImplBase.java:156)
        at io.vertx.core.http.impl.ServerWebSocketImpl.writeBinaryMessage(ServerWebSocketImpl.java:43)
        at io.vertx.ext.web.handler.sockjs.impl.RawWebSocketTransport$RawWSSockJSSocket.write(RawWebSocketTransport.java:86)
        at io.vertx.ext.web.handler.sockjs.impl.SockJSSocketBase.lambda$new$0(SockJSSocketBase.java:70)
        at io.vertx.core.eventbus.impl.HandlerRegistration.deliver(HandlerRegistration.java:212)
        at io.vertx.core.eventbus.impl.HandlerRegistration.handle(HandlerRegistration.java:189)
        at io.vertx.core.eventbus.impl.EventBusImpl.lambda$deliverToHandler$3(EventBusImpl.java:538)
        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:344)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
        at java.lang.Thread.run(Thread.java:745)

These are benign and we think due to the timing of processing in-flight events and the closing of the socket (that close does unregister the event bus consumer, but obviously not in a way that guarantees that no further messages will be processed by the handler).
Unfortunately for our deployed server this results in a near constant spam of these error messages (it doesn't happen all the time, but often enough that at scale we are getting at least one every few seconds).  We'd rather not turn the logger off entirely since sometimes errors like this indicate an actual problem.
Possible solutions:

Wrap the write to the socket at line 70 in SockJSSocketBase.java with a try/catch to consume the exception in this case.
Provide a way for us to replace the write handler used by the Socks code with our own so we can catch/consume the exception.
Guarantee that no data will be delivered to the handler after a close has occurred (not sure if that's possible/a good idea).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 18, 2018 7:19:00  io.vertx.ext.web.impl.RoutingContextImplBase
: Unexpected exception in route
freemarker.template.TemplateNotFoundException: Template not found for name "templates.ftl".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use zookeeper as a service storage, the application has just started running no problem, but the operation of the period of time the following error:

I think it is not connected in the source code is not caused by the release?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using WebClient.rxSendStream method to upload a large file(2GB) to remote server. The upload speed is normal in the beginning. But it became slower and slower, finally the OutOfMemoryError was thrown.
Vert.x version 3.5.0
Below is my code causing problem, I can consistently reproduce it:
Vertx vertx = Vertx.vertx();
WebClient client = WebClient.create(vertx, new WebClientOptions()
               .setDefaultHost("localhost")
               .setDefaultPort(3000));

vertx.fileSystem().rxOpen("largefile.tar", new OpenOptions())
               .flatMap(file ->client.put("/upload/largefile.tar").rxSendStream(file))
               .subscribe(resp -> {
                   System.out.println("response received: " + resp.statusCode());
               });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx-mysql-postgresql-client(3.5.0 version)
OS: windows 10;
List batch = new ArrayList<>();
JsonArray params = new JsonArray().add("val1").add("val2").add("val3");
batch.add(params);
SQLConnection connection = connect.result();
connection.batchWithParams("SQLQuery", batch, create -> {
System.out.println("batchWithParams");
connection.close();
});
As soon as the 'batchWithParams; method is called on SQLConnection, the event loop gets hanged, and no statements inside the handler are executed, and no exceptions are thrown. I'm facing similar issue while calling the 'batch' method of SQLConnection class as well.
I tried finding similar queries on this group, but couldn't find any relevant ones
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using swagger codegen to generate POJOs from an OpenAPI spec file, I obtain some objects of the following type:
...
public class MyClass extends HashMap<String, String> implements Serializable {
  private static final long serialVersionUID = 1L;

  @JsonProperty("name")
  private String name = null;

  public MyClass name(String name) {
    this.name = name;
    return this;
  }
...

When converting this particular object into a Vertx JsonObject (i.e. JsonObject json = JsonObject.mapFrom(obj);), only the key/value "fields" present in the hashtable are kept and not the extra fields present in my class e.g. name in the above example.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
Just curious if there is a recommended way to run a test on the context a verticle is using. Currently, I've solved it in by creating a super class method for integration type tests (https://github.com/pitchpoint-solutions/sfs/blob/master/sfs-server/src/test/java/org/sfs/integration/java/BaseTestVerticle.java) that contains a runOnServerContext method. A rule is responsible for deploying the verticles.
Here's an example of a test that uses the runOnServerContext method https://github.com/pitchpoint-solutions/sfs/blob/master/sfs-server/src/test/java/org/sfs/integration/java/test/blob/RemoteBlobActionsTest.java.
If I don't do this I run into deadlock issues when pumping (write/drain/resume calls) involves http client request/response instances and http server request/response instances since either the readstream or writestream context differs from the context used by the verticle.
In the case of the RemoteBlobActionsTest the test generates a file then attempts to pump it to a remote node using an httpclient associated with the SfsServer verticle. If the AsyncFile isn't opened in the server verticle context the pump deadlocks against the http client request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
Here's a reproducer for #2287. Perhaps it would make sense to bind an http client request to the context in which it is created (like AyncFile) instead of the context in which it's first used or throw an exception. In my case this is only an issue in tests since I need to access some of the internal sfs api associated with a verticle instance. Another option could enhance the vertx unit artifact by creating a rule to deploy a verticle and allow a test to be run in the context of a verticle instead of the context of the RunTestOnContext rule so that resources initialized for a test (AsyncFile) could be pumped to an http client request that made an initial connection using a verticle context. The example below is trivial... in a more complex application, it becomes difficult to manage the current behavior during test execution. A non trivial example of an api might look like volumeReplicaGroup.consume(size, newArrayList(MD5, SHA512), asyncFile) and the http clients used internally by the volume replica group may or may not already be bound to the verticle context instead of the test context asycFile is bound to (it would depend on if the verticle had attempted to use the client).
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.file.AsyncFile;
import io.vertx.core.file.OpenOptions;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.streams.Pump;
import io.vertx.core.streams.WriteStream;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.RunTestOnContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;


@RunWith(VertxUnitRunner.class)
public class Reproducer {

    @Rule
    public RunTestOnContext runTestOnContext = new RunTestOnContext();

    @Test
    public void testClientVerticlePumpsToServerVerticle(TestContext testContext) throws IOException, NoSuchAlgorithmException {
        final byte[] data = new byte[256];
        SecureRandom.getInstanceStrong().nextBytes(data);
        int dataSize = 256 * 1024 * 1024;


        final Path tempFile = Files.createTempFile("", "");

        int bytesWritten = 0;
        try (OutputStream out = Files.newOutputStream(tempFile)) {
            while (bytesWritten < dataSize) {
                out.write(data);
                bytesWritten += data.length;
            }
        }

        Async async = testContext.async();
        Vertx vertx = runTestOnContext.vertx();

        TestVerticleClient testVerticleClient = new TestVerticleClient();
        TestVerticleServer testVerticleServer = new TestVerticleServer();

        OpenOptions openOptions = new OpenOptions();
        openOptions.setRead(true);
        AsyncFile asyncFile = vertx.fileSystem().openBlocking(tempFile.toString(), openOptions);

        vertx.deployVerticle(testVerticleServer, serverDeployment -> {
            if (serverDeployment.failed()) {
                testContext.fail(serverDeployment.cause());
            }
            vertx.deployVerticle(testVerticleClient, clientDeployment -> {
                if (clientDeployment.failed()) {
                    testContext.fail(clientDeployment.cause());
                }
                try {
                    HttpClient clientVerticleHttpClient = testVerticleClient.getHttpClient();
                    HttpClientRequest httpClientRequest = clientVerticleHttpClient.post("/", httpClientResponse -> {
                        testContext.assertEquals(200, httpClientResponse.statusCode());
                        async.complete();
                    }).exceptionHandler(testContext::fail)
                            .putHeader(HttpHeaders.CONTENT_LENGTH, String.valueOf(dataSize))
                            .setTimeout(10000);

                    asyncFile.endHandler(aVoid -> httpClientRequest.end());
                    asyncFile.exceptionHandler(testContext::fail);

                    Pump pump = Pump.pump(asyncFile, httpClientRequest);
                    pump.start();
                } catch (Throwable e) {
                    testContext.fail(e);
                }
            });
        });
    }

    public static class TestVerticleClient extends AbstractVerticle {

        private HttpClient httpClient;

        @Override
        public void start(Future<Void> startFuture) {
            HttpClientOptions httpClientOptions = new HttpClientOptions();
            httpClientOptions.setDefaultHost("127.0.0.1");
            httpClientOptions.setDefaultPort(9999);
            httpClient = getVertx().createHttpClient(httpClientOptions);
            httpClient.post("/", event -> {
                System.out.println("Quick ping to associate connection to this context. If this is not done then no deadlock happens");
                startFuture.complete();
            }).setTimeout(20000)
                    .exceptionHandler(startFuture::fail)
                    .end();
        }

        public HttpClient getHttpClient() {
            return httpClient;
        }

        public Context getContext() {
            return context;
        }
    }

    public static class TestVerticleServer extends AbstractVerticle {

        @Override
        public void start(Future<Void> startFuture) {
            HttpServerOptions httpServerOptions = new HttpServerOptions();
            HttpServer httpServer = getVertx().createHttpServer(httpServerOptions).requestHandler(httpServerRequest -> {
                System.out.println("Server Received Request");
                httpServerRequest.pause();
                httpServerRequest.endHandler(event -> {
                    System.out.println("Server Ended Request");
                    httpServerRequest.response()
                            .setStatusCode(HttpURLConnection.HTTP_OK)
                            .end();
                });
                Pump pump = Pump.pump(httpServerRequest, new NullWriteStream());
                pump.start();
                httpServerRequest.resume();
            });
            httpServer.listen(9999, "127.0.0.1", event -> {
                if (event.failed()) {
                    startFuture.fail(event.cause());
                } else {
                    System.out.println("Server is listening on 127.0.0.1:9999");
                    startFuture.complete();
                }
            });
        }

        public Context getContext() {
            return context;
        }
    }

    public static class NullWriteStream implements WriteStream<Buffer> {

        private boolean dirty = false;
        private boolean ended = false;
        private Handler<Void> drainHandler;
        private Handler<Void> endHandler;

        public NullWriteStream() {
        }


        @Override
        public NullWriteStream write(Buffer data) {
            dirty = true;
            handleDrain();
            return this;
        }

        @Override
        public NullWriteStream exceptionHandler(Handler<Throwable> handler) {
            return this;
        }

        @Override
        public NullWriteStream setWriteQueueMaxSize(int maxSize) {
            return this;
        }

        @Override
        public boolean writeQueueFull() {
            return false;
        }

        @Override
        public NullWriteStream drainHandler(Handler<Void> handler) {
            this.drainHandler = handler;
            handleDrain();
            return this;
        }

        @Override
        public void end(Buffer buffer) {
            ended = true;
            handleEnd();
        }

        @Override
        public void end() {
            ended = true;
            handleEnd();
        }

        protected void handleDrain() {
            if (dirty) {
                dirty = false;
                Handler<Void> handler = drainHandler;
                if (handler != null) {
                    drainHandler = null;
                    handler.handle(null);
                }
            }
        }

        protected void handleEnd() {
            if (ended) {
                Handler<Void> handler = endHandler;
                if (handler != null) {
                    endHandler = null;
                    handler.handle(null);
                }
            }
        }
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am working in Red Hat OpenShift Application Runtimes and thus limited to using certain APIs in version 3.4.2 and earlier. There does not appear to be a simple way to view the older versions of the Documentation from the Vert.x web site. It would be awesome if we could view documentation from older versions of Vert.x easily.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello,
io.vertx.reactivex.core.shareddata.AsyncMap.This class does not provide the values method, is it a problem?
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While HTTP requests are fired against a vertx based HTTP server and a shutdown is initiated the following exceptions start appearing in the logs:
14:10:05.743 [vert.x-eventloop-thread-0] WARN  i.n.c.AbstractChannelHandlerContext - An exception '{}' [enable DEBUG level for full stacktrace] was thrown by a user handler's exceptionCaught() method while handling the following exception:
io.netty.channel.ChannelPipelineException: io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handlerAdded() has thrown an exception; removed.
	at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:626)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:235)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:201)
	at io.vertx.core.http.impl.HttpServerImpl.configureHttp1(HttpServerImpl.java:461)
	at io.vertx.core.http.impl.HttpServerImpl.access$700(HttpServerImpl.java:109)
	at io.vertx.core.http.impl.HttpServerImpl$1$1.configure(HttpServerImpl.java:319)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:48)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:27)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NullPointerException: null
	at io.vertx.core.http.impl.ServerHandler.handlerAdded(ServerHandler.java:47)
	at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:606)
	... 21 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
after upgrading to vert.x 3.5.0 we've been seeing a consistent problem with one of our service APIs: when replying with chunked responses over SSL, clients are reporting encoding errors when processing the response.
The problem is that after a certain load threshold (not sure if the number of such chunks of their size but I can consistently repro it in our service with >4000 chunks) the client will receive invalid chunks and break the connection.
On the server side the problem surfaces with a long list of ClosedChannelException instances which for me I believe was a red herring as a root cause. Trying to debug the service, I noticed that the exceptions are legitimate and caused by a Connection reset by peer exception which is swallowed by netty:
this = {SslHandler@4076}

ctx = {DefaultChannelHandlerContext@4077} "ChannelHandlerContext(ssl, [id: 0x09b97b73, L:/127.0.0.1:8444 - R:/127.0.0.1:63298])"

cause = {IOException@4081} "java.io.IOException: Connection reset by peer"

detailMessage = "Connection reset by peer"

The channel will then be closed and triggering the large number of ClosedChannelException instances when the originally scheduled zrange commands complete.
But there is no symptom on the server-side to describe an encoding problem so my hypothesis is that the client breaks the connection when it receives the first bad chunk thus triggering the Connection reset by peer which in turn surfaces the ClosedChannelException. So I think this is a symptom of a more delicate problem.
When this happens, curl -raw on the web server's endpoint will display some chunks but then stop with one of the following errors:
(...)
curl: (56) Malformed encoding found in chunked-encoding

(...)
curl: (56) Illegal or missing hexadecimal sequence in chunked-encoding

Other clients (see JavaScript below) report the same type of error:
      "name": "RequestError",
      "message": "Error: Parse Error",
      "cause": {
        "bytesParsed": 3,
        "code": "HPE_INVALID_CHUNK_SIZE",
        "cert": {}
      },
      "error": {
        "bytesParsed": 3,
        "code": "HPE_INVALID_CHUNK_SIZE",
        "cert": {}
      },

Also, comparing the payload observed by curl with what the server should provide, the chunk size appears to be correct every time but the chunk content is truncated at random points along the way.
All of the above leads me to believe that the response is indeed corrupted but I can't figure out why/when/how or by whom the chunked response is corrupted in the stack:
 at io.netty.handler.codec.http.HttpObjectEncoder.encodeChunkedContent(HttpObjectEncoder.java:165)
	  at io.netty.handler.codec.http.HttpObjectEncoder.encode(HttpObjectEncoder.java:138)
	  at io.vertx.core.http.impl.VertxHttpResponseEncoder.encode(VertxHttpResponseEncoder.java:35)
	  at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:88)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
	  at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816)
	  at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
	  at io.netty.handler.stream.ChunkedWriteHandler.doFlush(ChunkedWriteHandler.java:304)
	  at io.netty.handler.stream.ChunkedWriteHandler.flush(ChunkedWriteHandler.java:137)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)
	  at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)
	  at io.netty.channel.ChannelDuplexHandler.flush(ChannelDuplexHandler.java:117)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	  at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802)
	  at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814)
	  at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794)
	  at io.vertx.core.net.impl.ConnectionBase.write(ConnectionBase.java:100)
	  at io.vertx.core.net.impl.ConnectionBase.writeToChannel(ConnectionBase.java:110)
	  - locked <0xfd0> (a io.vertx.core.http.impl.ServerConnection)
	  at io.vertx.core.http.impl.ServerConnection.writeToChannel(ServerConnection.java:217)
	  at io.vertx.core.net.impl.ConnectionBase.writeToChannel(ConnectionBase.java:127)
	  at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:611)
	  at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:303)
	  at io.vertx.core.http.impl.HttpServerResponseImpl.write(HttpServerResponseImpl.java:58)

Other observations:

the problem is isolated to versions above 3.5.0 (does not repro in 3.5.0.Beta1 or below and the service code which triggers this behavior hasn't been changed in a while)
it only appears with https and toggling OpenSSL has no effect
for low number of chunks (less than 1000) it rarely reproduces on a cold service start but consistently reproduces afterwards
the actual payload (string content) does not affect it. Considering that there are times in which it does not reproduce with the same content, I believe it behaves like a race condition and not like an input validation bug
debugging appears to be adding synchronization and changes the behavior. I never succeeded in reproducing it while trying to observe this breakpoint. What I did was to condition the breakpoint to fire when contentLength == 0 (marking the end of the response). With the breakpoint enabled, it never reproduces. With the breakpoint muted, it always reproduces.
looking at the change history, my initial idea was that the change which added this behavior was due to this issue (Serialize messages sent to the connection in the order of the synchronization monitor) which was closed with these changes. But after confirming that all messages are written from the event-loop thread, I think it's not relevant.
HttpServerOptions.setMaxChunkSize has no effect.
HttpServerResponse.setWriteQueueMaxSize has no effect.

A reproducer can be consulted here.
Any pointers/help to get to the root cause of this issue would be greatly appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SSLv2Hello was already removed by the JDK7 enabled algorithms filtering applied, the patch #2279 makes it enabled by default - it should be disabled by default as this is what Java does since JDK7
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 3.5.0 issue
public static void main(String[] args) {
Vertx vertx = Vertx.vertx();
log.debug("start call");
vertx.executeBlocking(f->{
try {
for (int i =0 ; i< 10; i++){
Thread.sleep(10000);
}
f.complete();
}catch (Exception e){
f.fail(e);
}
},ar->{
log.debug("start end {}",ar.succeeded());
});
}
13:12:01.907 [vertx-blocked-thread-checker] WARN  i.v.c.i.BlockedThreadChecker - Thread Thread[vert.x-worker-thread-4,5,main] has been blocked for 61988 ms, time limit is 60000
io.vertx.core.VertxException: Thread blocked
but use 3.3.3 version is ok
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in my project, I can't get ttf file.
the response state is 403.
how can i do?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The use of:
String className = System.getProperty("vertx.logger-delegate-factory-class-name");
Thread.currentThread().getContextClassLoader().loadClass(className);
in io.vertx.core.logging.LoggerFactory can be problematic in "context ClassLoader sensitive environments", such as OSGi (but this could also affect use of Vert.x within other environments that do funky class loading); here are some links with background about why that is so:

http://njbartlett.name/2010/08/30/osgi-readiness-loading-classes.html
http://wiki.eclipse.org/Context_Class_Loader_Enhancements
https://helpx.adobe.com/experience-manager/kb/OsgiClassLoading3Party.html
https://issues.apache.org/jira/browse/FELIX-2951

I've actually run into this problem myself, see the detailed error below (which probably won't really make all that sense, without more context ; it's from https://github.com/vorburger/minecraft-storeys-maker/ running under https://github.com/vorburger/ch.vorburger.minecraft.osgi ... but ignore that).
I was able to work-around this in my code by instead of doing this:
System.setProperty("vertx.logger-delegate-factory-class-name", SLF4JLogDelegateFactory.class.getName());
vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(23));
using this beauty:
ClassLoader tccl = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
try {
    System.setProperty("vertx.logger-delegate-factory-class-name", SLF4JLogDelegateFactory.class.getName());
    vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(23));
} finally {
    Thread.currentThread().setContextClassLoader(tccl);
}
but in an ideal world... this kind of hand-stand should not be required?
One possible solution to this could be to offer an alternative to the system property and ClassLoader mess by simply letting users of Vert.x specify an instance of their desired io.vertx.core.spi.logging.LogDelegateFactory programmatically - I guess this would naturally fit into the io.vertx.core.VertxOptions.VertxOptions ?
Another solution, less flexible and IMHO best combined with above, would be to let io.vertx.core.logging.LoggerFactory try both (first) the getContextClassLoader() (as well as, if NOK) the LoggerFactory.class.getClassLoader().
Would a Pull Request proposing this via code be a welcome contribution to the Vert.x project?
Full background:
[00:07:57 ERROR] [ch.vorburger.osgi.builder.internal.SourceInstallServiceImpl]: Problem reading/installing bundle JAR: /home/vorburger/dev/Minecraft/git/minecraft-storeys-maker/web/build/libs/web-1.0.0-SNAPSHOT.jar
org.osgi.framework.BundleException: Activator start error in bundle web [30].
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2276) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.startBundle(Felix.java:2144) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:998) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:984) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at ch.vorburger.osgi.builder.internal.SourceInstallServiceImpl.lambda$installSourceBundle$0(SourceInstallServiceImpl.java:69) ~[4_ch.vorburger.osgi.gradle-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.osgi.builder.internal.SourceInstallServiceImpl.lambda$installSourceBundle$1(SourceInstallServiceImpl.java:102) ~[4_ch.vorburger.osgi.gradle-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.fswatch.DirectoryWatcherBuilder.firstListenerNotification(DirectoryWatcherBuilder.java:86) [4_ch.vorburger.osgi.gradle-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.fswatch.FileWatcherBuilder.build(FileWatcherBuilder.java:53) [4_ch.vorburger.osgi.gradle-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.osgi.builder.internal.SourceInstallServiceImpl.installSourceBundle(SourceInstallServiceImpl.java:117) [4_ch.vorburger.osgi.gradle-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.minecraft.osgi.dev.BundleManagerPersistence.installAndStartAll(BundleManagerPersistence.java:71) [5_ch.vorburger.minecraft.osgi.dev-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.minecraft.osgi.dev.BundleManager.<init>(BundleManager.java:50) [5_ch.vorburger.minecraft.osgi.dev-1.0.0-SNAPSHOT.jar:?]
	at ch.vorburger.minecraft.osgi.dev.internal.Activator.start(Activator.java:38) [5_ch.vorburger.minecraft.osgi.dev-1.0.0-SNAPSHOT.jar:?]
	at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697) [ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226) [ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.startBundle(Felix.java:2144) [ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:998) [ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:984) [ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at ch.vorburger.minecraft.osgi.OSGiFrameworkWrapper.installBundles(OSGiFrameworkWrapper.java:158) [OSGiFrameworkWrapper.class:?]
	at ch.vorburger.minecraft.osgi.OSGiFrameworkWrapper.installBundles(OSGiFrameworkWrapper.java:134) [OSGiFrameworkWrapper.class:?]
	at ch.vorburger.minecraft.osgi.OSGiFrameworkWrapper.installBootBundles(OSGiFrameworkWrapper.java:123) [OSGiFrameworkWrapper.class:?]
	at ch.vorburger.minecraft.osgi.Bootstrap.bootstrapMinecraftOSGi(Bootstrap.java:50) [Bootstrap.class:?]
	at ch.vorburger.minecraft.osgi.MinecraftSpongePlugin.onGameStartingServerEvent(MinecraftSpongePlugin.java:52) [MinecraftSpongePlugin.class:?]
	at org.spongepowered.common.event.listener.GameStartingServerEventListener_MinecraftSpongePlugin_onGameStartingServerEvent3.handle(Unknown Source) [?:?]
	at org.spongepowered.common.event.RegisteredListener.handle(RegisteredListener.java:95) [RegisteredListener.class:1.12.2-7.1.0-BETA-13]
	at org.spongepowered.common.event.SpongeEventManager.post(SpongeEventManager.java:403) [SpongeEventManager.class:1.12.2-7.1.0-BETA-13]
	at org.spongepowered.common.event.SpongeEventManager.post(SpongeEventManager.java:430) [SpongeEventManager.class:1.12.2-7.1.0-BETA-13]
	at org.spongepowered.common.SpongeImpl.postEvent(SpongeImpl.java:213) [SpongeImpl.class:1.12.2-7.1.0-BETA-13]
	at org.spongepowered.common.SpongeImpl.postState(SpongeImpl.java:221) [SpongeImpl.class:1.12.2-7.1.0-BETA-13]
	at org.spongepowered.server.SpongeVanilla.onServerStarting(SpongeVanilla.java:162) [SpongeVanilla.class:1.12.2-7.1.0-BETA-13]
	at net.minecraft.server.dedicated.DedicatedServer.handler$callServerStarting$zpk000(SourceFile:1258) [nz.class:?]
	at net.minecraft.server.dedicated.DedicatedServer.func_71197_b(SourceFile:233) [nz.class:?]
	at net.minecraft.server.MinecraftServer.run(SourceFile:434) [MinecraftServer.class:?]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_151]
Caused by: java.lang.ExceptionInInitializerError
	at io.vertx.core.impl.VertxImpl.<clinit>(VertxImpl.java:99) ~[?:?]
	at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:42) ~[?:?]
	at io.vertx.core.Vertx.vertx(Vertx.java:92) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.VertxStarter.start(VertxStarter.java:49) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.StoreysWebPlugin.start(StoreysWebPlugin.java:66) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.Activator.start(Activator.java:44) ~[?:?]
	at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	... 32 more
Caused by: java.lang.IllegalArgumentException: Error instantiating transformer class "io.vertx.core.logging.SLF4JLogDelegateFactory"
	at io.vertx.core.logging.LoggerFactory.initialise(LoggerFactory.java:59) ~[?:?]
	at io.vertx.core.logging.LoggerFactory.<clinit>(LoggerFactory.java:37) ~[?:?]
	at io.vertx.core.impl.VertxImpl.<clinit>(VertxImpl.java:99) ~[?:?]
	at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:42) ~[?:?]
	at io.vertx.core.Vertx.vertx(Vertx.java:92) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.VertxStarter.start(VertxStarter.java:49) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.StoreysWebPlugin.start(StoreysWebPlugin.java:66) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.Activator.start(Activator.java:44) ~[?:?]
	at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	... 32 more
Caused by: java.lang.ClassNotFoundException: io.vertx.core.logging.SLF4JLogDelegateFactory
	at net.minecraft.launchwrapper.LaunchClassLoader.findClass(LaunchClassLoader.java:191) ~[launchwrapper-1.12.jar:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[?:1.8.0_151]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[?:1.8.0_151]
	at io.vertx.core.logging.LoggerFactory.initialise(LoggerFactory.java:56) ~[?:?]
	at io.vertx.core.logging.LoggerFactory.<clinit>(LoggerFactory.java:37) ~[?:?]
	at io.vertx.core.impl.VertxImpl.<clinit>(VertxImpl.java:99) ~[?:?]
	at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:42) ~[?:?]
	at io.vertx.core.Vertx.vertx(Vertx.java:92) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.VertxStarter.start(VertxStarter.java:49) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.StoreysWebPlugin.start(StoreysWebPlugin.java:66) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.Activator.start(Activator.java:44) ~[?:?]
	at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	... 32 more
Caused by: java.lang.NullPointerException
	at net.minecraft.launchwrapper.LaunchClassLoader.findClass(LaunchClassLoader.java:182) ~[launchwrapper-1.12.jar:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[?:1.8.0_151]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[?:1.8.0_151]
	at io.vertx.core.logging.LoggerFactory.initialise(LoggerFactory.java:56) ~[?:?]
	at io.vertx.core.logging.LoggerFactory.<clinit>(LoggerFactory.java:37) ~[?:?]
	at io.vertx.core.impl.VertxImpl.<clinit>(VertxImpl.java:99) ~[?:?]
	at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:42) ~[?:?]
	at io.vertx.core.Vertx.vertx(Vertx.java:92) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.VertxStarter.start(VertxStarter.java:49) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.StoreysWebPlugin.start(StoreysWebPlugin.java:66) ~[?:?]
	at ch.vorburger.minecraft.storeys.web.Activator.start(Activator.java:44) ~[?:?]
	at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226) ~[ch.vorburger.minecraft.osgi-1.0.0-SNAPSHOT-all.jar:?]
	... 32 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
so the tests can run with the latest Oracle JDK.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the default dns client host is localhost.
It could be changed to null which means to use the value used by the address resolver which would be more consistent.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation: currently the http client redirection following feature will cache the sent body along with the request, this may is not desirable
change: remove the request body cache
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj I'm not comfortable with this. As a default, we should follow the W3C recommendations:

If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.


If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.


If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.

https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
This is what other HTTP clients do (I checked Apache and OkHttp)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation: currently connecting from the client may invoke the error handler more than one time (the errors are reported from the underlying websocket stream).
change: use an future in the implementation to guarantee at most one callback
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation: the current redirection policy does not follow strictly https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html. It performs a redirection on any HTTP method for the 301, 302 and 307 status instead of only GET and HEAD. In addition for 301 and 302 status it changes the method to GET
change: perform redirection for 301, 302 and 307 status code only when the method is GET or HEAD and do not change the method
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
yes I planned to do so
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj please review
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
env
Java : 1.8.0_144
vertx: 3.5.0 with cluster manager Hazelcast
netty: netty-all:4.1.19.Final
os: ubuntu 16.04
I use vertx to create tcp server and set setPreferNativeTransport = true  ,NetServerOptions
NetServerOptions ops = new NetServerOptions();
        ops.setReceiveBufferSize(32 * 1024)
                .setSendBufferSize(32 * 1024)
                .setIdleTimeout(timeoutSecond)
                .setPort(port)
                .setHost(host)
                .setTcpFastOpen(true)
                .setTcpQuickAck(true)
                .setUsePooledBuffers(true)
                .setTcpNoDelay(true);
client will send 3 kinds package

< 38B  every 1 second ,server just receive then send to kafka
1.2KB  every 1 second ,server just receive then send to kafka
heartbeat 35B every 5 seconds , server send ack

 log.info("write data to client...[{}]", StringUtil.toHexString(cmd.getBytes()));
        if (Objects.isNull(client)) {
            return false;
        }
        client.write(cmd);
        if (client.writeQueueFull()) {
            client.pause();
            client.drainHandler(done -> client.resume());
        }

with 1000 clients after a few hours netty will throw readAddress(..) failed: Connection timed out
2018-02-01 07:36:59,545 [ERROR] [vert.x-eventloop-thread-9] 
DataHubBroker [DataHubBroker.java : 154] device error io.netty.channel.unix.Errors$NativeIoException: readAddress(..) failed: Connection timed out
 at io.netty.channel.unix.Errors.newIOException(Errors.java:122)
 at io.netty.channel.unix.Errors.ioResult(Errors.java:146)
 at io.netty.channel.unix.FileDescriptor.readAddress(FileDescriptor.java:178)
 at io.netty.channel.epoll.AbstractEpollChannel.doReadBytes(AbstractEpollChannel.java:347)
 at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:786)
 at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:404)
 at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:304)
 at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
 at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 at java.lang.Thread.run(Thread.java:748)

I find   netty  issues.but it close at 4.0.26 .Any ideas for help?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello @vietj,
could you please review the PR and merge it if possible?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
monitoring does not seem available for native transports :-( (because classes are final)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
rebased on master
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
good catch, is there any practical way to test this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A few improvements and simplifications can be done in Vert.x Context

remove the internal ContextTask functional interface (which is a Runnable that can throw) as we can use Handler<Void> in practice which unified the internal Context#wrapTask method
remove the internal Action functional interface (which is similar to a Callable) as we can use the Handler<Future<T>> idiom instead
add a ContextInternal#executeFromIO(T,Handler<T>) so an handler task can be passed an argument
decompose the implementation of ContextImpl#wrapTask so the logic can be reused by executeFromIO without creating a unnecessary lambda
handle the worker task metric in WorkerContext instead of ContextImpl#wrapTask
avoid unnecessary lambda captures in VertxHandler when handling a message from Netty
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj looks good to me. Have you prepared PRs for cluster managers?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version

vert.x core: 3.5.1

Context
An EOFException is unexpectedly thrown when deserializing a JSON primitive (null, Integer, String) from a vert.x Buffer. Unrolling the buffer into a String prior to deserialization works as expected.
Do you have a reproducer?

https://github.com/GeorgeMH/vertx-json-eof-bug

Steps to reproduce

Call Json.encodeToBuffer(42)
Call Json.decodeValue(buffer, Integer.class) on the buffer created in step 1.

Extra

N/A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, the upgrade implementation assumes that the HTTP/1.1 request should not be treated as an HTTP/2 stream and only send an HTTP/1.1 response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/354abf0332a5218959c32f237b622bdfcd26faae/src/main/java/io/vertx/core/impl/DeploymentManager.java#L205
Need to catch as Throwable.
Explain: MavenVerticleFactory resolve "compile" scope only. MavenVerticleFactory will missing some runtime dependencies, NoClassDefFoundError will throw and this block can not catch it.
Console prints only "INFO: Resolving xxxxx.xxx"
and nothing happen after that.No way know why application not run without debuging
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For now class "Message" have only one way to report about failure on consumer side:
void fail(int failureCode, String message);
Maybe this is useful for proxy services, but for simple message passing it is redundant. I need to define some list of error codes and maintain it on clients. But I just want to send a simple message to some address and get simple response (OK or NOT).
What was the reason for such design decision?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP server keeps processing pipelined HTTP messages when the connection is closed during the processing of a request and there are pending HTTP request in the server pipeline (i.e the response has not been sent). This is due to a bug that when a message has not been processed during a check, the connection redo the check and it must not do it.
Changes: we only trigger an message processing check from the message check itself when a message has been effectively processed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@tsegismont the server connections receives pipelined requests messages (HttpRequest, HttpLastContent, HttpRequest, etc...)
The first requests does not end the first response so the field pendingResponse remains assigned and it closes the connection.
When the second requests arrives (it arrives in the same channel read operation since it's pipelined and aggregated at the TCP level) then processMessage(Object) returns false and the request object is enqueued. The first processing  message triggered a call to checkNextTick(), when the asynchronous checkNextTick() runs it tries to process the message and fails since pendingResponse  is still assigned, the message is put back on the queue and since the queue is not empty checkNextTick() is called again and so on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
rebased on master
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today I received a lot of exceptions every millisecond for hours looking like an infinite loop in the log file:
2018-04-04 01:16:38,513 [31mWARN[0;39m [vert.x-eventloop-thread-2] [i.n.c.DefaultChannelPipeline] - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. java.lang.IllegalArgumentException: invalid version format: (T H I S  I S   J U S T  A  S U R V E Y !)
	at io.netty.handler.codec.http.HttpVersion.<init>(HttpVersion.java:121)
	at io.netty.handler.codec.http.HttpVersion.valueOf(HttpVersion.java:76)
	at io.netty.handler.codec.http.HttpRequestDecoder.createMessage(HttpRequestDecoder.java:87)
	at io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:219)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:60)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:38)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)


What does this come from? Does i thappen during request or response handling or during SSL handshake?
Where to add a exception handler to catch this exception
Where does T H I S  I S  J U S T  A  S U R V E Y ! come from?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When running a Vert.x instance, the following warnings will be output to stdout:
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by io.netty.util.internal.ReflectionUtil (file://io.netty/netty-common/4.1.19.Final/b281916c11d3eeec5e839677ec4f2eb9d7586928/netty-common-4.1.19.Final.jar) to constructor java.nio.DirectByteBuffer(long,int)
WARNING: Please consider reporting this to the maintainers of io.netty.util.internal.ReflectionUtil
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations

These warnings were fixed by netty/netty#7650 and are available in release 4.1.21.Final and later
Upgrading the Netty dependency to that version should fix that problem
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClient pool assumes that the underlying ConnectionProvider will make an asynchronous callback, which is the case with the asynchronous DNS resolver but not with the JVM synchronous resolver when the host cannot be resolved.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
where BlockedThreadChecker call registerThreadVertxThread?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I'm new to Vert.x and going through documentation. Not sure where to report doc issues.
I m going through 'Security notes' (https://vertx.io/docs/vertx-core/java/#_clustered_event_bus_traffic), and it is mentioned:

Clustered event bus traffic
When clustering the event bus between different Vert.x nodes on a network, the traffic is sent un-encrypted across the wire, so do not use this if you have confidential data to send and your Vert.x nodes are not on a trusted network.

But in 'Configuring the event bus' (https://vertx.io/docs/vertx-core/java/#_configuring_the_event_bus) section, it is mentioned we can provide keystore for secure communication.

Configuring the event bus
...

VertxOptions options = new VertxOptions()
    .setEventBusOptions(new EventBusOptions()
        .setSsl(true)
        .setKeyStoreOptions(new JksOptions().setPath("keystore.jks").setPassword("wibble"))
        .setTrustStoreOptions(new JksOptions().setPath("keystore.jks").setPassword("wibble"))
        .setClientAuth(ClientAuth.REQUIRED)
    );


The previous snippet depicts how you can use SSL connections for the event bus, instead of plain TCP connections.

So, which is correct? I can confirm this by running Vert.x in cluster mode with keystore and see the traffic over the wire myself. But wanted to get the confirmation from the experienced users/authors. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the ConnectionBase#writeToChannel(Object) method uses the channel void promise for the channel write. When an error occurs, the channel void promise will invoke the pipeline exception handling. This can create undesired loop where an API exception handling performs a write operations that fails and invoke the same exception handler again for its own failure.
Instead we create our own void promise that won't fire the exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
While running servers with vert.x 3.5.1 (vertx + vertx web), I got
"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception."
The exception itself is an java.lang.IllegalArgumentException thrown by io.netty.handler.codec.http.HttpVersion either for empty version or invalid version.
So far I was not able torreproduce this error with a simple example, but here some observations :
If I send a valid HTTP request (with keep alive) and then an invalid HTTP request (like GET / HTTP/dummy), I got the IllegalArgumentException, but it is actually catched and logged by vertx ConnectionBase.
In the case where I got  "An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.", it is actually not caught by vert.x at all, and it is looping forever (like the error is not "consumed" from the event loop).
Here the stack trace
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.lang.IllegalArgumentException: invalid version format: (LINUX; U; ANDROID 4.3; RU-RU; GT-I9300I BUILD/JLS36C) APPLEWEBKIT/534.30 (KHTML, LIKE GECKO) VERSION/4.0 MOBILE SAFARI/534.30 
 at io.netty.handler.codec.http.HttpVersion.<init>(HttpVersion.java:121)
 at io.netty.handler.codec.http.HttpVersion.valueOf(HttpVersion.java:76)
 at io.netty.handler.codec.http.HttpRequestDecoder.createMessage(HttpRequestDecoder.java:87)
 at io.netty.handler.codec.http.HttpObjectDecoder.decode(HttpObjectDecoder.java:219)
 at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
 at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
 at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
 at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
 at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
 at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
 at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
 at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
 at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
 at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
 at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
 at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
 at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
 at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the Http1xOrH2CHandler removes itself after firing the buffer which leads the Http1xOrH2CHandler to process a decoded error (that is fired in the pipeline to be treated like a network error). It should should remove itself before, since once the protocol has been identified, it should not interact anymore with the pipeline
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I am using vertx redis and I need to idle timeout in less than a seconds. I am using Redis vertx and I have checked that NetClientImpl always call IdleStateHandler in a way that it will idle in seconds.
Do you support only TimeUnit.SECONDS for a specific reason ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@julianladisch thanks, nice catch!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Inside of Transport.java, the configure method has the following:
    setOption("TCK_CORK", options.isTcpCork(), setter);
    setOption("TCK_QUICKACK", options.isTcpQuickAck(), setter);
    setOption("TCK_FASTOPEN", options.isTcpFastOpen(), setter);

But inside EpollTransport.java it is looking for:
      case "TCP_QUICKACK":
        return EpollChannelOption.TCP_QUICKACK;
      case "TCP_CORK":
        return EpollChannelOption.TCP_CORK;
      case "TCP_FASTOPEN":
        return EpollChannelOption.TCP_FASTOPEN;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version 3.5.1
fun main(args: Array<String>) {

    val vertx = Vertx.vertx()

    val router = Router.router(vertx)
    router.route().handler { context ->
        context.request().isExpectMultipart = true
        context.request().uploadHandler { upload ->
            val uploadedFileName = File.createTempFile("test", ".txt").path
            upload.streamToFileSystem(uploadedFileName)
            upload.exceptionHandler { t -> context.fail(t) }
            upload.endHandler { context.response().end() }
        }
    }
    vertx.createHttpServer().requestHandler(router::accept).listen(8080)
}
The code was taken from the BodyHandler. Using the following code and a small file (2 byte) causes the problem
[xxx@smu ~]$ cat empty.txt
x
[xxx@smu ~]$ curl -v 'http://localhost:8080/[1-2]' -H 'Expect:' -F "file=@empty.txt"

[1/2]: http://localhost:8080/1 --> <stdout>
--_curl_--http://localhost:8080/1
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
> POST /1 HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.58.0
> Accept: */*
> Content-Length: 189
> Content-Type: multipart/form-data; boundary=------------------------abce4460631f57f4
> 
< HTTP/1.1 200 OK
< Content-Length: 0
< 
* Connection #0 to host localhost left intact

[2/2]: http://localhost:8080/2 --> <stdout>
--_curl_--http://localhost:8080/2
* Found bundle for host localhost: 0x561ca934a440 [can pipeline]
* Re-using existing connection! (#0) with host localhost
* Connected to localhost (::1) port 8080 (#0)
> POST /2 HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.58.0
> Accept: */*
> Content-Length: 189
> Content-Type: multipart/form-data; boundary=------------------------abce4460631f57f4
> 

The second request is stuck and the vert.x handler is never called. Problem is associated with HttpServerFileUploadImpl.streamToFileSystem.
        Pump p = Pump.pump(HttpServerFileUploadImpl.this, ar.result());
        p.start();
        resume();
The resume() Method sometimes instantly calls the endHandler (without another eventloop iteration). When this happens the HTTP connection cannot be used for further requests.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I encountered a behaviour which looks weird when I was trying to create a seperate Handler that ends a Response. [For a reason!].
As a solution, I think we should write the headers only in the end method and if we're trying to and not while writing.
If you agree, let me know to create a PR.
Cheers
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried to setup two HTTP Servers.
Server1 is user facing, accepting REST request to download large file. Server1 then forward request to Server2 to get file.
Server2 will open file from filesystem and send it back.
Results:
100MB file -> It takes 2 ~ 5 seconds to start download.
1GB file -> It takes 5 ~ 10 seconds to start download.
10GB file -> It takes 70 ~ 100 seconds to start download.
Code: vertx 3.5.1
Server1:
 public HttpVerticle() {
        vertx = Vertx.vertx();
        Router router = Router.router(vertx);

        WebClient webClient = WebClient.create(vertx,
                new WebClientOptions().setDefaultPort(8081).setDefaultHost("localhost"));

        router.route("/").handler(routingContext ->
                routingContext.response().end("server1")
        );

        router.get("/file").handler(ctx -> {

            HttpServerResponse response = ctx.response();
            response.setChunked(true);
            response.putHeader("Content-Type", "application/octet-stream");
            response.putHeader("Content-Disposition", "attachment; filename=test.tar");

            webClient.get("/file2").as(BodyCodec.pipe(response))
                    .followRedirects(false)
                    .timeout(600000)
                    .rxSend()
                    .subscribe(ctx1 -> {
                        System.out.println("subscribed");
                    });
        });

        vertx.createHttpServer().requestHandler(router::accept).listen(8080);
    }
Server2
public HttpVerticle() {
        vertx = Vertx.vertx();
        Router router = Router.router(vertx);

        router.route("/").handler(routingContext ->
                routingContext.response().end("server2")
        );
        router.get("/file2").handler(ctx -> {
            HttpServerResponse response = ctx.response();
            String path = "test.jar";

            vertx.fileSystem()
                    .rxOpen(path, new OpenOptions().setRead(true))
                    .doOnSuccess(file -> {
                        response.setChunked(true);
                        Pump pump = Pump.pump(file, response);
                        pump.start();
                        file.endHandler(h -> response.end());
                    })
                    .subscribe(v -> {
                        System.out.println("Completed");
                    });
        });

        vertx.createHttpServer().requestHandler(router::accept).listen(8081);

    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I had a method as:
public Function<JsonArray, Future<Void>> dbUpdate(String sql) {

        return params -> {
            return Future.<Void>future(ft -> {
                PGConnector.getAsyncClient().updateWithParams(sql, params, res -> {
                    if (res.failed() || res.result().getUpdated() != 1) {
                        ft.fail("db fail");
                    } else {
                        try {
                            ft.complete();
                        } catch (Throwable t) {
                            ft.fail("has exception");
                        }
                    }
                });
            });
        };
    }
When catch a exception happend:



how can i do? or is there any better way to write it?


This will solve the problem, but it will be so bad
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to implement a wrapper for Vertx instance that would do some custom stuff before delegating to actual instance. Implementing only Vertx interface would not work(in some cases Vertx instance is casted to VertxInternal inside vertx libs).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes we write this idiomatic code:
context.runOnContext(v -> callback.handle(result));

Having a value version:
public interface ContextInternal {
   <T> void runOnContext(T value, Handler<T> handler);
}

would allow to simply write instead:
context.runOnContext(result, callback);

without an extra capturing lambda and be more concise and remains readable.
I'm targetting ContextInternal to avoid overloading Context with an extra method that would create unnecessary API noise.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From the RFC:
Request-URI    = "*" | absoluteURI | abs_path | authority

* means does not apply to a resource so it won't be handled by vertx-web
absoluteURI | abs_path these must start with /
authority this is authN feature that we don't support on web either
So when you do:
http://127.0.0.1:8080?test=something

The path is not valid as the part: ?test=something would probably be handled as an authority
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our server is using Vertx 3.5.1, it handles thousands of request/sec from thousands of JS clients. Those JS clients sometimes create rubbish request with strange chars
ar.bids%Foout=false&

When processing query parameters with invalid chars like the one above we don't have problems because Http1xServerConnection's processMessage always return true, this can be check with the following stack trace
java.lang.IllegalArgumentException: unterminated escape sequence at index 510 of: /someurl?ar.bids%5B2%5D.tout=false
    at io.netty.handler.codec.http.QueryStringDecoder.decodeComponent(QueryStringDecoder.java:349)
    at io.netty.handler.codec.http.QueryStringDecoder.addParam(QueryStringDecoder.java:257)
    at io.netty.handler.codec.http.QueryStringDecoder.decodeParams(QueryStringDecoder.java:245)
    at io.netty.handler.codec.http.QueryStringDecoder.parameters(QueryStringDecoder.java:180)
    at io.vertx.ext.web.impl.RouteImpl.matches(RouteImpl.java:298)
    at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:110)
    at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:120)
    at io.vertx.ext.web.impl.RouterImpl.accept(RouterImpl.java:79)
    at io.vertx.core.http.impl.Http1xServerConnection.processMessage(Http1xServerConnection.java:433)
    at io.vertx.core.http.impl.Http1xServerConnection.handleMessage(Http1xServerConnection.java:141)
    at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:683)
    at io.vertx.core.http.impl.HttpServerImpl$ServerHandlerWithWebSockets.handleMessage(HttpServerImpl.java:636)
    at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:146)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
    at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:195)
    at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:144)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)

But when request.decoderResult().isFailure() returns true (from Http1xServerConnection's processMessage) and after invoking handleError method, the request is queued again (Http1xServerConnection's  handleMessage), so event loop will handle it again later
Actually I am "quite sure" about this because now this machine does not receive any request, it has been disconnected from the load balancer, and this event-loop is still using lots of resources
I attach some stack traces of the problematic event-loop
Stack Trace
ch.qos.logback.classic.Logger.filterAndLog_0_Or3Plus line: 373 
   ch.qos.logback.classic.Logger.warn line: 692 
   io.netty.util.internal.logging.Slf4JLogger.warn line: 151 
   io.netty.channel.DefaultChannelPipeline.onUnhandledInboundException line: 1158 
   io.netty.channel.DefaultChannelPipeline$TailContext.exceptionCaught line: 1241 
   io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught line: 285 
   io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught line: 264 
   io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught line: 256 
   io.netty.channel.DefaultChannelPipeline$HeadContext.exceptionCaught line: 1326 
   io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught line: 285 
   io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught line: 264 
   io.netty.channel.DefaultChannelPipeline.fireExceptionCaught line: 923 
   io.vertx.core.http.impl.Http1xServerConnection.handleError line: 409 
   io.vertx.core.http.impl.Http1xServerConnection.processMessage line: 420 
   io.vertx.core.http.impl.Http1xServerConnection.lambda$checkNextTick$3 line: 489 
   io.vertx.core.http.impl.Http1xServerConnection$$Lambda$81/1471778344.handle line: not available 
   io.vertx.core.impl.ContextImpl.lambda$wrapTask$2 line: 339 
   io.vertx.core.impl.ContextImpl$$Lambda$33/1449263511.run line: not available 
   io.netty.util.concurrent.AbstractEventExecutor.safeExecute line: 163 
   io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks line: 404 
   io.netty.channel.nio.NioEventLoop.run line: 463 
   io.netty.util.concurrent.SingleThreadEventExecutor$5.run line: 886 
   io.netty.util.concurrent.FastThreadLocalRunnable.run line: 30 
   java.lang.Thread.run line: 748 

Stack trace
io.vertx.core.impl.EventLoopContext.executeAsync line: 39 
io.vertx.core.impl.ContextImpl.runOnContext line: 204 
io.vertx.core.impl.VertxImpl.runOnContext line: 337 
io.vertx.core.http.impl.Http1xServerConnection.checkNextTick line: 483 
io.vertx.core.http.impl.Http1xServerConnection.lambda$checkNextTick$3 line: 504 
io.vertx.core.http.impl.Http1xServerConnection$$Lambda$81/1471778344.handle line: not available 
io.vertx.core.impl.ContextImpl.lambda$wrapTask$2 line: 339 
io.vertx.core.impl.ContextImpl$$Lambda$33/1449263511.run line: not available 
io.netty.util.concurrent.AbstractEventExecutor.safeExecute line: 163 
io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks line: 404 
io.netty.channel.nio.NioEventLoop.run line: 463 
io.netty.util.concurrent.SingleThreadEventExecutor$5.run line: 886 
io.netty.util.concurrent.FastThreadLocalRunnable.run line: 30 
java.lang.Thread.run line: 748
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
Im using JDK 10 and have encountered an issue with the version of netty being used(netty/netty#7768, where the owner said on the 4th of may, "Upgrade to latest Netty version as it was fixed there")
Language: Kotlin
JDK: 10
OS: Windows 10
IDE: Intellij Idea ultimate
Stack trace
13:15:33.467 [main] DEBUG io.netty.util.internal.PlatformDependent0 - direct buffer constructor: available
13:15:33.467 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true
13:15:33.468 [main] DEBUG io.netty.util.internal.PlatformDependent0 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable
java.lang.IllegalAccessException: class io.netty.util.internal.PlatformDependent0$6 cannot access class jdk.internal.misc.Unsafe (in module java.base) because module java.base does not export jdk.internal.misc to unnamed module @59d016c9
	at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:360)
	at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:589)
	at java.base/java.lang.reflect.Method.invoke(Method.java:556)
	at io.netty.util.internal.PlatformDependent0$6.run(PlatformDependent0.java:312)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at io.netty.util.internal.PlatformDependent0.<clinit>(PlatformDependent0.java:303)
	at io.netty.util.internal.PlatformDependent.isAndroid(PlatformDependent.java:208)
	at io.netty.util.internal.PlatformDependent.<clinit>(PlatformDependent.java:79)
	at io.netty.util.ConstantPool.<init>(ConstantPool.java:32)
	at io.netty.util.Signal$1.<init>(Signal.java:27)
	at io.netty.util.Signal.<clinit>(Signal.java:27)
	at io.netty.util.concurrent.DefaultPromise.<clinit>(DefaultPromise.java:43)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:36)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:58)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:47)
	at io.netty.channel.MultithreadEventLoopGroup.<init>(MultithreadEventLoopGroup.java:59)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:77)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:72)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:59)
	at io.vertx.core.net.impl.transport.Transport.eventLoopGroup(Transport.java:125)
	at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:166)
	at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:145)
	at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:141)
	at io.vertx.core.impl.VertxFactoryImpl.vertx(VertxFactoryImpl.java:30)
	at io.vertx.core.Vertx.vertx(Vertx.java:78)
	at io.github.johnfg10.MainKt.main(Main.kt:8)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/ed75286d4e6a206244829fdbd01775d9516f6a70/src/main/java/io/vertx/core/Vertx.java#L557-L562
https://github.com/eclipse/vert.x/blob/ed75286d4e6a206244829fdbd01775d9516f6a70/src/main/java/examples/CoreExamples.java#L95-L104
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj sorry , it commit by a wrong email, and i have delete it, you can close this pr, i will create new later
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi We are working to implement oAuth2 in our vertx application. We have configured path in while creating oAuth2Oauth and tokens are generated. When we try to introspect token using oauth2oauth.introspecttoken() method it throws error "405 Method not allowed". Reason is introspect token method fetches the introspect URL using POST. But our r provider is custom oauth provider and the validate URL is GET URL.
So is it possible to provide http method as config to oAuth provider or can we create custom oauth provider. If so can anyone please refer a link for custom oAuth provider. Many thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please change the signature of this method from:
static CompositeFuture all(List<Future> futures)
to
static <T> CompositeFuture all(List<Future<T>> futures)
in order to call it with any type of Future (like List<Future<Void>>).
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use WebClient to send a HTTPS request, I get an error:
Here is my code:
public class SyncWebClient<T> {
    public T get(int port, String host, String api, Class<T> entityClass) throws ExecutionException, InterruptedException {
        Vertx vertx = Vertx.vertx();
        WebClient webClient = WebClient.create(vertx);
        CompletableFuture<T> completableFuture = new CompletableFuture<>();
        webClient.get(port, host, api).ssl(true).as(BodyCodec.json(entityClass)).send(ar -> {
            if (ar.succeeded()) {
                T result = ar.result().body();
                completableFuture.complete(result);
            } else {
                System.out.println("Error Info: " + ar.cause());
            }
        });

        return completableFuture.get();
    }
}

test code:TestSyncWebClient.java
public class TestSyncWebClient {
    private SyncWebClient<String> stringSyncWebClient = new SyncWebClient<>();

    @Test
    public void test() throws UnsupportedEncodingException, ExecutionException, InterruptedException {
        String response = stringSyncWebClient.get(8080, "localhost", "api/v1/version", String.class);
        System.out.println("status: " + response);
    }
}


Error info:
Error Info: javax.net.ssl.SSLHandshakeException: Failed to create SSL connection
16:30:18.810 [vert.x-eventloop-thread-0] WARN  i.n.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
	at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1529)
	at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535)
	at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:813)
	at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
	at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
	at io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:281)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1215)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1127)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1162)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
	... 15 common frames omitted
Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
	at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1728)
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:330)
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)
	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)
	at sun.security.ssl.Handshaker$1.run(Handshaker.java:992)
	at sun.security.ssl.Handshaker$1.run(Handshaker.java:989)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.security.ssl.Handshaker$DelegatedTask.run(Handshaker.java:1467)
	at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1364)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1272)
	... 19 common frames omitted
Caused by: java.security.cert.CertificateException: No name matching localhost found
	at sun.security.util.HostnameChecker.matchDNS(HostnameChecker.java:231)
	at sun.security.util.HostnameChecker.match(HostnameChecker.java:96)
	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:455)
	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:436)
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:252)
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:136)
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1601)
	... 27 common frames omitted

Can you help me,thanks in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zsiegel nice catch! Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can't capture javax.net.ssl.SSLHandshakeException when using HttpClient.
See the following snippet:
private val httpClient : HttpClient =
            this.vertx.createHttpClient(HttpClientOptions(HttpClientOptions()
                    .setSsl(true)
                    .setPemTrustOptions(PemTrustOptions().addCertPath("my-cert"))))

 suspend fun postIt(port : Int, host: String, requestUri: String, body : JsonObject,
                       token: String) = awaitEvent<HttpClientResponse> {
        this.httpClient.post(port, host, requestUri)
                .putHeader("Content-Type", "application/json")
                .putHeader("Authorization", "Bearer $token" )
                .handler(it)
                .end(body.toString())
    }

When using postIt method and my-cert does not match the cert in the server I get:
app           | Apr 19, 2018 4:15:01 AM io.vertx.core.http.impl.HttpClientRequestImpl
app           | SEVERE: javax.net.ssl.SSLHandshakeException: Failed to create SSL connection
app           | 2018-04-19 04:15:01.844 [vert.x-eventloop-thread-0] WARN  i.n.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
app           | io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: General SSLEngine problem

But this exception happens at Netty level apparently and I'm not able to capture it to report it to interested parties.
Is there anyway to handle this exception? I'm also integrating the service with Prometheus but I don't see Vertx publishing any of these stats.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should be replaced by another PR. See comments in #2399
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is there any good solutions?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ok this is all ready to go. I have updated the documentation and augmented the tests slightly to check the content-length headers are correct
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[issue]
but we read wrong data from HttpServerRequest.getFormAttribute. UTF8 will change illegal byte to EFBFBD.
didn't find any method to read binary data from vertx HttpServerRequest like like getReader or others
Do you have any comments about this? thank you in advance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/eclipse/vert.x/blob/5945cd3aabbfad8ef8b79fab3fd0feca98f5ee35/src/main/java/io/vertx/core/http/impl/ConnectionManager.java#L62
starts a Timer with 1 milli-second delay to search for closeable/evictable connections.
Is it really required to do this so often? - Especially as we can define the keep-alive time only as whole seconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are sending packets directly to IP and noticed that it's trying to resolve hostname. https://git.io/vpmfI addr.isUnresolved()) are always true.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks, that's actually a good idea
have you checked all tests are passing ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See https://blog.cloudflare.com/announcing-1111/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This comes after these discussions.
@cescoffier already provided an implementation here.
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java, Vert.x 3.5.0
When an exception occurs within one of HttpServerResponseImpl::headersEndHandler this exception does not seem to be processed by HttpServerResponse::exceptionHandler and the response remains not ended. The following tests proves this on the example of an incorrect cookie (triggering an IllegalArgumentException in cookie.encode()), which leaves the server response in limbo:
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.ext.web.Cookie;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.CookieHandler;


public class TestCookieException {

	@Rule
	public ExpectedException exception = ExpectedException.none();

	@Test
	public void withCookie_onNoException_responseEnded() throws Exception {
		onPortWithCookieValue(14352, "aPerfectlyValidCookieValue");
	}

	@Test
	public void withCookie_onEncodeException_responseNotEnded() throws Exception {
		// FIXME this should be the case: exception.expectMessage("Cookie value contains an invalid char");
		exception.expect(TimeoutException.class);
		onPortWithCookieValue(14353, "values with spaces are not supported");
	}

	private void onPortWithCookieValue(int port, String cookieValue) throws Exception {
		CompletableFuture<Void> responseEndedOnServer = new CompletableFuture<>();
		Vertx vertx = Vertx.vertx();
		Router router = Router.router(vertx);
		router.route()
			.handler(CookieHandler.create())
			.handler(ctx -> {
				Cookie cookie = Cookie.cookie("session", cookieValue);
				cookie.setPath("/");
				cookie.setMaxAge(3600);
				ctx.addCookie(cookie);

				HttpServerResponse response = ctx.response();
				response.endHandler(responseEndedOnServer::complete);
				response.exceptionHandler(responseEndedOnServer::completeExceptionally);
				response.setStatusCode(200).end();
			});

		CompletableFuture<HttpServer> serverStarted = new CompletableFuture<>();
		vertx
			.createHttpServer()
			.requestHandler(router::accept)
			.listen(port, "0.0.0.0", (s) -> serverStarted.complete(s.result()));
		HttpServer server = serverStarted.get(2, TimeUnit.SECONDS);

		vertx
			.createHttpClient(new HttpClientOptions().setDefaultHost("localhost").setDefaultPort(port))
			.get("/")
			.handler($ -> {})
			.end();

		try {
			responseEndedOnServer.get(2, TimeUnit.SECONDS);
		}
		finally {
			server.close();
		}
	}

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This enum misses the VertxGen annotation making it impossible to be used by non java languages.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For example, following code fails in local mode, but works fine in clustered one:
    Vertx.vertx().sharedData().<String, MutableObject>getAsyncMap("map", getMapResult -> {
      final AsyncMap<String, MutableObject> asyncMap = getMapResult.result();
      asyncMap.put("key", new MutableObject("old value"), putResult -> { /* do nothing */ });
      asyncMap.get("key", value -> value.result().setValue("new value"));
      asyncMap.get("key", value -> {
        if (value.result().getValue().equals("old value")) {
          System.out.println("value was not updated");  // expected behaviour
        } else {
          System.err.println("value was updated");  // unexpected behaviour
        }
      });
    });
  private static final class MutableObject implements Serializable {
    private String value;

    public MutableObject(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    public void setValue(String value) {
      this.value = value;
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here is the code, which illustrates the problem.
The Consumer verticle acuires lock1 and gets stuck.
I have reproduced the same problem using HazelcastClusterManager and IgniteClusterManager.
    Vertx.clusteredVertx(
        new VertxOptions().setClusterManager(new HazelcastClusterManager()),
        result -> {
          final Vertx vertx = result.result();

          final int messagesToSend = 10;

          final Consumer consumer = new Consumer();
          vertx.deployVerticle(
              consumer,
              new DeploymentOptions(),
              event -> {
                if (event.succeeded()) {
                  vertx.deployVerticle(
                      new Supplier(messagesToSend),
                      new DeploymentOptions()
                  );
                }
              }
          );

          vertx.setTimer(
              messagesToSend * DEFAULT_LOCK_TIMEOUT,
              timer -> {
                final long failsNumber = messagesToSend - consumer.counter.sum();
                if (failsNumber != 0) {
                  System.err.println("Failed to get " + failsNumber + " locks");
                }
                vertx.close();
              }
          );
        }
    );
  class Supplier extends AbstractVerticle {
    private final long messagesToSend;

    public Supplier(long messagesToSend) {
      this.messagesToSend = messagesToSend;
    }

    @Override
    public void start() {
      final LongAdder sent = new LongAdder();
      vertx.setPeriodic(1, timer -> {
        vertx.eventBus().send(TEST_ADDRESS, "message");
        sent.increment();
        System.out.println(sent.sum() + " messages sent");
        if (sent.sum() >= messagesToSend) {
          vertx.cancelTimer(timer);
        }
      });
    }
  }
class Consumer extends AbstractVerticle {
    private final LongAdder counter = new LongAdder();

    @Override
    public void start(Future<Void> startFuture) {
      vertx.eventBus().consumer(
          TEST_ADDRESS,
          event -> {
            vertx.sharedData().getLock("lock1", lock1 -> {
              if (lock1.failed()) {
                System.out.println("Failed to get lock1: " + lock1.cause());
              } else {
                System.out.println("Succeeded to get lock1");
                vertx.sharedData().getLock("lock2", lock2 -> {
                  if (lock2.failed()) {
                    System.out.println("Failed to get lock2: " + lock2.cause());
                  } else {
                    System.out.println("Succeeded to get lock2");
                    counter.increment();
                    System.out.println(counter.sum() + " messages consumed");
                    lock2.result().release();
                  }
                  lock1.result().release();
                });
              }
            });
          }
      ).completionHandler(startFuture);
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
just signed the ECA with this email address.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have signed the ECA, but I still can't pass the eclipse valiadation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Static files in the JAR are not being "re-read" after they've been changed during development, while the app/server is running. The server has to be restarted after each change instead.
Inside my public static void main(String[] args) method, before any vert.x code, I have System.setProperty("vertx.disableFileCaching", "true");
Storing my static files on a file system path instead would be cumbersome due to this project's needs.
I have consulted Link #1514 and Link #1528, but I am not having success so far.
My development environment:
Vert.x 3.5.1
JRE Oracle Java 1.8.0_171
IntelliJ IDEA 2018.1.2
Ubuntu 18.04
Here is the main method:
    public static void main(String[] args) {

        System.setProperty("vertx.disableFileCaching", "true");

        Vertx vertx = Vertx.vertx();
        vertx.deployVerticle(new VerticleOne(), asyncResult -> {
            if(asyncResult.failed()) {
                LOGGER.error("VerticleOne experienced an issue: " + asyncResult.cause());
            }
            else {
                LOGGER.info("VerticleOne deployed");
            }

        });

    }

Here is the start method of the Verticle:
    @Override
    public void start(Future<Void> startFuture) throws Exception {

        StaticHandler staticHandler = StaticHandler.create()
                .setWebRoot("net/rprpx/static")
                ;

        Router router = Router.router(vertx);
        router.route("/static/*").handler(staticHandler);

        HttpServer httpServer = vertx.createHttpServer()
                .requestHandler(router::accept)
                .listen(8080, asyncResult -> {

                    if(asyncResult.failed()) {
                        LOGGER.error("Could not start the HTTP server", 
                            asyncResult.cause());
                        startFuture.fail(asyncResult.cause());
                    }
                    else {
                        LOGGER.info("HTTP server now running on port " 
                            + asyncResult.result().actualPort());
                        startFuture.complete();
                    }

                });

    }

Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When calling either "vertx.clusteredVertx(...);" or "vertx.Vertx.vertx();" the following exception gets thrown in 3.5.1:
Exception in thread "main" java.lang.NoSuchMethodError: io.netty.util.internal.ReflectionUtil.trySetAccessible(Ljava/lang/reflect/AccessibleObject;Z)Ljava/lang/Throwable;
	at io.netty.channel.nio.NioEventLoop$5.run(NioEventLoop.java:217)
	at java.security.AccessController.doPrivileged(Native Method)
	at io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:210)
	at io.netty.channel.nio.NioEventLoop.<init>(NioEventLoop.java:149)
	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:127)
	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:36)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:84)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:58)
	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:47)
	at io.netty.channel.MultithreadEventLoopGroup.<init>(MultithreadEventLoopGroup.java:59)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:77)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:72)
	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:59)
	at io.vertx.core.net.impl.transport.Transport.eventLoopGroup(Transport.java:125)
	at io.vertx.core.impl.VertxImpl.<init>(VertxImpl.java:166)
	at io.vertx.core.impl.VertxFactoryImpl.clusteredVertx(VertxFactoryImpl.java:45)
	at io.vertx.core.Vertx.clusteredVertx(Vertx.java:100)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Buffer interface is tightly coupled with the netty ByteBuf. IMO this is an unfortunate design and the Buffer should be completely third-party classes agnostic.
The default implementation offered by Vert.x could rely on the netty ByteBuf (essentially wrapping it), but other implementations should be allowed without using the ByteBuf
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the same PR as before, cherry-picked on top of master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using Vertx with Hazelcast as the cluster manager and I am stuck with a problem on how to deal with the situation where a Vertx node acquires a lock and crashes right after it. As no body else will be able to acquire that Lock, there is no way to release it with without recycling the cluster. Is that the expected behavior or am I missing something? Will Hazelcast deal with a crashing node that's holding a Lock?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motiviation: currently the FileResolver is in the io.vertx.core.impl package and owns a Vertx instance. The only reason it needs this instance is to delete the cache dir when it is closed, because it actually needs to schedule a blocking file deletion (via the filesystem instance).
Change: decouple the FileResolver from the Vertx instance and the FileSystem implementation so it can be used without Vertx or FileResolver. The close operation is now blocking and the callers run it in an execute internal blocking operation (Vert.x close) or a thread (at JVM shutdown).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation : currently the Metrics SPI expose the measured instances to the SPI implementation when at creation of the corresponding metrics instance. This instance is actually not really used by the implementations (Vertx instance was used by micrometer metrics instance to create an HTTP server but in practice it can start its own embedded instance as there is no much gain to create a new one). One issue providing the Vertx instance is that the provided instance was a racy publication of the Vertx instance complicated to solve (because the MetricsFactory needs to be called early for creating the pool metrics). The metrics event bus initialised callback is also not used in practice (it used to be by hawkular implementation), only by micrometer metrics as a signal to initialise the backend which can be replaced by a simple initialisation in the micrometer metrics factory.
Change : do not provide measured instances when calling the SPI for creating a metrics implementation. Callback methods have also been renamed to contain the type of the metrics created (i.e createMetrics -> createEventBusMetrics, etc...). The event bus initialised callback is removed as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MultiThreaded worker verticles are an extension to worker verticles. Like with usual worker verticles, events are handled on worker pool threads. But they can be executed by different threads concurrently, which means the verticle must manage its own state to be visible between threads.
There are many parts of Vert.x which simply doesn't support them. For example, you can't create an HTTP server on a MT worker verticle.
Also, we have seen many new users, in particular those experienced with Spring or Java EE, starting directly with MT worker verticles and adding as many threads as possible with the impression it would help get the best performance results. But this is really counter-productive.
We are looking for relevant use cases for MT worker verticles. If you are using them, can you please describe in a comment to this issue what you are doing and why you couldn't do with standard (event loop) or usual worker verticles?
We want to determine if MT worker verticles do more harm than good. Ultimately, if they are simply an anti-pattern, we could deprecate and remove them after a few releases.
Looking forward to your feedback, thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
First of all great work on vert.x, it is really enjoyable to work with and such a powerful tool in such a small package. But recently I came across a missing vert.x feature that if implemented would make the appeal of vert.x's event bus much greater.
As far as I can see there is no direct support for Consumer Groups in vert.x, and this is a real pity.
By consumer groups I mean a set of consumers that would listen to published messages on a same address but with only at most one of these consumers getting the message. This would allow us to do load balancing for published messages. Load balancing already works out of the box for send messages (point-to-point), and without it published messages have only limited useful use cases.
Without this, published message processing does not scale horizontally as all messages must be processed by every single verticle register as consumer (i.e. no load balancing).
Having Consumer Groups would make the event bus allot more powerful and should not be that hard to implement. I suppose that it would be possible to set this up with existing tools, but it would require to

hand craft an API for subscribing to consumer groups,
have verticles that manage these groups subscription and message distribution
hold the subscription information in a distributed data structure.

All possible but better provided by a vert.x api.
In code, I am looking for something like that
vertx.eventBus.consumer("order.completed.event", ProductStatsVerticle.class, message->{
    /* do some great things*/
})
Where the name of ProductStatsVerticle.class is used as the name of the consumer group. Variants with a String consumer group name should also exist.
I'd like to have some opinions on this. Maybe there are already 3rd party implementation that could be inspiring, or a pattern that easily permits this feature?
Best regards,
Thim.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello Vert.x,
This is a great repository , i would like to work as contributor, Can you please help me to become contributor.Or suggest me the way.

I have read readme for contributor, but so far i have not seen any need help tasks or issues which i can pick up.
You guys are instantly responding on issues, so i do not have any chance to look into it.
I tried commenting on one but later i got comment stating that it is already closed.
I have pulled the repository and looking into the code
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Building this list so that we can track any missing @Nullable annotation until 3.6 is released
[ ] Vertx.executeBlocking
[ ] Context.executeBlocking
[ ] WorkerExecutor.executeBlocking
[ ] AsyncMap.get
[ ] AsyncMap.putIfAbsent
[ ] AsyncMap.remove
[ ] AsyncMap.replace
------ Original comment
Currently, the executeBlocking result handler type is not annotated with @Nullable.
As a result, the generated Rxified API returns a Single<T>. But it's quite common to use Future<Void> for a blocking task which does not need to return any result.
Then if the user simply invoke future.complete(), the program fails at runtime.
As a workaround, the user can use a Future<Object> and invoke complete() with any non-null value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When HTTP server is initialized with invalid SSL configuration (e.g. invalid path to keystore file), it does not call the listen handler, breaking the async calls chain.
Example:
import io.vertx.core.AbstractVerticle
import io.vertx.kotlin.core.net.JksOptions
import io.vertx.kotlin.core.http.HttpServerOptions

class RestVerticle : AbstractVerticle() {
    override fun start(startFuture: Future<Void>) {
        val jksOptions = JksOptions(path = "invalid_path", password = "somePassword")
        val httpServer = vertx.createHttpServer(HttpServerOptions(ssl = true, keyStoreOptions = jksOptions))
        httpServer.requestHandler({}).listen(8083, "127.0.0.1", {
            // This handler is never called
            if (it.succeeded())
                startFuture.complete()
            else
                startFuture.fail(it.cause())
        })
    }
}
In addition to that, the verticle deployment code does not call the deployment completion handler.
Example:
import io.vertx.core.AbstractVerticle
import io.vertx.kotlin.core.net.JksOptions
import io.vertx.kotlin.core.http.HttpServerOptions

class MainVerticle : AbstractVerticle() {
    override fun start(startFuture: Future<Void>) {
        Future.future<String>().also { future ->
            // Future completer is never called
            vertx.deployVerticle(RestVerticle(), DeploymentOptions(worker = true), future.completer())
        }.compose({ startFuture.complete() }, startFuture)
    }
}
So far I see that the problem might be caused by the fact that actualServer is not set to anything at the point of this check, but listening is already set to true, so executeCloseDone above is not called either.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the connection base will log every error to a connection when an exception handler is not set, in particular connection RST. Let's only log the message like previously (pre 3.5.1) and the full stack trace when debug is enabled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
It seems as if there is a case in the ClusteredEventBus (3.5.1) where a NPE can appear. After trying out some different cluster manager implementations the following NPE appear from time to time on a new instance when it is being launched. This is the NPE that appears:
2018-05-11 16:14:32:531 +0200 [vert.x-eventloop-thread-1] ERROR ContextImpl - Unhandled exception
java.lang.NullPointerException
	at io.vertx.core.eventbus.impl.clustered.ClusteredEventBus.lambda$setClusterViewChangedHandler$9(ClusteredEventBus.java:283)
	at io.vertx.core.impl.HAManager.lambda$checkSubs$10(HAManager.java:516)
	at io.vertx.core.impl.HAManager.lambda$runOnContextAndWait$11(HAManager.java:525)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Looking at the code for the ClusteredEventBus it seems as if the member "subs" can be null when the view changed handler is called before the ClusteredEventBus has started completely. The view changed handler is set in the constructor but the "subs" member is only given a value in the method "start(...)". I briefly looked at previous versions of the ClusteredEventBus and there has previously been a null-check in the view changed handler.
Regards
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation
Vertx clustered instances are not properly initialised in cluster mode.
Changes
Rework the creation of Vertx that leads to a non racy initialisation. Add init methods that allow to properly bootstrap the clustered vertx instance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Will review this one early next week.

2018-05-11 21:03 GMT+02:00 Julien Viet <notifications@github.com>:

 @vietj <https://github.com/vietj> requested your review on:
 eclipse-vertx/vert.x#2440 <#2440>
 ClusteredEventBus racy initialization - fixes #2438
 <#2438> - fixes #2439
 <#2439>.

 
 You are receiving this because your review was requested.
 Reply to this email directly, view it on GitHub
 <#2440 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/ABbltrFBDk0lMZnILn6ltUnOkJZiWGNyks5txeCdgaJpZM4T7690>
 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We should probably add a property to the class DnsClientOptions to support sending non recursive DNS requests. something like DnsClientOptions.isRecursionDesired() and DnsClientOptions.setRecursionDesired(boolean newValue)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a weird issue with my ECA. I'll check this out tomorrow
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation
It prevents AsciiString based headers to be used efficiently (using the cached
change
Replace the method body by the body of VertxHttpHeaders#add(CharSequence,Object) and have VertxHttpHeaders#add(CharSequence,Object) delegate to VertxHttpHeaders#add(CharSequence,CharSequence)
Microbenchmarks shows a significant improvement when optimised headers are used (hint before the optimization was only partially used). Note the benchmark is not used to justify the change, the change itself is very obvious. This was reported also with Java Flight Recorder hot methods showing a unusual call to AsciiString#hashCode(CharSequence) that calls PlatformDependent.hashCodeAscii(CharSequence ) instead of casting to AsciiString and using the cached value since the AsciiString was converted to String.

Before

Benchmark                             Mode  Cnt      Score      Error   Units
HttpServerHandlerBenchmark.vertx     thrpt   10    666.131    14.881  ops/ms
HttpServerHandlerBenchmark.vertxOpt  thrpt   10    734.061    19.262  ops/ms


After

Benchmark                             Mode  Cnt    Score     Error   Units
HttpServerHandlerBenchmark.vertx     thrpt   10  727.892   10.855  ops/ms
HttpServerHandlerBenchmark.vertxOpt  thrpt   10  798.006   18.767  ops/ms
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation
Currently VertxHttpHeaders has lot of duplicate code and not always uses the CharSequence based methods performing unnecessary work.
Changes
Refactor methods so the overloaded methods always delegate to the CharSequence version, this will keep only a single implementation and it will be the optimal version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@tsegismont no implementation changed, only shuffled the methods and rearranged code, but it's better to have another pair of eyes validating this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The block thread checker sometimes reports GC pauses as misbehaving blocking application.
http://www.fasterj.com/articles/gcnotifs.shtml
The GC mbean emits notification about GC pauses (start time / end time) that could be used to mitigate this and avoid false positive.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using the command line or launcher API to launch vertx, it is possible to use system properties to configure values for the cluster properties found on the VertxOptions class, but there is no public documentation describing the naming convention for these properties.
There is a brief sentence indicating that it is possible to use system properties, but with no description of what the property names are:

You can also set system properties using: -Dkey=value
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
did you try with vertx-lang-ceylon ? this is the most impacted module it would be good to validate it with it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
forgot to mention in the comment that it fixes #2441
(there is no PR showing up in the issue, just the commit I made)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Step to reproduce:
vertx.createDnsClient(53, "2001:4860:4860::8888").lookup4("vertx.io", res -> {}); 
=> the result fails with the following exception: 'java.net.SocketException: Address family not supported by protocol'
Expected: The DnsClient should be able to call a Dns server over IpV4 or IpV6
As a sidenote, I also tried using the full IpV6 address "2001:4860:4860:0:0:0:0:8888" but it doesn't work as well.
If time permits, I'll investigate this issue and provide a fix for it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm building a HTTP2 proxy with Vert.x 3.5.1, when I try to migrate to 3.5.2.CR1, NullPointerException may happen when requests come
May 16, 2018 2:40:21 PM io.vertx.core.impl.ContextImpl
 SEVERE: Unhandled exception
 java.lang.NullPointerException
 	at io.vertx.core.http.impl.VertxHttp2Stream.checkNextTick(VertxHttp2Stream.java:104)
 	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:309)
 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
 	at java.lang.Thread.run(Thread.java:748)


I guess this might be caused when pending deque is empty, see https://github.com/eclipse/vert.x/blob/47d15d66dcd56381ee07754545258d3c48537784/src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java#L103
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm building a server with Vert.x 3.5.1, after I use setIdleTimeout() to setup a idle timeout for some sockets, sockets will be closed by timeout. I keep writing to the sockets continuously,  some sockets may throw java.nio.channels.ClosedChannelException.
 17, 2018 10:33:08  io.vertx.core.net.impl.ConnectionBase
: Unhandled exception
java.nio.channels.ClosedChannelException
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)

Here's what I have tried, the exception may be thrown.

I wrote to sockets by write() method from other workers continuously, stop when endHandler or closeHandler invoked.
I tried to send buffer to WriteHandlerId through EventBus. When a socket is closed, the WriteHandlerId will automatically unregisterd.
I tried with WebSocket and Socket, they both throw the exception.

How to avoid this exception?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry for bad English.
I made simple solution dealing with multipart.
My reference is vertx-blueprint-microservice which use MSA.
I got problem How can I handle multipart.
PROBLEM IS HANGING RESPONSE.
Simple summary until now I found is
CLIENT ------ API_GATEWAY ----- SERVICE (multipart X, json O)
CLIENT ------ SERVICE (multipart O, json O)
In ApiGateway source,
if (context.getBody() == null) {
  toReq.end();
} else {
  toReq.end(context.getBody());
}

hanging point is  toReq.end(context.getBody());
after 10sec, it timeout.
I don't know how can I solve this.
I doubt that SERVICE can't accept multipart, however
CLIENT ------ SERVICE (multipart O, json O)
this is succeed. it's wierd.
Is there any more example how can I handle multipart proxying?
PS
vertx-blueprint-microservice
I saw this repo in vertx homepage.
I think this means quite important reference for understanding vertx.
However this repo looks dead. There is no response at all.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In NetSocketImpl:
  @Override
  protected synchronized void handleClosed() {
    checkContext();
    if (endHandler != null) {
      endHandler.handle(null);
    }
    super.handleClosed();
    if (vertx.eventBus() != null) {
      registration.unregister();
    }
  }

In WebSocketImplBase:
  void handleClosed() {
    synchronized (conn) {
      cleanupHandlers();
      if (endHandler != null) {
        conn.getContext().runOnContext(endHandler);
      }
      if (closeHandler != null) {
        conn.getContext().runOnContext(closeHandler);
      }
    }
  }

I set a closed flag in the endHandler. I will stop write to the socket, if the socket has the closed flag. However IllegalStateException: WebSocket is closed will be thrown by WebSocket sometimes. I modify the code snippet in WebSocketImplBase according to NetSocketImpl, Then the IllegalStateException never occurs again :
  void handleClosed() {
    synchronized (conn) {
      cleanupHandlers();
      if (endHandler != null) {
        endHandler.handle(null);
      }
      if (closeHandler != null) {
        conn.getContext().runOnContext(closeHandler);
      }
    }
  }

Is it a proper fix?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have signed the ECA. What should I do to pass the check?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a WorkExecutor is created via a vertx.createSharedWorkerExecutor(...) call, a reference to the WorkExecutor is added to the closeHooks for the current Context:
    ContextImpl context = getOrCreateContext();
    WorkerExecutorImpl namedExec = new WorkerExecutorImpl(this, sharedWorkerPool, true);
    context.addCloseHook(namedExec);
    return namedExec;

However, when the WorkerExecutor is closed, the reference is not removed from closeHooks, resulting in a leak:
  public void close() {
    synchronized (this) {
      if (!closed) {
        closed = true;
      } else {
        return;
      }
    }
    if (releaseOnClose && pool instanceof VertxImpl.SharedWorkerPool) {
      ((VertxImpl.SharedWorkerPool)pool).release();
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
At the moment the workerPool in VertxImpl is initialized as follows:
ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),
        new VertxThreadFactory("vert.x-worker-thread-", checker, true, options.getMaxWorkerExecuteTime()));
This creates an underlying ThreadPoolExecutor with an unbounded LinkedBlockingQueue
When our HTTP server is under immense load the queue grows which causes our latencies to grow unbounded.
We would prefer to fail fast or at least set a fixed size for the worker queue.
How do you feel about a new VertxOptions#workerPoolQueueCapacity ?
I could provide the accompanying PR as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jponge yes it would be better as the developer has to care about this result more than an runtime exception in the execute blocking call
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
motivation
Currently HttpClientRequest and HttpServerResponse don't check wether header name or value contain \r or \n chars. Of course developers are fully responsible for http headers set and
such incorrect value is likely unintended. Forbidding it prevents HTTP header injection for application that omit to check headers.
change
throw an IllegalArgumentException when a header name or value contains \r or \n char
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I update vert.x from version 3.5.0 to 3.5.1,project run with errors,  this is my shell
java -javaagent:/Users/xxx/.m2/repository/co/paralleluniverse/quasar-core/0.7.9/quasar-core-0.7.9.jar=b -Dvertx.zookeeper.config=./zookeeper.json -jar target/aaa-fat.jar   -conf application-conf.json -cluster
[quasar] ERROR: Unable to instrument class io/vertx/core/impl/DeploymentManager$DeploymentImpl
co.paralleluniverse.fibers.instrument.UnableToInstrumentException: Unable to instrument io/vertx/core/impl/DeploymentManager$DeploymentImpl#lambda$rollback$1(Ljava/lang/Throwable;Lio/vertx/core/impl/ContextImpl;Lio/vertx/core/Handler;Lio/vertx/core/impl/ContextImpl;Lio/vertx/core/AsyncResult;)V because of synchronization
at co.paralleluniverse.fibers.instrument.InstrumentMethod.dumpCodeBlock(InstrumentMethod.java:720)
at co.paralleluniverse.fibers.instrument.InstrumentMethod.accept(InstrumentMethod.java:415)
at co.paralleluniverse.fibers.instrument.InstrumentClass.visitEnd(InstrumentClass.java:265)
at co.paralleluniverse.asm.ClassReader.accept(Unknown Source)
at co.paralleluniverse.asm.ClassReader.accept(Unknown Source)
at co.paralleluniverse.fibers.instrument.QuasarInstrumentor.instrumentClass(QuasarInstrumentor.java:120)
at co.paralleluniverse.fibers.instrument.QuasarInstrumentor.instrumentClass(QuasarInstrumentor.java:88)
at co.paralleluniverse.fibers.instrument.JavaAgent$Transformer.transform(JavaAgent.java:187)
at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClass(ClassLoader.java:760)
at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at io.vertx.core.impl.DeploymentManager.doDeploy(DeploymentManager.java:465)
at io.vertx.core.impl.DeploymentManager.lambda$doDeployVerticle$2(DeploymentManager.java:203)
at io.vertx.core.impl.DeploymentManager$$Lambda$45/1076984738.handle(Unknown Source)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:76)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:171)
at io.vertx.core.impl.DeploymentManager.doDeployVerticle(DeploymentManager.java:143)
at io.vertx.core.impl.DeploymentManager.deployVerticle(DeploymentManager.java:131)
at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:665)
at io.vertx.core.Starter.runVerticle(Starter.java:328)
at io.vertx.core.Starter.run(Starter.java:138)
at io.vertx.core.Starter.main(Starter.java:96)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The file.encoding setting is valid when the trial java -jar command starts, but it does not work with the start parameter.(Vert.x 3.5.1) Here is an example:
This is the MainVerticle:
package com.longruan;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;

public class TestVerticle extends AbstractVerticle {

    Logger logger = LoggerFactory.getLogger(TestVerticle.class);

    @Override
    public void start() {
        logger.info(System.getProperty("file.encoding"));
    }
}

Execute the following command in a Chinese windows server:
java  -jar gateway-1.0-SNAPSHOT-fat.jar
java -Dfile.encoding=UTF-8 -jar gateway-1.0-SNAPSHOT-fat.jar
java -Dfile.encoding=UTF-8 -jar gateway-1.0-SNAPSHOT-fat.jar start

the Log is
2018-05-25 11:57:30.617 [ vert.x-eventloop-thread-0 ] - [ INFO  ] [ com.longruan.TestVerticle : 162 ] - GBK
2018-05-25 11:57:49.007 [ vert.x-eventloop-thread-0 ] - [ INFO  ] [ com.longruan.TestVerticle : 162 ] - UTF-8
2018-05-25 11:58:00.556 [ vert.x-eventloop-thread-0 ] - [ INFO  ] [ com.longruan.TestVerticle : 162 ] - GBK
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Used following helper script to auto-create certs:
echo "set -xe" > recreate-ssl.sh
echo "rm -rf root-ca int-ca other-ca | true" >> recreate-ssl.sh
echo "rm *.p12 *.jks *.pem *.crt *.key | true" >> recreate-ssl.sh
cat ssl.txt | grep -v -e ^# | grep -v -e ^[1-5T\(] | grep -v -e ^\- >> recreate-ssl.sh
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I just signed Eclipse Contributor Agreement.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
env : Windows 10 pro.
The Java process builder now removes double quotes in process arguments (https://bugs.openjdk.java.net/browse/JDK-8131908) to conform to Windows CLI parsing https://msdn.microsoft.com/en-us/library/17w5ykft.aspx
This affects the Vert.x redeploy mode with inline configuration which contains double quotes and the JSON will not be parsed by the process created by the launcher, the Verticle will not get the expected configuration.
On Windows we should escape this differently by surrounding with double quotes and using a \ char to escape inner double quotes (A double quotation mark preceded by a backslash (") is interpreted as a literal double quotation mark character (").)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@tsegismont can you check this commit f908ef9 (test fix) ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj here is the test in Vert.x core. There are PRs for all cluster managers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
clone project down my local,but some dependence dose not have contain version suan as netty in pom.xml
[ERROR]     'dependencies.dependency.version' for io.netty:netty-common:jar is missing. @ line 77, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-buffer:jar is missing. @ line 81, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-transport:jar is missing. @ line 85, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-handler:jar is missing. @ line 89, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-handler-proxy:jar is missing. @ line 93, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-codec-http:jar is missing. @ line 97, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-codec-http2:jar is missing. @ line 101, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-resolver:jar is missing. @ line 105, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-resolver-dns:jar is missing. @ line 109, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-transport-native-epoll:jar is missing. @ line 113, column 17
[ERROR]     'dependencies.dependency.version' for io.netty:netty-transport-native-kqueue:jar is missing. @ line 118, column 17
[ERROR]     'dependencies.dependency.version' for com.fasterxml.jackson.core:jackson-core:jar is missing. @ line 125, column 17
[ERROR]     'dependencies.dependency.version' for com.fasterxml.jackson.core:jackson-databind:jar is missing. @ line 129, column 17
[ERROR]     'dependencies.dependency.version' for io.vertx:vertx-codegen:jar is missing. @ line 161, column 17
[ERROR]     'dependencies.dependency.version' for io.vertx:vertx-docgen:jar is missing. @ line 166, column 17
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Every time a unique lock name is taken via SharedData.getLock(...), it gets added to a Map inside of SharedDataImpl. Currently, entries added to this Map are never removed, even if all references to the lock have been released, and there are no pending waiters. This means the Map can grow infinitely if an application takes locks using generated names, rather than hard-coded ones. To avoid this, entries could be removed from the internal map at the point the lock is released, as long as there are no pending waiters.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I am trying to deploy my micro services through docker in AWS ECS cluster, I am able to deploy the containers and services are registered with Zookeeper. Once registration is happend, microservices are not talking each other with the help of zookeeper. Can you please help on that.
Regards
2018-06-06 13:23:09,809 [myid:] - INFO [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:NIOServerCnxnFactory@215] - Accepted socket connection from /172.31.17.121:52002
2018-06-06 13:23:09,812 [myid:] - INFO [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:2181:ZooKeeperServer@948] - Client attempting to establish new session at /172.31.17.121:52002
2018-06-06 13:23:09,813 [myid:] - INFO [SyncThread:0:ZooKeeperServer@693] - Established session 0x10001caa9350007 with negotiated timeout 20000 for client /172.31.17.121:52002
2018-06-06 13:23:18,675 [myid:] - INFO [SessionTracker:ZooKeeperServer@354] - Expiring session 0x10001caa9350005, timeout of 20000ms exceeded
2018-06-06 13:23:18,676 [myid:] - INFO [ProcessThread(sid:0 cport:2181)::PrepRequestProcessor@487] - Processed session termination for sessionid: 0x10001caa9350005
Here is the log from Zookeeper, which shows connection established from docker containers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Issue
While using vertx to implement a websocket server, certain websocket client library (okhttp) got failure callback when closing the websocket from its side.
Finding
After doing a package capture, I found vertx didn't respond a CLOSE frame after receiving one. This behavior doesn't follow the RFC.
https://github.com/eclipse/vert.x/blob/e69a81a039400af76b256a55b38d8b65c3b07ca1/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java#L695-L703
I checked vertx source code, and did some debug. I believe there is a bug at Line 699. From the comment, these lines of code intend to Echo back close frame.
Actually the Line 699 would always fail.
ch.writeAndFlush(wsFrame).addListener(ChannelFutureListener.CLOSE); 

After adding some debug code there, it actually throws the following exception. The wrFrame cannot be passed to writeAndFlush directly.
java.lang.UnsupportedOperationException: unsupported message type: WebSocketFrameImpl (expected: ByteBuf, FileRegion)
	at io.netty.channel.nio.AbstractNioByteChannel.filterOutboundMessage(AbstractNioByteChannel.java:266)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:877)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1371)

Solution
Change Line 699 to the following code solves the issue.
ch.writeAndFlush(new CloseWebSocketFrame(wsFrame.closeStatusCode(), 
    wsFrame.closeReason())).addListener(ChannelFutureListener.CLOSE);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version - 3.5.1
The underlying implementation class (HandlerRegistration) has a discard handler, but setting this is not exposed (the method has a comment about it being for test use only).  Having the ability to find out when messages are discarded is actually useful when managing workloads at scale.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version - 3.5.1
The underlying implementation class (HandlerRegistration) has a discard handler, but setting this is not exposed (the method has a comment about it being for test use only).  Having the ability to find out when messages are discarded is actually useful when managing workloads at scale.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version -- 3.5.1
Currently when a message is handled by the bus the "choose" code will simply pick the next handler in line.  If it turns out that handler is paused, the message will get dropped on the pending queue and possibly discarded, even if there are other handlers on the same address that are available to process the message.  It would be preferable if it gave preference to handlers that are not paused over those that are when making this choice.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently FutureImpl keeps a reference on the handler after it has been completed. As side effect it can promote objects to survivor spaces. Since the future is completed there is no need to keep the reference onto the handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HttpClient adds the IdleStateHandler before the handler, relying on the handler presence. With HTTP/2 clear text upgrade the handler name cannot be preserved and therefore adding the idle state handler fails.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently when the HttpClient sends an HTTP/2 request, it uses the https scheme unconditionally. The scheme decision should look whether the connection uses TLS or not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Code to reproduce the error: https://gist.github.com/emmx/52e672b4f163d471ed36fed9fae8b93a
I'm running it on a AWS instance, it shouldn't matter but maybe network performance is important in case this is caused by a race condition.
Vert.x 3.5.2
Java 10.0.1
java.lang.IllegalStateException: Uh oh! Event loop context executing with wrong thread! Expected null got Thread[globalEventExecutor-1-1,5,main]
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:318)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:195)
	at io.vertx.core.http.impl.HttpClientRequestImpl.lambda$connect$10(HttpClientRequestImpl.java:639)
	at io.vertx.core.http.impl.ConnectionManager.lambda$getConnection$5(ConnectionManager.java:166)
	at io.vertx.core.http.impl.pool.Pool.lambda$createConnection$4(Pool.java:315)
	at io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:165)
	at io.vertx.core.http.impl.HttpChannelConnector.connectFailed(HttpChannelConnector.java:280)
	at io.vertx.core.http.impl.HttpChannelConnector.lambda$doConnect$2(HttpChannelConnector.java:181)
	at io.vertx.core.net.impl.ChannelProvider.lambda$connect$0(ChannelProvider.java:54)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:481)
	at io.netty.util.concurrent.DefaultPromise.access$000(DefaultPromise.java:34)
	at io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:431)
	at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:240)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:844)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Access to no existing routing,return Resource not found ,why not Get into failureHandler !
Such as default access / or access that does not exist
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The executeBlocking methods are common between the interfaces WorkerExecutor and Context. It would be an API convenience to have WorkerExecutor and Context be extensions of a common interface that supplies the two executeBlocking methods.
Then something like the following could be done:
// given:
public interface Context extends ExecuteBlockingInterface { /* ... */ }
public interface WorkerExecutor extends Measured, ExecuteBlockingInterface { /* ... */ }

// when:
public static void makeManyBlockingCalls(ExecuteBlockingInterface ebi, Future allDone) {
    // call `ebi.executeBlocking` many times, complete allDone when all blocking calls finish
}

// then: call it on the current Context
makeManyBlockingCalls(vertx.getOrCreateContext(), future)

// then: call it on a WorkerExecutor
WorkerExecutor exec = vertx.createSharedWorker("tmp-worker-pool");
makeManyBlockingCalls(exec, Future.future().setHandler(event -> exec.close()))
Currently, makeManyBlockingCalls needs to be overloaded to accept a Context or WorkerExecutor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In BaseSQLClient.class package io.vertx.ext.asyncsql.impl  dependency there is a limit for a record size set to 16777216. The internal config parameter name is maximumMessageSize.
When trying to download a large file from the database, the server produces an error:
com.github.mauricio.async.db.postgresql.exceptions.MessageTooLongException: Message of type 68 has size 38080055, higher than the limit 116777216.
Unfortunately there is no way to change the limit without the code modification (which I temporarily did)
It would be useful to be able to set that limit up in JsonObject config (additional configuration key)
How can I get large files from the database?
Best regards
ldvhome
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I know Akka and it's acotrs is very powerful.
My question is know how to implement actors model with vertx?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj
`package com.cloudyoung.wx.test.base;
import java.util.concurrent.CountDownLatch;
import org.junit.Test;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClient;
public class VertxWebSocketServerTest extends BaseTest {
private CountDownLatch latch = new CountDownLatch(1);

@Test
public void initWebSocketConnection() throws Exception {
    WebSocketVerticle verticle = new WebSocketVerticle();
    verticle.start();
    latch.await();
}

class WebSocketVerticle extends AbstractVerticle {
    
    private int port = 9090;

    private String host = "localhost";

    private String requestURI = "webSocketServer?appId=wxdc55ca89d7d4d1b8&module=WX_WEBSOCKET_DIALOGUE_MODULE&clientSign=7ab2c148-5bdb-4786-ad36-37ada47bb613";

    private int clientNum = 20;

    private int connectionNum = 60000;

    private Vertx vertx = Vertx.vertx();
    
    @Override
    public void start() throws Exception {
        for (int i = 1; i <= clientNum; i++) {
            HttpClient httpClient = vertx.createHttpClient();
            for(int j=1; j<= connectionNum; j++) {
                httpClient.websocket(port, host, requestURI, webSocket -> {
                    webSocket.handler(buffer -> {
                        System.out.println("got number from server: " + buffer.toJsonObject().getInteger("number"));
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    });
                });
            }
        }
    }
}

}
`
exception info:
19:24:30 [main] DEBUG io.netty.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework
19:24:30 [main] DEBUG io.netty.util.ResourceLeakDetector - -Dio.netty.leakDetection.level: simple
19:24:30 [main] DEBUG io.netty.util.ResourceLeakDetector - -Dio.netty.leakDetection.targetRecords: 4
19:24:30 [main] DEBUG io.netty.channel.MultithreadEventLoopGroup - -Dio.netty.eventLoopThreads: 16
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - Platform: MacOS
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - -Dio.netty.noUnsafe: false
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - Java version: 8
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.theUnsafe: available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - sun.misc.Unsafe.copyMemory: available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Buffer.address: available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - direct buffer constructor: available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.Bits.unaligned: available, true
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent0 - java.nio.DirectByteBuffer.(long, int): available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - sun.misc.Unsafe: available
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.tmpdir: /var/folders/m3/27h81r2d4815l01bbfsfj4fh0000gn/T (java.io.tmpdir)
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.bitMode: 64 (sun.arch.data.model)
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.noPreferDirect: false
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.maxDirectMemory: 3817865216 bytes
19:24:30 [main] DEBUG io.netty.util.internal.PlatformDependent - -Dio.netty.uninitializedArrayAllocationThreshold: -1
19:24:30 [main] DEBUG io.netty.util.internal.CleanerJava6 - java.nio.ByteBuffer.cleaner(): available
19:24:30 [main] DEBUG io.netty.channel.nio.NioEventLoop - -Dio.netty.noKeySetOptimization: false
19:24:30 [main] DEBUG io.netty.channel.nio.NioEventLoop - -Dio.netty.selectorAutoRebuildThreshold: 512
19:24:31 [main] DEBUG io.netty.util.internal.PlatformDependent - org.jctools-core.MpscChunkedArrayQueue: available
19:24:31 [main] DEBUG io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider - Default DNS servers: [/192.168.30.100:53, /202.106.0.20:53] (sun.net.dns.ResolverConfiguration)
19:24:31 [main] DEBUG io.netty.util.NetUtil - -Djava.net.preferIPv4Stack: false
19:24:31 [main] DEBUG io.netty.util.NetUtil - -Djava.net.preferIPv6Addresses: false
19:24:31 [main] DEBUG io.netty.util.NetUtil - Loopback interface: lo0 (lo0, 0:0:0:0:0:0:0:1)
19:24:31 [main] DEBUG io.netty.util.NetUtil - Failed to get SOMAXCONN from sysctl and file /proc/sys/net/core/somaxconn. Default: 128
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numHeapArenas: 16
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.numDirectArenas: 16
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.pageSize: 8192
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxOrder: 11
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.chunkSize: 16777216
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.tinyCacheSize: 512
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.smallCacheSize: 256
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.normalCacheSize: 64
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.maxCachedBufferCapacity: 32768
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.cacheTrimInterval: 8192
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.buffer.PooledByteBufAllocator - -Dio.netty.allocator.useCacheForAllThreads: true
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024
19:24:31 [vert.x-eventloop-thread-0] DEBUG io.netty.util.internal.InternalThreadLocalMap - -Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096
19:24:36 [vert.x-eventloop-thread-13] DEBUG io.netty.channel.DefaultChannelId - -Dio.netty.processId: 5803 (auto-detected)
19:24:36 [vert.x-eventloop-thread-13] DEBUG io.netty.channel.DefaultChannelId - -Dio.netty.machineId: ac48:ff:fe:00:11:22 (auto-detected)
19:24:36 [vert.x-eventloop-thread-10] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.allocator.type: pooled
19:24:36 [vert.x-eventloop-thread-10] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.threadLocalDirectBufferSize: 65536
19:24:36 [vert.x-eventloop-thread-10] DEBUG io.netty.buffer.ByteBufUtil - -Dio.netty.maxThreadLocalCharBufferSize: 16384
19:24:36 [vert.x-eventloop-thread-7] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.bytebuf.checkAccessible: true
19:24:36 [vert.x-eventloop-thread-7] DEBUG io.netty.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@35f3bcab
19:24:36 [vert.x-eventloop-thread-7] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: DCBugaCiw81NPWbpEClurQ==, expected response: jH2EtzeVP+k+rAJ0AjrwbuFadfM=
19:24:36 [vert.x-eventloop-thread-1] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: A4CwX+3VzVRbPOwpH2bqyA==, expected response: RsORCshbiUjp6/1UkHjoZ17VBo8=
19:24:36 [vert.x-eventloop-thread-14] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: rz29DcMc7WYz/hLSygPOiQ==, expected response: XP94LxqAOM/Bn3eMVTOnYMbqU5I=
19:24:36 [vert.x-eventloop-thread-8] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: namdWLhsBcn1SwSl+IrPUw==, expected response: 23w6+CWGIoLzfoXkb3I47e7KiMs=
19:24:36 [vert.x-eventloop-thread-4] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: 6jBb1K326SvGsmPFsvoHUA==, expected response: XmVxmdhuYdRZXNEWknOCLrTzAeI=
19:24:36 [vert.x-eventloop-thread-12] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: CfbYqKNEjAy0xmaxGvqKbQ==, expected response: HcK38aDk2ONaP1/SZDVO2E/f48U=
19:24:36 [vert.x-eventloop-thread-9] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: zQ1IFdb5feHhMlv5Aj+v6g==, expected response: sxiDkUJJFVw870241E0ryhf7rjM=
19:24:36 [vert.x-eventloop-thread-15] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: 0Jc72nZa+MskfAWVmwkFPg==, expected response: M6Mw4C2gENEyc4oXsN6BekgtSFE=
19:24:36 [vert.x-eventloop-thread-13] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: ct5UNZGkkinrPdPnMy5IOQ==, expected response: 3Rmnnhy9AKkYjogeKsYojdCWK6Y=
19:24:36 [vert.x-eventloop-thread-0] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: oppjdFJOWMziI8RzYwyl3w==, expected response: rY+bRyhcDyRXuOpUldCfqJ7GlA8=
19:24:36 [vert.x-eventloop-thread-3] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: Ibgk/MIeZzY+xQV3EcgsUA==, expected response: YIEdcu0C9YUK38sW0zwaYGfFZCI=
19:24:36 [vert.x-eventloop-thread-10] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: +NaoBLPOLly80PXBU6aU1A==, expected response: T4CSH8LrkJBO0r+PBYrW0pT4bLg=
19:24:36 [vert.x-eventloop-thread-6] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: S5CpXs+zk24yNBJLWIkZlw==, expected response: YDUujFU3ybb+ULHp4d+hjNXxH7Y=
19:24:36 [vert.x-eventloop-thread-2] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: WY68hG0tcQXt12Ybnk201w==, expected response: whI+Vq4w2yOugUVYWJ0hsynhWh0=
19:24:36 [vert.x-eventloop-thread-5] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: ErBmPnqZNYDBOhSyqDk0lw==, expected response: Q/9FO6AYPMXTXobXbqssYtH+Gyc=
19:24:36 [vert.x-eventloop-thread-11] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: D4XSHw9Z5HgYFjGATQiXWA==, expected response: YkMylc54LLHSki3xiekR5qT/Pbw=
 17, 2018 7:24:36  io.vertx.core.http.impl.HttpClientImpl
: java.lang.NullPointerException: value
 17, 2018 7:24:36  io.vertx.core.http.impl.HttpClientImpl
: java.lang.NullPointerException: value
19:24:36 [vert.x-eventloop-thread-6] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: GUfEstOfYBKkmC6QgBNttA==, expected response: lo8lorxtK2YL7f+MNvCqcpuC0AY=
 17, 2018 7:24:36  io.vertx.core.http.impl.HttpClientImpl
: java.lang.NullPointerException: value
19:24:36 [vert.x-eventloop-thread-14] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: SKpjw3ho8j3dBVdECeRt8Q==, expected response: LnJj7PqkaYe8DEJnK/MXVVOJz50=
19:24:36 [vert.x-eventloop-thread-11] DEBUG io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13 - WebSocket version 13 client handshake key: qUBnp78dz0sMeu7NeHKQgg==, expected response: Xc7XnO+2eAQIuiHmSZ7qi3iMEZs=
 17, 2018 7:24:36  io.vertx.core.http.impl.HttpClientImpl
: java.lang.NullPointerException: value
 17, 2018 7:24:36  io.vertx.core.http.impl.HttpClientImpl
: java.lang.NullPointerException: value
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I saw this in our log file. Is it something that should be fixed? I suspected that it might have something to do with websocket but I can't be sure.
i.n.c.DefaultChannelPipeline [vert.x-eventloop-thread-0] [] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. java.io.IOException: Connection reset by peer | 	at sun.nio.ch.FileDispatcherImpl.read0(Native Method) | 	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39) | 	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) | 	at sun.nio.ch.IOUtil.read(IOUtil.java:192) | 	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) | 	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288) | 	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108) | 	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345) | 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:126) | 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645) | 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580) | 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497) | 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459) | 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886) | 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) | 	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,we are heavy use vert.x, and we want limit active client connection count both in HttpServer and NetServer.
If server had accepted certain amount of connection, new connection need reject for overload protection.
Any good idea ?
Best Regards & Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Will be reopened
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using Vertx 3.5.0 WebClient API to make HTTP call to remote server and given below is how my input URI look like :

/server/path?jREJBBB5x2AaiSSDO0/OskoCztDZBAAAAAADV1A4

In HttpClientContext Vertx is calling io.netty.handler.codec.http.QueryStringEncoder, which append "=" even though it wasn't there in actual input provided to Vertx.
QueryStringEncoder enc = new QueryStringEncoder(request.uri); request.queryParams().forEach(param -> enc.addParam(param.getKey(), param.getValue())); requestURI = enc.toString();
From QueryStringEncoder:
if (value != null) { this.uriBuilder.append('='); appendComponent(value, this.charsetName, this.uriBuilder); }
So actual URI received by remote server looks like below:

/server/path?jREJBBB5x2AaiSSDO0%2FOskoCztDZBAAAAAADV1A4=

If you notice in above URL, Vertx is encoding the parameter and also appending extra "=" at the end.
This issue isn't there if we use HttpClient API instead of WebClient API. Unfortunately the remote server doesn't like this extra "=" added to query and encoded query, and fails hard. This remote system can't be updated to handle this behavior because if doesn't belong to us.
Moving back to HttpClient will be very expensive to us because of amount of code change. Looking forward to your feedback. We are open for suggestions, and we can create a PR once agreed upon the solution.
Here is sample reproducer - https://github.com/manish-panwar/vertx-issue-2544-reproducer-
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
will review today
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have tried to load ECDSA key pair that is formatted using following delimiters:
TLS_CERT
-----BEGIN CERTIFICATE-----
... cert content comes here ...
-----END CERTIFICATE-----

TLS_KEY
-----BEGIN EC PRIVATE KEY-----
... private key content comes here ...
-----END EC PRIVATE KEY-----

using the following conde snippet:
        return new HttpServerOptions()
                .setUseAlpn(true)
                .setSsl(true)
                .setPemKeyCertOptions(
                        new PemKeyCertOptions()
                                .setKeyValue(Buffer.buffer(getMandatoryString(config, "TLS_KEY")))
                                .setCertValue(Buffer.buffer(getMandatoryString(config, "TLS_CERT")))
                );

And I get the following error message:
{
      "time" : "24-07-2018 03:51:05 BST",
      "level" : "DEBUG",
      "loggerName" : "com.crypt.common.http.routes.AbstractApiVerticle",
      "message" : "Unable to starting Api Verticle",
      "thrown" : [
        "io.vertx.core.VertxException: java.lang.RuntimeException: Missing -----END PRIVATE KEY----- delimiter",
        "        at io.vertx.core.net.impl.SSLHelper.createContext(SSLHelper.java:297)",
        "        at io.vertx.core.net.impl.SSLHelper.getContext(SSLHelper.java:457)",
        "        at io.vertx.core.net.impl.SSLHelper.validate(SSLHelper.java:482)",
        "        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:243)",
        "        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:216)",
        "        at io.vertx.reactivex.core.http.HttpServer.listen(HttpServer.java:249)",
        "        at io.vertx.reactivex.core.http.HttpServer.lambda$rxListen$2(HttpServer.java:268)",
        "        at io.vertx.reactivex.core.impl.AsyncResultSingle.subscribeActual(AsyncResultSingle.java:42)",
        "        at io.reactivex.Single.subscribe(Single.java:3313)",
        "        at io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback.onSuccess(SingleFlatMap.java:84)",
        "        at io.reactivex.internal.operators.single.SingleDoOnError$DoOnError.onSuccess(SingleDoOnError.java:52)",
        "        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)",
        "        at io.vertx.reactivex.core.impl.AsyncResultSingle.lambda$subscribeActual$0(AsyncResultSingle.java:46)",
        "        at io.vertx.reactivex.ext.web.api.contract.openapi3.OpenAPI3RouterFactory$8.handle(OpenAPI3RouterFactory.java:272)",
        "        at io.vertx.reactivex.ext.web.api.contract.openapi3.OpenAPI3RouterFactory$8.handle(OpenAPI3RouterFactory.java:269)",
        "        at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:79)",
        "        at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:289)",
        "        at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)",
        "        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)",
        "        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)",
        "        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)",
        "        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)",
        "        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)",
        "        at java.lang.Thread.run(Thread.java:748)",
        "Caused by: java.lang.RuntimeException: Missing -----END PRIVATE KEY----- delimiter",
        "        at io.vertx.core.net.impl.KeyStoreHelper.loadPems(KeyStoreHelper.java:355)",
        "        at io.vertx.core.net.impl.KeyStoreHelper.loadPrivateKey(KeyStoreHelper.java:305)",
        "        at io.vertx.core.net.impl.KeyStoreHelper.loadKeyCert(KeyStoreHelper.java:293)",
        "        at io.vertx.core.net.impl.KeyStoreHelper.create(KeyStoreHelper.java:107)",
        "        at io.vertx.core.net.KeyCertOptions.getKeyManagerFactory(KeyCertOptions.java:43)",
        "        at io.vertx.core.net.impl.SSLHelper.getKeyMgrFactory(SSLHelper.java:302)",
        "        at io.vertx.core.net.impl.SSLHelper.createContext(SSLHelper.java:255)",
        "        ... 23 more"
      ]
    }


Which make me wonder wheter there is any support for elliptic-curve cryptography or if I am missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As can be seen from this line of FileResolver.java, unpackFromBundleURL() does not account for the possibility of a resource path to be a directory - even if it doesn't end with a '/'.
For example, consider the following sample OSGi bundle structure (excluding manifests etc.):
META-INF/
 resources
     webjars
         swagger-ui
             3.17.4
                 favicon-16x16.png
                 favicon-32x32.png
                 index.html
                 index.html.gz
                 oauth2-redirect.html
                 oauth2-redirect.html.gz
                 swagger-ui-bundle.js
                 swagger-ui-bundle.js.gz
                 swagger-ui-bundle.js.map
                 swagger-ui.css
                 swagger-ui.css.gz
                 swagger-ui.css.map
                 swagger-ui.js
                 swagger-ui.js.gz
                 swagger-ui.js.map
                 swagger-ui-standalone-preset.js
                 swagger-ui-standalone-preset.js.gz
                 swagger-ui-standalone-preset.js.map

4 directories, 18 files

If unpackFromBundleURL() is called for META-INF/resources/webjars/swagger-ui/3.17.4/, it will correctly reach the directory code here. However, if this method is called for META-INF/resources/webjars/swagger-ui/3.17.4, the else branch (for file resources) will be taken and the cache will be corrupted.
See #2549 for a fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have just signed the required ECA.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Class path resolving is currently enabled or disabled via System property.
In environments with multiple Vert.x-based applications the property will be set to the same value for all the applications running in the same JVM.
Adding a VertxOption field to override the System property would allow each Vert.x application in a JVM to decide individually whether to allow file class path resolving.
The use-case driving this issue is that we would like to use Vert.x as a client without any file system side effects (such as creating a .vertx directory), but we don't want to interfere with other Vert.x-based applications that may be running in the same JVM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we should use a FileSystemOptions as we may have other related options in the future.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi, now we have moved the docs here https://github.com/eclipse/vert.x/blob/master/src/main/asciidoc/http.adoc (the current file you edited is a left-over we need to clean up), can you reopen a new IP valid PR please ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign your commits and the ECA ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using RecordParser's delimited mode, it would be nice to somehow limit the maximum buffer size, to prevent misbehaving/malicious clients from exhausting server resources.
This could be achieved by exposing the buffer length, like so:
RecordParser rp = RecordParser.newDelimited("\n", System.out::println);
socket.handler(buffer -> {
   rp.handle(buffer);
   if (rp.getBufferSize() > config().getInteger("maxRecordSize")) {
      System.out.println("big record, eh?");
      socket.close();
   }
});
Another option would be to check the record size in RecordParserImpl.parseDelimited() and throw an exception, that could be handled inside the exceptionHandler:
RecordParser rp = RecordParser.newDelimited("\n", System.out::println);
rp.setMaxRecordSize(10);
rp.exceptionHandler(throwable -> {
   System.out.println("big record, eh?");
   socket.close();
});
Thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
I think I might have found a bug in Vert.x 3.5.3 or Netty. If I enable GZIP compression on both my HTTP server and the client and then try to send an HTTP trailer I get the exception below.
I created a gist demonstrating the error:
https://gist.github.com/michel-kraemer/382ef926d5503541fa1458d2e7695987
As soon as I comment out one of the lines marked with // XXXXXXX the program works correctly.
Am I doing something wrong or is this actually a bug?
Cheers,
Michel
SEVERE: Unhandled exception
java.lang.NullPointerException
	at io.vertx.core.http.impl.Http1xClientHandler.handleMessage(Http1xClientHandler.java:100)
	at io.vertx.core.http.impl.Http1xClientHandler.handleMessage(Http1xClientHandler.java:33)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelRead$1(VertxHandler.java:146)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:337)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:195)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:144)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The docs for SharedData.getLock() do not specify the behaviour when there is competition in acquiring a lock. While non-determinism is expected when this is happening from multiple threads, it is also silent about what happens if I try to acquire the same lock sequentially in the same method:
vertx.sharedData().getLock()
vertx.sharedData().getLock()

From the code I can see that a local lock uses an ordered list of waiters, so I would expect that the first call would acquire the lock before before the 2nd (in the absence of timeout, and obviously with the possibility of there being interleaving acquisitions from other threads). But I've no idea whether these same semantics would also apply with a clustered lock. If the API doesn't guarantee any such semantics the Javadoc should probably explain that to avoid people accidentally relying on such behaviour.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public synchronized HttpServer listen(int port, String host, Handler<AsyncResult> listenHandler) {
if (requestStream.handler() == null && wsStream.handler() == null) {
throw new IllegalStateException("Set request or websocket handler first");
}
if (listening) {
throw new IllegalStateException("Already listening");
}
listenContext = vertx.getOrCreateContext();
listening = true;
serverOrigin = (options.isSsl() ? "https" : "http") + "://" + host + ":" + port;
List applicationProtocols = options.getAlpnVersions();
if (listenContext.isWorkerContext()) {
applicationProtocols =  applicationProtocols.stream().filter(v -> v != HttpVersion.HTTP_2).collect(Collectors.toList());
}
sslHelper.setApplicationProtocols(applicationProtocols);
synchronized (vertx.sharedHttpServers()) {
this.actualPort = port; // Will be updated on bind for a wildcard port
id = new ServerID(port, host);
HttpServerImpl shared = vertx.sharedHttpServers().get(id);
if (shared == null || port == 0) {
serverChannelGroup = new DefaultChannelGroup("vertx-acceptor-channels", GlobalEventExecutor.INSTANCE);
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(vertx.getAcceptorEventLoopGroup(), availableWorkers);
applyConnectionOptions(bootstrap);
sslHelper.validate(vertx);
bootstrap.childHandler(new ChannelInitializer() {
@OverRide
protected void initChannel(Channel ch) throws Exception {
if (requestStream.isPaused() || wsStream.isPaused()) {
ch.close();
return;
}
ChannelPipeline pipeline = ch.pipeline();
if (sslHelper.isSSL()) {
io.netty.util.concurrent.Future handshakeFuture;
if (options.isSni()) {
VertxSniHandler sniHandler = new VertxSniHandler(sslHelper, vertx);
pipeline.addLast(sniHandler);
handshakeFuture = sniHandler.handshakeFuture();
} else {
SslHandler handler = new SslHandler(sslHelper.createEngine(vertx));
pipeline.addLast("ssl", handler);
handshakeFuture = handler.handshakeFuture();
}
handshakeFuture.addListener(future -> {
if (future.isSuccess()) {
if (options.isUseAlpn()) {
SslHandler sslHandler = pipeline.get(SslHandler.class);
String protocol = sslHandler.applicationProtocol();
if ("h2".equals(protocol)) {
handleHttp2(ch);
} else {
handleHttp1(ch);
}
} else {
handleHttp1(ch);
}
} else {
HandlerHolder handler = httpHandlerMgr.chooseHandler(ch.eventLoop());
handler.context.executeFromIO(() -> handler.handler.exceptionHandler.handle(future.cause()));
}
});
} else {
if (DISABLE_H2C) {
handleHttp1(ch);
} else {
IdleStateHandler idle;
if (options.getIdleTimeout() > 0) {
pipeline.addLast("idle", idle = new IdleStateHandler(0, 0, options.getIdleTimeout()));
} else {
idle = null;
}
// Handler that detects whether the HTTP/2 connection preface or just process the request
// with the HTTP 1.x pipeline to support H2C with prior knowledge, i.e a client that connects
// and uses HTTP/2 in clear text directly without an HTTP upgrade.
pipeline.addLast(new Http1xOrH2CHandler() {
@OverRide
protected void configure(ChannelHandlerContext ctx, boolean h2c) {
if (idle != null) {
// It will be re-added but this way we don't need to pay attention to order
pipeline.remove(idle);
}
if (h2c) {
handleHttp2(ctx.channel());
} else {
handleHttp1(ch);
}
}
                @Override
                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
                  if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
                    ctx.close();
                  }
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
                  super.exceptionCaught(ctx, cause);
                  HandlerHolder<HttpHandlers> handler = httpHandlerMgr.chooseHandler(ctx.channel().eventLoop());
                  handler.context.executeFromIO(() -> handler.handler.exceptionHandler.handle(cause));
                }
              });
            }
          }
        }
    });

    addHandlers(this, listenContext);
    try {
      bindFuture = AsyncResolveConnectHelper.doBind(vertx, SocketAddress.inetSocketAddress(port, host), bootstrap);
      bindFuture.addListener(res -> {
        if (res.failed()) {
          vertx.sharedHttpServers().remove(id);   //fixme    //async to remove
        } else {
          Channel serverChannel = res.result();
          HttpServerImpl.this.actualPort = ((InetSocketAddress)serverChannel.localAddress()).getPort();
          serverChannelGroup.add(serverChannel);
          VertxMetrics metrics = vertx.metricsSPI();
          this.metrics = metrics != null ? metrics.createMetrics(this, new SocketAddressImpl(port, host), options) : null;
        }
      });
    } catch (final Throwable t) {
      // Make sure we send the exception back through the handler (if any)
      if (listenHandler != null) {
        vertx.runOnContext(v -> listenHandler.handle(Future.failedFuture(t)));
      } else {
        // No handler - log so user can see failure
        log.error(t);
      }
      listening = false;
      return this;
    }
    vertx.sharedHttpServers().put(id, this);    //fixme  //syn put
    actualServer = this;
  } else {
    // Server already exists with that host/port - we will use that
    actualServer = shared;
    this.actualPort = shared.actualPort;
    addHandlers(actualServer, listenContext);
    VertxMetrics metrics = vertx.metricsSPI();
    this.metrics = metrics != null ? metrics.createMetrics(this, new SocketAddressImpl(port, host), options) : null;
  }
  actualServer.bindFuture.addListener(future -> {
    if (listenHandler != null) {
      final AsyncResult<HttpServer> res;
      if (future.succeeded()) {
        res = Future.succeededFuture(HttpServerImpl.this);
      } else {
        res = Future.failedFuture(future.cause());
        listening = false;
      }
      listenContext.runOnContext((v) -> listenHandler.handle(res));
    } else if (future.failed()) {
      listening  = false;
      // No handler - log so user can see failure
      log.error(future.cause());
    }
  });
}
return this;

}
has two line code use //fixme
we use async to remove id when happends error
but use sync to put id later on
may the error happends before the  (vertx.sharedHttpServers().put(id, this);    //fixme  //syn put)
then rarely
first remove
second put.
it while listen error
but sharedHttpServers has the id
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There appears to be no way for an application to discover if a Timer is active, or to inspect the metadata of a timer.
The timeouts map (io.vertx.core.impl.VertxImpl#timeouts) is private, as is the timer data (io.vertx.core.impl.VertxImpl.InternalTimerHandler).  All that is possible is to cancel a timer.  Is there a mechanic for managing timers that isn't obvious?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My Eclipse contributor agreement is under the e-mail address deven.phillips@gmail.com
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vertx version 3.5.1
Recently i migrated from vertx 2 to vertx 3.5.1. I am sending a value - %%SOME_VALUE%% in my paramater. But Vertx 3 throws error "invalid hex byte" while handling the request. I cannot change the format of the value due to some constraints but looking for some ways to handle within the vertx application. I am unable to overwrite the netty decoder used in vertx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what's the motivation ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HI I have compressed data as byte[], stored in DB table column. I need to get the byte[] and decompress it. But there is no direct method to get data as byte[] in vert.x jdbc. I tried using getBinary(0) , but it throws me below exception
java.lang.IllegalArgumentException: Illegal base64 character 1f
at java.util.Base64$Decoder.decode0(Base64.java:714)
at java.util.Base64$Decoder.decode(Base64.java:526)
at java.util.Base64$Decoder.decode(Base64.java:549)
at io.vertx.core.json.JsonArray.getBinary(JsonArray.java:222)
at com.example.test.WebVerticle.lambda$null$3(WebVerticle.java:138)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:81)
at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:294)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:344)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:465)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Can anyone please help me out to decompress byte[] stored in DB.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello i cannot catch null error on sending email
my code is like this :
fun sendMessage(data: JsonObject) : Observable<MailResult> {
         return observable<MailResult> {
            val message = MailMessage(data)
            mailClient.sendMail(message, it)
         }.doOnError {
             log.error("error on mailClient, move to resend"+it.message + " "+ it.getStackTraceAsString())
         }.onErrorReturn {
             null
         }.map {
             it
         }
    }

and try to use this, but still cannot catch the error on failed :
mailClient.sendMail(message) {
             if (it.succeeded()) {} 
             else {
                  log.error("error on mailClient "+it.cause().printStackTrace())
             }
}

log error :
io.vertx.core.impl.ContextImpl - Unhandled exception
java.lang.NullPointerException: null
    at io.vertx.ext.mail.impl.SMTPConnection.handleError(SMTPConnection.java:171)
    at io.vertx.ext.mail.impl.SMTPConnection.handleError(SMTPConnection.java:167)
    at io.vertx.ext.mail.impl.SMTPConnection.lambda$null$2(SMTPConnection.java:203)
    at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A Vert.x stream isn't trivial to implement and actual adapters using request flow control (RxJava,Reactive-Streams) have to maintain an extra queue for buffering unrequested items until they are requested.
The ReadStream interface should be augmented with a fetch operation that allows to provide request based control. The stream interface continues to operate with pause/resume control that is easier to use (and also more realistic with actual transports such as TCP, as request based flow control has to prefetch for efficiency in practice).
The state changes from two states (paused / flowing) to (fetching[n] / flowing), fetching[0] is equivalent to pause.
A fetch method is added to ReadStream:
public interface ReadStream<T> {

  // Set the stream into flowing mode
  @Fluent
  ReadStream<T> resume();

  // Set the stream into fetch mode with no fetched items
  @Fluent
  ReadStream<T> pause();

  // Set the stream into fetch mode with the specified amount of fetched items
  // or increase the current amount of fetched items if the stream was previously fetching
  @Fluent
  ReadStream<T> fetch(long amount);

}
ReadStream is difficult to implement and it is often implemented multiples times. We want to provide a helper for implementation (Queue) that acts as a event driven queue relieving the implementor to handle threading, reentrancy and data races. Currently such queue is maintained in several places implicitly (like HttpServerRequest or AsyncFile) and sometimes not:
public interface Queue<T>  {

  // Add an item in the queue
  // returns whether more items can be added
  boolean add(T item);

  // Signal when the queue becomes writable again
  Queue<T> writableHandler(Handler<Void> handler);

  // Flow control
  Queue<T> pause();
  Queue<T> resume();
  Queue<T> take(long amount);

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, it uses PartialPooledByteBufAllocator. Therefore, it does not pool the buffer which results in extra memory allocation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using latest vert.x core 3.5.3
When trying to create a Http server listen on either port 80 of 127.0.0.1, 0.0.0.0, or ::
will result in an exception java.lang.IllegalStateException: failed to create a new resolver
Command run: vertx run Test.java
Code used.
import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;

public class Test extends AbstractVerticle {

  public void start() throws Exception {

    HttpServer server = vertx.createHttpServer();

    server.requestHandler(req -> {
      req.response().putHeader("content-type", "text/html").end("<html><body><h1>Hello from vert.x!</h1></body></html>");
    }).listen(80);
  }
}

console log when the process is executed:

[root@vps290614 backend]# vertx run Test.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Using java.util.logging as the default logging framework
-Dio.netty.leakDetection.level: simple
-Dio.netty.leakDetection.targetRecords: 4
-Dio.netty.eventLoopThreads: 4
-Dio.netty.noUnsafe: false
Java version: 8
sun.misc.Unsafe.theUnsafe: available
sun.misc.Unsafe.copyMemory: available
java.nio.Buffer.address: available
direct buffer constructor: available
java.nio.Bits.unaligned: available, true
jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9
java.nio.DirectByteBuffer.(long, int): available
java.nio.ByteBuffer.cleaner(): available
-Dio.netty.noKeySetOptimization: false
-Dio.netty.selectorAutoRebuildThreshold: 512
Default DNS servers: [/213.186.33.99:53] (sun.net.dns.ResolverConfiguration)
-Djava.net.preferIPv4Stack: false
-Djava.net.preferIPv6Addresses: false
Loopback interface: lo (lo, 0:0:0:0:0:0:0:1%lo)
/proc/sys/net/core/somaxconn: 128
-Dio.netty.allocator.numHeapArenas: 4
-Dio.netty.allocator.numDirectArenas: 4
-Dio.netty.allocator.pageSize: 8192
-Dio.netty.allocator.maxOrder: 11
-Dio.netty.allocator.chunkSize: 16777216
-Dio.netty.allocator.tinyCacheSize: 512
-Dio.netty.allocator.smallCacheSize: 256
-Dio.netty.allocator.normalCacheSize: 64
-Dio.netty.allocator.maxCachedBufferCapacity: 32768
-Dio.netty.allocator.cacheTrimInterval: 8192
-Dio.netty.allocator.useCacheForAllThreads: true
-Dio.netty.threadLocalMap.stringBuilder.initialSize: 1024
-Dio.netty.threadLocalMap.stringBuilder.maxSize: 4096
java.lang.IllegalStateException: failed to create a new resolver
Succeeded in deploying verticle

It is fine when I run on Mac OS but on a VPS (OVH) with centos 7 (firewall disabled) the Exception will be thrown and I can't get any content if I curl to the http end point.
On the same server if I yum install nginx and start it, it is fine on the same port. Only vertx had the problem on listen on the port. This vps instance is with both ipv4 and ipv6
Centos 7 ifconfig

eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
inet 209.46.145.138  netmask 255.255.255.255  broadcast 209.46.145.138
inet6 fe80::f016:3eff:ee6f:e624  prefixlen 64  scopeid 0x20
ether fa:26:3e:6f:e6:14  txqueuelen 1000  (Ethernet)
RX packets 13056  bytes 1093307 (1.0 MiB)
RX errors 0  dropped 0  overruns 0  frame 0
TX packets 9591  bytes 1411397 (1.3 MiB)
TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
inet 127.0.0.1  netmask 255.0.0.0
inet6 ::1  prefixlen 128  scopeid 0x10
loop  txqueuelen 1000  (Local Loopback)
RX packets 193  bytes 39411 (38.4 KiB)
RX errors 0  dropped 0  overruns 0  frame 0
TX packets 193  bytes 39411 (38.4 KiB)
TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HttpServerRequest#netSocket() has a few problems:

when used with a CONNECT requests, the code is different for HTTP/1 and HTTP/2, HTTP/2 will send an header frame and HTTP/1 will not
the request/response lifecycle is not properly handled in all cases, when using a NetSocket the response should be marked as ended so it cannot be used anymore
the net socket should be obtained before the response is sent, assuming the handler has the still the ownership of the stream
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HA tests pass on Vert.x core, currently running Hazelcast CM. Will try others as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign off your commits and the Eclipse Contributor Agreement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
here is the corresponding change for vertx-rx which gives context to review this PR : vert-x3/vertx-rx@0c67929
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpClient (with SSL)
JsonParser to process the response in objectValueMode
Default configuration in the rest of the parameters

When I receive a JSON object inside the handle, I make a parser.pause() to prevent the arrival of new events, however, I get to receive some more events before it really stays paused (3~5).
I think that this is because internally JsonParser does not check when processing the tokens if it is paused, sending all the buffer read so far by the HTTP client. The stream is already paused, but if in this buffer there are 4 json objects, the method "handle" will be called 4 times.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpServerImpl synchronously accepts or rejects the Websocket handshake:
conn.handleWebsocketConnect(ws);
          if (!ws.isRejected()) {
            ChannelHandler handler = ctx.pipeline().get(HttpChunkContentCompressor.class);
            if (handler != null) {
              // remove compressor as its not needed anymore once connection was upgraded to websockets
              ctx.pipeline().remove(handler);
            }
            ws.connectNow();
          } else {
            ch.writeAndFlush(new DefaultFullHttpResponse(HTTP_1_1, ws.getRejectedStatus()));
          }

I think we should probably make it async, in case we have an async operation (i.e. hitting an OAuth server with a token) that rejection depends on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if io.vertx.core.file.FileSystem supported the creation of temporary files and directories (using java.nio.files.Files.createTempFileand java.nio.files.Files.createTempDirectory respectively)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you avoid reformat what is not necessary ? this creates unnecessary friction when merging other PRs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we do have now, base (dummy) implementation of these but we should better provide default methods instead
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In 3.5.3, when deploying a verticle using deployVerticle(Class<? extends Verticle, DeployOptions), it throws a NPE if the class is not public (default: package-private).
e.g.
In Main.java:
        vertx.deployVerticle(MessageReceiverVerticle.class, new DeploymentOptions().setInstances(10));

In MessageReceiverVerticle.java:
class MessageReceiverVerticle extends AbstractVerticle {
}

NPE:
Exception in thread "main" java.lang.NullPointerException
	at io.vertx.core.impl.DeploymentManager.deployVerticle(DeploymentManager.java:105)
	at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:646)
	at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:613)
	at io.vertx.core.impl.VertxImpl.deployVerticle(VertxImpl.java:602)
	at com.groupon.api.test.Main.main(Main.java:13)

Reproducible example is provided: vertx-test.zip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are running into a situation where an http client connection is paused when its last message is received.
This causes the paused connection to be recycled.
We think paused connections should be resumed when they are pooled.
A test to reproduce this behaviour:
@RunWith(VertxUnitRunner.class)
public class PausedPooledConnectionTest {
    @Test
    public void test(TestContext context) {
        Vertx vertx = Vertx.vertx();
        vertx.createHttpServer()
                .requestHandler(req -> req.response().end("pong"))
                .listen(0, "localhost", context.asyncAssertSuccess(server -> {
                    HttpClient client = vertx.createHttpClient(new HttpClientOptions()
                            .setKeepAlive(true) // When set to false everything works as expected (first socket is also closed correctly)
                            .setDefaultPort(server.actualPort())
                    );
                    Async async = context.async();
                    // first request
                    client.get("/").handler(resp -> resp.endHandler(v -> {
                        resp.pause();
                        // second request which reuses the just paused connection.
                        vertx.setTimer(10, l -> client.get("/").handler(resp1 -> resp1.endHandler(v1 -> {
                            async.countDown();
                            vertx.close();
                        })).end());
                    })).end();
                }));
    }
}
A fix could be as easy as:
--- a/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
+++ b/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
@@ -874,6 +874,7 @@ class Http1xClientConnection extends Http1xConnectionBase implements HttpClientC
 
   private void recycle() {
     long expiration = keepAliveTimeout == 0 ? 0L : System.currentTimeMillis() + keepAliveTimeout * 1000;
+    doResume();
     listener.onRecycle(expiration);
   }
 }
If you think this is the correct fix, I do not mind to create a PR with the test and the fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the eclipse contributor agreement and the commit please ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP client upgrade to socket might lose buffers when these buffers are received in the same chunk than the HTTP response.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when i use java vert.x 3.5.3 ,io.netty vertion is 4.1.19, but i got
java.lang.NoSuchMethodError: io.netty.handler.codec.http2.Http2ConnectionEncoder.writePing(Lio/netty/channel/ChannelHandlerContext;ZJLio/netty/channel/ChannelPromise;)Lio/netty/channel/ChannelFuture; at com.turo.pushy.apns.ApnsClientHandler.userEventTriggered(ApnsClientHandler.java:268) ~[pushy-0.13.3.jar:na] at io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:329) [netty-transport-4.1.19.Final.jar:4.1.19.Final]
i need to update io.netty to vertion 4.1.27, how to do? thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
mac os 10.13.6
mvn 3.5.3
java 1.8
vertx 3.6.0-SNAPSHOT
netty 4.1.25
run: mvn package
[vert.x-eventloop-thread-5] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLException: Received fatal alert: certificate_unknown
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:392)
at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:359)
at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:342)
at io.netty.handler.ssl.SslHandler.channelInactive(SslHandler.java:1028)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1429)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:947)
at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:822)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:465)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: javax.net.ssl.SSLException: Received fatal alert: certificate_unknown
at sun.security.ssl.Alerts.getSSLException(Alerts.java:219)
at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1666)
at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1634)
at sun.security.ssl.SSLEngineImpl.recvAlert(SSLEngineImpl.java:1800)
at sun.security.ssl.SSLEngineImpl.readRecord(SSLEngineImpl.java:1083)
at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:907)
at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
at io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:294)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1275)
at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1177)
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1221)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
... 18 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
times to times we get this thread-block warning exception. any idea?
io.vertx.core.impl.BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 1368 ms, time limit is 1000
io.vertx.core.VertxException: Thread blocked
	at io.vertx.core.http.impl.headers.VertxHttpHeaders.names(VertxHttpHeaders.java:337)
	at io.vertx.core.http.impl.headers.VertxHttpHeaders.size(VertxHttpHeaders.java:58)
	at io.vertx.core.http.impl.headers.VertxHttpHeaders.entries(VertxHttpHeaders.java:293)
	at io.vertx.core.http.impl.headers.VertxHttpHeaders.iterator(VertxHttpHeaders.java:322)
	at io.netty.handler.codec.http.HttpHeaders.set(HttpHeaders.java:1504)
	at io.netty.handler.codec.http.DefaultHttpHeaders.set(DefaultHttpHeaders.java:111)
	at io.netty.handler.codec.http.HttpContentEncoder.encode(HttpContentEncoder.java:171)
	at io.netty.handler.codec.http.HttpContentEncoder.encode(HttpContentEncoder.java:51)
	at io.netty.handler.codec.MessageToMessageCodec$1.encode(MessageToMessageCodec.java:67)
	at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:88)
	at io.netty.handler.codec.MessageToMessageCodec.write(MessageToMessageCodec.java:116)
	at io.vertx.core.http.impl.HttpChunkContentCompressor.write(HttpChunkContentCompressor.java:38)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
	at io.netty.handler.stream.ChunkedWriteHandler.doFlush(ChunkedWriteHandler.java:304)
	at io.netty.handler.stream.ChunkedWriteHandler.flush(ChunkedWriteHandler.java:137)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814)
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794)
	at io.vertx.core.net.impl.ConnectionBase.write(ConnectionBase.java:107)
	at io.vertx.core.net.impl.ConnectionBase.lambda$queueForWrite$0(ConnectionBase.java:128)
	at io.vertx.core.net.impl.ConnectionBase$$Lambda$236/1662235749.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
	at io.vertx.core.impl.ContextImpl$$Lambda$23/1301528418.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes the Netty's bootstrap may notify client connections on the GlobalEventExecutor thread when it happens early in the boostrap when an event-loop has not been yet determined. Vertx expects notifications to happen on the event loop thread and this results in a Uh oh! Event loop context executing with wrong thread! failure.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems there is a problem with the websocket frame encoding when tunneling a websocket SSL connection through a HTTP proxy.
The following testcase fails on the websocketWithProxy method
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.RequestOptions;
import io.vertx.core.net.ProxyOptions;
import io.vertx.core.net.ProxyType;
import io.vertx.core.net.SelfSignedCertificate;
import io.vertx.junit5.Timeout;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;

@ExtendWith(VertxExtension.class)
public class TestProxy {

    @BeforeEach
    void createServer(Vertx vertx, VertxTestContext testContext) {

        final var cp = testContext.checkpoint(2);

        // HTTP connect proxy
        vertx.createHttpServer(new HttpServerOptions()
                .setPort(1098))
                .requestHandler(req -> {

                    // Connect to websocket server
                    vertx.createNetClient().connect(1099, "localhost", ar -> {

                        final var clientSocket = req.netSocket();
                        clientSocket.write("HTTP/1.0 200 Connection established\n\n");

                        final var serverSocket = ar.result();

                        serverSocket.handler(buff -> {
                            System.out.println("Forwarding server packet to the client");
                            clientSocket.write(buff);
                        });
                        serverSocket.closeHandler(v -> {
                            System.out.println("Server socket closed");
                            clientSocket.close();
                        });

                        clientSocket.handler(buff -> {
                            System.out.println("Forwarding client packet to the server");
                            serverSocket.write(buff);
                        });
                        clientSocket.closeHandler(v -> {
                            System.out.println("Client socket closed");
                            serverSocket.close();
                        });
                    });
                })
                .listen(testContext.succeeding(x -> {
                    cp.flag();

                }));

        final var certificate = SelfSignedCertificate.create();

        // SSL websocket server
        vertx.createHttpServer(new HttpServerOptions()
                .setSsl(true)
                .setKeyCertOptions(certificate.keyCertOptions())
                .setTrustOptions(certificate.trustOptions())
                .setPort(1099))
                .requestHandler(x -> {
                    x.response().end("it worked");
                })
                .websocketHandler(x -> {
                    x.textMessageHandler(msg -> {
                        System.out.println("got client message: " + msg);
                    });
                    
                    x.writeTextMessage("it worked");
                })
                .listen(testContext.succeeding(x -> {
                    cp.flag();
                }));

    }



    @Test
    @Timeout(2000)
    void websocketWithoutProxy(Vertx vertx, VertxTestContext testContext) {

        var client = vertx.createHttpClient(new HttpClientOptions()
                .setLogActivity(true)
                .setTrustAll(true)
                .setVerifyHost(false));

        var req = new RequestOptions()
                .setPort(1099)
                .setHost("localhost")
                .setSsl(true)
                .setURI("/");

        client.websocket(req, ws -> {
            ws.textMessageHandler(h -> {
                testContext.completeNow();
            });
        });
    }



    @Test
    @Timeout(2000)
    void requestWithProxy(Vertx vertx, VertxTestContext testContext) {
        var client = vertx.createHttpClient(new HttpClientOptions()
                .setProxyOptions(new ProxyOptions()
                        .setHost("localhost")
                        .setPort(1098)
                        .setType(ProxyType.HTTP))
                .setLogActivity(true)
                .setTrustAll(true)
                .setVerifyHost(false));

        var req = new RequestOptions()
                .setPort(1099)
                .setHost("localhost")
                .setSsl(true)
                .setURI("/");

        client.get(req, res -> {
            res.bodyHandler(body -> {
                if (body.toString().equals("it worked")) {
                    testContext.completeNow();
                }
            });
        })
        .end();
    }



    @Test
    @Timeout(2000)
    void websocketWithProxy(Vertx vertx, VertxTestContext testContext) {
        var client = vertx.createHttpClient(new HttpClientOptions()
                .setProxyOptions(new ProxyOptions()
                        .setHost("localhost")
                        .setPort(1098)
                        .setType(ProxyType.HTTP))
                .setLogActivity(true)
                .setTrustAll(true)
                .setVerifyHost(false));

        var req = new RequestOptions()
                .setPort(1099)
                .setHost("localhost")
                .setSsl(true)
                .setURI("/");

        client.websocket(req, ws -> {
            
            ws.writeTextMessage("test");
            
            ws.textMessageHandler(h -> {
                testContext.completeNow();
            });
        });
    }

}


After the initial websocket handshake
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 48 54 54 50 2f 31 2e 31 20 31 30 31 20 53 77 69 |HTTP/1.1 101 Swi|
|00000010| 74 63 68 69 6e 67 20 50 72 6f 74 6f 63 6f 6c 73 |tching Protocols|
|00000020| 0d 0a 75 70 67 72 61 64 65 3a 20 77 65 62 73 6f |..upgrade: webso|
|00000030| 63 6b 65 74 0d 0a 63 6f 6e 6e 65 63 74 69 6f 6e |cket..connection|
|00000040| 3a 20 75 70 67 72 61 64 65 0d 0a 73 65 63 2d 77 |: upgrade..sec-w|
|00000050| 65 62 73 6f 63 6b 65 74 2d 61 63 63 65 70 74 3a |ebsocket-accept:|
|00000060| 20 61 47 2f 2b 30 76 48 4a 4c 45 50 67 33 34 58 | aG/+0vHJLEPg34X|
|00000070| 36 49 39 49 77 58 4a 78 56 6a 71 59 3d 0d 0a 0d |6I9IwXJxVjqY=...|
|00000080| 0a                                              |.               |
+--------+-------------------------------------------------+----------------+

the following messages are completely missing the websocket frame informations. The message is therefore never received on the server side
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 74 65 73 74                                     |test            |
+--------+-------------------------------------------------+----------------+
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As of now, vertx router does not handle case when binding to a url path.
For instance, if your application acts as a proxy and have no control on the case for the URI path and in order define a handler you bind to router like this,
final Router router = Router.router(vertx);
router.get("/example-path").handler()
router.get("/Example-Path").handler()

rather than just writing,
router.get("/example-path").handler()
Is there a reason/limitation that we not using equalsIgnoreCase here?
Also if this change is acceptable, our team is more than happy to contribute to that.
Vertx version
3.5.0
JVM version (e.g. java -version)
1.8_181
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can I use database cache and  how to do?same as spring  boot @Cacheable
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Moved from vert-x3/vertx-web#1017
Version

vert.x core: 3.5

Context
Following the very first example on the vertx documenation js version causes the following warning on the console:
WARNING: You're already on a Vert.x context, are you sure you want to create a new Vertx instance?
Code looks to be work fine until you start to use some clustering API-s, where they just won't function as expected. I believe because we're on a differently configured context by now.
Do you have a reproducer?
var Vertx = require("vertx-js/vertx");
var vertx = Vertx.vertx();
Solution
As I found out from the examples the vertx variable is already defined js verticles, so the above initialization is not required.
If this is true in every cases then the documentation should be updated to reflect this, otherwise it should be more clear describing when the vertx is already defined and when not.
Many thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to create a development environment inside Docker for Vert.x, I have the file system mounted and the file watcher is successfully detecting changes. However when a change occurs the redeploy task ./gradlew classes fails with the following:
INFO: Redeploying!
Error: Could not find or load main class org.gradle.wrapper.GradleWrapperMain
Despite the failure Vert.x subsequently reboots but with the stale code as the recompilation never occurs. Whats odd is if there was an issue with the wrapper it would have occurred when the container boots as its started with the command: ./gradlew clean run
Any help would be much appreciated
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the executeBlocking(Handler<Future<T>>, Handler<AsyncResult<T>>) might execute the callback on the wrong thread when the runOnContext(...) execution loses the race against the thread that completes the future. This never happens when the worker thread completes the future, but it can happen when the worker thread hands off the future to another thread that completes it.
This happen in the Mongo client and fails with a stack-trace like:
	at io.vertx.ext.mongo.impl.MongoIterableStream.lambda$doRead$5(MongoIterableStream.java:120)
	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:125)
	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:86)
	at io.vertx.ext.mongo.impl.MongoIterableStream.lambda$null$3(MongoIterableStream.java:112)
	at com.mongodb.internal.async.ErrorHandlingResultCallback.onResult(ErrorHandlingResultCallback.java:49)
	at com.mongodb.operation.AsyncQueryBatchCursor.handleGetMoreQueryResult(AsyncQueryBatchCursor.java:271)
	at com.mongodb.operation.AsyncQueryBatchCursor.access$300(AsyncQueryBatchCursor.java:55)
	at com.mongodb.operation.AsyncQueryBatchCursor$CommandResultSingleResultCallback.onResult(AsyncQueryBatchCursor.java:301)
	at com.mongodb.operation.AsyncQueryBatchCursor$CommandResultSingleResultCallback.onResult(AsyncQueryBatchCursor.java:276)
	at com.mongodb.internal.async.ErrorHandlingResultCallback.onResult(ErrorHandlingResultCallback.java:49)
	at com.mongodb.connection.DefaultServer$DefaultServerProtocolExecutor$2.onResult(DefaultServer.java:207)
	at com.mongodb.internal.async.ErrorHandlingResultCallback.onResult(ErrorHandlingResultCallback.java:49)
	at com.mongodb.connection.CommandProtocolImpl$1.onResult(CommandProtocolImpl.java:102)
	at com.mongodb.connection.DefaultConnectionPool$PooledConnection$1.onResult(DefaultConnectionPool.java:458)
	at com.mongodb.connection.UsageTrackingInternalConnection$2.onResult(UsageTrackingInternalConnection.java:110)
	at com.mongodb.internal.async.ErrorHandlingResultCallback.onResult(ErrorHandlingResultCallback.java:49)
	at com.mongodb.connection.InternalStreamConnection$2$1.onResult(InternalStreamConnection.java:381)
	at com.mongodb.connection.InternalStreamConnection$2$1.onResult(InternalStreamConnection.java:359)
	at com.mongodb.connection.InternalStreamConnection$MessageHeaderCallback$MessageCallback.onResult(InternalStreamConnection.java:651)
	at com.mongodb.connection.InternalStreamConnection$MessageHeaderCallback$MessageCallback.onResult(InternalStreamConnection.java:618)
	at com.mongodb.connection.InternalStreamConnection$5.completed(InternalStreamConnection.java:487)
	at com.mongodb.connection.InternalStreamConnection$5.completed(InternalStreamConnection.java:484)
	at com.mongodb.connection.AsynchronousSocketChannelStream$BasicCompletionHandler.completed(AsynchronousSocketChannelStream.java:233)
	at com.mongodb.connection.AsynchronousSocketChannelStream$BasicCompletionHandler.completed(AsynchronousSocketChannelStream.java:216)
	at sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:126)
	at sun.nio.ch.Invoker.invokeDirect(Invoker.java:157)
	at sun.nio.ch.UnixAsynchronousSocketChannelImpl.implRead(UnixAsynchronousSocketChannelImpl.java:553)
	at sun.nio.ch.AsynchronousSocketChannelImpl.read(AsynchronousSocketChannelImpl.java:276)
	at sun.nio.ch.AsynchronousSocketChannelImpl.read(AsynchronousSocketChannelImpl.java:297)
	at com.mongodb.connection.AsynchronousSocketChannelStream.readAsync(AsynchronousSocketChannelStream.java:128)
	at com.mongodb.connection.InternalStreamConnection.readAsync(InternalStreamConnection.java:484)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Problem:
The project I am working on requires prioritization of HTTP/2 streams. For that I need to be able to set stream dependency and weight in HEADER frames in request made from client, as well as responses sent from the server. Currently stream dependency and stream weight is not exposed through the API. When writing HTTP/2 requests/responses stream dependency and weight are not passed to Netty, therefore default values are used (0 and 16 respectively).
Solution:
It seems it would be enough to to add  extend HttpClientRequest and HttpServerResponse interfaces with setStreamDependecy and setWeight to override the default values and pass them through Http2ClientStream.writeHead -> VertxHttp2ConnectionHandler.writeHeaders to io.netty.handler.codec.http2.Http2ConnectionEncoder.writeHeaders
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I am making a really simple route in vert.x scala:
    router
      .put("/clients/:apiKey")
      .handler(handler => {
        handler.response().end()
      })
I have some payloads with "=" and "%", like this example:
curl -v XPUT localhost:8085/clients/test -d '{"s":"Q==","":"%IM" }'
For some strange reason when both are present I am getting this in log:
Caused by: java.lang.IllegalArgumentException: invalid hex byte 'IM' at index 8 of '=","":"%IM" }'
	at io.netty.util.internal.StringUtil.decodeHexByte(StringUtil.java:244)
	at io.netty.handler.codec.http.QueryStringDecoder.decodeComponent(QueryStringDecoder.java:351)
	at io.netty.handler.codec.http.QueryStringDecoder.decodeComponent(QueryStringDecoder.java:309)
	at io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.decodeAttribute(HttpPostStandardRequestDecoder.java:644)

What I cand do about? Not sure if it is vertx or netty issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I just learning about vert.x. I think it is suitable for PvP MMO game server for its speed.
Anyone use vert.x for game server?
Or official support plan?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MultiMap mm = ...
mm.add("h", "v1");
mm.add("h", "v2");
mm.add("h", "v3");

// Returns v3 but should return v1
String s = mm.get("h");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the SSL handshake leaks handshake failures to the ChannelPipeline during the handshake because we are using the HandshakeFuture to progress during the handshake.
Improve the SSL handshake handling to use a channel handlers (client / server) that will not propagate uncaught failures in the pipeline. The handlers are implemented using events emitted by the SslHandler/SniHandler when the handshake completes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the ChannelProvider is responsible for connecting the channel on behalf of the NetClient/HttpClient . SSL handshaking and setup is handled separately by the clients.
Improve the ChannelProvider to also handle the SSL client handshake in a common place. The proxy provider has also been merged in the ChannelProvider as there is no much interest to have a subclass for it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could the ClusterManager be extended to expose shared/distributed queues provided by underneath cluster managers in the same way as AsyncMap?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm shutting down a Vertx environment using vertx.close.  During this process the system runs its shutdown hooks.  One of those is deployed by FileResolver and it is consistently throw the following exception:
java.util.concurrent.RejectedExecutionException: Task io.vertx.core.impl.TaskQueue$$Lambda$62/2067180044@6ab80713 rejected from java.util.concurrent.ThreadPoolExecutor@48cf5273[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 308]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
	at io.vertx.core.impl.TaskQueue.execute(TaskQueue.java:93)
	at io.vertx.core.impl.ContextImpl.executeBlocking(ContextImpl.java:293)
	at io.vertx.core.impl.ContextImpl.executeBlocking(ContextImpl.java:237)
	at io.vertx.core.file.impl.FileSystemImpl$BlockingAction.run(FileSystemImpl.java:839)
	at io.vertx.core.file.impl.FileSystemImpl.deleteRecursive(FileSystemImpl.java:223)
	at io.vertx.core.impl.FileResolver.deleteCacheDir(FileResolver.java:328)
	at io.vertx.core.impl.FileResolver.lambda$setupCacheDir$1(FileResolver.java:317)
	at java.lang.Thread.run(Thread.java:745)

The issue is that since we're doing close we've already terminated the executor used to run blocking code so the attempt to queue work is rejected.  It would be better if this exception didn't leak as it does currently since there is essentially nothing the Vert.x programmer can do about it (at least not AFAICT).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we need tests that use directly the netty API, see Http2ServerTest and Http2ClientTest as well
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the VertxMetrics SPI does not leak the Vertx instance during metrics creation because the instance might be not be fully initialised yet. We should add a callback to the VertxMetrics to signal when the Vertx instance is initialised before it is returned to the application.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, there are different processes for configuring clustered eventbus.

the cluster manager configuration file (eg cluster.xml for HZ)
the ClusteredEventBusOptions
the Launcher CLI args (cluster-host, cluster-port)

When running a Vert.x app from the CLI, or in an executable jar with the Launcher, we try to determine a host address if not provided via argument. Then the host/port are set in the ClusteredEventBusOptions.
When it starts the ClusteredEventBus uses values from options.
There are a number of issues with this process:

the address chosen by the cluster manager is not always consistent with the address chosen by the CLI
it's difficult to configure for beginners: users must update the cluster manager configuration file and provide CLI arguments or EB options
EB options defaults to localhost and when embedding Vert.x, users often forget to set cluster host

For Vert.x 4 we must think about better processes, for a better user experience and less questions/issues posted of course :)
Not all issues need to be solved with code changes: a better documentation about this process can help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also I think that we should say that instead of providing the deployment option trick only:

either they should use regular worker and increase the worker size (as you said)
can combine regular verticle + executeBlocking with ordered = false (that needs to be verified in a test I think before)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So I have a scenario where a file upload from a server is uploaded to another server. The client code is taken from Paulo Lopes' SO post. Client saves a file from user's form and streams it to another server. Though it's written in scala, basically it just forwards futures from file open to http post.
  router.post("/form").handler(BodyHandler.create().setUploadsDirectory("./temp"))

  router.post("/form").handler(ctx => {
    ctx.fileUploads().foreach(p => {
      val size    = p.size()
      val f = for {
        ffil <- vertx.fileSystem().openFuture(p.fileName(), OpenOptions())
        fpos <- client.post(8065, "localhost", "/form")
                .putHeader("content-length", size.toString)
                .sendStreamFuture(ffil)
      } yield fpos
      f onComplete {
        case Success(a) => ctx.response.end("ok")
        case Failure(e) => ctx.response.end(e.getMessage)
      }
    })


The target server follows the Vertx example with some modifications to receive, reconstruct the file as byte array instead of saving it in local stroage. It doesn't use vertx-web either.
vertx.createHttpServer().requestHandler(req => {
 (req.method(), req.uri()) match {

   case (HttpMethod.POST, "/form") =>
      req.setExpectMultipart(true)
      req.uploadHandler(upload => { // <-- stuck, never proceeds
         var cache: Option[Buffer] = None
         upload.exceptionHandler(cause => println(cause.getMessage))
         upload.handler(b => {
             if (cache.isDefined){
                cache.get.appendBuffer(b)
             } else {
                 cache = Some(b.copy())
             }
         })
        upload.endHandler(end => resizeAndOtherProcess(cache))
    })
}

Here req detects incoming request but uploadHandler never proceeds into Handle and is just stuck in the line with comment.  it doesn't throw any exception either. However a file upload from html form directed at that path works. Any help pointing the problem is appreciated. Thanks in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When the server receives h2c upgrade request without Host header, it throws NPE:
09:41:50,996 ERROR (vert.x-eventloop-thread-2) [i.v.c.n.i.ConnectionBase] value java.lang.NullPointerException: value
	at io.netty.util.internal.ObjectUtil.checkNotNull(ObjectUtil.java:31)
	at io.netty.handler.codec.DefaultHeaders.set(DefaultHeaders.java:431)
	at io.netty.handler.codec.http2.DefaultHttp2Headers.authority(DefaultHttp2Headers.java:145)
	at io.vertx.core.http.impl.HttpServerImpl$Http2UpgradeHandler.channelRead(HttpServerImpl.java:966)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:284)

The host header is mandatory, but upon client error the server should respond with error (right now it sends 101 Switching protocols and then the connection is terminated).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In io/vertx/core/http/impl/HttpServerResponseImpl.java:145  version 3.5.4, the methods tries to compare CharSequence with a String and always returns false even when the header is present.
  @Override
  public boolean isChunked() {
    synchronized (conn) {
      return HttpHeaders.CHUNKED.equals(headers.get(HttpHeaders.TRANSFER_ENCODING));
    }
  }
```
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm writing a tcp server using vertx NetClient, however i found that even if i start multiple servers and listen at the same time, the handler won't using every eventloop thread.
Here's the example code:
vertx: 3.5.3
package com.netease.connectiontest;

import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.net.NetServer;

public class TestMain {
    public static void main(String[] args) {
        Vertx vertx = Vertx.vertx(new VertxOptions().setEventLoopPoolSize(4));
        for (int i = 0; i < 4; ++i) {
            NetServer server = vertx.createNetServer();
            server.connectHandler(sock -> {
                sock.write("Hello world\r\n");
                sock.handler(buf -> {
                    System.out.println(Thread.currentThread());
                });
            });
            server.listen(8080);
        }
    }
}
then repeating telnet -> send some msg -> quit telent
The result I imagine would be printing vert.x-eventloop-thread-(0 to 3), however the output ranges from 1 to 3, where 0 was never printed.
I check the source code and found that when the first server.listen is called, it tries to resolve the local socket host, even if the host is set to 0.0.0.0. The resolve process will start a UDP sock for DNS. The UDP sock will use the second EventLoop element inside the PowerOfTwoEventExecutorChooser.
io.netty.util.concurrent.DefaultEventExecutorChooserFactory line 56:
        @Override
        public EventExecutor next() {
            return executors[idx.getAndIncrement() & executors.length - 1];
        }
executors[0] will be used by the first tcp server
executors[1] will be used by the udp sock
executors[2] will be used by the second tcp server
executors[3] will be used by the third tcp server
then
executors[0] will be used by the last tcp server, where it's the same as the first one. And the DNS lookup will not bu used very often, so the result would be: one event loop thread not doing anything.
I'm wondering whether this is a bug? This is easy to fix, just set the event loop to 5. But if the vertx is upgraded, I must check whether there are any new process fetching event loop from the chooser.
And I don't see it very clear that: why the event loop should be set to 2 * cores. If all libs i'm using are async (async-mysql-client/webclient/redisclient and so on), I think I won't get better performance when setting event loop size to ${a number > cores} than ${= cores} (or change it to ${cores - 1} if considering soft interrupt).
Looking forward to your reply~thx
^_^
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MultiThreaded worker verticles are an extension to worker verticles. Like with usual worker verticles, events are handled on worker pool threads. But they can be executed by different threads concurrently, which means the verticle must manage its own state to be visible between threads.
There are many parts of Vert.x which simply doesn't support them. For example, you can't create an HTTP server on a MT worker verticle.
Also, we have seen many new users, in particular those experienced with Spring or Java EE, starting directly with MT worker verticles and adding as many threads as possible with the impression it would help get the best performance results. But this is really counter-productive.
In 3.6.0 we deprecate the usage of multi-threader worker verticles and we document how to replace them. The feature will be dropped in Vert.x 4.
See

#2697
#2431
#2755
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Deprecated in 3.6, they can be removed in 4.0
See #2702

remove mt worker context
update deployment options
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The replyAddress cannot be used in both standalone and clustered mode. When clustered, the remote recipient cannot use the reply address because it's not registered in cluster manager.
Reply address is an internal detail of implementation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Enviornment Information:
------------------------------------------------------------
Gradle 4.10.2
------------------------------------------------------------

Build time:   2018-09-19 18:10:15 UTC
Revision:     b4d8d5d170bb4ba516e88d7fe5647e2323d791dd

Kotlin DSL:   1.0-rc-6
Kotlin:       1.2.61
Groovy:       2.4.15
Ant:          Apache Ant(TM) version 1.9.11 compiled on March 23 2018
JVM:          1.8.0_172 (Oracle Corporation 25.172-b11)
OS:           Mac OS X 10.14.1 x86_64

Reproducer: https://github.com/kjstouffer/vertx-fd-issue-repro (README with more detailed information)
FD open/close log generated by http://file-leak-detector.kohsuke.org/ : files-2-loops.log
This issue only happens when an exception happens (a Timeout in this case), but not in every combination of timeout / number of requests. for example, with number of request set to 10 and timeout set to 8000ms, the issue does not appear (only 2 requests fail), however, when the number of requests is 20 and timeout set to 8000ms, the issue does appear (12 requests fail).
I'm wondering if I'm doing something wrong in my reproducer or if there's a bug in the underlying implementation that's supposed to close / free sockets.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As the name of the system classloader class changes with Java version, it seems better to use tccl == ClassLoader.getSystemClassLoader() rather than tccl.getClass().getName().equals("sun.misc.Launcher$AppClassLoader").
Without this, it cause to issue warns on Java > 8 when creating a context from the main thread with the vertx.disableTCCL flag set.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I've got a problem with the Json-class in vertx-core.
java.lang.IllegalStateException: Illegal type in JsonObject: class my.code.SomeEnum
	at io.vertx.core.json.Json.checkAndCopy(Json.java:211)
	at io.vertx.core.json.JsonObject.put(JsonObject.java:677)
	at as.leap.vertx.rpc.impl.VertxRPCServer.lambda$replyFail$10(VertxRPCServer.java:188)
...

I think it is related to this piece of code in Json.java:
  static Object checkAndCopy(Object val, boolean copy) {
    if (val == null) {
      // OK
    } else if (val instanceof Number && !(val instanceof BigDecimal)) {
      // OK
    } else if (val instanceof Boolean) {
      // OK
    } else if (val instanceof String) {
      // OK
    } else if (val instanceof Character) {
      // OK
    } else if (val instanceof CharSequence) {
      val = val.toString();
    } else if (val instanceof JsonObject) {

Another else-if fixed it for me:
    } else if (val instanceof Enum) {
      // OK

This is my first issue / PR, so please tell me, if I can improve something.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you read the Eclipse Contributor Agreement ?
also this is missing tests to check it's fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be useful in javadocs and docs to have a quick overview of the ReadStream state machines when in regular push vs (new) pull/fetch mode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On exploring the use of web-api-contract and OpenAPI3RouterFactory.create and have the requirement to have a variable (dynamic) number of query parameters for an endpoint e.g. /my/path/v1?param1=value1&param2=value2 etc. (for a search solution) but the parsing of this in OpenApi3Utils.class fails with a NPE.
Nov 15, 2018 8:41:36 AM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.NullPointerException
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenApi3Utils.solveObjectParameters(OpenApi3Utils.java:196)
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenAPI3RequestValidationHandlerImpl.magicParameterExplodedObject(OpenAPI3RequestValidationHandlerImpl.java:293)
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenAPI3RequestValidationHandlerImpl.checkSupportedAndNeedWorkaround(OpenAPI3RequestValidationHandlerImpl.java:371)
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenAPI3RequestValidationHandlerImpl.parseParameter(OpenAPI3RequestValidationHandlerImpl.java:405)
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenAPI3RequestValidationHandlerImpl.parseOperationSpec(OpenAPI3RequestValidationHandlerImpl.java:97)
    at io.vertx.ext.web.api.contract.openapi3.impl.OpenAPI3RequestValidationHandlerImpl.<init>(OpenAPI3RequestValidationHandlerImpl.java:87)

the relevant slice of my spec.yaml is
- name: params
  in: query
     schema:
        type: object
            type: string
     style: form
     explode: true

it parses fine in SwaggerUI for example with the correct output.
A suggested workaround of an empty {} for the object properties sorted the NPE, but no additionalProperties are parsed from the url (which may be a secondary issue)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what's the point ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In addition, I have no idea how this makes sense in SNI due to df4a3dd since Netty does not give a way to configure the timeout in SniHandler directly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
default void bytesWritten(S socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
}
default void bytesRead(S socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
}
the numberOfBytes only contains the body length.
numberOfBytes  equals  buff.getBytes().length
HttpClient localhost = http2Client.getNow(8080, "localhost", "", resp -> {
  resp.bodyHandler(buff -> {
    System.out.println(buff.getBytes().length);
  });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the same code run correctly in the 3.5.3
when I use 3.6.0.CR1, it throws
Nov 19, 2018 3:25:35 PM io.vertx.core.http.impl.HttpClientRequestImpl
SEVERE: javax.net.ssl.SSLHandshakeException: Failed to create SSL connection
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the message consumer, keep the pending messages (accumulated when the consumer was paused) after unregistration. There can be some races that the consumer is resumed after unregistration (user issue) and the pending messages will be processed and it results in internal failures.
Instead the pending messages should be cleared on unregistration and the discarded messages processed by the internal discard handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx version
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-core</artifactId>
            <version>3.5.4</version>
        </dependency>

code

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * vertx-test
 * chenpx 2018/11/19 19:20
 **/
public class TestCompose extends AbstractVerticle {
    public static void main(String[] args) {
        VertxOptions options = new VertxOptions();
        Vertx vertx = Vertx.vertx(options);

        vertx.deployVerticle(TestCompose.class.getName());
    }
    AtomicInteger index = null;

    @Override
    public void start() throws Exception {
        //1. must try catch
        try {
            getData().compose(res->{
                return Future.succeededFuture("i am foo");
            }).setHandler(res->{
               //attention will skip this handler
               if (res.failed()){
                   System.out.println("=== error");
                   res.cause().printStackTrace();
               }else {
                   System.out.println(res.result());
               }
            });
        } catch (Exception e) {
            //RuntimeException catch in hera
            System.out.println("xxx-xx ERROR");
            e.printStackTrace();
        }

        //2. not need try catch
        getData2().compose(res->{
            return getData();
        }).setHandler(res->{
            if (res.failed()) {
                System.out.println("have error ");
                res.cause().printStackTrace();
            }else {
                System.out.println(res.result());
            }
        });
    }

    //test throw RuntimeException
    public Future<String> getData(){
        return Future.future(r->{
            index.getAndIncrement();
            r.tryComplete("hello");
        });
    }

    public Future<String> getData2(){
        Future<String> future = Future.future();
        vertx.setPeriodic(1000,ar->{
            future.tryComplete("hello amy");
        });
        return future;
    }
}

my question is why the first future of compose futures must be success?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently calling sendFile on a NetSocket or HttpServerResponse might timeout for connection having a TCP idle timeout set. This happens because we send a single file region that takes more time than the idle timeout value and cause a timeout. Since it's a FileRegion object, configuring observeOutput on IdleStateHandler will have no effect as such regions are not reporting progress on the ChannelOutboundBuffer.
Instead of sending a very large region, instead we stream file regions of a fixed size (1mo) until the file is completely sent.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
so that the tests work with the latest Oracle JDK.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can't merge it for now, we are awaiting for an Eclipse works-with CQ
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When closing Vert.x, only the first shared server is closed and not the other servers, which actually does not close the server, since the other shared servers are not closed and prevent closing to happen.
On Vert.x close we should instead close all the servers with a special method as this is not a regular close.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, it's only possible to configure cluster public host and port with sysprops.
This will help having a consistent user experience (cluster host and port can be configured via the command line).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #2325
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi All,
Is it possible to update netty to 4.1.31.Final and add support for TLS 1.3?

TLSv1.3 support
TLSv1.3 was recently finalized as a standard. In this release we add support for it in various ways, when either of these is true:
using Java11 or later
using netty-tcnative (build against OpenSSL 1.1.1+) and Java8+
using netty-tcnative-boringssl-static and Java8+.
That said TLSv1.3 is not enabled by default so if you want to use it you will need to explicit enable it by using TLSv1.3 when configure your SslContextBuilder (like for example):
SslContextBuilder.forClient().protocols("TLSv1.3") ....
To be able to do this for our native implementations you also need to ensure you use netty-tcnative 2.0.19 (compiled against OpenSSL 1.1.1+) or netty-tcnative-boringssl-static 2.0.19.

Regards,
Pratik Parikh
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj  I need some help.
pom:
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-core</artifactId>
      <!--<version>3.5.3</version>-->
      <version>3.6.0.CR1</version>
    </dependency>
    <dependency>
      <groupId>io.netty</groupId>
      <artifactId>netty-tcnative-boringssl-static</artifactId>
      <version>2.0.12.Final</version>
    </dependency>

server:

public class HttpServerDownloadTest {
    public static void main(String[] args) {
        HttpServerOptions httpServerOptions = new HttpServerOptions();
        httpServerOptions.setUseAlpn(true)
                .setSsl(true)
                .setPemKeyCertOptions(new PemKeyCertOptions().setKeyPath("tsl/server-key.pem").setCertPath("tsl/server-cert.pem"));
        Vertx vertx = Vertx.vertx();
        HttpServer httpServer = vertx.createHttpServer(httpServerOptions);
        httpServer.requestHandler(request -> {
            request.bodyHandler(body -> {
                System.out.println("server : " + body.toString());
            });
            String file = "filePath";
            request.response().headers().set("Content-Disposition", attachment;filename=tempFileEntity.txt");
            request.response().sendFile(file);
        });
        httpServer.listen(8080, "localhost", req -> {
            if (req.succeeded()) {
                System.out.println("bind port :" + req.result().actualPort());
            } else {
                System.out.println("bind port error");
            }
        });
    }
}

client:

public class HttpClientTest {
    public static void main(String[] args) {
        Vertx vertx = Vertx.vertx();
        String filePath = "filePath";
        HttpClientOptions http2ClientOption = new HttpClientOptions();
        http2ClientOption.setProtocolVersion(HttpVersion.HTTP_2)
                .setUseAlpn(true)
                .setHttp2ClearTextUpgrade(false)
                .setTrustAll(true)
                .setSsl(true)
                .setDefaultPort(8080)
                .setDefaultHost("localhost");
        HttpClient httpClient = vertx.createHttpClient(http2ClientOption);
        HttpClientRequest httpClientRequest = httpClient.request(HttpMethod.POST, "", res -> {
            res.pause();
            vertx.fileSystem().open(filePath, new OpenOptions(), ares -> {
                AsyncFile file = ares.result();
                Pump pump = Pump.pump(res, file);
                res.endHandler(v1 -> {
                    System.out.println("end...");
                    file.flush().close(v2 -> {
                        System.out.println(" download success");
                    });
                });
                pump.start();
                res.resume();
            });
        });
        httpClientRequest.setChunked(true);
        httpClientRequest.end("hello");
    }
}


when I start the server and client. the file download successfully. but it will throw an exception
 22, 2018 9:55:03  io.vertx.core.http.impl.HttpClientResponseImpl
: io.vertx.core.VertxException: Connection was closed
 22, 2018 9:55:03  io.vertx.core.http.impl.HttpClientResponseImpl
: java.lang.IllegalStateException: Cannot save zero bytes
end...
 download success

How can I avoid this exception or can I ignore this exception?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
Please look at the chart below.
Using localConsumer here will make other vertx instances in the cluster invisible.Why not consumer but localConsumer?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently AsyncFile allocates an heap ByteBuffer for repeated reads and could instead allocate a single that would be reused.
Change the doRead() method so it allocates a ByteBuffer and then call doRead passing the buffer instead of calling the read method that allocates the ByteBuffer. After copy the ByteBuffer must be compacted for reuse.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Related to: #2020
Methods available: core/shareddata/AsyncMap
Methods not available: reactivex/core/shareddata/AsyncMap


Is there a way to gain access to these methods from reactivex/core even if they are not the rx variant?
Will there be an observable returning rx variant?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
pom:
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-core</artifactId>
     <version>3.6.0.CR1</version>
    </dependency>

    <dependency>
      <groupId>io.netty</groupId>
      <artifactId>netty-tcnative-boringssl-static</artifactId>
      <version>2.0.12.Final</version>
    </dependency>

server:
public class Server {

  public static void main(String[] args) {
    HttpServerOptions httpServerOptions = new HttpServerOptions();
    httpServerOptions.setUseAlpn(true)
        .setSsl(true)
        .setPemKeyCertOptions(
            new PemKeyCertOptions().setKeyPath("tsl/server-key.pem").setCertPath("tsl/server-cert.pem"));
    VertxOptions vertxOptions = new VertxOptions();
    VertxMetricsFactory factory = (options) -> new DummyVertxMetrics() {
      @Override
      public HttpServerMetrics<?, ?, ?> createHttpServerMetrics(HttpServerOptions options, SocketAddress localAddress) {
        return new DummyHttpServerMetrics() {
          @Override
          public Void requestBegin(Void socketMetric, HttpServerRequest request) {
            System.out.println("request begin");
            return null;
          }

          @Override
          public void responseEnd(Void requestMetric, HttpServerResponse response) {
            System.out.println("response end ");
          }

          @Override
          public Void connected(SocketAddress remoteAddress, String remoteName) {
            System.out.println("connected");
            return null;
          }

          @Override
          public void disconnected(Void socketMetric, SocketAddress remoteAddress) {
            System.out.println("disconnected");
          }

          @Override
          public void bytesRead(Void socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
            System.out.println("bytes read : " + numberOfBytes);
          }

          @Override
          public void bytesWritten(Void socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
            System.out.println("bytes write : " + numberOfBytes);
          }

          @Override
          public boolean isEnabled() {
            return true;
          }

          @Override
          public void close() {

          }
        };
      }
    };
    vertxOptions.setMetricsOptions(new MetricsOptions().setEnabled(true).setFactory(factory));

    Vertx vertx = Vertx.vertx(vertxOptions);
    HttpServer server = vertx.createHttpServer(httpServerOptions).requestHandler(req -> {
      HttpServerResponse response = req.response();
      response.setStatusCode(200).setChunked(true).write("bye").end();
      response.close();
    });
    server.listen(8081, "localhost", handler -> {
      if (handler.succeeded()) {
        System.out.println(" bind success");
      }
    });
  }
}

client :
public class Client {

  public static void main(String[] args) {

    VertxOptions vertxOptions = new VertxOptions();

    Vertx vertx = Vertx.vertx(vertxOptions);
    HttpClientOptions http2ClientOption = new HttpClientOptions();
    http2ClientOption.setProtocolVersion(HttpVersion.HTTP_2)
        .setUseAlpn(true)
        .setIdleTimeout(0)
        .setHttp2ClearTextUpgrade(false)
        .setTrustAll(true)
        .setSsl(true);

    HttpClient http2Client = vertx.createHttpClient(http2ClientOption);

    http2Client.getNow(8081, "localhost", "", resp -> {
      resp.bodyHandler(buff -> {
        System.out.println(buff.toString());
      });
    });
  }
}

logging:
bind success
connected
request begin
bytes read : 0
disconnected

the method  bytesWritten(Void socketMetric, SocketAddress remoteAddress, long numberOfBytes)  has not been invoked
@Override
void bytesWritten(Void socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
         System.out.println("bytes write : " + numberOfBytes);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That's a regression introduced by the usage of InboundBuffer.
The consequence is that the TCP when the TCP connection is paused, it is never resumed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So we upgrade to 3.6.0-CR2 to make our code base ready for 3.6.0.
And we encountered an Issues related to File Uploads.
When you try to upload a large file to an vertx webserver and pump this file to the filesystem the following happens:
The writeStream gets full because the fs can write fast enough. This leads to an full InboundBuffer in the HttpServerFileUploadImpl which the proceeds to pause the request when it recives another chunk of data.
The thing is, the request never gets resumed again even tho write stream and inbound buffer get empty.
Looking at the code in HttpServerFileUploadImpl i dont get how this could have worked before since nothing resumes the request. But everything works with 3.5.2.
I think this is a regression introudced through the refactoring of the internal Queue in the HttpServerFileUploadImpl to the InboundBuffer class.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello guys!
It seems like vertx cluster event bus (zookeeper implementation) loosing some messages when some of the nodes leaving the cluster. This can be related to #1594 or vert-x3/vertx-hazelcast#13 issues.
Theoretically, it is still sending the messages to the shutted down node.
Here is a code to reproduce:
Start zookeeper
docker run -p 2181:2181 zookeeper:3.4.13
Base class:
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.spi.cluster.zookeeper.ZookeeperClusterManager;

public class ShutdownTestBase {

    protected List<Vertx> cluster = Collections.synchronizedList(new ArrayList<>());

    public Future<Object> startClusterNode(String serviceName) {
        Future<Object> retval = Future.future();

        JsonObject zkConfig = new JsonObject();
        zkConfig.put("zookeeperHosts", "127.0.0.1");
        ZookeeperClusterManager cm = new ZookeeperClusterManager(zkConfig);
        VertxOptions options = new VertxOptions();
        options.setClusterManager(cm);
        // for cluster init do not throw any warnings
        options.setMaxEventLoopExecuteTime(8_000_000_000l);
        Vertx.clusteredVertx(options, res -> {
            if (res.succeeded()) {
                cluster.add(res.result());
                runService(serviceName, res.result()).setHandler(retval);
                System.out.println("................... Vertx deployed ...................");
            } else {
                res.cause().printStackTrace();
            }
        });

        return retval;
    }

    private Future<Object> runService(String serviceName, Vertx vertx) {
        Future<Object> retval = Future.future();
        vertx.deployVerticle(serviceName, new DeploymentOptions(), e -> {
            retval.complete();
        });
        return retval;
    }

}

Test class:
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Test;
import org.junit.runner.RunWith;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;

@RunWith(VertxUnitRunner.class)
public class ShutdownTest extends ShutdownTestBase {

    private static String ADDRESS = "test.shutdown";
    private static int INSTANCES_COUNT = 2;
    private int i = 0;

    // massages tracking map
    private static Map<Integer, Object> MESSAGE_MAP = Collections.synchronizedMap(new HashMap<>());

    @Test
    public void shutdownTest(TestContext context) {
        Async async = context.async();

        @SuppressWarnings("rawtypes")
        List<Future> servicesDeploy = new ArrayList<>();
        // start cluster
        for (int i = 0; i < INSTANCES_COUNT; i++) {
            servicesDeploy.add(startClusterNode(ShutdownTestMS.class.getName()));
        }
        // start test
        CompositeFuture.join(servicesDeploy).setHandler(e -> {
            System.out.println("Cluster: " + cluster);
            // sending messages
            long periodic = cluster.get(0).setPeriodic(10l, timer -> sendMessage());
            // closing last instance
            cluster.get(0).setTimer(500l, timer -> cluster.get(cluster.size() - 1).close());
            // stop sending messages
            cluster.get(0).setTimer(1000l, timer -> {
                cluster.get(0).cancelTimer(periodic);
            });
            // Closing all
            cluster.get(0).setTimer(2000l, timer -> {
                System.out.println("Failed messages " + MESSAGE_MAP);
                context.assertTrue(MESSAGE_MAP.isEmpty(),
                        "Message map should be empty, but was " + MESSAGE_MAP.toString());
                async.complete();
                cluster.forEach(vertx -> vertx.close());
            });

        });
    }

    private void sendMessage() {
        System.out.println("Sending message " + i);
        MESSAGE_MAP.put(i, i);
        cluster.get(0).eventBus().send(ADDRESS, String.valueOf(i));
        i++;
    }

    public static class ShutdownTestMS extends AbstractVerticle {

        private static AtomicInteger holder = new AtomicInteger(0);

        @Override
        public void start() throws Exception {
            int number = holder.incrementAndGet();
            vertx.eventBus().<String> consumer(ADDRESS, e -> {
                int message = Integer.parseInt(e.body());
                System.out.println(number + " got message " + message);
                MESSAGE_MAP.remove(message);
            });
        }

    }

}

Stack trace:
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:36,668 [vert.x-worker-thread-0] INFO  [admins-MacBook-Pro.local] o.a.c.f.imps.CuratorFrameworkImpl - Starting
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:36,668 [vert.x-worker-thread-0] INFO  [admins-MacBook-Pro.local] o.a.c.f.imps.CuratorFrameworkImpl - Starting
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:41,785 [vert.x-worker-thread-0-EventThread] INFO  [admins-MacBook-Pro.local] o.a.c.f.state.ConnectionStateManager - State change: CONNECTED
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:41,785 [vert.x-worker-thread-0-EventThread] INFO  [admins-MacBook-Pro.local] o.a.c.f.state.ConnectionStateManager - State change: CONNECTED
................... Vertx deployed ...................
................... Vertx deployed ...................
Cluster: [io.vertx.core.impl.VertxImpl@2fbb33e6, io.vertx.core.impl.VertxImpl@5c18005b]
Sending message 0
Sending message 1
1 got message 1
Sending message 2
1 got message 0
Sending message 3
Sending message 4
1 got message 3
Sending message 5
1 got message 5
Sending message 6
2 got message 2
2 got message 4
2 got message 6
Sending message 7
1 got message 7
Sending message 8
2 got message 8
...
Sending message 50
Sending message 51
1 got message 51
Sending message 52
Sending message 53
1 got message 53
Sending message 54
1 got message 54
Sending message 55
1 got message 55
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:48,083 [Curator-Framework-0] INFO  [admins-MacBook-Pro.local] o.a.c.f.imps.CuratorFrameworkImpl - backgroundOperationsLoop exiting
Sending message 56
1 got message 56
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:48,097 [vert.x-eventloop-thread-9] ERROR [admins-MacBook-Pro.local] i.v.c.e.impl.HandlerRegistration - Failed to propagate registration for handler io.vertx.spi.cluster.zookeeper.impl.AsyncMapTTLMonitor$$Lambda$191/1719340525@23cb1cde and address __VERTX_ZK_TTL_HANDLER_ADDRESS
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:48,099 [vert.x-eventloop-thread-10] ERROR [admins-MacBook-Pro.local] i.v.c.e.i.c.ClusteredEventBus - Failed to remove sub
java.lang.IllegalStateException: instance must be started before calling this method
	at org.apache.curator.shaded.com.google.common.base.Preconditions.checkState(Preconditions.java:176)
	at org.apache.curator.framework.imps.CuratorFrameworkImpl.checkExists(CuratorFrameworkImpl.java:367)
	at io.vertx.spi.cluster.zookeeper.impl.ZKMap.lambda$checkExists$5(ZKMap.java:198)
	at org.apache.curator.framework.imps.CuratorFrameworkImpl.sendToBackgroundCallback(CuratorFrameworkImpl.java:749)
	at org.apache.curator.framework.imps.CuratorFrameworkImpl.processBackgroundOperation(CuratorFrameworkImpl.java:522)
	at org.apache.curator.framework.imps.SyncBuilderImpl$1.processResult(SyncBuilderImpl.java:108)
	at org.apache.zookeeper.ClientCnxn$EventThread.processEvent(ClientCnxn.java:634)
	at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:505)
Sending message 57
1 got message 57
Sending message 58
1 got message 58
Sending message 59
1 got message 59
...
Sending message 98
1 got message 98
Sending message 99
1 got message 99
Failed messages {50=50, 52=52}
[WEAVO_MODE_IS_UNDEFINED] [NATIVE] 2018-11-29 18:29:49,528 [vert.x-eventloop-thread-5] ERROR [admins-MacBook-Pro.local] io.vertx.core.impl.ContextImpl - Unhandled exception
java.lang.AssertionError: Message map should be empty, but was {50=50, 52=52}. Expected true
	at io.vertx.ext.unit.impl.TestContextImpl.reportAssertionError(TestContextImpl.java:467)
	at io.vertx.ext.unit.impl.TestContextImpl.assertTrue(TestContextImpl.java:307)
	at com.anyclip.weavo._test.gk.ShutdownTest.lambda$4(ShutdownTest.java:54)
	at io.vertx.core.impl.VertxImpl$InternalTimerHandler.handle(VertxImpl.java:885)
	at io.vertx.core.impl.VertxImpl$InternalTimerHandler.handle(VertxImpl.java:844)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

For now this is really blocking for my project. Is it possible to do something with this?
For example:




Send a call to other nodes, that current node is leaving
And just then start all shutdown procedure





enable some retry mechanism on the event bus and track closed connections or something..





Unsubscribe from receiving messages
push to verticles all the messages, received by event bus, before vertx instance will be shutted down
In this case I can fail the messages manually
stop the event bus and stop the instance

I will be very grateful for any help!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Vertx 3.5.3 chunked transfer encoding could be enabled by

Call response.setChunked(true)
Call response.headers().setAll(responseToProxiedRequest.headers().remove("content-length"))

In Vertx 3.5.4 the above call order breaks with

IllegalStateException: You must set the Content-Length header to be the total size of the message body BEFORE sending any data if you are not using HTTP chunked encoding.
Please note that headers().remove("content-length") was not a requirement for getting/retaining chunked transfer encoding in 3.5.3. That call just adds clarity by leading to an IllegalStateException whenever chunked transfer encoding is not enabled.

Vertx 3.5.4 require that the call order be reversed. I.e.

Call response.headers().setAll(responseToProxiedRequest.headers().remove("content-length"))
Call response.setChunked(true)

I would not expect the behaviour of 3.5.4 unless chunked transfer-encoding was enabled and disabled by setting the appropriate header (with a call to header().set("transfer-encoding", "chunked")), rather than controlling it through a separate instance method.
Given the presence of the setChunked instance method , I do expect the behaviour of 3.5.3: That only explicit calls to setChunked can enable and disable chunked transfer encoding, and that the appropriate transfer-encoding header be set accordingly.
According to https://greenbytes.de/tech/webdav/rfc2616.html#rfc.section.4.4:

Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding. If the message does include a non-identity transfer-coding, the Content-Length MUST be ignored

Neither Vertx 3.5.3, nor 3.5.4 removed or prevented the content-length header from being set when chunked transfer encoding is enabled. I don't see a problem with it, because I can control this behaviour in my implementation. But if you really do feel that it is desireable for headers().setAll to be an implicit call to setChunked(false),  then I strongly believe you should do the same whenever the content-length header is set. I also believe you should change the documentation by

Adding a note about this breaking change in the release notes for 3.5.4
Changing the documentation for both ::setChunked and headers::setAll to clearly state that calls to these methods are inter-dependent as well as document the impact of different method call ordering.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add
void messageSent(String address, Boolean publish, Boolean local, Boolean remote, ServerID sid) 
method to the EventBusMetrics class to help track the delivery of event bus messages across cluster nodes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpClient request/response methods are using in Vert.x 3 patterns using an Handler<HttpClientResponse>. For obvious reasons we want to use instead Handler<AsyncResult<HttpClientResponse>> in Vert.x 4. The WebClient provides already this in Vert.x 3.x and it is the advocated client for high level operations so we don't need to provide replacement for these operations, only to deprecate them.
Pull request for Vert.x 3 that deprecates the methods of the HttpClient with a mention for removal in Vert.x 4:

#2743

A bunch of pull requests for the Vert.x 4 stack that upgrade the usage of the handler:

vert-x3/vertx-lang-ruby#37
vert-x3/vertx-lang-kotlin#100
vert-x3/vertx-unit#67
vert-x3/vertx-rx#169
vert-x3/vertx-dropwizard-metrics#84
vert-x3/vertx-micrometer-metrics#67
vert-x3/vertx-sync#33
vert-x3/vertx-circuit-breaker#32
vert-x3/vertx-http-service-factory#10
vert-x3/vertx-service-discovery#101
vert-x3/vertx-auth#252
vert-x3/vertx-tcp-eventbus-bridge#45
vert-x3/vertx-web#1094
vert-x3/vertx-config#62
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi there,
i am already using vertx.executeBlocking() but i always get this exception:
Jan 13, 2019 4:18:24 PM io.vertx.core.impl.BlockedThreadChecker
WARNUNG: Thread Thread[vert.x-worker-thread-1,5,main] has been blocked for 5644 ms, time limit is 0
io.vertx.core.VertxException: Thread blocked
	at sun.misc.Unsafe.park(Native Method)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at com.jukusoft.mmo.gs.region.RegionContainerImpl.lambda$init$3(RegionContainerImpl.java:220)
	at com.jukusoft.mmo.gs.region.RegionContainerImpl$$Lambda$116/89177479.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$1(ContextImpl.java:273)
	at io.vertx.core.impl.ContextImpl$$Lambda$10/1232703108.run(Unknown Source)
	at io.vertx.core.impl.TaskQueue.run(TaskQueue.java:76)
	at io.vertx.core.impl.TaskQueue$$Lambda$9/303846650.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)

Jan 13, 2019 4:18:24 PM io.vertx.core.impl.BlockedThreadChecker
WARNUNG: Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 5593 ms, time limit is 0
io.vertx.core.VertxException: Thread blocked
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
	at java.net.SocketInputStream.read(SocketInputStream.java:170)
	at java.net.SocketInputStream.read(SocketInputStream.java:141)
	at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)
	at java.io.BufferedInputStream.read1(BufferedInputStream.java:286)
	at java.io.BufferedInputStream.read(BufferedInputStream.java:345)
	at java.io.FilterInputStream.read(FilterInputStream.java:107)
	at org.apache.commons.net.io.Util.copyStream(Util.java:102)
	at org.apache.commons.net.ftp.FTPClient._retrieveFile(FTPClient.java:1920)
	at org.apache.commons.net.ftp.FTPClient.retrieveFile(FTPClient.java:1885)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadSingleFile(FTPUtil.java:41)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:102)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:96)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:96)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:96)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:96)
	at com.jukusoft.mmo.gs.region.ftp.FTPUtil.downloadDirectory(FTPUtil.java:60)
	at com.jukusoft.mmo.gs.region.RegionContainerImpl.lambda$downloadFilesFromFtp$5(RegionContainerImpl.java:256)
	at com.jukusoft.mmo.gs.region.RegionContainerImpl$$Lambda$112/113015548.handle(Unknown Source)
	at com.jukusoft.mmo.gs.region.ftp.NFtpFactory.lambda$create$1(NFtpFactory.java:52)
	at com.jukusoft.mmo.gs.region.ftp.NFtpFactory$$Lambda$114/113714097.handle(Unknown Source)
	at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:79)
	at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:289)
	at io.vertx.core.impl.ContextImpl$$Lambda$11/2011477534.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
	at io.vertx.core.impl.ContextImpl$$Lambda$12/727546868.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
source code:
//download files for region from ftp server (in another thread to avoid blocking og this thread)
vertx.executeBlocking(future -> {
    downloadFilesFromFtp();//this operation takes about 6-10 seconds
    future.complete();
}, (Handler<AsyncResult<Void>>) event -> {
    //don't do anything here
});
For explanaition:
I download some files from ftp server and this takes some time. So i have also tried to set the checker interval:
vertxOptions.setBlockedThreadCheckInterval(30000);
but this doesn't have any effect.
It is a clustered vertx instance (source file).
What can i do to solve this problem? Or how can i increase the limit?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using web client to get urls . I need to get the redirected uri for further parsing as base url . Thanks in advance . As I investigated, HttpAsyncClient uses a HttpContext to get it:
CloseableHttpAsyncClient httpclient = HttpAsyncClients.custom().build();
            try {
                httpclient.start();
                HttpClientContext localContext = HttpClientContext.create();
                HttpGet request = new HttpGet("https://bit.ly/1eTpSHp");
                request.setHeader("User-Agent", "gis");
                Future<HttpResponse> future = httpclient.execute(request, localContext, null);
                HttpResponse response = future.get();
                String result = IOUtils.toString(response.getEntity().getContent(), StandardCharsets.UTF_8);
                System.out.println("Response: " + response.getStatusLine().getStatusCode() + ":" + result.length());
                HttpHost target = localContext.getTargetHost();
                List<URI> redirectLocations = localContext.getRedirectLocations();
                for (URI u : redirectLocations) {
                    System.out.println("location: " + u.toASCIIString());
                }
                URI location = URIUtils.resolve(request.getURI(), target, redirectLocations);
                System.out.println("Final HTTP location: " + location.toASCIIString());
                // Expected to be an absolute URI
            } finally {
                httpclient.close();
            }

just for reference.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I'm trying to run natural language search. I have collection tag, and that collection has text field, with text index on it.
When I connect via shell, and run the query:
 db.tag.find(
    { $text: { $search: "tag" } },
    { score: { $meta: "textScore" } }
).sort( { score: { $meta: "textScore" } } )
I get expected results back. When I do the same from the vert.x kotlin app:
threadMongoClient.rxFindWithOptions(
            "tag",
            json("\$text" to json("\$search" to msg.body())),
            FindOptions()
                .setSort(json("score" to json("\$meta" to "textScore")))
                .setFields(json("score" to json("\$meta" to "textScore")))
                .setLimit(5))
        ).subscribe({ matches ->
            msg.reply(JsonArray(matches))
        }, { err ->
            log.error("Could not retrieve similar tags", err)
            msg.fail(500, err.message)
        })
I always get 0 results back for the same input  - "tag" string in this case.
Is there some obvious mistake I'm making?
Many thanks for wonderful work!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently users might use executeBlocking for operations that lasts an indefinite amount of time (e.g using a worker thread to poll a blocking input in a while loop). Add documentation to clarify this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add a callback to HttpServerResponse.sendFile so the caller can react to when the file is completely put on the wire.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When setting an exceptionHandler for a response, it is called with a "connection closed" exception for every HTTP2 request, even when the response has been written and ended properly. This does not happen for HTTP1.1 requests. The following unit test illustrates this problem - it passes for HTTP1.1 and fails for HTTP2. Maybe PR #2319 fixes this.
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpVersion;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunnerWithParametersFactory;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import java.util.List;

@RunWith(Parameterized.class)
@Parameterized.UseParametersRunnerFactory(VertxUnitRunnerWithParametersFactory.class)
public class Http2ConnectionClosedReproducer {

  @Parameterized.Parameters
  public static Iterable<HttpVersion> httpVersions() {
    return List.of(HttpVersion.HTTP_1_1, HttpVersion.HTTP_2);
  }

  @Parameterized.Parameter
  public HttpVersion httpVersion;

  @Test
  public void test(TestContext ctx) {
    var vertx = Vertx.vertx();
    var listenFut = Future.<HttpServer>future();
    
    vertx.createHttpServer(new HttpServerOptions())
      .requestHandler(r -> r.response()
        .exceptionHandler(ctx::fail)
        .end("world!"))
      .listen(0, listenFut);

    listenFut.compose(server -> {
      var requestFut = Future.future();
      vertx.createHttpClient(new HttpClientOptions()
          .setProtocolVersion(httpVersion)
          .setDefaultPort(server.actualPort()))
        .getNow("/hello", r -> r.bodyHandler(body -> {
          ctx.assertEquals("world!", body.toString());
          requestFut.complete();
        }));
      return requestFut;
    }).setHandler(ctx.asyncAssertSuccess());
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Not sure how to fix ip-validation check. I have signed the ECA before. Resigned it again. Also not able to see any details regarding the ip-validation check:
https://dev.eclipse.org/eclipse-webhook/services/status_details.php?id=5c48098f32584
Current status
Validation status unavailable. Contact support.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm using vertx-service-discovery for rpc service. And use vertx-ignite for cluster. The vertx version is 3.5.4.
I also got this exception: NO HANDLER (-1) for address , it appears sometime, not always.
the exception showed below
LOCAL_SYSTEM_TIME=[2019-01-23 18:14:56.257],THREAD=[vert.x-eventloop-thread-0],LOG_LEVEL=[INFO ],CLASS=[c.e.s.m.b.p.r.DynamicMessageProcessRPC.lambda$send$1:125],LOG_VERSION=[V1],LOG_FLAG=[BIZ],SYSTEM_TRACEID=[111],MODULE_NAME=[SPLITTER],SERVICE_NAME=[BUSINESS_SERVICE],CONTAINER ID=[iZuf68d2sa0635xqj2s1bqZ],TYPE=[FUNCTION],STATUS=[ING],DESCRIPTION=[DynamicMessageProcessRPC send(), success to get the consumer ],PARAMS=[{"location":{"endpoint":"_ComService_192.168.16.33"},"metadata":{"service.interface":"com.eigpay.splitter.infrastructure.communication.provider.chief.message.MessageProvider"},"name":"MessageProvider_ComService_192.168.16.33","status":UP,"registration":"e2519632-c7e7-4e05-acde-c6a4cbaae514","type":"eventbus-service-proxy"},MessageProvider_ComService_192.168.16.33]
LOCAL_SYSTEM_TIME=[2019-01-23 18:14:56.329],THREAD=[vert.x-eventloop-thread-0],LOG_LEVEL=[INFO ],CLASS=[c.e.s.m.b.p.r.DynamicMessageProcessRPC$1.handle:150],LOG_VERSION=[V1],LOG_FLAG=[BIZ],SYSTEM_TRACEID=[111],MODULE_NAME=[SPLITTER],SERVICE_NAME=[BUSINESS_SERVICE],CONTAINER ID=[iZuf68d2sa0635xqj2s1bqZ],TYPE=[FUNCTION],STATUS=[ING],DESCRIPTION=[DynamicMessageProcessRPC send(), forward message fails, retrying],PARAMS=[{"value":1},(NO_HANDLERS,-1) No handlers for address _ComService_192.168.16.33
at io.vertx.core.eventbus.impl.HandlerRegistration.sendAsyncResultFailure(HandlerRegistration.java:127)
at io.vertx.core.eventbus.impl.EventBusImpl.deliverMessageLocally(EventBusImpl.java:368)
at io.vertx.core.eventbus.impl.clustered.ClusteredEventBus.lambda$sendOrPub$4(ClusteredEventBus.java:245)
at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:79)
at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:289)
at io.vertx.core.impl.ContextImpl.lambda$wrapTask$2(ContextImpl.java:339)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
]
I registered in the eventbus address _comservice_192.168.1.33 bond with the service name messagepriovder_comservice_192.168.1.33 . when the com service node(192.168.1.33) started, the rpc service will be published. Then the biz service node will find the rpc service by service name rhen call the rpc interface.  The com service node and biz service node are clustered by ignite with tcpvmfinder configurations.
I succeed to get the rpc service consumer , but when calling the rpc interface, the error  appears.
I got very confused , and test some days , have not fixed this. Could anyone offer s
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are cases where you want to setup a Verticle with a specific ObjectMapper configurations (additional configs, modules, etc).
But we dont want to change the global mapper, but we are also using items (like the Web Client) that use the global mapper.
Would be great if Abstract Verticle allowed you to control the specific mapper being used.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have to deal with many messages send via send/reply strategy over a clustered eventbus. Vertx registeres a new handler for each call which causes in heavy load in cluster manager (we use zookeeper cluster manager) which has to create a new entry for each message and propagate it to all cluster memebers (< 600 instances). This could be avoid and we implement our own Reply Strategy which uses send strategy of vertx inside. We register only one reply consumer/handler while start of each verticle/eventbus instance. It's address is send as header via send and while reply this address is used.
maybe its possible to integrate this into vertx core.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This code:
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Vertx;

public class Main {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new A());
  }

  static class A extends AbstractVerticle {
    @Override
    public void start() {
      vertx.deployVerticle(new B(), deployResult -> {
        if (deployResult.succeeded()) {
          System.out.println("deployed");
        } else {
          System.out.println("not deployed");
        }
      });
    }
  }

  static class B extends AbstractVerticle {
    @Override
    public void start(Future<Void> startFuture) {
      vertx.getOrCreateContext().addCloseHook(hook -> {
        System.out.println("close hook handler is called");
      });
      startFuture.fail("Something is wrong");
    }
  }
}
Actual behaviour
prints:
close hook handler is called

Expected behaviour
prints:
close hook handler is called
not deployed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have this error:
java.lang.IllegalStateException: Set request or websocket handler first
        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:196)
        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:191)
        at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:187)
        at huru.MainVerticle.start(MainVerticle.java:206)
        at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.j
here is the culprit (the main verticle):
package huru;

import huru.middleware.JWTHandler;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.sql.SQLRowStream;
import io.vertx.ext.web.Router;
import io.vertx.ext.asyncsql.PostgreSQLClient;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.ResultSet;
import io.vertx.ext.sql.SQLClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.RoutingContext;
import org.apache.log4j.Logger;
import io.vertx.core.Future;
import io.vertx.ext.web.handler.BodyHandler;


public class MainVerticle extends AbstractVerticle {
  
  private final Logger log = Logger.getLogger(MainVerticle.class);
 
  @Override
  public void start(Future<Void> f) throws Exception {
    
    super.start();
    
    final Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    router.route().handler(new JWTHandler());
    
    final EventBus eventBus = vertx.eventBus();
    
    eventBus.consumer("address", receivedMessage -> {
      log.debug("Received message: " + receivedMessage.body());
      receivedMessage.reply("my reply");
    });
    
    router.route(HttpMethod.GET, "/hello/:name").handler(ctx -> {
      // Retrieving request and response objects
      HttpServerRequest request = ctx.request();
      HttpServerResponse response = ctx.response();
      
      String name = request.getParam("name");
 
      response.putHeader("Content-Type", "text/plain");
      response.setChunked(true);
      response.write("Hello " + name);
      response.setStatusCode(200);
      response.end();
    });
    
    router.route("/").handler(ctx -> {
      HttpServerResponse response = ctx.response();
      response
        .putHeader("content-type", "text/html")
        .end("<h1>Hello from non-clustered messenger example!</h1>");
    });
    
    router.post("/send/:message").handler(this::sendMessage);

    router.route().last().handler(ctx -> {
      ctx.response().setStatusCode(404).end();
    });
    
    JsonObject config = new JsonObject()
      .put("username", "postgres")
      .put("password", "postgres")
      .put("database", "oleg")
      .put("host", "localhost")
      .put("port", 5432);
    
    SQLClient client = PostgreSQLClient.createShared(vertx, config);
  
    int port = 3005;
    
    vertx.createHttpServer()
      .exceptionHandler(ctx -> {
        
        log.error("In the exception handler.");
        log.error(ctx.getCause());
        
      })
//      .requestHandler(req -> {
//            the culprit? this request handler is commented out
//      })
      .listen(port, res -> {
        if (res.succeeded()) {
          System.out.println("Server listening on port " + port);
          f.complete();
        } else {
          System.out.println("Failed to launch server");
          f.fail(res.cause());
        }
      });
    
  }
  
}
there seems to be a conflict of interested between
    vertx.createHttpServer()
     .requestHandler(req -> {
            the culprit? this request handler is commented out
      })
and
    final Router router = Router.router(vertx);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
currently:

we create multiple vertx instances in one process
sometimes our code is not so good, that caused create unnecessary eventloopContext

so we extend VertxImpl in vertx 3.5.3 and previous versions (https://github.com/apache/servicecomb-java-chassis/blob/master/foundations/foundation-vertx/src/main/java/io/vertx/core/impl/VertxImplEx.java):

give vertx a name, and make eventloop thread name prefix relate to vertx name
calculate how many eventloopContext created


but when i try this in 3.6.3-SNAPSHOT, i fount that constructor changed from package to private, so i can not do what we want.
someone help me to resolve this? thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the name is too simple, how about threadNamePrefix
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Originally filed as an Rxified consumer issue (vert-x3/vertx-rx#179) but it turns out the MessageConsumer implementation itself is the root cause.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think the fix is incorrect as the EventBus flow control tests don't pass anymore, also this fix makes an unecessary to pending when it is empty.
The actual issue of this bug is that the demand is never decreased when a message is processed and adding simply:
        if (demand != Long.MAX_VALUE) {
          demand--;
        }

fixes the issue
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From org.owasp:dependency-check-maven plugin,
[ERROR] jackson-databind-2.9.7.jar: CVE-2018-19362, CVE-2018-19361, CVE-2018-19360
Bumping to v2.9.8 solves the issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am looking for a feature to determine if a method call x is in the same event loop tick as a previous method call y. If it's the same tick, I will use code like this to make sure the call gets run on the next tick:
private void putCallOnNextTickIfNecessary(int previousTickId, Runnable v, Whatever w) {
  
  if(vertx.weAreInNewTick(previousTickId)){
      v.run(w);
      return;
   }

  vertx.runOnContext(new Handler<Void>() {
    public void handle(Void event) {
         v.run(w);
    }
  });
}
this kind of thing will make sure APIs are always sync or always async to make them consisent. Doing this in Node.js is known as avoiding Zalgo.
Anyway, my question is, how do we implement vertx.weAreInNewTick(previousTickId)?
What that method would do is get the id of the current tick and if that id is greater than the previous tick, return true. But not sure if we can do this yet?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The listen method in the NetServerImpl class :
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(availableWorkers);
sslHelper.validate(vertx);
Threads that handle other IO events and tasks in addition to accept can easily block
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why is it wasteful to create a new context, but only callContext
       ` if (deployCount.incrementAndGet() == verticles.length) {
            reportSuccess(deploymentID, callingContext, completionHandler);
          }`

Isn't that a waste of an eventloop thread? There's nothing to do!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I posted this question on StackOverflow:
https://stackoverflow.com/questions/54498162/how-to-catch-errors-in-asynchronous-code-using-vert-x
Maybe I missed it in the docs but I think it's an important feature and I am wondering if Vertx attempts to solve this one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClient pool on idle timeout might evict connections but does not check progress. It should check progress so the pool is closed and released when it becomes empty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Say I have a simple API, like so:
x.doSomething(v -> {
   v.done(null, 5);
});

v.onDone((err,value) ->{
   System.out.println("This gets fired after v.done() is called");
});
Given the above code, my question is - using Vertx with Java, is there a guarantee that v.onDone will be called in a deterministic amount of time?
for example, assume that v.done() looks like:
class V {
  ArrayList<Object> onDoneHandlers  = new ArrayList<>();
  
  public void onDone(Object cb){
    this.onDoneHandlers.add(cb);
  }

  public void done(Object err, Integer result){
     var v = this;
     new Thread(() -> {
        Thread.sleep(50);
        v.onDoneHandlers.get(0).run(err, result)
    }).start();
 }

}
so by using a thread, we delay, in the hopes that  v.onDone() in the same scope will be registered, but I don't believe there is any such guarantee, when it comes to basic Java threads. So I assume that using an event loop will give us such a guarantee, where vanilla Java threads wouldn't.  Is there some documentation that explains how this guarantee works?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
I am working with vertx web and I am migrating from the 3.5.0 to the 3.6.3.
I am now facing a issue that was not present on the previous version: when request is sent to the websocket server there is a CORS problem
Here is the header of the sent request:
Accept: */*
Accept-Encoding: gzip, deflate, br
Accept-Language: fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3
Cache-Control: no-cache
Connection: keep-alive
Host: xxx.xxx.xxx.xxx:yyyy
Origin https://xxx.xxx.xxx.xxx
Pragma: no-cache
Referer: https://xxx.xxx.xxx.xxx/myURL

Here is the former response (3.5.0):
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: https://xxx.xxx.xxx.xxx
Cache-Control: no-store, no-cache, no-transform, must-revalidate, max-age=0
content-length: 77
Content-Type: application/json; charset=UTF-8

Here is the new response (3.6.3):
Access-Control-Allow-Credentials: true
access-control-allow-origin: *
Cache-Control: no-store, no-cache, no-transform, must-revalidate, max-age=0
content-length: 78
Content-Type: application/json; charset=UTF-8

You can see that the parameter access-control-allow-origin is different from one version to another. As a result Firefox tells me it is not allowed to look for a resource which access-control-allow-origin is "*" while Access-Control-Allow-Credentials is set to true.
I might have seen something in the vertx code that changed and could explain that but I do not know if it was on purpose. In the method setCORS() in the class io.vertx.ext.web.handler.sockjs.impl.BaseTransport, the new version does not override the Access-Control-Allow-Origin if already set resulting in the wildcard in the response.
Here is my implementation for opening a server websocket:
Router router = serverFactory.getRouter(port);

router.route()
            .handler(CorsHandler.create("*").allowedHeader("Authorization").allowedHeader("www-authenticate")
           .allowedHeader("Content-Type").allowedHeader("origin").allowedHeader("x-requested-with")
           .allowedHeader("Access-Control-Allow-Origin").allowedHeader("accept").allowedMethod(HttpMethod.OPTIONS)
           .allowedMethod(HttpMethod.GET).allowedMethod(HttpMethod.POST.allowedMethod(HttpMethod.DELETE)
           .allowedMethod(HttpMethod.HEAD));

Yours faithfully
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For basic authentication, the basicAuthentication method in HttpRequests should be joining the client_id and client_secret with a colon (as the javadoc also suggests), but in reality it joins them using a hyphen, as shown below. It's not the biggest inconvenience, but just thought I'd point that out.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am seeing this:

I would think there would be a method that tells the test case that there is failure?
should we just throw an error?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I posted this question on SO:
https://stackoverflow.com/questions/54645377/best-way-to-map-jsonobject-to-class-fields
here is the only definition for mapTo:
  public <T> T mapTo(Class<T> type) {
    return Json.mapper.convertValue(this.map, type);
  }
I am thinking another definition which accepts another map which can map the fields before converting? Something like this:
  public <T> T mapTo(Class<T> type, Map<String,String> m) {
    return Json.mapper.convertValue(renameKeys(this.map,m), type);
  }
where renameKeys would rename the keys in this.map to the expected names.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I asked this question on SO:
https://stackoverflow.com/a/54607357/1223975
Is there a good way to implement an asynchronous version of synchronized keyword? Obviously synchronous blocks the current thread.
For example:
  public static boolean getLockSync(Runnable r) {

    if (isLocked) {
      r.run();
      return true;
    }

    synchronized (My.lock) {  // this is blocking, could block for more than 1-2 ms
      isLocked = true;
      r.run();
      isLocked = false;
      return false;
    }

  }
I can return a boolean from this block - it's synchronous. Is there a way to do this asynchronously?
Something like this:
  public static void getLockAsync(Runnable r) {

    if (isLocked) {
      CompletableFuture.runAsync(r);
      return;
    }

    Object.onLockAcquisition(My.lock, () -> {  // this is non-blocking
           isLocked = true;
           r.run();
           isLocked = false;
           Object.releaseLock(My.lock);
     });

  }
I made up the Object.onLockAcquisition method, but looking for something like that.
Object.wait() and Object.notify() are for threads, I don't think a non-blocking locking system will play well with traditional synchronization primitives
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I looked through the source code, and therefore I believe this is a request not a question.
Say we have a SQLConnection conn:
   conn.query("select * from bagel", res -> {
        JsonObject o = res.result().toJson();
        ctx.response().end(o.toString());
   });
however it's pretty obvious that this query is going to return a list (of rows), so always putting everything in a JsonObject is not very refined. I would hope for something like this instead:
   conn.query("select * from bagel", res -> {
        JsonArray o = res.result().toJsonArray();
        ctx.response().end(o.toString());
   });
but that call doesn't seem to exist. I looked through the source, I see this for toJson();
ResultSetConverter.toJson(this, obj);
which converts into:
  public static void toJson(ResultSet obj, JsonObject json) {
    toJson(obj, json.getMap());
  }
which calls:
public static void toJson(ResultSet obj, Map<String, Object> json) {
    JsonArray array;
    if (obj.getColumnNames() != null) {
      array = new JsonArray();
      obj.getColumnNames().forEach((item) -> {
        array.add(item);
      });
      json.put("columnNames", array);
    }

    if (obj.getNext() != null) {
      json.put("next", obj.getNext().toJson());
    }

    json.put("numColumns", obj.getNumColumns());
    json.put("numRows", obj.getNumRows());
    if (obj.getOutput() != null) {
      json.put("output", obj.getOutput());
    }

    if (obj.getResults() != null) {
      array = new JsonArray();
      obj.getResults().forEach((item) -> {
        array.add(item);
      });
      json.put("results", array);
    }

    if (obj.getRows() != null) {
      array = new JsonArray();
      obj.getRows().forEach((item) -> {
        array.add(item);
      });
      json.put("rows", array);
    }

  }
the above code is very if/elsey - I think it would be nice to see a toJsonArray and toJson method?
if it couldn't be converted to an array, it would throw an Exception, which is fine. If it's an array and you attempt to convert it to a single object, then it would also throw.
Is this a good idea? All I see right now is:
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am looking this:

I just want to write json to the response. I assume the right way to do this now is something like:
 ctx.response().end(r.result().toJson().toString());
but I wonder if there could exist a json() method or sendJson() method that could accept various different kinds of JSON library types and handle them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@pk-work thanks for the PR. This is a good start. To complete it we need:

shared data documentation update
test (like two clustered nodes may acquire a local lock with same name at the same time)

I would also prefer not to break the feature into pieces (local locks in 3.7 and the rest in 4.0). Can you also contribute the changes for local counters and local async map?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I believe this can create a JsonObject from a string:
 JsonObject o = new JsonObject(`{"foo":"bar"}`);
however, I expected this to work:
 JsonObject o = JsonObject.from(`{"foo":"bar"}`);
but there is no from() static method...this would be a nice-to-have.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently TrustOptions and KeyCertOptions interface defines a clone() method without extending the Cloneable interface. The method should be deprecated in 3.x with a new copy() method and the copy() method should delegate to the clone() method as default implementation. The clone() method is removed in 4.0.
This method is not intended to be used by developers, usually it is used internally when an options object is copied and this is used to implement a polymorphic copy.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The ip-validation check failed even though I had signed the ECA before I opened this PR. Could someone please help with this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
actually this has just been added by this commit a8d751e
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP server/client have many discrepencies and the documentation is inconsistent with the spec for the WebSocket compression extensions.
In addition a few methods needs to be actually renamed to have proper getters and a couple of constants for default parameter value are inconsistent with their corresponding attribute.

HttpClientOptions

DEFAULT_TRY_USE_WEBSOCKET_DEFLATE_FRAME  DEFAULT_TRY_USE_PER_FRAME_WEBSOCKET_COMPRESSION
DEFAULT_TRY_USE_WEBSOCKET_PERMESSAGE_DEFLATE  DEFAULT_TRY_USE_PER_MESSAGE_WEBSOCKET_COMPRESSION
DEFAULT_WEBSOCKET_COMPRESSION_ALLOW_CLIENT_NO_CONTEXT  DEFAULT_WEBSOCKET_ALLOW_CLIENT_NO_CONTEXT
DEFAULT_WEBSOCKET_COMPRESSION_REQUEST_SERVER_NO_CONTEXT  DEFAULT_WEBSOCKET_REQUEST_SERVER_NO_CONTEXT
tryWebsocketDeflateFrameCompression()
tryUsePerMessageWebsocketCompression()


HttpServerOptions

DEFAULT_WEBSOCKET_SUPPORT_DEFLATE_FRAME_COMPRESSION  DEFAULT_PER_FRAME_WEBSOCKET_COMPRESSION_SUPPORTED
DEFAULT_WEBSOCKET_SUPPORT_PERMESSAGE_DEFLATE_COMPRESSION  DEFAULT_PER_MESSAGE_WEBSOCKET_COMPRESSION_SUPPORTED
DEFAULT_WEBSOCKET_COMPRESSION_ALLOW_SERVER_NO_CONTEXT  DEFAULT_WEBSOCKET_ALLOW_SERVER_NO_CONTEXT
DEFAULT_WEBSOCKET_COMPRESSION_PREFERRED_CLIENT_NO_CONTEXT  DEFAULT_WEBSOCKET_PREFERRED_CLIENT_NO_CONTEXT
perFrameWebsocketCompressionSupported()  getPerFrameWebsocketCompressionSupported()
perMessageWebsocketCompressionSupported()  getPerMessageWebsocketCompressionSupported()
websocketCompressionLevel()  getWebsocketCompressionLevel()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently SSLEngineOptions class defines a clone() method without extending the Cloneable interface. The method should be deprecated in 3.x with a new copy() method and the copy() method should delegate to the clone() method as default implementation. The clone() method is removed in 4.0.
This method is not intended to be used by developers, usually it is used internally when an options object is copied and this is used to implement a polymorphic copy.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently some options classes define equals/hashCode methods with tests. There is no real purpose for such methods and such implementations require to be implemented / tested. The equals method is used in some tests (for instance to assert copy constructors) but this can be replaced by comparing the json version of the options.
We can remove such methods which are not really necessary and this will simplify the implementation of vertx options and be less error prone synchronising the implementation with the actual options fields (which does not happen for json as we generate them).
Users code should not rely on these methods, this will only be removed in Vert.x 4 however.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj do need something else?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Support context tracing in a Vert.x runtime.
See also https://github.com/vert-x3/wiki/wiki/RFC:-context-tracing
Goals

trace an activity or flow attached to the current Vert.x context (which implies it can be statically retrieved using a thread local using the Vert.x context)
hooks for transport context propagation (HTTP client/server, event-bus consumer/producer)
tracing management, i.e the ability to start/end an activity for third-party integration

Non goals

generic framework for tracing arbitrary continuations
thread local like registries

Changes

allow to shallow duplicate and attach local data to a io.vertx.core.Context, this creates a new context which shares the same state than its creating context (same event-loop, same attribute map, same concurrency, etc...).
add a local map storage on the context, that is used to store state to distinguish contexts (i.e it can store a span id, etc...)
add an event-driven tracer SPI (that can be configured or discovered) for integration with external tracing systems (tracing clients such as Zipkin, OpenTracing, etc...)
modify server implementations so that contexts are created when necessary

per HTTP server request
per event-bus message received
etc...



Not covered by this issue (i.e todo)

integration of other Vert.x middleware with the tracer SPI so their activity can be traced
integration with tracing clients
per verticle tracing configuration (not planned)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This PR breaks a few internal API, so the stack needs to be checked after merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using the CLI API for parsing command-line parameters I noticed that the shortName for Options are case-insensitive.  I wouldn't have expected this behavior by default, and didn't see this behavior documented anywhere.  I recall working with other command-line tools which accept single-character ("shortName") options in both uppercase and lowercase forms (i.e. ./someTool -a someValue -A someOtherValue).
Here's a quick test case demonstrating this behavior (short names):
    @Test
    public void testCliOptionShortNamesAreCaseSensitive() {
        CLI cli = CLI.create("test")
                .addOption(new Option().setShortName("a").setLongName("lowercase"))
                .addOption(new Option().setShortName("A").setLongName("uppercase"));

        String lowercaseValue = "someValue";
        String uppercaseValue = "someOtherValue";

        CommandLine commandLine = cli.parse(Arrays.asList("-a", lowercaseValue,
                                                          "-A", uppercaseValue));

        Assert.assertEquals(lowercaseValue, commandLine.getOptionValue("a"));
        Assert.assertEquals(uppercaseValue, commandLine.getOptionValue("A"));
    }

org.junit.ComparisonFailure: 
Expected :someOtherValue
Actual   :someValue

And here's another, where I pass the long names into commandLine.getOptionValue():
    @Test
    public void testCliOptionLongNamesAreCaseSensitive() {
        CLI cli = CLI.create("test")
                .addOption(new Option().setShortName("a").setLongName("lowercase"))
                .addOption(new Option().setShortName("A").setLongName("uppercase"));

        String lowercaseValue = "someValue";
        String uppercaseValue = "someOtherValue";

        CommandLine commandLine = cli.parse(Arrays.asList("-a", lowercaseValue,
                                                          "-A", uppercaseValue));

        Assert.assertEquals(lowercaseValue, commandLine.getOptionValue("lowercase"));
        Assert.assertEquals(uppercaseValue, commandLine.getOptionValue("uppercase"));
    }

java.lang.AssertionError: 
Expected :someOtherValue
Actual   :null

Interestingly enough, if I pass the full long name representations into cli.parse(), and use the full long names when retrieving the values via commandLine.getOptionValue(), then I get the expected behavior (test passes):
    @Test
    public void testCliOptionLongNames() {
        CLI cli = CLI.create("test")
                .addOption(new Option().setShortName("a").setLongName("lowercase"))
                .addOption(new Option().setShortName("A").setLongName("uppercase"));

        String lowercaseValue = "someValue";
        String uppercaseValue = "someOtherValue";

        CommandLine commandLine = cli.parse(Arrays.asList("--lowercase=" + lowercaseValue,
                                                          "--uppercase=" + uppercaseValue));

        Assert.assertEquals(lowercaseValue, commandLine.getOptionValue("lowercase"));
        Assert.assertEquals(uppercaseValue, commandLine.getOptionValue("uppercase"));
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Remove this SPI internal method that has been marked as deprecated and never really used/implemented.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This method has been deprecated a long time ago and replaced by NetServerOptions#clientAuth enumerated field.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This method is replaced by the nested FileSystemOptions#fileCachingEnabled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@OverRide
public void start(Future future) throws Exception {
System.out.println("start : "+Thread.currentThread().getName());
vertx.setPeriodic(1000,res->{
System.out.println("1 : "+Thread.currentThread().getName());
try {
Thread.currentThread().sleep(2000);
} catch (InterruptedException e) {
e.printStackTrace();
}
});
vertx.setPeriodic(400 , res->{
System.out.println("2 : " + Thread.currentThread().getName());
});
future.complete();
}
the second setPriodic sync with first setPriodic ?????????????????
if first setPrioic have a long time operations why the second setPriodic must w8 for it.
this is a worker verticle ,
DeploymentOptions.setWorker(true)
sorry my english is not good.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@OverRide
public void start(Future future) throws Exception {
System.out.println("start : "+Thread.currentThread().getName());
vertx.setPeriodic(1000,res->{
System.out.println("1 : "+Thread.currentThread().getName());
try {
Thread.currentThread().sleep(2000);
} catch (InterruptedException e) {
e.printStackTrace();
}
});
vertx.setPeriodic(400 , res->{
System.out.println("2 : " + Thread.currentThread().getName());
});
future.complete();
}
verticle is worker verticle , DeplpymentOptions().setWorker(true).
why the second operation (setPriodic) synced with first.
if the first operation have a long time process why the second operation must w8ing for it , while we used worker thread and worker threads used for long operation.
plz explain this behavor , sorry my english is not good.TY.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the InboundBuffer uses a lower or equals comparison to the high water mark when checking the buffer writability. It should use a strict bound, so a buffer with a zero high water mark  will reported to be full when the buffer is paused and there is no demand
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the drain handler can be called when writing to the InboundBuffer as the InboundBuffer will append the elements to the queue when it receives elements and is already emitting and the internal buffer is full.
Instead writing to the internal buffer should always succeed when there is demand and the result of the write operation should only be based on the high water mark and the size of the internal queue instead of being based previously on the high water mark only.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In 3.6, the stream contract was changed to pause only the event notification and not the end handler notification. The assumption was that pause only concerns the data and that a stream could end when there is no demand for its elements.
This issue restores the previous behaviour and add test for this behavior (it was actually inconsistentin the codebase).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj please restart ci build, this is the logging fix for 3.7 you merged on master some weeks ago
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Only getting one response, when processing the event bus message, (reply is from websocket client handler.)
public class WorkerVerticle extends AbstractVerticle {
    private WebSocket webSocket;

    @Override
    public void start(Future<Void> startFuture) {
        vertx.eventBus().<JsonObject>consumer("/processRequest")
                .toFlowable()
                .subscribe(this::processRequest);

        vertx.createHttpClient().websocket(9000, "localhost", "/requestURL", webSocket -> {
            System.out.println("Connected to server");
            this.webSocket = webSocket;
        });
        startFuture.complete();
    }

    private void processRequest(Message<JsonObject> message) {
        webSocket.writeBinaryMessage(Buffer.buffer(constructRequest(message).toString()));
        webSocket.handler(res -> {
            System.out.println(res.toString());
            message.reply(constructResponse(res));
        });
    }
}

Getting reply only for the first message, all other requests which are sent via eventbus are getting timeout after 30 seconds.
Using Vert.x 3.6.3
Stuck with this for a very long time. Any help would be greatly appreciated !!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
reproduce step

start upload server sample in vertx-examples.
don't choose file or choose empty file(size is 0) and upload
after upload, check program's open file with lsof( on linux ) or processexplore(on windows)
can see the remain uploaded file handle




preliminary analysis

it seems that the HttpServerFileUploadImpl.streamToFileSystem does not set the file variable,  it's null, and can not close while handleComplete. But I'm not sure about it now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what version did you try with ?

 On 1 Mar 2019, at 09:41, fishjam ***@***.***> wrote:

 can not close the file handle if upload empty or zero size file
 When my test:
 Starting test: Http1xTest#testFormUploadZeroFile
 Unhandled exception
 java.lang.AssertionError: Issue: 2856, if it's null for zero file, can not close the file

 ....

 after streamToFileSystem succeeded, ***@***.***

  <https://user-images.githubusercontent.com/1870684/53626369-7e891f80-3c40-11e9-9a0c-33041e53e8bf.png>
 You can view, comment on, or merge this pull request online at:

   #2857 <#2857>
 Commit Summary

 reproduce step for issue 2856 scenario 1:
 File Changes

 M src/main/java/io/vertx/core/http/impl/HttpServerFileUploadImpl.java <https://github.com/eclipse-vertx/vert.x/pull/2857/files#diff-0> (3)
 M src/test/java/io/vertx/core/http/HttpTest.java <https://github.com/eclipse-vertx/vert.x/pull/2857/files#diff-1> (5)
 Patch Links:

 https://github.com/eclipse-vertx/vert.x/pull/2857.patch <https://github.com/eclipse-vertx/vert.x/pull/2857.patch>
 https://github.com/eclipse-vertx/vert.x/pull/2857.diff <https://github.com/eclipse-vertx/vert.x/pull/2857.diff>
 
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub <#2857>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AANxijoWxSXioyNK7xFCJk1UWUjUuTEjks5vSOeigaJpZM4bYh8l>.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the server WebSocket handler can decide to accept or reject a WebSocket when it is invoked otherwise it will be accepted when no action has been explicitly taken. Sometimes it is desirable to perform an asynchronous decision (e.g authentication).
This feature provides asynchronous handshake with a setHandshake method accepting a future instance.
server.websocketHandler(websocket -> {
  Future<Integer> fut = Future.future();
  websocket.setHandshake(fut);
  authenticate(websocket, ar -> {
    if (ar.succeeded()) {
      // Terminate the handshake with the status code 101 (Switching Protocol)
      // Reject the handshake with 401 (Unauthorized)
      fut.complete(ar.succeeded() ? 101 : 401);
    } else {
      // Will send a 500 error
      fut.fail(ar.cause());
    }
  });
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP server does not close file descriptors when empty files are streamed to the file system. There is a race happening because the completion check does not pay check that the stream isn't being paused, causing the file opening to happen after the completion leading to the leak.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
right, can you also make a PR for 3.7 branch ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@fishjam I've added your test and fixed it in #2865
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj @jponge there are a lot of files changed (updated imports) but you can review the commits separately
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, it's possible to decode content to a JsonObject or a JsonArray, if you know what the actual content is.
But sometimes you receive JSON without knowing the format beforehand, and it would be handy to have methods to decode to the right target object.
An example use case is a GraphQL request: some clients (Apollo) support request batching and then will send you an array of request instead of a single request object. Only by inspecting the content you can determine if the request is batched request or a regular one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
When doing mvn package it gives this error:
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project myapp: Compilation failure: Compilation failure: 
[ERROR] /home/devrck/Downloads/echo2/target/classes/com/echo2/echo2/services/EchoServiceVertxProxyHandler.java:[61,17] reference to Vertx is ambiguous
[ERROR]   both interface io.vertx.core.Vertx in io.vertx.core and class io.vertx.reactivex.core.Vertx in io.vertx.reactivex.core match
[ERROR] /home/devrck/Downloads/echo2/target/classes/com/echo2/echo2/services/EchoServiceVertxProxyHandler.java:[67,39] reference to Vertx is ambiguous
[ERROR]   both interface io.vertx.core.Vertx in io.vertx.core and class io.vertx.reactivex.core.Vertx in io.vertx.reactivex.core match
[ERROR] /home/devrck/Downloads/echo2/target/classes/com/echo2/echo2/services/EchoServiceVertxProxyHandler.java:[71,39] reference to Vertx is ambiguous
[ERROR]   both interface io.vertx.core.Vertx in io.vertx.core and class io.vertx.reactivex.core.Vertx in io.vertx.reactivex.core match
[ERROR] /home/devrck/Downloads/echo2/target/classes/com/echo2/echo2/services/EchoServiceVertxProxyHandler.java:[75,39] reference to Vertx is ambiguous
[ERROR]   both interface io.vertx.core.Vertx in io.vertx.core and class io.vertx.reactivex.core.Vertx in io.vertx.reactivex.core match
[ERROR] /home/devrck/Downloads/echo2/target/classes/com/echo2/echo2/services/EchoServiceVertxProxyHandler.java:[44,1] a type with the same simple name is already defined by the single-type-import of io.vertx.core.Vertx

Here is my pom.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <groupId>com.echo2</groupId>
  <artifactId>myapp</artifactId>
  <version>0.0.1-SNAPSHOT</version>

  <name>echo2</name>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.target>1.10</maven.compiler.target>
    <maven.compiler.source>1.10</maven.compiler.source>
    <vertx.version>3.7.1</vertx.version>
    <vertx-maven-plugin.version>1.0.18</vertx-maven-plugin.version>
    <vertx.verticle>com.echo2.echo2.MainVerticle</vertx.verticle>
    <slf4j.version>1.7.21</slf4j.version>
    <graal.version>1.0.0-rc14</graal.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-core</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-jdk14</artifactId>
      <version>${slf4j.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-reactive-streams</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-gen</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-java2-gen</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-java2</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-service-factory</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-service-proxy</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-api-contract</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-api-service</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web</artifactId>
      <version>${vertx.version}</version>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-codegen</artifactId>
      <version>${vertx.version}</version>
      <classifier>processor</classifier>
    </dependency>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-client</artifactId>
      <version>${vertx.version}</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>io.reactiverse</groupId>
        <artifactId>vertx-maven-plugin</artifactId>
        <version>${vertx-maven-plugin.version}</version>
        <executions>
          <execution>
            <id>vmp</id>
            <goals>
              <goal>initialize</goal>
              <goal>package</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
package com.echo2.echo2.services;

import com.echo2.echo2.services.impl.EchoServiceImpl;
import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.ext.web.api.OperationRequest;
import io.vertx.ext.web.api.OperationResponse;
import io.vertx.ext.web.api.generator.WebApiServiceGen;
import io.vertx.reactivex.core.Vertx;

@WebApiServiceGen
public interface EchoService {

  static EchoService create(Vertx vertx) {
    return new EchoServiceImpl(vertx);
  }

  void getEcho(
    String name,
    OperationRequest context, Handler<AsyncResult<OperationResponse>> resultHandler);

}
Can you please help with the issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj this fixes the issue without breaking compatibility so it's fine for 3.8
Yet there are a couple of problems with RecordParser:

it's only safe in verticle code (not truly thread safe)
back-pressure is managed with the internal buffer state, whereas it could be simplified with an InboundBuffer

If that's fine with you, I can file an issue for 4.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Summary of the changes:

This code is (to my knowledge) backward compatible
Existing commands can be overriden by a new command with higher priority (default priority: 0)
A new Default-Verticle-Factory flag is read from the MANIFEST.MF which will prefix all main verticles with xyz: IIF the main verticle has no specific factory already in the name.
Converters were refactored to use less reflection
Command factory was refactored to use less reflection

Use cases:
Commands can be overriden as:
@Name("run", priority = 100)
public class MyRunCommand extends RunCommand {
  ...
}
Polyglot verticles can now be declared as:
Default-Verticle-Factory: js
Main-Verticle: index

Doing this will ensure that the main verticle will not be assumed to be a java verticle and will be transformed to: js:index.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to Create an Https server on localhost and i have a client which uses SockJS and connects to the event bus via a url https://localhost:8001/eventbus. I have a self signed certificate and the server.cert and server.key files are in the resources of my project.
Server Code
router.route("/eventbus/*").handler(sockJSHandlerCreator(inboundAddress, outboundAddress));

        router.get("/storeassist").handler(this::storeAssist);

        Buffer crtBuffer = Buffer.buffer();
        Buffer keyBuffer = Buffer.buffer();
        HttpServerOptions httpOpts = new HttpServerOptions();
        try {

            httpOpts.setSsl(true)
                    .setPemKeyCertOptions(new PemKeyCertOptions()
                    .setKeyValue(keyBuffer.appendBytes(IOUtils.toByteArray(getClass()
                            .getClassLoader().getResourceAsStream("server.key"))))
                    .setCertValue(crtBuffer.appendBytes(IOUtils.toByteArray(getClass()
                            .getClassLoader().getResourceAsStream("server.crt")))));
            

            this.getVertx()
                    .createHttpServer(httpOpts)
                    .requestHandler(router::accept)
// Other logic
And i'm using Vertx eventbus js https://github.com/vert-x3/vertx-bus-bower/blob/master/vertx-eventbus.js to connect the server to the client. The client runs on an azure blob url and has a host like https://azcdn.com/my/ap
When i send a message from the vertx module to the client i get the following error
May 28, 2019 11:35:41 PM io.netty.channel.DefaultChannelPipeline onUnhandledInboundException
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLException: Received fatal alert: certificate_unknown
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: javax.net.ssl.SSLException: Received fatal alert: certificate_unknown
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
	at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1666)
	at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1634)
	at sun.security.ssl.SSLEngineImpl.recvAlert(SSLEngineImpl.java:1800)
	at sun.security.ssl.SSLEngineImpl.readRecord(SSLEngineImpl.java:1083)
	at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:907)
	at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
	at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
	at io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:292)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1248)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1159)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1194)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)

Am i doing something wrong,
I am running this on Mac OSX El Capitan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
some method like :

  
    
      vert.x/src/main/java/io/vertx/core/json/JsonArray.java
    
    
        Lines 524 to 527
      in
      d9bfe3e
    
  
  
    

        
          
           @Override 
        

        
          
           public Iterator<Object> iterator() { 
        

        
          
             return new Iter(list.iterator()); 
        

        
          
           } 
        
    
  



  
    
      vert.x/src/main/java/io/vertx/core/json/JsonArray.java
    
    
        Lines 663 to 671
      in
      d9bfe3e
    
  
  
    

        
          
           public Object next() { 
        

        
          
             Object val = listIter.next(); 
        

        
          
             if (val instanceof Map) { 
        

        
          
               val = new JsonObject((Map)val); 
        

        
          
             } else if (val instanceof List) { 
        

        
          
               val = new JsonArray((List)val); 
        

        
          
             } 
        

        
          
             return val; 
        

        
          
           } 
        
    
  


it conver the value to JsonArray if it's a List, conver to JsonObject if it's a map.
but some other method didn't conver.eg:forEach, stream,spliterator. So should we implements these methods
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey,
I have been playing with a simple TCP server, and it seems like exceptions thrown in socket::handler are silently ignored. None of the below exception handlers are passed to InboundBuffer as a result an exception neither being caught or logged:
public class SimpleServer {
	public static void main(String[] args) {
		System.err.println("Application starting...");
		
		final Vertx vertx = Vertx.vertx();
		final FileSystem fs = vertx.fileSystem();

		final NetServer server = vertx.createNetServer();
		server.exceptionHandler(System.err::println);

		server.connectHandler(socket -> {
			socket.exceptionHandler(System.err::println);
			socket.handler($ -> fs.readDirBlocking("/WHERE_IS_MY_EXCEPTION").forEach(System.out::println));
		}).listen(3456);
	}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we need a test, thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello Experts,
I have been trying to implement a scenario where the verticle may be
executing a long running call. For e.g. Opening a socket with external
application (MS Exchange) and retrieving records.

I tried implementing the logic using "executeBlocking" (see below:) and
inside that block I use "*Thread.sleep(long)"* to mimic long running call,
however I see that when I fire two concurrent requests the  second one gets
queued up and completes only after the first one is done.

Example code
----------------------------------------------------------------------------------------------------------
static int a=0;
  @OverRide
  public void start() throws Exception {

    vertx.createHttpServer().requestHandler(request -> {

     vertx.<String>executeBlocking(future -> {
a++;
String result = null;
                try {
 if(a%2==0) {
Thread.sleep(10000);
result = "armadillos!";
  }else {
  Thread.sleep(5000);
  result = "Amol!";
 }
} catch (InterruptedException e) {e.printStackTrace();}
        future.complete(result);
      }, res -> {
        if (res.succeeded()) {
          request.response().putHeader("content-type",
"text/plain").end(res.result());
        } else {
          res.cause().printStackTrace();
        }
      });
    }).listen(8080);
  }
--------------------------------------------------------------------------------------------------------------------

I'm not sure if this  is the right way to implement the required use case,
but would like to hear your thoughts on this.

Thanks,
Umesh
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Close the socket buffer write when reading a socket in the connetionBase class.
Why is this design?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you avoid reformating imports ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
actually we want to go away from Jackson data binding in vertx 4, so we should find another way to do it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We have taken the vert.x hello world application and run that as a standalone application
Git Repo: https://github.com/himanshumps/web-examples.git
Maven Command: mvn clean install exec:java -Dexec.mainClass="io.vertx.example.web.helloworld.Server"
When we run the load test with a single user, we get the following response:

Percentage of the requests served within a certain time (ms)
50%      3
66%      4
75%      4
80%      5
90%      5
95%      7
98%      9
99%     15
100%     65 (longest request)

When the same test is ran with 10 user, we get the following:

Percentage of the requests served within a certain time (ms)
50%     28
66%     33
75%     38
80%     42
90%     59
95%     85
98%    148
99%    235
100%    252 (longest request)

When the same test is ran with 100 users, we get the following:

Percentage of the requests served within a certain time (ms)
50%    455
66%    566
75%    651
80%    682
90%    874
95%   1177
98%   1354
99%   1406
100%   1949 (longest request)

As you can see from the test, as we increase the load on the application, the response time increases exponentially.
Are the request getting queued up ?
When we used LoggerHandler, we can see the response time on the server is 0-3 ms. So where is the additional time going?
The similar results were seen when we ran it in a docker container with 1 core CPU and 4GB of RAM.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes, it appears that some eventloops are blocked while doing some http client relative stuff (Vert.x 3.7.0)
Here is a threaddump:
"vert.x-eventloop-thread-0" #10 prio=5 os_prio=0 tid=0x00007f55410b0000 nid=0x855f waiting for monitor entry [0x00007f54fb771000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at io.vertx.core.http.impl.HttpClientRequestImpl.handleDrained(HttpClientRequestImpl.java:352)
	- waiting to lock <0x00000000c5b865e0> (a io.vertx.core.http.impl.HttpClientRequestImpl)
	at io.vertx.core.http.impl.Http1xClientConnection.handleInterestedOpsChanged(Http1xClientConnection.java:847)
	- locked <0x00000000c541b4b8> (a io.vertx.core.http.impl.Http1xClientConnection)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelWritabilityChanged$3(VertxHandler.java:136)
	at io.vertx.core.net.impl.VertxHandler$$Lambda$757/154866834.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:188)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:180)
	at io.vertx.core.net.impl.VertxHandler.channelWritabilityChanged(VertxHandler.java:136)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:434)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:416)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelWritabilityChanged(AbstractChannelHandlerContext.java:409)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelWritabilityChanged(CombinedChannelDuplexHandler.java:450)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelWritabilityChanged(ChannelInboundHandlerAdapter.java:119)
	at io.netty.channel.CombinedChannelDuplexHandler.channelWritabilityChanged(CombinedChannelDuplexHandler.java:273)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:434)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:416)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelWritabilityChanged(AbstractChannelHandlerContext.java:409)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelWritabilityChanged(DefaultChannelPipeline.java:1457)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:434)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:416)
	at io.netty.channel.DefaultChannelPipeline.fireChannelWritabilityChanged(DefaultChannelPipeline.java:977)
	at io.netty.channel.ChannelOutboundBuffer.fireChannelWritabilityChanged(ChannelOutboundBuffer.java:607)
	at io.netty.channel.ChannelOutboundBuffer.setWritable(ChannelOutboundBuffer.java:573)
	at io.netty.channel.ChannelOutboundBuffer.decrementPendingOutboundBytes(ChannelOutboundBuffer.java:194)
	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:259)
	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:338)
	at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:428)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:934)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:360)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:901)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1396)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.flush(CombinedChannelDuplexHandler.java:533)
	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115)
	at io.netty.channel.CombinedChannelDuplexHandler.flush(CombinedChannelDuplexHandler.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814)
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794)
	at io.vertx.core.net.impl.ConnectionBase.write(ConnectionBase.java:102)
	at io.vertx.core.net.impl.ConnectionBase.lambda$queueForWrite$0(ConnectionBase.java:123)
	- locked <0x00000000c541b4b8> (a io.vertx.core.http.impl.Http1xClientConnection)
	at io.vertx.core.net.impl.ConnectionBase$$Lambda$756/897948790.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$64/397318359.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

"vert.x-eventloop-thread-3" #13 prio=5 os_prio=0 tid=0x00007f55410b6800 nid=0x8562 waiting for monitor entry [0x00007f54fb46d000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at io.vertx.core.http.impl.Http1xClientConnection.handleRequestEnd(Http1xClientConnection.java:659)
	- waiting to lock <0x00000000c541b4b8> (a io.vertx.core.http.impl.Http1xClientConnection)
	at io.vertx.core.http.impl.Http1xClientConnection.access$1100(Http1xClientConnection.java:59)
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.endRequest(Http1xClientConnection.java:411)
	at io.vertx.core.http.impl.HttpClientRequestImpl.write(HttpClientRequestImpl.java:653)
	- locked <0x00000000c5b865e0> (a io.vertx.core.http.impl.HttpClientRequestImpl)
	at io.vertx.core.http.impl.HttpClientRequestImpl.end(HttpClientRequestImpl.java:576)
	at io.vertx.core.streams.impl.PipeImpl.lambda$to$4(PipeImpl.java:105)
	at io.vertx.core.streams.impl.PipeImpl$$Lambda$480/828512551.handle(Unknown Source)
	at io.vertx.core.impl.FutureImpl.setHandler(FutureImpl.java:79)
	at io.vertx.core.streams.impl.PipeImpl.to(PipeImpl.java:89)
	at io.vertx.core.streams.ReadStream.pipeTo(ReadStream.java:130)
	at io.vertx.ext.web.client.impl.HttpContext.handleSendRequest(HttpContext.java:439)
	at io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:266)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:250)
	at io.gravitee.elasticsearch.client.http.HttpClient$1.handle(HttpClient.java:136)
	at io.gravitee.elasticsearch.client.http.HttpClient$1.handle(HttpClient.java:123)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:247)
	at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
	at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:247)
	at io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:257)
	at io.vertx.ext.web.client.impl.HttpContext.sendRequest(HttpContext.java:173)
	at io.vertx.ext.web.client.impl.HttpContext.handlePrepareRequest(HttpContext.java:330)
	at io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:263)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:250)
	at io.gravitee.elasticsearch.client.http.HttpClient$1.handle(HttpClient.java:136)
	at io.gravitee.elasticsearch.client.http.HttpClient$1.handle(HttpClient.java:123)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:247)
	at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
	at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
	at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:247)
	at io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:257)
	at io.vertx.ext.web.client.impl.HttpContext.prepareRequest(HttpContext.java:160)
	at io.vertx.ext.web.client.impl.HttpRequestImpl.send(HttpRequestImpl.java:263)
	at io.vertx.ext.web.client.impl.HttpRequestImpl.sendStream(HttpRequestImpl.java:228)
	at io.vertx.reactivex.ext.web.client.HttpRequest.sendStream(HttpRequest.java:376)
	at io.vertx.reactivex.ext.web.client.HttpRequest.lambda$rxSendStream$3(HttpRequest.java:394)
	at io.vertx.reactivex.ext.web.client.HttpRequest$$Lambda$533/1751013907.accept(Unknown Source)
	at io.vertx.reactivex.impl.AsyncResultSingle.subscribeActual(AsyncResultSingle.java:48)
	at io.reactivex.Single.subscribe(Single.java:3495)
	at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)
	at io.reactivex.Single.subscribe(Single.java:3495)
	at io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)
	at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.run(ContextScheduler.java:184)
	at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction$$Lambda$535/208536531.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$64/397318359.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

I'm trying to provide a simple reproducer but it seems that the deadlock is pretty hard to reproduce.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jponge well spotted, I renamed the lambda parameters to "promise" instead of "future"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is there any plan to upgrade apache curator framework to the latest version. It seems we are using a very old version -
Project = Vert.x ZooKeeper
Curator Version used in project = 2.12.0
Curator current version = 4.2.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When attempting to build vert.x out of the box, I get:
[INFO] --- maven-enforcer-plugin:1.0:enforce (enforce-no-vertx-snapshots) @ vertx-web-parent ---
[WARNING] Rule 0: org.apache.maven.plugins.enforcer.RequireJavaVersion failed with message:
Vert.x must be released with Java 1.8!
[WARNING] Rule 1: org.apache.maven.plugins.enforcer.RequireReleaseDeps failed with message:
No Vert.x Snapshots Allowed during a release!
Found Banned Dependency: io.vertx:vertx-codegen:jar:4.0.0-SNAPSHOT
Found Banned Dependency: io.vertx:vertx-core:jar:4.0.0-SNAPSHOT
Found Banned Dependency: io.vertx:vertx-core:test-jar:tests:4.0.0-SNAPSHOT

The BUILDING.md file says you need JDK 1.8+ (not 1.8 exactly). Also, it does not tell you how to build a snapshot from git master. How do I fix the above issues?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the EventBus overloads the send method to implement one-way messaging and request-response messaging (using a reply handler). Although both methods share a lot they have a different semantic. This will cause an issue in Vert.x 4 asynchronous model based on futures: the future form of request-response pattern will have the same name than the one-way pattern.
We introduce a new method request for the request-response pattern that will always specify a reply handler.
// Before
eventBus.send("addr", payload, reply -> { ... };

// After
eventBus.request("addr", payload, reply -> { ... };
The send methods having a reply handler are deprecated and shall be removed in Vert.x 4.
Likewise, the Message reply methods having an handler are deprecated in favour of replyAndRequest method that will carry on the conversation between the two points:
// Before
eventBus.consumer("addr", msg -> {
  msg.reply(reply, response -> { ... });
});

// After
eventBus.consumer("addr", msg -> {
  msg.replyAndRequest(reply, response -> { ... });
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
When an async spring task is getting executed, vertx/netty threads are blocked.
Reproducer Code: https://github.com/himanshumps/springVertxAsyncIssue.git
To see the issue in action:
Once the application is deployed successfully, add a breakpoint at https://github.com/himanshumps/springVertxAsyncIssue/blob/0aa025a6f97a052545e74c1fff008473235c7d73/src/main/java/io/vertx/example/async/AsyncJob.java#L29 , wait for breakpoint to become active and then try to access https://localhost:8443/
Result: The https://localhost:8443/ will keep on processing and will not complete with status code 200 until we move forward the breakpoint.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm currently developing a framework comparison. Among other things I have vert.x with me. However, I have a problem, which I do not understand, respectively can solve.
If I set the duration of an observable to about 100ms, I get only 8 requests per second with vert.x. I have 145 rps with Helidon or Quarks.
If the response time is not reduced, vert.x also reacts to about 150 rps.
the code can be found here:
https://github.com/auryn31/spring-async-rest-example/tree/master/reactive-backend/reactive-vertx
does anyone have an idea what I'm doing wrong? or is vert.x just slower with such requests?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vertx: 3.7.x
Assuming the following code:
JsonArray a = new JsonArray((List)null);
JsonArray b = a.copy(); // NPE
I am not sure of the correct fix is to allow that, or throw the NPE when calling the constructor. But throwing the NPE in the copy method seems wrong to me.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, Our company wants to use a driver for clickhouse with vertx. And we want to use ODBC driver for it. But vertx doesn't have a support of this driver. We want to develop lib and add such support. What are the requirements to take this library to vertx in future?  And what do you think about this? Maybe we shouldn't do this and use another way.
https://github.com/yandex/clickhouse-odbc
Thank you for help
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In our application, we have used LoggerHandler (https://vertx.io/docs/apidocs/io/vertx/ext/web/handler/LoggerHandler.html) and we see that the time reported by it for the health URL is 0-2 msec. But when we run the test using jmeter, we see that it is taking much longer for end to end processing. We are running the application in docker container with 1 core CPU and 4 GB of RAM.
I am suspecting it is due to handshake taking time as the LoggerHandler is the last in the chain before the response is written out.
How can we move the SSL handshake to a different executor or dedicated eventloop for SSL handshake so that other eventloops doesn't participate in SSL handshake ?
If needed I can share a reproducer with jmeter job.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why is the chunkedwriter made as default when SSL is enabled ?
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java#L401
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 4 will provide a future based asynchronous model while retaining compatibility with Vert.x 3.x callback model. Each callback method will have a corresponding future version, e.g:
client.connect(addr, ar -> ...);

Future<NetSocket> future = client.connect(addr);
This issues records the futurisation of Vert.x Core and the update of the stack. Note that this issue is a subset of the entire effort.
For more details see https://github.com/vert-x3/wiki/wiki/RFC:-Future-API
HttpClient
HttpClient is a special case because it is low level and gives great control over the request/response and most methods cannot use directly the Future<T>.
Most request/response methods have already been updated to use an Handler<AsyncResult<HttpClientResponse>> async type instead of Handler<HttpClientResponse> in Vert.x 3.x.
*Now methods futurization
@Fluent
HttpClient getNow(RequestOptions options, Handler<AsyncResult<HttpClientResponse>> responseHandler);
default Future<HttpClientResponse> getNow(RequestOptions options);

The RxVersion will generate a Single<HttpClientResponse> rxGetNow(RequestOptions options).
Request methods returning an HttpClientRequest
These methods cannot simultaneously return an HttpClientRequest and a Future<HttpClientResponse>. The current choice is to make HttpClientRequest extends Future<HttpClientResponse>. HttpClientRequest already has an handler method allowing to set the handler after the request is created, this method is replaced by Future#setHandler(Handler<AsyncResult<HttpClientResponse>) instead.
For RxJava such methods are not translated to rx pretty much like before because they all return an HttpClientResponse.
Body handler
HttpClientResponse now provides:
HttpClientResponse body(Handler<AsyncResult<Buffer>> handler);
Future<Buffer> body();

In addition of the existing bodyHandler.
In RxJava now it is possible to write:
Single<Buffer> single = client
  .rxGetNow(8080, "localhost", "/the_uri")
  .flatMap(HttpClientResponse::rxBody);

We might provide more *Now methods in HttpClient that would use a ReadStream<Buffer> as argument, e.g void put(int port, String host, String path, ReadStream<Buffer> body, Handler<AsyncResult<HttpClientResponse>> handler)
Same for HttpServerRequest.
WriteStream
The futurization of WriteStream raises a couple of challenges due to the interface fluent design
The write(T) method is fluent and therefore its return type cannot be changed to a Future type without a breaking change, the possible solutions are:

change write(T) return type to Future<T>, in fact the write method behaves as an fire and forget method as it will never report a write error directly (only through the exception handler of the stream)
add a version of write(T) method with that returns a Future<T>, akin to writeWithFuture(T) (find a better name) . That might be odd with existing overload of write such as AsyncFile or HttpServerResponse

In addition there are other current issues with WriteStream<T>

when the stream is not usable anymore it should raise an exception which can be inconvenient for usability purpose (in HttpServerResponse when the stream has been reset by the client).
the pipe feature added in Vert.x 3.7 can perform a callback when the operation completes after the WriteStream has ended but cannot guarantee that the end operation is finished (from the application perspective).

Therefore here is the proposal:
Vert.x 3.x
. Add these in WriteStream
.. @Fluent WriteStream<T> WriteStream#write(T, Handler<AsyncResult<Void>>)
.. @Fluent WriteStream<T> WriteStream#end(T, Handler<AsyncResult<Void>>)
. The method HttpServerResponse#write(Buffer) and HttpServerResponse#end(Buffer) won't anymore throw an IllegalStateException but instead raise it asynchronously in the asynchronous overload
. Add missing methods interfaces extending WriteStream, some already exist, e.g
.. AsyncFile#write(Buffer, long, Handler<AsyncResult<Void>>)
.. NetSocket#write(String, Handler<AsyncResult<Void>)
.. etc...
. Update the pipe operation to use WriteStream#end(Handler<AsyncResult<Void>> to behave correctly
Vert.x 4
Do the same and change the fluent return type to a Future<Void> or void, e.g

WriteStream
** Future<Void> write(T)
** void write(T, Handler<AsyncResult<Void>>)
** Future<Void> end()
** void end(Handler<AsyncResult<Void>>)
AsyncFile
** Future<Void> write(Buffer, long)
** void write(Buffer, long, Handler<AsyncResult<Void>>)
NetSocket
** Future<Void> write(String)
** void write(String, Handler<AsyncResult<Void>>)
** etc...

This will be a breaking change but it seems to be the right trade-off.
FileSystem
No particular issue with this.
AsyncFile
No particular issue with this.
Execute blocking
No particular issue with this
EventBus request-response
EventBus#send(String, Object) and EventBus#send(String, Object, Handler<AsyncResult<Message>>) don't have the same semantic

add a request(String,Object) method acting like send(String,Object,Handler)
add a similar replyAndRequest(Object, Handler) method on Message
send(String,Object,Handler) and reply(Object,Handler) will be kept in 4.0 for compatibility

The request and requestAndReply methods will have a version that returns a Future<Message<T>>.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/2999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
for the new codecs (Byte array, Instant) : register them manually in the registry since they are always here we don't need them to be service loaded
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently JsonObject and JsonArray do not validate the argument of their constructors leading to the creation a invalid objects, e.g new JsonObject("null"), new JsonObject((String)null), new JsonObject("1234").
We should validate this at creation time, in addition we also improve documentation to tell people to use Json#decodeValue method instead of constructor when they are unsure of the json value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While running tests in my projects, I start a Vertx instance BeforeEach and deploy the relevant verticles that i want to test with isolation group and extra-classpath (we use that to create a plugin-like system with isolated classpaths) and close the vertx instance AfterEach.
Some of the tests fetch a plugin (shaded vertx jar with a main-verticle), place it in a folder, and load it dynamically with an isolation group and extra-classpath. After calling vertx.close() I tried to remove the temp jar file but it was used by the jvm and could not be deleted.
After debugging it, I found that the reason it is being held by the JVM is that inside VertxImpl there is DeploymentManager that has Map<String, ClassLoader> classloaders and it does not close the URLClassLoader instances when calling vertx.close().
To test my assumption, i did some ugly reflection work to check it:
suspend fun Vertx.closeAllAwait() {
  this.closeAwait()

  val deploymentManagerField = this::class.java.getDeclaredField("deploymentManager")
  deploymentManagerField.isAccessible = true
  val deploymentManager = deploymentManagerField.get(this) as DeploymentManager

  val classLoadersField = deploymentManager.javaClass.getDeclaredField("classloaders")
  classLoadersField.isAccessible = true
  val classLoaders = classLoadersField.get(deploymentManager) as Map<String, ClassLoader>

  classLoaders
    .forEach {
      try {
        val classLoader: URLClassLoader = it.value as URLClassLoader
        classLoader.close()
      } catch (e: Exception) {
        // ignore!
      }
    }
}
After using my new vertx.closeAllAwait() the jar could be removed as the classloaders created by vertx were closed.
I wonder if it is not closing the classloaders by design and if it is possible to close them when vertx is closing, or maybe add a boolean flag and close them when the user want to.
EDIT: it is a bit inconsistent, sometimes the classloaders list is empty but the JVM still hold the file, but i still wonder if some other resources in vertx are not being released.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using Vert.x for HTTP POST/PUT client requests, some of which receive a 307 redirection response from the server. These requests fail to redirect as described in the RFC and the original POST/PUT payload is not cached for redirection. RFC description of the behaviour is here: https://tools.ietf.org/html/rfc7231#section-6.4.7.
I found the change made to the HttpClientRequestImpl class that specifically removes payload caching, #2305. The change appears to have been based on an outdated RFC and the 307 behaviour is quite different.
I will attempt to create a pull request for a possible fix and submit it. I believe that caching of the original payload body should be optionally defined by the user agent, caching all payloads could place a high resource load.
I have attempted workarounds but at the moment I can't see a possibility of using the Vert.x build in redirectHandler method to proceed with 307 responses. Instead in my current dev project I plan to handle 307 responses manually by optionally caching the payload and making a brand new HTTP request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The MessageProducer interface declares two send methods, such methods should be deprecated. MessageProducer#write(T) should be used instead of MessageProducer#send(T), EventBus#request(String,Object,Handler) should be used instead of MessageProducer#send(T,Handler).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Such methods are deprecated in 3.8 and needs to be removed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
actually this class is only used in vertx-web and should be moved there instead of vertx-core where it's not used at all
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation of MessageProducer.close() calls close(null), which results in a NullPointerException trying to call the handler.
This simple example demonstrates the problem:
Vertx vertx = Vertx.vertx();
MessageProducer<Object> publisher = vertx.eventBus().publisher("endpoint");
publisher.close();
Also, since end() also just calls close(), it also throws a NullPointerException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JVM Fatal Exceptions can be silently ignored in vertx-rx. This results in errors such as OutOfMemoryError to not be logged or output anywhere.
The problem lies in the catch(Throwable ignore) blocks in some rx classes.
I've found them in io.vertx.reactivex.impl.AsyncResultMaybe (e.g. on line 53) and io.vertx.reactivex.impl.AsyncResultCompletable. There may be others too.
The catch blocks in AsyncResultSingle attempt to log the error rather than ignore it. However a better solution for all classes that deal with uncaught exceptions might be to call RxJavaPlugin.onError() as below...
catch( Throwable err ) { RxJavaPlugins.onError(err); }
which would allow users to define their own error handler.
(See for  https://groups.google.com/d/topic/vertx/VxNoP6OuhMA/discussion user group discussion)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The test class at the end of this comment doesn't report the fatal StackOverflowError at all - it just silently swallows it.  If the call to make RxJava use the vertx scheduler is skipped - i.e. line 23 is commented out - then the exception is reported on the console.
The output from the code using vertx schedulers is...
Starting...
vertxHandler(): Entry
Sleeping...
throwFatal(hello)
...Awake
vertxHandler(): Exit
...Done

and using the RxSchedulers (i.e. with L23 commented out) it's...
Starting...
vertxHandler(): Entry
Sleeping...
throwFatal(hello)
Rx error handler invoked
io.reactivex.exceptions.UndeliverableException: java.lang.StackOverflowError: FATAL!!
	at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:349)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:69)
	at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266)
	at java.util.concurrent.FutureTask.run(FutureTask.java)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.StackOverflowError: FATAL!!
	at FatalSwallowed.throwFatal(FatalSwallowed.java:71)
	at FatalSwallowed.lambda$3(FatalSwallowed.java:60)
	at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:57)
	at io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)
	at io.reactivex.Single.subscribe(Single.java:2846)
	at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)
	at io.reactivex.Single.subscribe(Single.java:2846)
	at io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
	... 8 more
...Awake
vertxHandler(): Exit
...Done

The problem appears to be in io.vertx.core.impl.ContextImpl. (Hence raised here and not on the rx repo).
At lines 273-275, in method executeBlocking(Handler<Future<T>>, Handler<AsyncResult<T>>, Executor, TaskQueue, PoolMetrics) there is the following
        } catch (Throwable e) {
            res.tryFail(e);
        } finally {


However, if the Handler<AsyncResult<T>> resultHandler supplied to the method is null, as is the case in the test code below,  then as far as I can tell there is nothing listening to the response of the Future res variable. See lines 283-285...
        if (resultHandler != null) {
          res.setHandler(ar -> runOnContext(v -> resultHandler.handle(ar)));
        }


I think the fix is that the catch block at line 273 should call reportException(e) if resultHandler is null.
        } catch (Throwable e) {
          if ( resultHandler != null ) {
            res.tryFail(e);
          } else {
            reportException(e);
          }
        } finally {


This is the output with the change suggested above.
Starting...
vertxHandler(): Entry
Sleeping...
throwFatal(hello)
...Awake
vertxHandler(): Exit
...Done
Vertx exception handler invoked
java.lang.StackOverflowError: FATAL!!
	at FatalSwallowed.throwFatal(FatalSwallowed.java:71)
	at FatalSwallowed.lambda$3(FatalSwallowed.java:60)
	at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:57)
	at io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)
	at io.reactivex.Single.subscribe(Single.java:2846)
	at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)
	at io.reactivex.Single.subscribe(Single.java:2846)
	at io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)
	at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.run(ContextScheduler.java:184)
	at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.lambda$execute$1(ContextScheduler.java:169)
	at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$2(ContextImpl.java:272)
	at io.vertx.core.impl.TaskQueue.run(TaskQueue.java:76)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)


The test class follows.
import io.reactivex.Single;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;
import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.VertxOptions;
import io.vertx.reactivex.SingleHelper;
import io.vertx.reactivex.core.RxHelper;
import io.vertx.reactivex.core.Vertx;

public class FatalSwallowed {

    private final Vertx vertx;

    public static void main(String[] args) {

        System.out.println("Starting...");

        FatalSwallowed fs = new FatalSwallowed();

        // Comment out to see the exception on the console,
       // leave in to see the exception silently ignored
        fs.useVertxSchedulers();

        fs.vertxHandler();

        System.out.println("...Done");
        fs.close();
    }

    public FatalSwallowed() {

        // Long blocking check to allow for debugging
        vertx = Vertx.vertx(new VertxOptions().setBlockedThreadCheckInterval((1000*60)*60));

        vertx.exceptionHandler(t -> {
            System.out.println("Vertx exception handler invoked");
            t.printStackTrace();
        });

        RxJavaPlugins.setErrorHandler( t -> {
            System.out.println("Rx error handler invoked");
            t.printStackTrace();
        });

    }

    private void close() {
        vertx.close();
    }

    private void useVertxSchedulers() {
        RxJavaPlugins.setIoSchedulerHandler(s -> RxHelper.blockingScheduler(vertx));
    }


    private void vertxHandler() {

        System.out.println("vertxHandler(): Entry");
        Handler<AsyncResult<String>> h = getHandler();

        Single.just("hello")
                .map( s -> throwFatal(s) )
                .subscribeOn(Schedulers.io())
                .subscribe(SingleHelper.toObserver(h));

        sleep();
        System.out.println("vertxHandler(): Exit");

    }

    private String throwFatal(String s) {
        System.out.println("throwFatal(" + s + ")");
        throw new StackOverflowError("FATAL!!");
    }

    private void sleep() {

        System.out.println("Sleeping...");

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            System.out.println("Interrupted");
            e.printStackTrace();
        }

        System.out.println("...Awake");
    }

    public Handler<AsyncResult<String>> getHandler() {

        return new Handler<AsyncResult<String>>() {
            @Override
            public void handle(AsyncResult<String> event) {
                System.out.println("failed=" + event.failed());
                System.out.println("cause=" + event.cause());
                System.out.println("result=" + event.result());
            }

        };
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I try to run this test several times.
@RunWith(VertxUnitRunner.class)
public class Khmmm extends VertxTestBase {

    @Test
    public void sometimesFails(TestContext tc) {
        Async async = tc.async(2);

        vertx.executeBlocking(fut -> {

            vertx.setTimer(10, l -> {
                System.out.println("timer1");
                async.countDown();
            });

            vertx.setTimer(10, l -> {
                System.out.println("timer2");
                async.countDown();
            });

            fut.complete();
        }, tc.asyncAssertSuccess());

        async.await(1000);
    }
}
Somethimes (but not every case) the very first (and only very first) execution fails:
Starting test: Khmmm#sometimesFails 
timer2

java.util.concurrent.TimeoutException: Timed out

	at io.vertx.ext.unit.impl.CompletionImpl.await(CompletionImpl.java:73)
	at ru.finam.vertx.sql.Khmmm.sometimesFails(Khmmm.java:29)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at io.vertx.ext.unit.junit.VertxUnitRunner.invokeTestMethod(VertxUnitRunner.java:95)
	at io.vertx.ext.unit.junit.VertxUnitRunner.lambda$invokeExplosively$0(VertxUnitRunner.java:114)
	at io.vertx.ext.unit.impl.TestContextImpl.run(TestContextImpl.java:90)
  ....

Starting test: Khmmm#sometimesFails 
timer1
timer2
Starting test: Khmmm#sometimesFails 
timer1
timer2

It havens when I do this in verticle context or in test context.
It never happens if setTimer() executes from eventloop.
Vertx version=3.7.1
What am I doing wrong?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes it can be useful to attach an object to an HttpServerRequest that has the same lifecycle than the request without having the specific need to maintain a Map<HttpServerRequest, Object> for such tracking. We should add an internal get/set (HttpServerRequestInternal) for this case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I work on a constraint device and start a webserver seems quite long.
I check some value and :

Starting vert.x (version 3.7.1) takes and execute a task on context take 6 seconds.
Starting vert.x & deploy a verticle which deploy a Http server take 13 seconds.

The webserver is deployed with :
@Override
    public void start() {
      vertx.createHttpServer().requestHandler(ignored ->{}).listen(8081,ar -> {
        System.out.println("Hello from vert.x after " + (System.currentTimeMillis()- start));
      });
    }

I got some stack trace that seems to indicate that event loop block at some point but they are not the same from one launch to another :
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2191 ms, time limit is 2000 ms
Jul 01, 2019 4:45:13 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 3190 ms, time limit is 2000 ms
Jul 01, 2019 4:45:14 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 4348 ms, time limit is 2000 ms
Jul 01, 2019 4:45:15 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5348 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at io.netty.resolver.dns.DnsNameResolver.<clinit>(DnsNameResolver.java:131)
	at io.netty.resolver.dns.DnsNameResolverBuilder.<init>(DnsNameResolverBuilder.java:49)
	at io.netty.resolver.dns.DnsAddressResolverGroup.<init>(DnsAddressResolverGroup.java:64)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1$1.<init>(DnsResolverProvider.java:137)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1.newResolver(DnsResolverProvider.java:137)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.AddressResolver.resolveHostname(AddressResolver.java:82)
	at io.vertx.core.impl.VertxImpl.resolveAddress(VertxImpl.java:803)
	at io.vertx.core.net.impl.AsyncResolveConnectHelper.doBind(AsyncResolveConnectHelper.java:82)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:304)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:190)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:186)
	at com.se.gxl.forum.deployment.TestMain$DeployerVerticle.start(TestMain.java:71)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.java:552)
	at io.vertx.core.impl.DeploymentManager$$Lambda$8/8582895.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$9/16818525.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Jul 01, 2019 4:45:16 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 6349 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.util.zip.Inflater.inflateBytes(Native Method)
	at java.util.zip.Inflater.inflate(Inflater.java:259)
	at java.util.zip.InflaterInputStream.read(InflaterInputStream.java:152)
	at sun.misc.Resource.getBytes(Resource.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:463)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at io.netty.buffer.ByteBufAllocator.<clinit>(ByteBufAllocator.java:24)
	at io.netty.channel.DefaultChannelConfig.<init>(DefaultChannelConfig.java:58)
	at io.netty.channel.socket.DefaultDatagramChannelConfig.<init>(DefaultDatagramChannelConfig.java:54)
	at io.netty.channel.socket.nio.NioDatagramChannelConfig.<init>(NioDatagramChannelConfig.java:117)
	at io.netty.channel.socket.nio.NioDatagramChannel.<init>(NioDatagramChannel.java:149)
	at io.netty.channel.socket.nio.NioDatagramChannel.<init>(NioDatagramChannel.java:116)
	at io.vertx.core.net.impl.transport.Transport.datagramChannel(Transport.java:150)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1.lambda$newResolver$0(DnsResolverProvider.java:136)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1$$Lambda$15/26381689.newChannel(Unknown Source)
	at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)
	at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:234)
	at io.netty.resolver.dns.DnsNameResolver.<init>(DnsNameResolver.java:395)
	at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:430)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1$1.newNameResolver(DnsResolverProvider.java:183)
	at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:94)
	at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:79)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1.newResolver(DnsResolverProvider.java:187)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.AddressResolver.resolveHostname(AddressResolver.java:82)
	at io.vertx.core.impl.VertxImpl.resolveAddress(VertxImpl.java:803)
	at io.vertx.core.net.impl.AsyncResolveConnectHelper.doBind(AsyncResolveConnectHelper.java:82)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:304)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:190)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:186)
	at com.se.gxl.forum.deployment.TestMain$DeployerVerticle.start(TestMain.java:71)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.java:552)
	at io.vertx.core.impl.DeploymentManager$$Lambda$8/8582895.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$9/16818525.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Hello from vert.x after 13043

another :
Jul 01, 2019 4:42:30 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2187 ms, time limit is 2000 ms
Jul 01, 2019 4:42:31 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 3187 ms, time limit is 2000 ms
Jul 01, 2019 4:42:32 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 4277 ms, time limit is 2000 ms
Jul 01, 2019 4:42:33 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5277 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at io.netty.handler.codec.dns.DnsRecordDecoder.<clinit>(DnsRecordDecoder.java:29)
	at io.netty.handler.codec.dns.DatagramDnsResponseDecoder.<init>(DatagramDnsResponseDecoder.java:43)
	at io.netty.resolver.dns.DnsNameResolver.<clinit>(DnsNameResolver.java:160)
	at io.netty.resolver.dns.DnsNameResolverBuilder.<init>(DnsNameResolverBuilder.java:49)
	at io.netty.resolver.dns.DnsAddressResolverGroup.<init>(DnsAddressResolverGroup.java:64)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1$1.<init>(DnsResolverProvider.java:137)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1.newResolver(DnsResolverProvider.java:137)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.AddressResolver.resolveHostname(AddressResolver.java:82)
	at io.vertx.core.impl.VertxImpl.resolveAddress(VertxImpl.java:803)
	at io.vertx.core.net.impl.AsyncResolveConnectHelper.doBind(AsyncResolveConnectHelper.java:82)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:304)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:190)
	at com.se.gxl.forum.deployment.TestMain$DeployerVerticle.start(TestMain.java:71)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.java:552)
	at io.vertx.core.impl.DeploymentManager$$Lambda$8/8582895.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$9/16818525.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Jul 01, 2019 4:42:34 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 6277 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.lang.reflect.Proxy.<clinit>(Proxy.java:240)
	at sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:305)
	at sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:303)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:303)
	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:293)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at sun.reflect.annotation.AnnotationParser.parseSelectAnnotations(AnnotationParser.java:101)
	at sun.reflect.annotation.AnnotationType.<init>(AnnotationType.java:145)
	at sun.reflect.annotation.AnnotationType.getInstance(AnnotationType.java:85)
	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:266)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)
	at java.lang.Class.createAnnotationData(Class.java:3521)
	at java.lang.Class.annotationData(Class.java:3510)
	at java.lang.Class.createAnnotationData(Class.java:3526)
	at java.lang.Class.annotationData(Class.java:3510)
	at java.lang.Class.getAnnotation(Class.java:3415)
	at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258)
	at java.lang.Class.isAnnotationPresent(Class.java:3425)
	at io.netty.channel.ChannelHandlerAdapter.isSharable(ChannelHandlerAdapter.java:57)
	at io.netty.channel.DefaultChannelPipeline.checkMultiplicity(DefaultChannelPipeline.java:599)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:202)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:385)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:372)
	at io.netty.bootstrap.Bootstrap.init(Bootstrap.java:265)
	at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:321)
	at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:234)
	at io.netty.resolver.dns.DnsNameResolver.<init>(DnsNameResolver.java:395)
	at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:430)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1$1.newNameResolver(DnsResolverProvider.java:183)
	at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:94)
	at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:79)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.resolver.DnsResolverProvider$1.newResolver(DnsResolverProvider.java:187)
	at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
	at io.vertx.core.impl.AddressResolver.resolveHostname(AddressResolver.java:82)
	at io.vertx.core.impl.VertxImpl.resolveAddress(VertxImpl.java:803)
	at io.vertx.core.net.impl.AsyncResolveConnectHelper.doBind(AsyncResolveConnectHelper.java:82)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:304)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:190)
	at com.se.gxl.forum.deployment.TestMain$DeployerVerticle.start(TestMain.java:71)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$8(DeploymentManager.java:552)
	at io.vertx.core.impl.DeploymentManager$$Lambda$8/8582895.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$9/16818525.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Hello from vert.x after 12938


Does this value seems reasonnable or something is realy blocking the event loop ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.vertx.core.json.Json#mapper and io.vertx.core.json.Json#prettyMapper are public and static.
In the runtime environment any code that has access to the Json class can manipulate the mapper globally.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A bunch of improvements aiming at simplifying the code and remove existing potential deadlocks when client is used elsewhere than the event loop

move the 100 continue handling in the stream management instead of HttpClientRequest implementation
request timeout is now fully handled by resetting the request
resetting a request will always call the request / response exception handlers
remove usage of end sentinel in HTTP 1 streams and instead use the trailers map
stream reset now takes an exception as argument instead of a code
stream reset exception does not anymore capture the stack trace
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
val exception = Exception()
val future = Future.failedFuture(exception)
try{
    future.result()
}catch(e: Exception){
    assertEquals(exception, e)
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Running  the demo server with run/start works - that is, the server displays text in the browser.
With start, executing vertx list results with;
Listing vert.x applications...
e586a4f4-9bd4-4535-9d1f-a0adec1ceb25	my.jsc.vertx.Server

With run, executing vertx list results with;
Listing vert.x applications...
No vert.x application found.

With run and redeploy ;
Starting vert.x application...
3c34e176-2b83-4ff0-8849-09c6a15fd7fa-redeploy

executing vertx list results with;
Listing vert.x applications...
No vert.x application found.

And the browser gets a Unable to connect.
executing ps -ef |grep vertx gets the following;
31784 31730  0 17:02 pts/3    00:00:02 /usr/java/latest/bin/java -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 -Djava.util.logging.config.file=/home/daveo/work/vertx3/conf/logging.properties -Dvertx.home=/home/daveo/work/vertx3 -Dvertx.cli.usage.prefix=vertx -Dvertx.clusterManagerFactory=io.vertx.spi.cluster.impl.hazelcast.HazelcastClusterManagerFactory -classpath /usr/lib64/python3.6/site-packages/jep/jep-3.7.0.jar:/home/daveo/work/vertx3/conf:/home/daveo/work/vertx3/lib/* io.vertx.core.Launcher run my.jsc.vertx.Server -cp /usr/lib64/python3.6/site-packages/jep/jep-3.7.0.jar:.:/home/daveo/installs/jin-0.1.0/classes../lib/vertx-core-3.8.3.jar:/home/daveo/installs/jin-0.1.0/classes:/home/daveo/installs/jin-0.1.0/classes../lib/jin/jin.jar --redeploy /home/daveo/installs/jin-0.1.0/classes/my/jsc/vertx/Server.class --launcher-class=io.vertx.core.Launcher

While the redeploy is executing, changing code results with;
Stopping vert.x application '3c34e176-2b83-4ff0-8849-09c6a15fd7fa-redeploy'
Cannot find process for application using the id '3c34e176-2b83-4ff0-8849-09c6a15fd7fa-redeploy'.
Starting vert.x application...
3c34e176-2b83-4ff0-8849-09c6a15fd7fa-redeploy

And the browser still gets a Unable to connect.
The Server code;
package my.jsc.vertx;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class Server extends AbstractVerticle {

  @Override
    // public void start(Future<Void> fut) {
    public void start(Promise<Void> fut) {
    
    vertx
        .createHttpServer()
        .requestHandler(r -> {
          r.response().end("<h1>Hello from my first " +
              "Vert.x 3 application</h1>");
        })
        .listen(8083, result -> {
          if (result.succeeded()) {
            fut.complete();
          } else {
            fut.fail(result.cause());
          }
        });
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I debug a vertx project created by Vert.x Starter, execution will not pause at any breakpoint.
Any one can help me? Thanks very much.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I created a vert.x project using https://start.vertx.io/ . I  tried  build project using ./mvnw clean package command .   get an exception .
Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1:test (default-test) on project starter: There are test failures.
I changed  surefire plugin version and it worked . vert.x project default version hava a problem . 2.19.1 working perfectly
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the bug
Error on  build a vert.x  (v3.8.3) native image with graalvm.
Log
Build on Server(pid: 1970, port: 28040) [httpvertx2:1970]    classlist:   1,499.06 ms [httpvertx2:1970]        (cap):     567.00 ms [httpvertx2:1970]        setup:     826.96 ms [httpvertx2:1970]     analysis:  11,292.09 ms Warning: Aborting stand-alone image build. Unsupported features in 6 methods Detailed message: Error: No instances of io.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf are allowed in the image heap as this class should be initialized at image runtime. To see how this object got instantiated use -H:+TraceClassInitialization. Trace:  object io.netty.buffer.UnreleasableByteBuf object io.vertx.core.buffer.impl.BufferImpl method io.vertx.core.eventbus.impl.clustered.ClusteredEventBus.access$300() Call path from entry point to io.vertx.core.eventbus.impl.clustered.ClusteredEventBus.access$300(): at io.vertx.core.eventbus.impl.clustered.ClusteredEventBus.access$300(ClusteredEventBus.java:48) at io.vertx.core.eventbus.impl.clustered.ClusteredEventBus$1.handle(ClusteredEventBus.java:321) at io.vertx.core.eventbus.impl.clustered.ClusteredEventBus$1.handle(ClusteredEventBus.java:304) at io.vertx.core.impl.launcher.commands.RunCommand.stopBackgroundApplication(RunCommand.java:333) at io.vertx.core.impl.launcher.commands.RunCommand$$Lambda$3584/881120997.handle(Unknown Source) at io.vertx.core.impl.launcher.commands.Watcher.close(Watcher.java:282) at io.vertx.core.impl.launcher.commands.Watcher.run(Watcher.java:300) at java.lang.Thread.run(Thread.java:748) at com.oracle.svm.core.thread.JavaThreads.threadStartRoutine(JavaThreads.java:460) at com.oracle.svm.core.posix.thread.PosixJavaThreads.pthreadStartRoutine(PosixJavaThreads.java:193) at com.oracle.svm.core.code.IsolateEnterStub.PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(generated:0) 
Environment:

GraalVM version  : graalvm-ce-19.2.0.1
Vert.x version : 3.8.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Vert.x 3, promise/future are not associated to Vert.x concurrency model.
Callback is performed when both the promise is resolved and the handler is set, consequently the callback thread cannot be predicted when the promise/future is used outside Vert.x event-loop, e.g when the callback handler is set on a resolved future by a non event-loop thread, this handler is called on the current thread.
Handler failure are also propagated to the thread resolving the promise or setting the callback handler.
This feature gives the opportunity to create a promise/future associated with a Vert.x context to provide the alleviate these issues.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When the API returns a future, it should return a context future instead of a context-less one. Such futures provides a better support for concurrency.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Similar questions like 
https://github.com/quarkusio/quarkus/issues/4891
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cluster manager updates will be done as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've created a set of new commands extending BareCommand.
In my launcher class, that is extending io.vertx.core.Launcher, I've overrode the getMainVerticle()  since all commands should deploy this root verticle. But this information are not being passed thru the command instances.
Seems that the problem occurs because io.vertx.core.impl.launcher.VertxCommandLauncher.dispatch(Object, String[]) is calling the command (line 382) before the mainVerticle be evaluated (line 395).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Given a scenario, I want to make some legacy synchronous API calls. In this example, I will simply call Thread.sleep() to represent that.
In order not to block the event-loop, I will need to use rxExecuteBlocking api provided by vertx
vertx.rxExecuteBlocking( future -> {
    try {
        Thread.sleep(3000);
        future.complete("ExampleResult");
    } catch (Exception e) {
        future.fail(e);
    }
}) 
... chain to other rxjava operation

In our project, where we exclusively code with RxJava
Ideally, we would prefer
vertx.rxExecuteBlocking( () -> {
    Thread.sleep(3000);
    return "ExampleResult";
})

or perhaps, chain it as method reference
private String synchronousCall() throws Exception{
    Thread.sleep(3000);
    return "ExampleResult";
}
...
vertx.rxExecuteBlocking(this::synchronousCall);

In order to achieve this, we wrapped the rxExecuteBlocking with our own spin, replacing Handler<Promise<T>> with Callable (and also overload it with Runnable that so that it can return void)
public Maybe<Object> rxExecuteBlocking(Callable caller){
    return vertx.rxExecuteBlocking( objectFuture -> {
        try {
            objectFuture.complete(caller.call());
        } catch (Throwable e) {
            objectFuture.fail(e);
        }
    });
}

I think it would make these rx APIs slightly more align with the Reactive programming paradigm. But that's just my two cents. It's not a deal-breaker.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
{a:null}.equals({b:1}) 
returns true instead of false.
solution:
if (!fieldNames().equals(m2.fieldName()))
   return false;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this is easy to add and is available in most json libs
PS: and for JsonArray.set(int index, Object value)
methods add and set have the same semantics as in java's List
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vert.x/src/main/java/io/vertx/core/shareddata/AsyncMap.java
    
    
         Line 90
      in
      07fe826
    
  
  
    

        
          
           put(k, v, ttl); 
        
    
  


Should change to
put(k, v, ttl, promise);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, the Future type has a single handler value making it not suitable when a future needs to have multiple listeners unless the developers handles it manually.
We need to support multiple listeners per future.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the Future type allows to set a callback using the setHandler(...) method. We should improve the API naming and provide finer grained callbacks.

onComplete(...)
onSuccess(...)
onFailure(...)

setHandler(...) will likely be deprecated or at least discouraged to use.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MetricsTest#testDatagram1 and/or MetricsTest#testDatagram2 fail intermittently in at least one out of five runs:
MetricsTest.lambda$testDatagram$95:830->AsyncTestBase.assertEquals:241 expected:<1> but was:<0>
Example: https://travis-ci.org/eclipse-vertx/vert.x/jobs/607323914#L14311
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I review vert.x code, i have a question why vert.x implements Buffer with netty Unpooled instead of PooledByteBuf? If request body is too big, this can cause high gc frequency?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting that vert.x 3 official doc doesn't have any documentation for Python.
We are trying to use our Python projects into Vert.x system.
Python system are Machine Learning based projects.
Can anyone help us, how can we use Python ML projects using Vert.x 3.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As reported here quarkusio/quarkus#5247, the stacktrace shows that constructing a io.vertx.core.net.impl.SocketAddressImpl leads to a NullPointerException if the passed InetSocketAddress is "unresolved".
This is due to the code in SocketAddressImpl which looks like:
this(address.getPort(), address.getAddress().getHostAddress());

The address.getAddress() can return null (as stated in its javadoc) if the address is unresolved. I think a better/safer way to instantiate this would be to:
this(address.getPort(), address.getAddress() == null ? address.getHostString() : address.getAddress().getHostAddress());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I can create another PR for master of course.
My implementation that works much better in Quarkus for REST calls handling is based on JCTools and I did not want to add a dependency to those; therefore I'll add that dependency rather to the Quarkus extension.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Below is my setPeriodic code
        vertx.setPeriodic(300000, handler -> vc.myClass().myHandler());

I am running in Vertx 3.5.3 in Kubernetes. There is a logger inside myHandler but the log does not get printed every 5 minutes (time is in milliseconds). The pod is serving request properly throughout the day but the log line in myHandler does not get printed every 5 minutes. Logs gets printed for 1 hour and then stops for sometime. The behaviour is random.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In VertxImpl, a 'Executors.newFixedThreadPool' is created for the worker thread pool ;
    ExecutorService workerExec = Executors.newFixedThreadPool(options.getWorkerPoolSize(),
        new VertxThreadFactory("vert.x-worker-thread-", checker, true, options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit()));

Executors.newFixedThreadPool() allocates a LinkedBlockingQueue for the workQueue;
    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }

LinkedBlockingQueue shows up as a scalability bottleneck when heavily contended in systems where there are many cores (32 in our test case), the tasks delegated to the worker pool are fast and do not make blocking calls. We were unable to saturate 32 CPU cores with current implmentation.
Swapping the implementation to a data structure that scales better with high contention, we observed max throughput increase from 182k req/sec to 290k req/sec, and CPU cores became saturated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently ConnectionBase localAddress() and remoteAddress() are computed on each call. We should cache the allocated objects as it might be called multiple times for the same connection when using HTTP/1.1 keep-alive or HTTP/2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you write a test for this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have used vertx Sync + Quasar and that is an awesome mix. but there are cases that implementing with quasar is hard obviously its java agent and transformation.
I think this can be a good feature to implement it with a simpler case like ea-async or other library for the same job.
I dont know is Vertx.Sync possible support to make a native image with GraalVM also or not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Previously, using Socket.IO in Node.js was a very convenient way to implement a chat room, but now I want to use Vert.x, and I don't know how to integrate Socket.IO into Vert.x, to see a project netty-socketio. Can you integrate it into Vert.x?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to integrate some libraries into Vert.x, such as netty-socket.io,. I don't see in the documentation how to wrap a library as a mod, for Vert.x. Where should I start?
Sent from PPHub
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the eclipse agreement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the Closeable interface defines a close(Handler<AsyncResult<Void>>) to call when the call when close is completed. It would be better to use instead Promise<Void> instead of an Handler to signal the close operation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can we get the JMH benchmark as well in the PR ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Have an application that executes a ton of outbound requests to various endpoints in a number of different ways. With vertx 3.7.1 I have no issues. After upgrading to 3.8.3 I started getting NPEs in the Http1xClientConnection class. I see the stacktrace in a couple different ways but they all end up in Http1xClientConnection.java:187. It doesnt happen very often but at 100k->200k requests a second across many boxes those add up quick. I havent been able to trace it down to any certain endpoint or particular post/get secure/non-secure scenario. Of course I have already made all the Promise/Future changes so its not an easy revert.
Stacktrace #1
atio.vertx.core.http.impl.Http1xClientConnection$StreamImpl.access$1800(Http1xClientConnection.java:187)
atio.vertx.core.http.impl.Http1xClientConnection.handleResponseEnd(Http1xClientConnection.java:624)
atio.vertx.core.http.impl.Http1xClientConnection.handleHttpMessage(Http1xClientConnection.java:580)
atio.vertx.core.http.impl.Http1xClientConnection.handleMessage(Http1xClientConnection.java:562)
atio.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:369)
atio.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
atio.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:232)
atio.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:173)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
atio.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
atio.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438)
atio.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:328)
atio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:302)
atio.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
atio.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:287)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
atio.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475)
atio.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224)
atio.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271)
atio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)
atio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444)
atio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
atio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
atio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
atio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931)
atio.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
atio.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:700)
atio.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635)
atio.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552)
atio.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514)
atio.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044)
atio.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
atio.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
atjava.lang.Thread.run(Thread.java:834)

Stacktrace #2
at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.access$1500 (Http1xClientConnection.java:187)
at io.vertx.core.http.impl.Http1xClientConnection.handleResponseBegin (Http1xClientConnection.java:601)
at io.vertx.core.http.impl.Http1xClientConnection.handleHttpMessage (Http1xClientConnection.java:572)
at io.vertx.core.http.impl.Http1xClientConnection.handleMessage (Http1xClientConnection.java:562)
at io.vertx.core.impl.ContextImpl.executeTask (ContextImpl.java:369)
at io.vertx.core.impl.EventLoopContext.execute (EventLoopContext.java:43)
at io.vertx.core.impl.ContextImpl.executeFromIO (ContextImpl.java:232)
at io.vertx.core.net.impl.VertxHandler.channelRead (VertxHandler.java:173)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead (AbstractChannelHandlerContext.java:352)
at io.netty.handler.codec.MessageToMessageDecoder.channelRead (MessageToMessageDecoder.java:102)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead (AbstractChannelHandlerContext.java:352)
at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead (CombinedChannelDuplexHandler.java:438)
at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead (ByteToMessageDecoder.java:328)
at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead (ByteToMessageDecoder.java:315)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode (ByteToMessageDecoder.java:429)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead (ByteToMessageDecoder.java:283)
at io.netty.channel.CombinedChannelDuplexHandler.channelRead (CombinedChannelDuplexHandler.java:253)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead (AbstractChannelHandlerContext.java:352)
at io.netty.handler.timeout.IdleStateHandler.channelRead (IdleStateHandler.java:287)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead (AbstractChannelHandlerContext.java:352)
at io.netty.handler.ssl.SslHandler.unwrap (SslHandler.java:1475)
at io.netty.handler.ssl.SslHandler.decodeJdkCompatible (SslHandler.java:1224)
at io.netty.handler.ssl.SslHandler.decode (SslHandler.java:1271)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection (ByteToMessageDecoder.java:505)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode (ByteToMessageDecoder.java:444)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead (ByteToMessageDecoder.java:283)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead (AbstractChannelHandlerContext.java:352)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead (DefaultChannelPipeline.java:1422)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead (AbstractChannelHandlerContext.java:360)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead (DefaultChannelPipeline.java:931)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read (AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey (NioEventLoop.java:700)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized (NioEventLoop.java:635)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys (NioEventLoop.java:552)
at io.netty.channel.nio.NioEventLoop.run (NioEventLoop.java:514)
at io.netty.util.concurrent.SingleThreadEventExecutor$6.run (SingleThreadEventExecutor.java:1044)
at io.netty.util.internal.ThreadExecutorMap$2.run (ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run (FastThreadLocalRunnable.java:30)
at java.lang.Thread.run (Thread.java:834)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the VerticleFactory provides a synchronous contract for instantiating a Verticle. We are changing this contract to become asynchronous and provide instead a Callable<Verticle> instead of a single Verticle, allowing the deployment phase to call this method once and later on invoke the returned callable many times for creating instances.
The blockingCreate() setting that instruct the deployer to execute the factory creation within executeBlocking is not necessary anymore as the VerticleFactory can itself perform the executeBlocking execution when it needs it.
// Before
Verticle createVerticle(String verticleName, ClassLoader classLoader) throws Exception;

// Now
void createVerticle(String verticleName, ClassLoader classLoader, Promise<Callable<Verticle>> promise);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently when sending the request the HTTP/1 stream will update the connection state without synchronisation which can lead to race conditions. We should synchronise properly so the other parts reading the state will see the correct state.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you avoid un-necessary code reformatting to make the review easier to read ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In many parts of vertx (vertx-sql-client) a context equality check (context == Vertx.currentContext) is done in order to know if we are running in the same event loop else runOnContext
With the introduction of context duplicate this equality check is not functioning correctly
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vert.x/src/main/java/io/vertx/core/file/FileSystem.java
    
    
         Line 418
      in
      6b13bdc
    
  
  
    

        
          
           FileSystem deleteRecursive(String path, boolean recursive, Handler<AsyncResult<Void>> handler); 
        
    
  


Since we are changing the API i am not sure if it should be considered a breaking change
Do you want me to make a PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
indeed this is a breaking change can you modify the PR so that it adds new methods without recursive without removing existing ones ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Following discussion on netty: netty/netty#8530
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently a HTTP/1 stream keeps a reference to the next stream for pipelining. This reference field is used for tracking the list of request in progress and the list of response in progress. For a given request, this next field is currently cleared when it is sent and promoted to be the next response in progress (directly or as a next reference of the current response in progress). This field is cleared when the stream request headers are sent so it can be used for tracking the response in progress. In some cases the field should not be cleared:
  @Test
  public void testPipeliningBug() throws Exception {
    waitFor(3);
    server.requestHandler(req -> {
      req.response().end();
    });
    startServer(testAddress);
    client.close();
    client = vertx.createHttpClient(createBaseClientOptions().setPipelining(true).setMaxPoolSize(1).setKeepAlive(true));
    HttpClientRequest req1 = client.request(HttpMethod.GET, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/", resp -> {
      complete();
    }).sendHead();
    client.request(HttpMethod.GET, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/", resp -> {
      complete();
    }).end();
    client.request(HttpMethod.GET, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/", resp -> {
      complete();
    }).end();
    // Need to wait a little so requests 2 and 3 are appended to the first request
    Thread.sleep(300);
    req1.end();
    await();
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A HTTP/1 client connection maintains two queue of stream request in progress and stream response in progress using the same field. Sometimes this field can be updated twice leading to race issues. We should instead use a single queue of all streams created by the connection. The queue is pushed when a new stream is created and popped when the stream response ends.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JsonPointer pointer = JsonPointer.from("/hello/world/some");
    String s = "{\n" +
            "  \"hello\": {\n" +
            "    \"world\": \"text\"\n" +
            "  },\n" +
            "  \"other\": \"other text\"\n" +
            "}";

    JsonObject jsonObject = new JsonObject(s);
    pointer.writeJson(jsonObject, new JsonObject().put("b", 2), true);
    System.out.println(jsonObject.encode());

result is : {"hello":{"world":"text"},"other":"other text"}
Then 'pointer' change : JsonPointer.from("/hello/world1/some");
result is : {"hello":{"world":"text","world1":{"some":{"b":2}}},"other":"other text"}
Is this correct?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Same applies to shared data.
If a factory would attempt to store any data (think a Singleton as an example) it would NPE too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClientResponse#netSocket has some design flaws (it is synchronous and does not report errors). It works correctly in Vert.x 3.x at the expense of a few work around but should not be left as it is.
Instead, the requester should provide a socket handler on the request that will be called when the correct response is received.
// Before
client.request(HttpMethod.CONNECT, uri, ar -> {
  if (ar.succeeded()) {
    HttpClientResponse response = ar.result();
    if (response.statusCode() == 200) {
      NetSocket so = response.netSocket();
   }
  }
}).end();

// In 4.0
client.request(HttpMethod.CONNECT, uri, ar -> {
}).netSocket(ar -> {
  if (ar.succeeded()) {
   // Got a response with a 200 status code
   NetSocket so = ar.result();
   // Go for tunneling
  }  
}).end();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Folks,
As vert.x platform growing adding to external services are needed.
This is very interested feature to add RSocket to vert.x to use great potentials of it in microservices architecture
Do you have any plan for protocols this ?
Thank You.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.vertx.core.eventbus.impl.clustered.ClusteredEventBus
SEVERE: Failed to remove sub
com.hazelcast.core.HazelcastInstanceNotActiveException: Hazelcast instance is not active!
	at com.hazelcast.spi.AbstractDistributedObject.throwNotActiveException(AbstractDistributedObject.java:105)
	at com.hazelcast.spi.AbstractDistributedObject.lifecycleCheck(AbstractDistributedObject.java:100)
	at com.hazelcast.spi.AbstractDistributedObject.getNodeEngine(AbstractDistributedObject.java:94)
	at com.hazelcast.multimap.impl.ObjectMultiMapProxy.remove(ObjectMultiMapProxy.java:128)
	at io.vertx.spi.cluster.hazelcast.impl.HazelcastAsyncMultiMap.lambda$remove$8(HazelcastAsyncMultiMap.java:169)
	at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$2(ContextImpl.java:316)
	at io.vertx.core.impl.TaskQueue.run(TaskQueue.java:76)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)

It seems that the reason is that EventBusImpl#unregisterAll calls HandlerRegistration#unregister with null doneHandler. This leads to the cluster leaving before the EventBus is shutted down.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP client does callback on the HTTP connection context event-loop. When the client is used from another event-loop. In Vert.x 4 we want to have a client connection to be usable from any event-loop (https://github.com/vert-x3/wiki/wiki/RFC:-Vert.x-4-context-model).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently HttpClient connection handlers are called when the client request obtains the client connection. Such handlers should be called before the connection is provided to client request. The ability to set such handler on the client request is also a problem as it can be racy and the client request context might not be the same than the connection itself and thus should be removed. Instead application should use the gobal HttpClient connection handler to keep track of connections or set handlers on it. This removal will be deprecated in 3.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClientRequest#connectionHandler is removed in Vert.x 4 and deprecated in 3.x (see #3211).
Application can instead rely on the HttpClient#connectionHandler to achieve the same:
// Deprecated
client.request().connectionHandler(conn -> {
  // Do something with connection
}).end();

// Instead do
client.connectionHandler(conn -> {
  // Do something with connection
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClientRequest#sendHead(Handler<HttpVersion>) method will only call back when the head has been successfully sent and not when there is an error. We need to change this method in Vert.x 4 to be instead HttpClientRequest#sendHead(Handler<AsyncResult<HttpVersion>>).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current implementation of HttpClientRequest#sendHead method will call the handler when the client stream has been created by the connection and provided to the client request. Instead the callback should be done in the HttpClientConnection#sendHead callback so the header is called when the header has been sent and it can also report send failures.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP client does callback on the HTTP connection context event-loop. When the client is used from another event-loop. In Vert.x 4 we want to have a client connection to be usable from any event-loop (https://github.com/vert-x3/wiki/wiki/RFC:-Vert.x-4-context-model).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP/2 server now supports worker processing. The implementation uses now message passing between the connection event loop and its streams.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently duplicate contexts use the original ordered task queue of the original context. Concurrent duplicate worker context will have their task serialised on the same queue.
Instead we need each duplicate to maintain its own queue so that worker context execution is serialised per duplicate to deliver the expected concurrency.
This is also valid for duplicate event loop context using executeBlocking.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When attempting to bind more than one HTTP server to (different) UNIX domain sockets, only the first socket will be opened and all none of the others will be opened.
Some sample code to replicate this (in Kotlin, but this exact code isn't particularly important):
val f1 = File("/tmp/f1.socket")
val f2 = File("/tmp/f2.socket")
val opts = VertxOptions()
opts.preferNativeTransport = true
val vertx = Vertx.vertx(opts)

f1.delete()
f2.delete()

val sem = java.util.concurrent.Semaphore(2)
sem.acquire(2)

vertx.createHttpServer().apply {
    requestHandler { }
    listen(SocketAddress.domainSocketAddress(f1.canonicalPath)) {
        println("S1 started: " + it.succeeded())
        sem.release()
    }
}

vertx.createHttpServer().apply {
    requestHandler { }
    listen(SocketAddress.domainSocketAddress(f2.canonicalPath)) {
        println("S2 started: " + it.succeeded())
        sem.release()
    }
}

// Wait for both servers to start
sem.acquire(2)

println("F1 exists: " + f1.exists())
println("F2 exists: " + f2.exists())

exitProcess(0)
Which outputs:
S1 started: true
S2 started: true
F1 exists: true
F2 exists: false

It seems (having run through it with a debugger) that the following fragment from HttpServerImpl is at fault:
    sslHelper.setApplicationProtocols(applicationProtocols);
    Map<ServerID, HttpServerImpl> sharedHttpServers = vertx.sharedHttpServers();
    synchronized (sharedHttpServers) {
      this.actualPort = port; // Will be updated on bind for a wildcard port
      id = new ServerID(port, host);
      HttpServerImpl shared = sharedHttpServers.get(id); // Caching issue here
      if (shared == null || port == 0) {
        serverChannelGroup = new DefaultChannelGroup("vertx-acceptor-channels", GlobalEventExecutor.INSTANCE);
        ServerBootstrap bootstrap = new ServerBootstrap();
The servers are cached by the unique combination of their port and hostname. Since domain sockets always have a host of localhost and a port of -1, only the first socket be created and all subsequent domain sockets will be found in the map.
I'm on Vertx 3.8.4, and while I haven't tried building from source it appears the relevant code is identical in master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry my English is not good enough.
vertx-core : bodyHandler.
It will be called twice.
for a sample GET request called twice.
for a sample submited form , called twice.
As a result, this handle will run two thousand times if a thousand people request the page.
And I did the following, is that right ???
var buff = Buffer.buffer();
request.handler(buffer->{
buff.appendBuffer(buffer);
request.endHandler(/TODO/)//using endHandler inside handler
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use CompositeFuture#all(List<Future> futures), it's really boring to add @SuppressWarnings("rawtypes").
How about to change the argument to List<Future<?>> futures, just like that of CompositeFutureImpl's?
And same to CompositeFuture#any and CompositeFuture#join.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
you need the eclipse agreement first and your PR - see the how to for contributing https://github.com/vert-x3/wiki/wiki/How-to-contribute-to-Vert.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 3.8.4
@RunWith(VertxUnitRunner.class)
public class DomainSocketTest {
  
  @Test
  public void test(TestContext context) {
    Async async = context.async();
    Logger logger = LoggerFactory.getLogger(DomainSocketTest.class);

    Vertx vertx = Vertx.vertx();
    HttpClient client = vertx.createHttpClient();
    SocketAddress sa = SocketAddress.domainSocketAddress("/var/run/docket.sock");
    // SocketAddress sa = SocketAddress.inetSocketAddress(4243, "localhost");
    HttpClientRequest req = client.requestAbs(HttpMethod.GET, sa, 
      "http://localhost:4243/v1.25/images/json", res -> {
      context.assertEquals(200, res.statusCode());
      async.complete();
    });
    req.exceptionHandler(d -> {
      logger.warn("exceptionHandler " + d, d);
      async.complete();
    });
    req.end();
    async.await();
  }

Getting an error that suggests that I'm not allowed to use Domain Socket at all - which is not what I expected.
Running org.folio.okapi.DomainSocketTest
Dec 11, 2019 2:29:29 PM org.folio.okapi.DomainSocketTest
WARNING: exceptionHandler java.lang.IllegalArgumentException
java.lang.IllegalArgumentException
at io.vertx.core.net.impl.transport.Transport.channelFactory(Transport.java:180)
at io.vertx.core.http.impl.HttpChannelConnector.doConnect(HttpChannelConnector.java:116)
at io.vertx.core.http.impl.HttpChannelConnector.connect(HttpChannelConnector.java:100)
at io.vertx.core.http.impl.pool.Pool$Holder.connect(Pool.java:126)
at io.vertx.core.http.impl.pool.Pool.checkPendingTasks(Pool.java:256)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:510)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:518)
at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Todo

 Examples
 Asciidoc documentation
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version: Vertx-core 4.0.0-SNAPSHOT
When jackson-databind is not available in class path, it falls over to use JacksonCodec, but the following tests will fail in case Enums are in the JsonObject:
  enum SomeEnum {
    FOO, BAR
  }

  @Test
  public void testJsonEnumNoJacksonDatabind() {
    JsonObject json = new JsonObject();
    json.put("name", "foo").put("enum", SomeEnum.FOO);
    assertEquals("{\"name\":\"foo\",\"enum\":\"FOO\"}", json.toString());
  }

The exceptions are:
java.lang.UnsupportedOperationException
    at io.vertx.core.json.jackson.JacksonCodec.encodeJson(JacksonCodec.java:303)
    at io.vertx.core.json.jackson.JacksonCodec.encodeJson(JacksonCodec.java:268)
    at io.vertx.core.json.jackson.JacksonCodec.toString(JacksonCodec.java:91)
    at io.vertx.core.json.JsonObject.encode(JsonObject.java:648)
    at io.vertx.core.json.JsonObject.toString(JsonObject.java:749)
    at io.vertx.ext.mail.MailConfigTest.testJsonEnumNoJacksonDatabind(MailConfigTest.java:38)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when i use eventbus cluster in docker  in the same computer, i got a Connection refused error
this is my config
eventBusOptions:
clusterPublicPort: ${publicPort}
clusterPublicHost: ${publicHost}
clusterPublicPort: 9005
clusterPublicHost: 192.168.10.164
port: 9000
host: 127.0.0.1
clustered: true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the options to build Vertx provide a clustered boolean with the following behavior:

calling vertx(options) with clustered set to false builds a non clustered instance
calling vertx(options) with clustered set to true throw an IllegalArgumentException
calling clusteredVertx(options) with clustered set to true builds a clustered instance
calling clusteredVertx(options) with clustered set to false does set clustered to true and then builds a clustered instance

Given this behaviour, the usefulness of this setting seems very low and instead it could be removed in Vert.x 4 with no actual impact other than not throwing an IllegalStateException when clustered is set to true and the vertx(options) method is called.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently when a message is delivered to an handler, two callbacks are done (before and after). This is simplified to a single callback (messageDelivered) to simplify since there practically not much value having two callbacks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I mentioned in this discussion (#2762 (comment)) we should have such approach, however this one does not seem recursive / generic enough. Would you mind improving your contribution for this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To switch the GenericMessageCodec install as this:
vertx.eventBus().registerDefaultCodec(GenericMessageCodec.class, new MyGenericCodec());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.4
Context
When looking at the values reported for the "credit" EB addresses I noticed that they frequently got "stuck" with a non-zero value.  The cause of this is that the Micrometer implementation (and perhaps others) is not clearing the gauges during handlerUnregistered (I've logged vert-x3/vertx-micrometer-metrics#95 for this).  However, it would be a bit cleaner if the SPI were told about the discarded messages explicitly, rather than having to infer this.
Do you have a reproducer?
Simply running an application which uses a message producer (and thus the credit side-channel) at any reasonable scale will illustrate the issue.  You can also see that in HandlerRegistration.java between lines 168 and 177, any pending messages are discarded, but the SPI is not called (mainly because it lacks the entry point).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually I meant rather the one defined in AsyncTestBase, e.g
server.listen(onSuccess(s ->
   // ...
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using Vert.x 4 milestone 4, I am using Web Client.
My server program needs to request a third-party HTTP service in a request, and the performance index of my server program is: Requests per second: 9.44 [# / sec] (mean). In the stress test.
I checked the configuration parameters of Web Client. Found the maxPoolSize parameter, I set it to 20 (I did not find the upper and lower limit of this value), there is no significant improvement in the performance metrics, what can I do to support more HTTP requests at the same time?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
Version
Affected: vert.x 3.8.5
Context
Running snyk against my app, gives this vulnerability report: https://app.snyk.io/vuln/SNYK-JAVA-IONETTY-543490
Basically it says there is invalid HTTP handling in Netty that has been fixed in 4.1.44.Final.
Do you have a reproducer?
Run sync monitor on any app that has vert.x 3.8.5 in the pom.xml file.

Link to github project/gist

Links

https://app.snyk.io/vuln/SNYK-JAVA-IONETTY-543490
netty/netty#9865
https://netty.io/news/2019/12/18/4-1-44-Final.html
jdordonezn/CVE-2020-72381#1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
All.
Context
When using the Vert.x HttpClient with the HTTP/2 protocol in clear text, the default setting will perform an HTTP/1 connection upgrade with the first request. The connection is corrupted when the client receives the connection preface before the request is fully sent.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HttpClient will send the connection preface when it receives the server connection preface. This works when the upgrade request is sent in a single HTTP message but corrupts the connection when the request is not fully sent since the preface will be sent and will be interpreted as HTTP data by the server.
Adding the Http2ConnectionHandler to the pipeline has two effects:

it is required to process the server preface
it will send the request preface to the server

The Http2ConnectionHandler is added to the pipeline when we receive the 101 response from the server. This might send the client preface before the initial HTTP request (doing the upgrade) is fully sent, resulting in corrupting the protocol (the server might interpret it as an corrupted connection preface).
To properly solve this we should be able to process the server response (i.e the server preface and the server HTTP/2 traffic) while delaying the client preface write. Currently this does not seem possible because processing the server preface is done by the handler that will sent the client preface as soon as it is added to the pipeline.
Therefore we must buffer all pending messages until the request is fully sent.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.5
Context
I have a Cassandra database with 7000 rows. When I query them all only 2000 are returned. I've tested with different fetch sizes. When using fetch size >= 7000 it works fine.
It is the last 2000 rows that are returned.
Looking into the code I can see that CassandraClientImpl calls ResultSetImpl.all. I believe I have found the bug in this method:
`private void loadMore(Context context, List loaded, Handler<AsyncResult<List>> handler) {
int availableWithoutFetching = resultSet.getAvailableWithoutFetching();
List rows = new ArrayList<>(loaded.size() + availableWithoutFetching);
for (int i = 0; i < availableWithoutFetching; i++) {
rows.add(resultSet.one());
}
if (!resultSet.isFullyFetched()) {
  handleOnContext(resultSet.fetchMoreResults(), context, ar -> {
    if (ar.succeeded()) {
      loadMore(context, rows, handler);
    } else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  });
} else {
  handler.handle(Future.succeededFuture(rows));
}

}`
The problem is that the loaded rows aren't added to the rows list (just the size is added).
I believe adding this row after the rows instantiation will solve this bug
rows.addAll(loaded)
Do you have a reproducer?
`
import io.vertx.cassandra.CassandraClient;
import io.vertx.core.Vertx;
import lombok.SneakyThrows;
public class CassandraTest {
@SneakyThrows
public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    CassandraClient cassandraClient = null;
    try {
        cassandraClient = CassandraClient.create(vertx);

        cassandraClient.executeWithFullFetch("SELECT * FROM <keyspace>.<table>", ar -> {
            if (ar.succeeded()) {
                System.out.println("Number of rows fetched: " + ar.result().size());
            } else {
                System.out.println("Failed to fetch: " + ar.cause());
            }
        });

        Thread.sleep(5000);
    } finally {
        if(cassandraClient != null) {
            cassandraClient.close();
        }
        vertx.close();
    }
}

}`
Steps to reproduce

Add 7000 rows to Cassandra
Run the CassandraTest code above
Number of rows fetched: 2000 is printed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Buffer interface defines these methods:

toJsonObject(): parse the buffer content as a JSON object
toJsonArray(): parse the buffer content as a JSON array
toJson(): parse the buffer content as a JSON element or value

These methods are actually mapping methods a JSON element or value according whose type depends on the content of the buffer. The toJson() method convention is actually used to encode data objects to their JSON representation. e.g for a buffer it would actually encode a base 64 representation of the content like JsonObject does. The toJson() method will likely be changed in Vert.x 4 to return an encoded base 64 String.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.5
Context
Seems that vertx websocket ping message handling changed with 3.8.0 release.
Before 3.8.0  - ping messages weren't triggering handler to be called.
After 3.8.0 - when websocket ping message received websocket handler would be called.
Is it a bug or an intended change?
Do you have a reproducer?
Server:
        vertx.createHttpServer()
                .websocketHandler(ws -> {
                    ws.handler(buf -> {
                        System.out.println("RECEIVED: " + buf.toString());
                        ws.write(buf);
                    });
                })
                .listen(8080);


Client:
       vertx.createHttpClient().websocket(8080, "localhost", "/test", ws -> {
            ws.writePing(Buffer.buffer("PING"));
            ws.writeTextMessage("MESSAGE");
        });

Server output with 3.8.0+:

RECEIVED: PING
RECEIVED: MESSAGE

with 3.4-3.7:

RECEIVED: MESSAGE

Steps to reproduce

run server verticle
run client verticle
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the WebSocket implementation will deliver frame and pong to the respective handlers when it is in paused state. The implementation will only queue the frame containing application buffers when in paused state. We should instead manage a queue of frames instead of application buffers and the queue handler should dispatch those messages to the respective handlers, applying the queue processing state to all handlers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj when this is merged I'll update the breaking changes page
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you describe how you are attempting to improve the test ?
note: you can test this in your own fork if you have travis enabled, the travis script are designed to work with repo forks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj if you're fine with this, I'll upgrade the 3.9 branch too. Then I can update the website with an override.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
io.vertx.core.file.impl.FileResolver.resolveFile(fileName) use a ClassLoader to resolve resource. It always return null when getResource() has been called. Because the fileName which send to resolveFile alway starts with '/'.
The resolveFile method will been used in StaticHandler and HttpServerResponse.
It will cause an error when sending the file to the client, the first time it is called, and the subsequent time it will not see an error because it reads from the cache and did not execute getResource
This leads to program instability.
Version
3.8.5
Context
resolveFile:143, FileResolver (io.vertx.core.file.impl)
resolveFile:805, VertxImpl (io.vertx.core.impl)
:933, FileSystemImpl$20 (io.vertx.core.file.impl)
existsInternal:932, FileSystemImpl (io.vertx.core.file.impl)
exists:340, FileSystemImpl (io.vertx.core.file.impl)
lambda$isFileExisting$2:283, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
call:-1, 1512148561 (io.vertx.ext.web.handler.impl.StaticHandlerImpl$$Lambda$234)
wrapInTCCLSwitch:266, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
isFileExisting:283, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
sendStatic:192, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
handle:145, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
handle:51, StaticHandlerImpl (io.vertx.ext.web.handler.impl)
Do you have a reproducer?
See the source code, everything is there.
Extra
OS: Windows 10
JVM: OpenJDK 12
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closing because I did not signoff my commit
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we decided to not go forward with this change
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to follow any basic example here:
https://vertx.io/docs/vertx-config/js/#_additional_formats
If I do the following:
import { ConfigRetriever } from '@vertx/config';
import { ConfigStoreOptions } from '@vertx/config/options';
import { JsonObject } from '@vertx/core';
const fileStore = new ConfigStoreOptions().setType("file").setConfig(new JsonObject().put('foo', 'bar'));

I will get an error that JsonObject is not found.
If I look at the @vertx/core/index.js file I can clearly see it missing.
FWIW I tried another way and seem to have gotten a workaround, but JsonObject should still be exposed for other use cases.
The workaround can be found here: #3308
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JsonArray should obey the condition that two arrays having same toString() representations are considered equal. This issue provides a counterexample to that.
The reason behind this is that the JsonArray constructor taking a list does not check the actual types of objects. Provided with a json-unfriendly type, it is being converted when reading. If the types of the objects were validated , IllegalArgumentException would be thrown - this would prevent confusion caused by implicit conversion on reading from array.
Version
3.8.4
Do you have a reproducer?
  @Test
  @DisplayName("Expect JsonArrays with equal toString() result to be equal")
  void jsonArrayLeadingToWeirdResults() {
    class SomeClass {
      private String field;

      SomeClass(String field) {
        this.field = field;
      }

      public String getField() {
        return field;
      }

      public JsonObject toJson() {
        return new JsonObject()
            .put("field", field);
      }
    }

    SomeClass instance = new SomeClass("fieldValue");

    JsonArray expected = new JsonArray().add(instance.toJson());
    JsonArray actual = new JsonArray(Collections.singletonList(instance));

    assertEquals(expected.toString(), actual.toString());
    assertEquals(expected, actual);
  }
Context
The issue was encountered when implementing unit tests for an utility class transforming metadata to a custom Json representation. See Knotx/knotx-fragments#92
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4
this topic is related to this one: #3198
We should have methods like this:
context.checkContextFamilyEquality(otherContext);
-> its true if the context is related to otherContext, cause one of them is a duplicated one of the other one
context.checkThreadEquality(otherContext)
-> its true if both live in/on the same-eventloopthread/same-thread.
it capsulate code like this: ctx.nettyEventLoop().inEventLoop()
if it changes in the future, we dont have to adjust these code snippet in x-files of the vertx project, but only in one^^
=> And also its a better code design, not relying on concrete implementations but on abstractions^^
context.checkEquality(otherContext)
-> its true if context==otherContext
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4
if i instantiate a verticle and start a http-server in it.
Each request is executed on a other context (not the verticle context itself)
So context-equality checks breaks and i cant use the context-locals
For the context-equality-checks there would be a documentation good, what we should use then.
Maybe a solution i referenced here: #3300
But that solves not the context-locals-problem.
We need there more clarification.
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4 (feature-request)
actually we have the contextA.runOnContext(Handler h)-method that do something like this:
it switch to the contextA and switch the eventloop to that in which contextA lives.
it does this that way without exception.
contextA.runOnContextTWO(Handler h):
here it should do that context switch to contextA also without exception.
But if the program sees here that eventloopThread from currentContext is the same as the eventloopThread of contextA then it should not do that eventloop-switch (do not a push to that mpsc-queue). Here in that case it should run the code directly, after "switching" the context.
Why we need both?
the first runOnContext is more fair. If i call in a forloop 1000times the runOnContext, thousand mpsc-queue-pushes are done. So other "events" have the chance to run, before the 1000 completed.
In the secound one (runOnContextTwo), if i call this method in a for-loop 1000times and the caller-eventloop is the same as the contextA-loop, then the 1000events are executed without a break. No other events have the chance to run in between. So its not so fair. But in sum faster.  (Cause i dont have 1000 expensive mpsc-queue pushes)
=> So the use case later decides, if the user want to use the fair or unfair runOnContext()-solution
Maybe the secound solution is also interessting for some internal stuff^^
Where we want to change the context, but dont do an expensiver one eventloop-switch to the same eventloop (if the eventloops from contextA and callerContext are the same^^)
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4 (feature request)
(1)
public  Future runAndGetFuture(Handler<Promise> runnable)
(2)
public  void run(Handler<Promise> ressourceRunner, Handler<AsyncResult> callerRunner)
Both methods are methods from the context-class and both should do the same:
They should run on that context. The result in case (1) can be fetched with the help of a future on the callerContext. In case (2) its similar to the method executeBlocking(..) The result can be fetched in that callbackmethod callerRunner.
Why these functionalitly?
-> The user dont have to write this code on his own; cause vertx have it^^
More informations and details you can get here: https://groups.google.com/forum/#!topic/vertx-dev/P1aDU1i1Tyg
in that Google-Forum-Topic you find links to a example-implementation by me of that functionality
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to follow the basic example here:
https://vertx.io/docs/vertx-core/js/#_configuring_an_http_server
Which shows:
var options = {
  "maxWebSocketFrameSize" : 1000000
};

var server = vertx.createHttpServer(options);

I am using Vue, and I place that code in my index.js file.  When I do an npm run build;npm start; I see the following error in the logs
Failed in deploying verticle caused by TypeError: invokeMember (createHttpServer) on JavaObject[io.vertx.core.impl.VertxImpl failed due to: no applicable overload found
(overloads: [
Method[public io.vertx.core.http.HttpServer io.vertx.core.impl.VertxImpl.createHttpServer(io.vertx.core.http.HttpServerOptions)],
Method[public io.vertx.core.http.HttpServer io.vertx.core.impl.VertxImpl.createHttpServer()],
], arguments: [DynamicObject<JSUserObject> (DynamicObjectBasic)])

It seems to work when I do:
import { HttpServerOptions } from '@vertx/core/options';
var server = vertx.createHttpServer(new HttpServerOptions().setMaxWebsocketFrameSize(1000000));

I suggest updating the docs to reflect the correct way to do it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to add jks options to my vertx server in javascript like so.
import { HttpServerOptions, JKSOptions } from '@vertx/core/options';

const myJks = new JKSOptions().setPath('/foo/bar.jks')
  .setPassword('baloneySandwich');

const server = vertx.createHttpServer(new HttpServerOptions()
  .setSsl(true)
  .setKeyStoreOptions(myJks));

It barfs with the following error:

TypeError: JKSOptions is not a constructor
at  load(file://node_modules/.lib/es4x-0.10.1.jar!/io/reactiverse/es4x/jvm-npm.js:97:3264-3345)

FWIW I am using GraalVM 19.2.1 CE (Which has NPM 6.9.0/ OpenJDK v 1.8.0_232), Vertx 3.8.5 and ES4X-pm 0.10.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx4
Actually im some cases a context is injected to the Future/Promise.
Later the resultHandler(s) is/are executed on that context.
The context is injected at Constructor-Time. Its the context of the caller, so that the handler is later executed on the right context.
actually it is also so that there exists cases, in which no context is injected.
So this is very inconsistenst and error-prone.
So the solution of that bug can be the following:
No-Context-Constructor-Injection, BUT
at the time the handler is registered to that future/promise, the context should be captured.
So i get the following benefits:

if i register a handler to that future on a other context, where the future is created, the result is executed in that case on the right context.
if i register different handlers from different context, each handler then is called on the correct context.

These two benefits i dont have in the acutally future-constructor-context-injection-solution.
More informations and details you can get here: https://groups.google.com/forum/#!topic/vertx-dev/F3w-AyiobF8
in that Google-Forum-Topic you find links to a example-implementation by me of that.
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4 (feature request)
the following method we should add to the Future-Interface:
public Future onComplete(Handler<AsyncResult> h, long timeout)
its easy to implement. We wrap in that method the handler into a TimeoutHandlerWrapper.
Take a look to my detailed informations in google-groups: https://groups.google.com/forum/#!topic/vertx-dev/r-0y-SzELzU
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It appears that the config retriever is passing futures by default.  I don't see anything in the docs about this:
https://vertx.io/docs/vertx-config/js/#_configuring_a_single_verticle
The code below works, and the docs may want to change to reflect something similar
import { ConfigRetriever } from '@vertx/config';
import { ConfigStoreOptions, ConfigRetrieverOptions } from '@vertx/config/options';

const fileStore = new ConfigStoreOptions().setType('file')
  .setFormat('properties')
  .setConfig({ 'path': '/foo/bar.properties' });
const configRetrieverOptions = new ConfigRetrieverOptions().addStore(fileStore);
const retriever = ConfigRetriever.create(vertx, configRetrieverOptions);

retriever.getConfig((futureResult, json_err) => {
  if (json_err != null) {
    console.error(json_err);
    return;
  }
  futureResult.onSuccess((result) => {
    console.log('From Future:', JSON.stringify(result)));
    // Do your work in here instead
  );}
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a myVertxConfig.properties file. In it I have:
  port=8080
If I load the properties file using the following code as example (#3308) I will see an output of 8080.0  (It adds a dot and then a zero)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x version 3.7.0
We are getting these rare errors (happened around 9 times in the last 90 days).
Not exactly sure how to reproduce these but it seems like this happens during high load.
Unhandled exception java.lang.NullPointerException at io.vertx.core.http.impl.Http1xServerConnection.handleInterestedOpsChanged(Http1xServerConnection.java:415)
	at io.vertx.core.net.impl.VertxHandler.lambda$channelWritabilityChanged$3(VertxHandler.java:136)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:320)
	at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:188)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:180)
	at io.vertx.core.net.impl.VertxHandler.channelWritabilityChanged(VertxHandler.java:136)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:436)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:423)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelWritabilityChanged(AbstractChannelHandlerContext.java:416)
	at io.netty.handler.stream.ChunkedWriteHandler.channelWritabilityChanged(ChunkedWriteHandler.java:150)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:436)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:423)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelWritabilityChanged(AbstractChannelHandlerContext.java:416)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelWritabilityChanged(DefaultChannelPipeline.java:1431)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:436)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext.java:423)
	at io.netty.channel.DefaultChannelPipeline.fireChannelWritabilityChanged(DefaultChannelPipeline.java:942)
	at io.netty.channel.ChannelOutboundBuffer$2.run(ChannelOutboundBuffer.java:620)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:405)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the HTTP client will assume that all HTTP messages are received in response of a request it sent which is correct. Some servers might send unsolicited message (e.g upon a connection close) and are misbehaving this way.
Such messages will trigger NullPointerException in the client because it is in a state assuming no message can be received.
java.lang.NullPointerException: null
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.access$2000(Http1xClientConnection.java:237)
	at io.vertx.core.http.impl.Http1xClientConnection.handleResponseEnd(Http1xClientConnection.java:628)
	at io.vertx.core.http.impl.Http1xClientConnection.handleHttpMessage(Http1xClientConnection.java:584)
	at io.vertx.core.http.impl.Http1xClientConnection.handleMessage(Http1xClientConnection.java:566)

The client needs to handle unsolicited messages to avoid such errors polluting the logs and potentially creating  performance issues.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
do you know how to reproduce it ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.1
Do you have a reproducer?
        Promise<String> p = Promise.promise();

        p.complete("Foo");

        p.future()
                .setHandler(ar -> {
                    System.out.format("1: %s%n", ar.result());
                })
                .setHandler(ar -> {
                    System.out.format("2: %s%n", ar.result());
                });
vs:
        Promise<String> p = Promise.promise();

        p.future()
                .setHandler(ar -> {
                    System.out.format("1: %s%n", ar.result());
                })
                .setHandler(ar -> {
                    System.out.format("2: %s%n", ar.result());
                });

        p.complete("Foo");
Steps to reproduce

... Run the two samples above

Extra
When the "complete" method is called after setting up the two handlers, only one handler is being called:
2: Foo

When complete is called before setting up the handler, both handlers get called:
1: Foo
2: Foo

My expectation would be that, now matter when the future gets completed, always the same handlers get called.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4 milestone 4
private void doDispatch(Handler<AsyncResult<T>> handler) {
    if (context != null) {
      context.dispatch(this, handler);
    } else {
      handler.handle(this);
    }
  }


thats the existing doDispatch-Method in your Future-Implementation.
The Problem is in the else-path.
if the handler throws an exception, the caller-side in the if-path is not abborted, cause the exception is caught anywhere in the context.dispatch......
in the else-path the exception abborts the caller-side.
So we have there a different behaviour in the cases if in the promise/Future is a context registered or not.
I guess we need here something like this:
} else {
try
{
      handler.handle(this);
}
catch(Throwable t)
{
//report t to the current-Context
}
}

that should not abbort the caller-side
lg knotenpunkt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this code cannot currently compile because the code generator does not support wildcards, so we cannot have such PR until the code generator supports. We are planning to try having this for Vert.x 4.0, for now i'll just close the PR because if we do support wildcard, the only use case we know in codebase is this one for now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vertx 3.8.5
Context
Found via OWASP dependency check
Do you have a reproducer?
NVD link has details on all issue from jackson-databind 2.9.9.  It appears jackson-databind 2.9.10.3 will cover all of these issues.
NVD: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&search_type=all&cpe_vendor=cpe%3A%2F%3Afasterxml&cpe_product=cpe%3A%2F%3Afasterxml%3Ajackson-databind&cpe_version=cpe%3A%2F%3Afasterxml%3Ajackson-databind%3A2.9.9
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.4
Context
At work, I'm developing a web application based on Vert.x: a main verticle that spawns 2 verticles. One for a RESTful API (with internal and public endpoints), and one for UI (static resources, among which a bundled ReactJS front app).
An end-user request transits through those architecture tiers: (HTTPS) 1x Microsoft IIS SSL-enabling frontend --> (HTTP) 1x authentication gateway --> (HTTP) 1x Vert.x app.
When upgrading from Vert.x 3.7.1 to Vert.x 3.8.4 with minimal compilation-required changes (i.e. resolving the new Vert.x Promises into app well-known Futures), I observe a consistent regression when accessing https://myhost.mydomain/myappcontextpath/foofileinsidewebroot.html from outside the Vert.x app host machine:

Firefox states a PR_CONNECT_RESET_ERROR, therefore gets no response from the server
Visually in the browser taskbar, the SSL handshake phase seems to enter a looping-behavior ("Establishing TLS connection..", "TLS connection established.", looping ~5 times, what is observed only once when page loads properly)
(may be unrelated) In the browser network monitoring tools: the TLS handshake phase takes longer than usual, and HSTS (HTTP Strict Transport Security) appears disabled (in our setup, it's enabled when page loads properly)
In the Vert.x app request logs, I see the request, I see an HTTP 200 Ok response status, and I see the proper response size
(may be unreliable due to logging misconfiguration in my app) The app logs state no error message nor exception stacktrace. Parameterizing logging to full-verbose outputs nothing more in logs

Reverting changes and downgrading to 3.7.1 extinguishes the issue.
Alternatively, regression is worked around by replacing the StaticHandler (i.e. router.route().handler(StaticHandler.create());) with this impl: CustomStaticHandlerServiceImpl_java.txt
Do you have a reproducer?
No
Steps to reproduce

Build and deploy a Vert.x app using the StaticHandler and having a foofileinsidewebroot.html file dropped in the Vert.x default webroot directory
Have a Microsoft IIS front with SSL-enabled (may reproduce with any web server), ideally on another host
Have this front pointing to your Vert.x app HTTP (non-secured) URL
From a public machine, browse https://myhost.mydomain/myappcontextpath/foofileinsidewebroot.html in Firefox, and assert: that you get a PR_CONNECT_RESET_ERROR

Extra

I realize this issue is not fully narrowed down and debugged, therefore not easily reproductible most probably. It's intended as an "heads up" ticket, in case the Vert.x developers may think of anything related to that regressive behavior
Updating to Vert.x 3.8.5 didn't solve the issue
When running the Vert.x app locally and accessing it directly (i.e. http://127.0.0.1:myappport/foofileinsidewebroot.html), issue is not reproduced. The same observation is made when performing a local attempt from the deployment machine. As such, issue is definitely SSL-related
When running in the bug context, where the UI static resource URL is not reachable, the public API endpoints still are: so the app-defined Vert.x router routes didn't fully regressed
The suggested workaround duplicates parts of the StaticHandler (reading the static files directory, writing the HTTP response headers, writing a file in the HTTP response body). As such, it disqualifies a regression cause in Netty?
In the Vert.x revisions, I see no changes made to the StaticHandler between version 3.7.1 and 3.8.4, so the problem would occur deeper in the Vert.x classes?
Due to a tight schedule, I didn't go deeper:



Didn't attempt to configure app into a debug mode in order to remotely attach a debugger, having our operations team to manage security/access/routing for the debugging port
Didn't attempt with in-between Vert.x releases (3.8.0, 3.8.1, 3.8.2 and 3.8.3) in order to identify when it regressed
Didn't attempt to monitor the network trafic on the architecture tiers (with Wireshark or any other monitoring tool)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.4
Context
Trying to set eventbus options so that bidirectional messaging is possible between to members.
Do you have a reproducer?
https://github.com/rc-dukes/dukes
Steps to reproduce
Start member verticles e.g. with CarServer or DukesFx App on a Mac OS laptop
Start member verticles on Raspberry PI
Use Echo functionality.
Message on Raspberry is received. Publishing a reply fails with different error messages depending on eventbus configuration. There is no known working configuration at this time.
Issue
The issue here is that there seem to be hidden features that lead to the situation.
The documentation e.g. for https://vertx.io/docs/apidocs/io/vertx/core/eventbus/EventBusOptions.html#setHost-java.lang.String-
is
Sets the host.
Which is not sufficient to explain what is going on.
https://vertx.io/docs/apidocs/io/vertx/core/eventbus/EventBusOptions.html#setClusterPublicHost-java.lang.String-
Says:
_Set the public facing hostname to be used for clustering. Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of proxying. If this is the case you can specify a public hostname which is different from the hostname the server listens at.
The default value is null which means use the same as the cluster hostname._
but does not describe why e.g.


https://stackoverflow.com/questions/49025541/in-vertx-clustering-whats-the-difference-between-cluster-host-port-and-public/49028531#49028531


rc-dukes/dukes#19
happen


#3229


e.g. states
when i use config
host: 0.0.0.0
this problem resolved
Which does not explain why 0.0.0.0 is a valid value and how this should work. I tried it and it leads to the other member to not know what to do with 0.0.0.0 ...

#2696
adds to the confusion instead of resolving it.
#1529
also adds more input that does not lead to clarification

Where is the reproducer that proves that things are not systematically broken?
I am in the process of modifying RemoteCar.java to allow specifying Host and ClusterPublicHost via command line. Do I also need to be able to modify the ports? Which is the valid setting that should work and where is this documented?
Please do not close this as a question - i have the feeling that there are quite a few people out there which ran into similar issues due to missing documentation/examples and clarification.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently the client connection Pool although takes care of closing the pool when it becomes empty in order to remove itself from the ConnectionManager. The ConnectionManager is actually coupled to the HTTP protocol and the Pool making it impossible to reuse for other purpose than HTTP connection management.
We want to decouple the ConnectionManager from HTTP and from the Pool and give flexibility by allowing a endpoint management. The manager will only now maintain of map of endpoint keys to Endpoint where the Endpoint is responsible for managing the connections, eventually with a Pool. It will also be responsible for maintaining managing the endpoint lifecycle relieving the pool from this responsibility.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently WebSockets are pooled like other HTTP connections and therefore are naturally associated with the Context of the Pool. We actually want to remove this coupling such as opening a WebSocket from a context will use that context. We could have a specific Context for WebSocket and perform message passing between the underlying channel and the user context, however this adds un-necessary complexity and potential bugs because WebSocket are closed after usage and thus not pooled.
We implement a different policy for WebSocket management that maintains a maximum set of connections for a given endpoint in order to satisfy the max pool size management as well as a list of waiters for connections, however we will not use a pool because connections are simply closed when the WebSocket closes the connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClient will maintain a single context for the client. This requirement is quite strong and actually be relaxed to maintain a context per endpoint for pooled connections. This will improve the shared client in the future as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x supports multiple handler per future since the 3.8.4 release. The setHandler method does convey the meaning that a single handler per future can be set and unset and the onComplete, onSuccess, onFailure methods shall be used instead.
The setHandler method usage should be replaced by the onComplete method, e.g
// Before
Future<String> fut = getSomeFuture();
fut.setHandler(ar -> ...);

// After
Future<String> fut = getSomeFuture();
fut.onComplete(ar -> ...);
The setHandler will be removed in Vert.x 4.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x supports multiple handler per future in 4.0. The setHandler method does convey the meaning that a single handler per future can be set and unset and the onComplete, onSuccess, onFailure methods shall be used instead.
The setHandler method usage must be replaced by the onComplete method, e.g
// Before
Future<String> fut = getSomeFuture();
fut.setHandler(ar -> ...);

// After
Future<String> fut = getSomeFuture();
fut.onComplete(ar -> ...);
The setHandler is deprecated in Vert.x 3.9
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'll backport this PR after (minus removing the pump doc section).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.5.2, 3.8.5
Context
Performing flush and close on multiple AsyncFiles results in each one being closed synchronously, one by one, since they are submitted to the internal ordered task queue. This results in performance degradation.
Originally these operations were executed on the event loop, but were moved since they are blocking operations that can take a while. However, I don't think the intention was to execute them one by one - though there could be something I am missing.
See https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java#L434
and
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java#L542
I think it would be more appropriate to send them to an unordered task queue / worker pool so that they can be flushed or closed in parallel.
Do you have a reproducer?
Obtain multiple references of AsyncFile by using fileSystem().open() and call flush or close on each one.
Steps to reproduce
See above.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a consumer discards a message (i.e unregistration, message overflow) it will drop messages.
A metrics implementation may maintain count pending message (incremented when a message is scheduled / decremented when a message is delivered). On a message discard, this value will not reflect the actual value.
Signalling an implementation that a message is discarded allows to maintain a correct count and also enables this implementation to be aware of it (i.e it could trigger a warn, etc...)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
I like the introduced state splitting between promises and futures in the upcoming 4.x version. I was just reasoning how we can escalate an exception back to the code that is running/backing the future without a signature to ask for it.
Reference to Java
https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#cancel(boolean)
Version
4.0.0-milestone4
Context
We are currently (miss) using the tryFail signature to signal an exception to the executing code and ask for an interrupt.
Possible use cases

resource management to abort non relevant processes
graceful shutdown of running processes

Do you have a reproducer?
Migration to 4.x would lead to a compilation error
Extra
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.5
Context
Invoking vertx.filesystem().exists() can block the event loop thread. This is because resolveFile() runs in the event loop thread instead of in the worker thread:
See https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/file/impl/FileSystemImpl.java#L1113:
  private BlockingAction<Boolean> existsInternal(String path) {
    Objects.requireNonNull(path);
    return new BlockingAction<Boolean>() {
      File file = vertx.resolveFile(path);
      public Boolean perform() {
        return file.exists();
      }
    };
  }

resolveFile should instead be called in the perform() method:
  private BlockingAction<Boolean> existsInternal(String path) {
    Objects.requireNonNull(path);
    return new BlockingAction<Boolean>() {
      public Boolean perform() {
        File file = vertx.resolveFile(path);
        return file.exists();
      }
    };
  }

Do you have a reproducer?
You can mock calls to resolveFile() to sleep for any amount of time or set a breakpoint on the resolveFile call as a test runs. Wait up to the blocked thread checker interval and unpause execution. BlockedThreadChecker will report that the thread has been blocked.
Steps to reproduce
See above.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpClientRequest timeout is created when upon call of setTimeout method. This may trigger the timeout when the request is not yet begun (i.e before it is in internal connecting state) causing timeout miss, leading to a racy situation.
We should create the timeout after the request has begun (i.e after it is set connecting or has a stream).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
EDNS is an extension mechanism for DNS (https://fr.wikipedia.org/wiki/EDNS) that should be disabled by default. It might cause unwanted issue such as #3150 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The EventBusMetrics#scheduleMessage event in 3.x is called when the message will be scheduled for delivery by the registration handler. Most metrics implementations will increase a pending count on this event. However there is no guarantee that the message will actually be processed, e.g the message is scheduled on a registration but this registration is unregistered before it receives the message leading to an incorrect metric value.
The scheduleMessage method should be called within the registration handler before the message is added to the internal pending list or processed or discarded.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.8.5
Context
When attempting to use Future.otherwise and Future.recover it was not clear what the intended differences were meant to be.
Do you have a reproducer?
No, N/A
Extra
I intend to submit a PR with a proposed update to the JavaDocs and perhaps the Vert.x documentation in order to make the use of these methods more clear in a broader context.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to use AmqpClient with a keystore and am getting a nonhelpful message of
SEVERE: Unhandled exception
io.vert.core.VertException: java.lang.NullPointerException
 at io.vertx.core.net.impl.SSLHelper.createContext(SSLHelper.java:303)
 at io.vertx.core.net.impl.SSLHelper.getContext(SSLHelper.java:478)


What is happening is that the catch block inside createContext is swallowing the stacktrace of the NPE, so I have no idea where/how it's originating inside that method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See: vert-x3/issues#500
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You can safely ignore the ECA check failure. I signed off my commits and GPG-signed them with my Red Hat address, so... we're covered.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a clustered vertx instance fails to start (i.e event bus start failure, cluster join failures, etc...), resources allocated in the vertx instance are not released.
On a start failure, the created vertx instance should be closed to release resources.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpServerRequest only setup the request decoder when the content-type header and the method say so. When it does not it should fail instead of being a no-op.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@srijan02420 there is no test for this feature
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks like the ECA check is based on my email address. I'm using different addresses for GitHub and eclipse.org. Any advice?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
JsonArray clusterNodes = redisConfig.getJsonArray("clusterNodes");
                RedisOptions redisOptions = new RedisOptions();
                redisOptions.getNetClientOptions().setConnectTimeout(500);
                redisOptions.setMaxWaitingHandlers(1000000);
                redisOptions.setType(RedisClientType.CLUSTER).setUseSlave(RedisSlaves.NEVER);
                List<String> endpoints = new ArrayList();
                for (int i = 0; i < clusterNodes.size(); i++) {
                    JsonObject node = clusterNodes.getJsonObject(i);
                    String host = node.getString("host");
                    Integer port = node.getInteger("port");
                    String password = node.getString("password");
                    String connStr;
                    if (password != null && password.length() > 0) {
                        connStr = String.format("redis://:%s@%s:%s/0", password, host, port);
                    } else {
                        connStr = String.format("redis://%s:%s/0", host, port);
                    }
                    endpoints.add(connStr);
                }
                redisOptions.setEndpoints(endpoints);
                Redis.createClient(vertx, redisOptions).connect(onConnect -> {
                    if (onConnect.succeeded()) {
                        RedisConnection client = onConnect.result();
                        redisAPI = RedisAPI.api(client);

                        // Here , got a fail message
                        redisAPI.ping(Lists.newArrayList(), responseAsyncResult -> {
                            log.info(responseAsyncResult.result().toString());
                        });

                        vertx.eventBus().consumer(EVENT_BUS_NAME, execute());
                        startPromise.complete();
                    } else {
                        startPromise.fail(onConnect.cause());
                    }
                });

Version
3.9.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HTTP/2 connection is missing an explicit flush when writing an header frame that might cause in not sending fully a response when a trailer frame is used for ending a stream.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When Vert.x is closed, all its event bus registrations are removed.
But the EventBusImpl#unregisterAll method does not take a callback nor return a future.
So it happens that the method returns, then later the cluster manager leave method is invoked before all unregistrations are completed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Description
We got new exception after updating Vert.x from 3.9.0 to 3.9.1
Tested with:

Netty 4.1.49.Final
Netty: 4.1.50.Final

On the Vert.x 3.9.0 there is no this exception (with Netty 4.1.49.Final/4.1.50.Final).
StackTrace
java.lang.IllegalStateException: Result is already complete: failed
	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:119)
	at io.vertx.ext.web.client.impl.HttpContext.lambda$handleSendRequest$15(HttpContext.java:530)
	at io.vertx.core.http.impl.HttpClientRequestImpl.connected(HttpClientRequestImpl.java:513)
	at io.vertx.core.http.impl.HttpClientRequestImpl.lambda$null$5(HttpClientRequestImpl.java:466)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:229)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:221)
	at io.vertx.core.http.impl.HttpClientRequestImpl.lambda$connect$7(HttpClientRequestImpl.java:465)
	at io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:105)
	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:150)
	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:111)
	at io.vertx.core.http.impl.Http1xClientConnection.createStream(Http1xClientConnection.java:847)
	at io.vertx.core.http.impl.HttpClientImpl.lambda$getConnectionForRequest$4(HttpClientImpl.java:1041)
	at io.vertx.core.http.impl.ConnectionManager.lambda$getConnection$7(ConnectionManager.java:158)
	at io.vertx.core.http.impl.pool.Pool.connectSucceeded(Pool.java:380)
	at io.vertx.core.http.impl.pool.Pool.access$500(Pool.java:89)
	at io.vertx.core.http.impl.pool.Pool$Holder.lambda$connect$0(Pool.java:127)
	at io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:105)
	at io.vertx.core.impl.FutureImpl.tryComplete(FutureImpl.java:150)
	at io.vertx.core.impl.FutureImpl.complete(FutureImpl.java:111)
	at io.vertx.core.http.impl.HttpChannelConnector.lambda$http1xConnected$3(HttpChannelConnector.java:226)
	at io.vertx.core.net.impl.VertxHandler.setConnection(VertxHandler.java:85)
	at io.vertx.core.net.impl.VertxHandler.handlerAdded(VertxHandler.java:102)
	at io.netty.channel.AbstractChannelHandlerContext.callHandlerAdded(AbstractChannelHandlerContext.java:938)
	at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:609)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:223)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:195)
	at io.vertx.core.http.impl.HttpChannelConnector.http1xConnected(HttpChannelConnector.java:232)
	at io.vertx.core.http.impl.HttpChannelConnector.lambda$doConnect$0(HttpChannelConnector.java:162)
	at io.vertx.core.net.impl.ChannelProvider.lambda$connect$1(ChannelProvider.java:78)
	at io.vertx.core.net.impl.ChannelProvider.connected(ChannelProvider.java:160)
	at io.vertx.core.net.impl.ChannelProvider.lambda$handleConnect$2(ChannelProvider.java:143)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:615)
	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:653)
	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)
	at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)
	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The core client lifecycle (HttpClient and NetClient) is correctly not bound to the Vert.x instance, i.e some clients might be not closed after a Vert.x instance is closed. This can raise an issue when a client is closed afterward and the related resources (event-loop) are not available anymore resulting in tasks rejections (exceptions).
Such exceptions can also be triggered by client finalisation that attempt to close a client when it is not referenced anymore.
Changes:

any client will be closed when the creating scope is closed which can be

the verticle that created this client
the vertx instance
the event-bus (that creates net client)


the referenced client should not prevent GC gc-ing them when they are not reachable anymore which imply that the close hooks should use weak references
a few useless finalisers are removed because there is no need to clean anything
non deployment context do not need to create a close hooks because they will not be closed and thus we don't need to create useless objects
TCP servers don't need to to be closed anymore in the vertx close process as they can be added as shutdown hooks of the vertx instance (that is a simplification)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
This lies somewhere between bug and feature.  In Vert.x 3.9.x the call to EventBusMetrics.scheduleMessage was moved from EventBusImpl.deliverToHander to HandlerRegistration.handle.  The call to EventBusMetrics.beginHandleMessage remains where it was before.
With the old placement it was possible to measure the number of EventBus messages that had been received and turned into Netty tasks, but which had not yet been run by Netty (since the call to scheduleMessage occurred before the task was created and the call to beginHandleMessage occurs only once the task has started running).
With the new placement this is no longer possible.  The only thing you can measure is the depth of the internal pending queue, which will only be used if the event consumer is paused for some reason (which our application never does).
If possible we would like the old capability restored in some fashion.  If it isn't feasible to move the call to schedule back where it was, then perhaps a new entry point to EventBusMetrics could be added to replace it.  The inability to measure the number of backlogged tasks hampers our performance analysis.
Use cases
Understanding (in detail) how work is flowing through the system when running at high throughput rates (>100K/s) is critical to both application tuning and provisioning.  The Netty task backlog is an important metric in understanding when and where incoming work is overwhelming the system's ability to process it.  Netty itself provides very little in the way of instrumentation so measuring it via Vert.x was the best we could do.
Contribution
I would be happy to contribute this change, though I've never done any work on the actual Vert.x core (I do have a current Eclipse contributor agreement).  Beyond that I don't know who the appropriate person might be to do the implementation.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
I am using ServiceDiscovery to publish httpclient/webclient record. But find out connections is not closed. And it consume all my client ports rapidly and report "cannot assgin address" error.
Version
3.9.1 and 4.0.0-M4
reproducer
https://github.com/chinfeng/vertx-conn-leaks-reproducer
Steps to reproduce

run gateway
run foo
visit http://127.0.0.1/foo/metrics in browser
refresh browser, see "open-connections" counter, it grow every refresh and no release at all.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
At the moment AsyncMap-s provided by SharedData have key and value type restrictions: primitive types, java.io.Serializable and io.vertx.core.shareddata.impl.ClusterSerializable. None of these could be used for POJO objects that doesn't implement Serializable (ClusterSerializable is internal interface - so it's very unlikely someone to implement it).
Support for AsyncMap key.value types could be extended using the same approach used in EventBus - by registering codecs. Codecs in both cases could even use the same interface - after all they would serve single concept - serialize and deserialiize custom objects.
Note: If such support is added, vertx could auto register codecs for JsonObject/JsonArray/Buffer instead of implementing ClusterSerializable (which is not public class and seems little strange in the documentation) . Probably ClusterSerializable could be even removed.
I don't see in current SharedData doc any notice which types are supported. And it would be little hard to explain because of internal ClusterSerializable.
Note: Event bus supports byte[]. There's no reason for AsymcMap to do not support byte[] as value type (at least to have similar supported types for event bus and AsyncMap)
Use cases
Having a cluster wide async map with key.value types that are legacy or not in developer control e.g. POJOs.
Contribution
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
java.lang.UnsupportedOperationException: Mapping is not available without Jackson Databind on the classpath
at io.vertx.core.json.jackson.JacksonCodec.fromValue(JacksonCodec.java:79)
at io.vertx.core.json.JsonObject.mapFrom(JsonObject.java:107)
Seems like JsonObject.mapFrom operation still need jackson databind dependency while vertx-core won't automatically import this dependency for 4.0 - m4
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.9.10.3</version>
</dependency>

if we manually add this dependency, it won't throw exceptions
Version
4.0.0 - milestone 4
Context
4.0.0 - milestone 4
Do you have a reproducer?
it happens in our open source project:
https://github.com/whitewoodcity/social-vertex
https://github.com/whitewoodcity/social-vertex/blob/master/src/main/java/cn/net/polyglot/MainVerticle.java
line 42:
config.mergeIn(JsonObject.mapFrom(ar.result()));
if we place a json config file(config.json) and main verticle will load the file and then parse it into json format and it will fail without jackson-databind dependency
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The "VertxImpl.java" constructor method force to create default ClusteredEventBus implementation, there is no way to create my specific implementation.
public class VertxImpl implements VertxInternal, MetricsProvider {
...
 private final EventBusInternal eventBus;
...
 VertxImpl(VertxOptions options, ClusterManager clusterManager, NodeSelector nodeSelector, VertxMetrics metrics, VertxTracer<?, ?> tracer, Transport transport, FileResolver fileResolver) {
 ...
 ...
 this.eventBus = clusterManager != null ? new ClusteredEventBus(this, options, clusterManager, nodeSelector) : new EventBusImpl(this);
 ...
 ...
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The EventBusMetrics#scheduleMessage method was changed to be called on the event-loop in order to avoid incorrect counter in metrics implementations (that needed to compensate and correct the counter value) when a message consumer is unregistered.
It is more interesting to have the event delivered on the thread scheduling the delivery action on the event-loop as it provides a better observation of the latency of a message dispatch after is has been received.
We should compensate a consumer unregistration with a discard message event so the metrics implementation will be aware of this and compensate the actual value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
do you mind backporting to 3 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 3 creates a new instance of io.vertx.core.Context each time it is called from a non Vert.x thread. In Vert.x 4 we use a future model and this model does not work well for code wrapping Vert.x objects and compose them, e.g
public Future<Integer> doSomething() {
  Future<Integer> result1 = getSomeResult();
  Future<Integer> result2 = getOtherResult();
  return CompositeFuture.all(result1, result2).map(this::composteResults);
}
When this is executed from a non Vert.x thread, two contexts will be created and the final result might be on either context.
This feature associates non Vert.x threads with a context the first time a context is created, hence allowing:
new Thread() -> {
  assertEquals(vertx.getOrCreateContext(), vertx.getOrCreateContext());
}).start();
This does is not a breaking change per se, since the getOrCreateContext() method either create or return an existing context. The only affected code will be code that relies on this implementation detail to create contexts instead of using a Verticle.
The implementation uses weak references to keep track of the context in the thread local to allow releasing contexts when the thread ends, although this is not a realistic use case.
Consequently, the trick in the event-bus that uses a specific contexts for ordering messages sent from a non Vert.x thread is not necessary anymore and it can simply use the context without worrying of this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Overall LGTM, and a welcomed change. I'm just really wondering about the opportunity to move createEventLoopContext to the public APIs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Remove the metrics SPI verticleDeployed / verticleUndeployed events. Such events are not really in the scope of what metrics should measure. They are removed in Vert.x 4.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Calling endAwait on the vertx http client causes the program execution to hang and not proceed
Version
3.9.0
Do you have a reproducer?
suspend fun main() {
  val vertx = Vertx.vertx()
  val httpClient = vertx.createHttpClient()
  println("before")
  httpClient.getAbs("https://reqres.in/api/users/1").handler { }.endAwait()
  println("after") // never prints
}

Extra
It does work if I change the endAwait to just end - which might be ok? Not sure if I can call end directly in a suspend function [blocking?]
But even if I call endAwait - after finishing the code in the handler it should proceed to the next line
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Provide an SPI Interface for an executor service that can be used to fulfill executeBlocking requests and Java service load and use an implementation of the SPI that is found on the classpath at runtime.
Use cases
I want to be able to run a Vert.x application in a managed environment that makes use of Vert.x in its implementation to run 'blocking' work asynchronously but I need to be able to control various aspects of the threads and threadpool that is used in order to be able to maintain my requirements on system management, tuning and so on.
As I do not have direct control of the application source code I want to be able to get
Vert.x to use my executor service without making changes to the current Vert.x APIs
or requiring the application to call any new APIs.
I do not want to have a large surface area of new API's for tuning and thread control
in Vert.x that I have to get approved, implement and then call and I also want to ability to handle
more than one Vert.x application that issues executeBlocking calls in the JVM at
one time. I want to be able to externalize my configuration in a way that is idiomatic
to my environment and this can be acheived by encapsulating this in my own implementation
of the SPI.
Similarly, I do not think I have a requirement to interject at the level of the Context class
(or the class that implements executeBlocking). I want to continue to have Vert.x handle
such issues as 'ordered', metrics plug-in points, handler callbacks and so on.
However, SPI insertion 'after' task queueing is too low level, as to maintain recognisable interfaces in the SPI we would probably 'wrap' any Callable/Runnable that gets submitted inorder to retrieve what contexts we needed when it was run.
It may make sense to have the SPI as a vanilla ExecutorService and leave in place
the Vert.x WorkerPool in order for that to handle metrics or other related requirements
but have WorkerPool::executor return the service loaded ExecutorService that has
been loaded off the classpath.
OpenLiberty embedding Vert.x
The first use case I have for this is to use it to enable the @Blocking annotation in
SmallRye Reactive Messaging 2.0+ in the context of the Liberty application server.
Note that as the service loaded ExecutorService may have a thread pool that grows
and shrinks, although Vert.x may schedule ordered=true blocking tasks one at
a time it may not be possible to run all tasks from a single Vert.x context on a the
same thread from the pool.
The SPI could be the standard j.u.c.ExecutorService but it is probably better to have
a Vert.x specific interface that can be used to obtain the ExecutorService as well as to provide better support for 'named' worker pools being backed by the external ExecutorService.
Contribution
All being well with my employer, I would be happy to implement a PR for this feature along with the normal level of test and documentation assets using the standard Vert.x processes.
This is different from #1539 (apologies for typing so much text in that issue)
as this feature is simpler and explicitly avoids API changes in Vert.x
which is a useful feature for our use case.
References
Netty 5
Of interest is that Netty 5 will switch to using a Executor/ExecutorFactory  in place of a ThreadFactory which would enable the loaded ExecutorFactory to be used for all Netty tasks.
( /netty/netty#2250 ). However, according to this "There is currently no clear timeline for Netty5"!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx 3.8.3-3.9.1
Context
listenMulticastGroup isn't ready the first time it is invoked on a vertx instance when its future completes. Delaying for an unusually long time seems to work around the issue.
Do you have a reproducer?
https://github.com/hiddenswitch/udp-broadcast-reproducer
You can use ./gradlew test --tests "udp.broadcast.reproducer.AppTest.testUdpBroadcastResponseInjected"
Steps to reproduce

Create a udp socket (socket "recipient").
Listen to a multicast group.
Send a packet from another udp socket to that group (socket "sender").
Observe that sometimes, the recipient does not receive the message even though the future indicating it is listening has completed.
Observe that injecting the vertx instance using vertx-junit5 100% reproduces the issue on the first invocation when no delay is used between completing the listening future and sending the packet.
Observe that the next invocation, which also uses no delay, even when a different port (multicast group) is listened to, the test passes.
Observe that on my machine, the minimum delay for the first invocation appears to be about 952 +/- 3ms. Not sure of the significance of this.

Extra
Platform: macOS 10.15.5 (Darwin MacBook-Pro.local 19.5.0 Darwin Kernel Version 19.5.0: Thu Apr 30 18:25:59 PDT 2020; root:xnu-6153.121.1~7/RELEASE_X86_64 x86_64)
Java:
openjdk version "13.0.2" 2020-01-14
OpenJDK Runtime Environment (build 13.0.2+8)
OpenJDK 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
At least vertx 3.8.3-3.9.1
Context
listenMulticastGroup throws a NullPointerException when it is called with the listenMulticastGroup(string multicastAddress, Handler<AsyncResult<DatagramSocket>> handler) signature.
Do you have a reproducer?
https://github.com/hiddenswitch/udp-broadcast-reproducer
You can use ./gradlew test --tests "udp.broadcast.reproducer.AppTest.testUdpListensNullInterface"
Steps to reproduce

Create a udp socket (socket "receipient").
Listen to a multicast group with the specified overload.
Observe a null pointer exception (see below).
Observe that heuristically choosing an interface works.

SEVERE: Unhandled exception
java.lang.NullPointerException: networkInterface
	at io.netty.util.internal.ObjectUtil.checkNotNull(ObjectUtil.java:33)
	at io.netty.channel.socket.nio.NioDatagramChannel.joinGroup(NioDatagramChannel.java:409)
	at io.netty.channel.socket.nio.NioDatagramChannel.joinGroup(NioDatagramChannel.java:371)
	at io.netty.channel.socket.nio.NioDatagramChannel.joinGroup(NioDatagramChannel.java:365)
	at io.vertx.core.datagram.impl.DatagramSocketImpl.listenMulticastGroup(DatagramSocketImpl.java:96)
	at udp.broadcast.reproducer.AppTest.lambda$testUdpListensNullInterface$0(AppTest.java:31)
	at io.vertx.junit5.VertxTestContext.lambda$succeeding$1(VertxTestContext.java:182)
	at io.vertx.core.datagram.impl.DatagramSocketImpl.lambda$null$0(DatagramSocketImpl.java:206)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:229)
	at io.vertx.core.net.impl.ChannelFutureListenerAdapter.operationComplete(ChannelFutureListenerAdapter.java:39)
	at io.vertx.core.net.impl.ChannelFutureListenerAdapter.operationComplete(ChannelFutureListenerAdapter.java:24)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(AbstractChannel.java:984)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:566)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:506)
	at io.netty.channel.AbstractChannelHandlerContext.access$900(AbstractChannelHandlerContext.java:61)
	at io.netty.channel.AbstractChannelHandlerContext$8.run(AbstractChannelHandlerContext.java:496)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:830)

Extra
Platform: macOS 10.15.5 (Darwin MacBook-Pro.local 19.5.0 Darwin Kernel Version 19.5.0: Thu Apr 30 18:25:59 PDT 2020; root:xnu-6153.121.1~7/RELEASE_X86_64 x86_64)
Java:
openjdk version "13.0.2" 2020-01-14
OpenJDK Runtime Environment (build 13.0.2+8)
OpenJDK 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
Version
Which version(s) did you encounter this bug ?
4.0.0-milestone5
Context
I encountered an exception which looks suspicious while ...
Do you have a reproducer?
This is my test code:
@RunWith(VertxUnitRunner.class)
public class SimpleRESTVerticleTests {
	private Vertx vertx_;
	private int port = 8081;
	@Before
	public void setup(TestContext context) throws IOException {
		vertx_ = Vertx.vertx();
		// Pick an available and random port number
		ServerSocket socket = new ServerSocket(0);
		port = socket.getLocalPort();
		socket.close();
		//System.out.println("port: "+port);
        DeploymentOptions options = new DeploymentOptions().setConfig(new JsonObject().put("http.port", port));
        vertx_.deployVerticle(SimpleRESTVerticle.class.getName(), options, context.asyncAssertSuccess());		
	}
	@Test
	public void successTest(TestContext context) {
		WebClient client = WebClient.create(vertx_);
		// Send a GET request
		client
		  .get(port, "localhost", "/api/v1/books/book/123")
		  .send(ar -> {
			  System.out.println(">>> SimpleRESTVerticleTests: ar: "+ar);
			  if (!ar.succeeded())
				  System.out.println("SimpleRESTVerticleTests Something went wrong: " + ar.cause().getMessage());
			  context.assertTrue(ar.succeeded());
		      // Obtain response
		      HttpResponse<Buffer> response = ar.result();
			  System.out.println("Status Code: " + response.statusCode());		      
		      context.assertEquals(200, response.statusCode());
		      context.assertTrue(response.body().toString().contains("Vertx HTTP Server"));
		  });		
	}
	@After
	public void tearDown(TestContext context) {
		vertx_.close(context.asyncAssertSuccess());
	}
}

Stack trace:
[INFO] Running com.restapi.vertx.test.SimpleRESTVerticleTests
Jun 05, 2020 8:47:26 PM io.vertx.core.impl.ContextImpl
SEVERE: Unhandled exception
java.lang.AssertionError: Expected true
        at io.vertx.ext.unit.impl.TestContextImpl.reportAssertionError(TestContextImpl.java:362)
        at io.vertx.ext.unit.impl.TestContextImpl.assertTrue(TestContextImpl.java:202)
        at io.vertx.ext.unit.impl.TestContextImpl.assertTrue(TestContextImpl.java:208)
        at com.restapi.vertx.test.SimpleRESTVerticleTests.lambda$successTest$0(SimpleRESTVerticleTests.java:44)
        at io.vertx.ext.web.client.impl.HttpContext.handleFailure(HttpContext.java:303)
        at io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:297)
        at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:269)
        at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
        at io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
        at io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:266)
        at io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:276)
        at io.vertx.ext.web.client.impl.HttpContext.fail(HttpContext.java:256)
        at io.vertx.ext.web.client.impl.HttpContext.lambda$handleSendRequest$8(HttpContext.java:416)
        at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181)
        at io.vertx.core.impl.AbstractContext.lambda$dispatch$0(AbstractContext.java:84)
        at io.vertx.core.impl.EventLoopContext.schedule(EventLoopContext.java:59)
        at io.vertx.core.impl.AbstractContext.schedule(AbstractContext.java:94)
        at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:84)
        at io.vertx.core.impl.FutureImpl.doDispatch(FutureImpl.java:125)
        at io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:119)
        at io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:170)
        at io.vertx.core.http.impl.HttpClientRequestBase.fail(HttpClientRequestBase.java:112)
        at io.vertx.core.http.impl.HttpClientRequestBase.handleException(HttpClientRequestBase.java:107)
        at io.vertx.core.http.impl.HttpClientRequestImpl.handleException(HttpClientRequestImpl.java:87)
        at io.vertx.core.http.impl.HttpClientRequestImpl.lambda$connect$2(HttpClientRequestImpl.java:433)
        at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181)
        at io.vertx.core.http.impl.HttpClientImpl.lambda$getConnectionForRequest$6(HttpClientImpl.java:1292)
        at io.vertx.core.net.impl.clientconnection.Endpoint.lambda$getConnection$0(Endpoint.java:51)
        at io.vertx.core.net.impl.clientconnection.Pool.connectFailed(Pool.java:389)
        at io.vertx.core.net.impl.clientconnection.Pool.access$600(Pool.java:89)
        at io.vertx.core.net.impl.clientconnection.Pool$Holder.lambda$connect$0(Pool.java:130)
        at io.vertx.core.impl.FutureImpl.doDispatch(FutureImpl.java:127)
        at io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:119)
        at io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:170)
        at io.vertx.core.http.impl.HttpChannelConnector.connectFailed(HttpChannelConnector.java:272)
        at io.vertx.core.http.impl.HttpChannelConnector.lambda$doConnect$0(HttpChannelConnector.java:186)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
        at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109)
        at io.vertx.core.net.impl.ChannelProvider.lambda$handleConnect$0(ChannelProvider.java:141)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
        at io.netty.channel.nio.AbstractNioChannel.doClose(AbstractNioChannel.java:502)
        at io.netty.channel.socket.nio.NioSocketChannel.doClose(NioSocketChannel.java:342)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(AbstractChannel.java:759)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:736)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:607)
        at io.netty.channel.nio.NioEventLoop.closeAll(NioEventLoop.java:762)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:524)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.base/java.lang.Thread.run(Thread.java:832)

Jun 05, 2020 8:47:26 PM io.vertx.core.http.impl.HttpClientRequestImpl
SEVERE: java.nio.channels.ClosedChannelException


Link to github project/gist

Steps to reproduce

...
...
...
...

Extra

Anything that can be relevant such as OS version, JVM version
Windows 10

>java -version
java version "14.0.1" 2020-04-14
Java(TM) SE Runtime Environment (build 14.0.1+7)
Java HotSpot(TM) 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using the Vert.x 4.0.0-SNAPSHOT stack with an AdoptOpenJDK 11.0.7 on Ubuntu 20.04. The first time I encountered this was with a Hazelcast-managed distibuted Vertx system (with only one node) with both a standard HTTP server and a vertx-grpc server running on two different ports (both with TLS/SNI enabled). After making a few successful calls to both, I closed the client (cleanly) and I let it rest for a few minutes. Then the console started to output that same error at what seems to be a sub-second interval :
[2020-06-05 13:06:34,190] [WARN] [io.vertx.core.impl.BlockedThreadChecker] [] [vertx-blocked-thread-checker] - Thread Thread[vert.x-eventloop-thread-9,5,main] has been blocked for 1120705 ms, time limit is 2000 ms MDC: {}
io.vertx.core.VertxException: Thread blocked
        at java.base@11.0.7/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1691)
        at app//io.vertx.core.net.impl.clientconnection.ConnectionManager.getConnection(ConnectionManager.java:46)
        at app//io.vertx.core.http.impl.HttpClientImpl.getConnectionForRequest(HttpClientImpl.java:1288)
        at app//io.vertx.core.http.impl.HttpClientRequestImpl.connect(HttpClientRequestImpl.java:422)
        at app//io.vertx.core.http.impl.HttpClientRequestImpl.sendHead(HttpClientRequestImpl.java:258)
        at app//io.vertx.ext.web.client.impl.HttpContext.handleSendRequest(HttpContext.java:501)
        at app//io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:285)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:269)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:266)
        at app//io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:276)
        at app//io.vertx.ext.web.client.impl.HttpContext.sendRequest(HttpContext.java:178)
        at app//io.vertx.ext.web.client.impl.HttpContext.handlePrepareRequest(HttpContext.java:353)
        at app//io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:282)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:269)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:266)
        at app//io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:276)
        at app//io.vertx.ext.web.client.impl.HttpContext.prepareRequest(HttpContext.java:165)
        at app//io.vertx.ext.web.client.impl.HttpRequestImpl.send(HttpRequestImpl.java:318)
        at app//io.vertx.ext.web.client.impl.HttpRequestImpl.send(HttpRequestImpl.java:288)
        at app//io.vertx.reactivex.ext.web.client.HttpRequest.send(HttpRequest.java:694)
        at app//io.vertx.reactivex.ext.web.client.HttpRequest.lambda$rxSend$20(HttpRequest.java:718)
        at app//io.vertx.reactivex.ext.web.client.HttpRequest$$Lambda$314/0x00000008405c5c40.accept(Unknown Source)
        at app//io.vertx.reactivex.impl.AsyncResultSingle.subscribeActual(AsyncResultSingle.java:45)
        at app//io.reactivex.Single.subscribe(Single.java:3603)
        at app//io.reactivex.internal.operators.single.SingleFlatMap.subscribeActual(SingleFlatMap.java:36)
        at app//io.reactivex.Single.subscribe(Single.java:3603)
        at app//io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)
        at app//io.reactivex.Single.subscribe(Single.java:3603)
        at app//io.reactivex.internal.operators.maybe.MaybeFilterSingle.subscribeActual(MaybeFilterSingle.java:40)
        at app//io.reactivex.Maybe.subscribe(Maybe.java:4290)
        at app//io.reactivex.internal.operators.maybe.MaybeMap.subscribeActual(MaybeMap.java:40)
        at app//io.reactivex.Maybe.subscribe(Maybe.java:4290)
        at app//io.reactivex.internal.operators.maybe.MaybeFilter.subscribeActual(MaybeFilter.java:39)
        at app//io.reactivex.Maybe.subscribe(Maybe.java:4290)
        at app//io.reactivex.internal.operators.maybe.MaybeMap.subscribeActual(MaybeMap.java:40)
        at app//io.reactivex.Maybe.subscribe(Maybe.java:4290)
        at app//io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher.subscribeActual(MaybeFlatMapPublisher.java:50)
        at app//io.reactivex.Flowable.subscribe(Flowable.java:14918)
        at app//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable.subscribeActual(FlowableFlatMapCompletableCompletable.java:56)
        at app//io.reactivex.Completable.subscribe(Completable.java:2309)
        at app//io.reactivex.internal.operators.completable.CompletableOnErrorComplete.subscribeActual(CompletableOnErrorComplete.java:35)
        at app//io.reactivex.Completable.subscribe(Completable.java:2309)
        at app//io.reactivex.internal.operators.completable.CompletableToFlowable.subscribeActual(CompletableToFlowable.java:32)
        at app//io.reactivex.Flowable.subscribe(Flowable.java:14918)
        at app//io.reactivex.Flowable.subscribe(Flowable.java:14865)
        at app//io.reactivex.internal.operators.flowable.FlowableRepeat$RepeatSubscriber.subscribeNext(FlowableRepeat.java:101)
        at app//io.reactivex.internal.operators.flowable.FlowableRepeat$RepeatSubscriber.onComplete(FlowableRepeat.java:80)
        at app//io.reactivex.internal.observers.SubscriberCompletableObserver.onComplete(SubscriberCompletableObserver.java:33)
        at app//io.reactivex.internal.operators.completable.CompletableOnErrorComplete$OnError.onError(CompletableOnErrorComplete.java:64)
        at app//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable$FlatMapCompletableMainSubscriber.onError(FlowableFlatMapCompletableCompletable.java:150)
        at app//io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher$FlatMapPublisherSubscriber.onError(MaybeFlatMapPublisher.java:80)
        at app//io.reactivex.internal.operators.maybe.MaybeMap$MapMaybeObserver.onError(MaybeMap.java:94)
        at app//io.reactivex.internal.operators.maybe.MaybeFilter$FilterMaybeObserver.onError(MaybeFilter.java:97)
        at app//io.reactivex.internal.operators.maybe.MaybeMap$MapMaybeObserver.onError(MaybeMap.java:94)
        at app//io.reactivex.internal.operators.maybe.MaybeFilterSingle$FilterMaybeObserver.onError(MaybeFilterSingle.java:98)
        at app//io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onError(SingleMap.java:69)
        at app//io.reactivex.internal.operators.single.SingleFlatMap$SingleFlatMapCallback.onError(SingleFlatMap.java:90)
        at app//io.vertx.reactivex.impl.AsyncResultSingle.lambda$subscribeActual$0(AsyncResultSingle.java:56)
        at app//io.vertx.reactivex.impl.AsyncResultSingle$$Lambda$75/0x000000084015f040.handle(Unknown Source)
        at app//io.vertx.reactivex.ext.web.client.HttpRequest$10.handle(HttpRequest.java:699)
        at app//io.vertx.reactivex.ext.web.client.HttpRequest$10.handle(HttpRequest.java:694)
        at app//io.vertx.ext.web.client.impl.HttpContext.handleFailure(HttpContext.java:303)
        at app//io.vertx.ext.web.client.impl.HttpContext.execute(HttpContext.java:297)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:269)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:69)
        at app//io.vertx.ext.web.client.impl.predicate.PredicateInterceptor.handle(PredicateInterceptor.java:32)
        at app//io.vertx.ext.web.client.impl.HttpContext.next(HttpContext.java:266)
        at app//io.vertx.ext.web.client.impl.HttpContext.fire(HttpContext.java:276)
        at app//io.vertx.ext.web.client.impl.HttpContext.fail(HttpContext.java:256)
        at app//io.vertx.ext.web.client.impl.HttpContext.lambda$handleSendRequest$8(HttpContext.java:416)
        at app//io.vertx.ext.web.client.impl.HttpContext$$Lambda$320/0x00000008405c4440.handle(Unknown Source)
        at app//io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181)
        at app//io.vertx.core.impl.AbstractContext.lambda$dispatch$0(AbstractContext.java:84)
        at app//io.vertx.core.impl.AbstractContext$$Lambda$131/0x0000000840214c40.handle(Unknown Source)
        at app//io.vertx.core.impl.EventLoopContext.schedule(EventLoopContext.java:59)
        at app//io.vertx.core.impl.AbstractContext.schedule(AbstractContext.java:94)
        at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:84)
        at app//io.vertx.core.impl.FutureImpl.doDispatch(FutureImpl.java:125)
        at app//io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:119)
        at app//io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:170)
        at app//io.vertx.core.http.impl.HttpClientRequestBase.fail(HttpClientRequestBase.java:112)
        at app//io.vertx.core.http.impl.HttpClientRequestBase.handleException(HttpClientRequestBase.java:107)
        at app//io.vertx.core.http.impl.HttpClientRequestImpl.handleException(HttpClientRequestImpl.java:87)
        at app//io.vertx.core.http.impl.HttpClientRequestImpl.lambda$connect$2(HttpClientRequestImpl.java:433)
        at app//io.vertx.core.http.impl.HttpClientRequestImpl$$Lambda$323/0x00000008405c3040.handle(Unknown Source)
        at app//io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181)
        at app//io.vertx.core.http.impl.HttpClientImpl.lambda$getConnectionForRequest$6(HttpClientImpl.java:1292)
        at app//io.vertx.core.http.impl.HttpClientImpl$$Lambda$324/0x00000008405c3440.handle(Unknown Source)
        at app//io.vertx.core.net.impl.clientconnection.Endpoint.lambda$getConnection$0(Endpoint.java:51)
        at app//io.vertx.core.net.impl.clientconnection.Endpoint$$Lambda$329/0x00000008405c1840.handle(Unknown Source)
        at app//io.vertx.core.net.impl.clientconnection.Pool.connectFailed(Pool.java:389)
        at app//io.vertx.core.net.impl.clientconnection.Pool.access$600(Pool.java:89)
        at app//io.vertx.core.net.impl.clientconnection.Pool$Holder.lambda$connect$0(Pool.java:130)
        at app//io.vertx.core.net.impl.clientconnection.Pool$Holder$$Lambda$332/0x00000008405c0840.handle(Unknown Source)
        at app//io.vertx.core.impl.FutureImpl.doDispatch(FutureImpl.java:127)
        at app//io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:119)
        at app//io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:170)
        at app//io.vertx.core.http.impl.HttpChannelConnector.connectFailed(HttpChannelConnector.java:272)
        at app//io.vertx.core.http.impl.HttpChannelConnector.lambda$doConnect$0(HttpChannelConnector.java:186)
        at app//io.vertx.core.http.impl.HttpChannelConnector$$Lambda$347/0x000000084060d440.operationComplete(Unknown Source)
        at app//io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
        at app//io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)
        at app//io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
        at app//io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
        at app//io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
        at app//io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109)
        at app//io.vertx.core.net.impl.ChannelProvider$1.userEventTriggered(ChannelProvider.java:113)
        at app//io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:346)
        at app//io.netty.channel.AbstractChannelHandlerContext.invokeUserEventTriggered(AbstractChannelHandlerContext.java:332)
        at app//io.netty.channel.AbstractChannelHandlerContext.fireUserEventTriggered(AbstractChannelHandlerContext.java:324)
        at app//io.netty.handler.ssl.SslUtils.handleHandshakeFailure(SslUtils.java:347)
        at app//io.netty.handler.ssl.SslHandler$5.run(SslHandler.java:2058)
        at app//io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)
        at app//io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)
        at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
        at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
        at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
        at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.base@11.0.7/java.lang.Thread.run(Thread.java:834)

Now I get it everytime I let the system run overnight. I'm the sole user of the system.
Does this ring a bell ? I can't try to use it with the 3.x stack because the Vertx-grpc has a completely different codebase fo 4.0.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we can have this however it should be named get following the same pattern than JsonObject and JsonArray uses
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vertx-web 3.9.1, but it seems present since 3.8.3
Context
The documentation in https://vertx.io/docs/vertx-web/java/#_routing_by_paths_that_begin_with_something mentions that a route with path /some/path/* should match a request to /some/path but it does not. It did match before (at least in version 3.7.1) and thus this bug introduces a backwards incompatible change, in addition to the mismatch with the documentation.
I believe this was introduced in vert-x3/vertx-web@628f49c
Do you have a reproducer?
Can be reproduced with https://github.com/gabrielguernikatdiscovery/vertx-path-matching-issue/blob/220c7496629783e51fad90be4e24ccb541a007f2/src/test/java/io/vertx/starter/MainVerticleTest.java#L31
Steps to reproduce

With vertx-web, add a route with a path ending in /*, eg, router.route("/some/path/*"); and a proper handler
Make a request to /some/path
HTTP 200 should be returned
Actually, HTTP 404 is returned

Extra

Nothing relevant
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you do a PR for 3.9 as well ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixes #3444
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
On the master branch but also on 4.0 milestones and 3.9.1
Context
mvn clean install fails as the testcase testListenInvalidPort assumes that it is
not possible to bind to port 7 (echo). It is possible on OSX.
Do you have a reproducer?
on OSX 'mvn clean install' on the master branch of this project
commit 76418f2 (HEAD -> fix_testListenInvalidPort_On_OSX, my_fork/fix_testListenInvalidPort_On_OSX)
Will fail.
Steps to reproduce

Get a macbook
Clone this repo
'mvn clean install'

Extra
mvn -v
Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-04T20:00:29+01:00)
Maven home: /Users/hutchig/apache-maven-3.6.1
Java version: 14.0.1, vendor: AdoptOpenJDK, runtime: /Library/Java/JavaVirtualMachines/adoptopenjdk-14.jdk/Contents/Home
Default locale: en_GB, platform encoding: UTF-8
OS name: "mac os x", version: "10.15.5", arch: "x86_64", family: "mac"
java -version
openjdk version "14.0.1" 2020-04-14
OpenJDK Runtime Environment AdoptOpenJDK (build 14.0.1+7)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 14.0.1+7, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
reported by @zenios
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jponge Hi Julien, can you please take a look at this simple change?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks @hutchig !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
Version
vertx-core: 3.8.5
vertx-web: 3.8.5
vertx-web-client: 3.8.5
Context
Vertx web client sends server cookies back in multiple COOKIE headers and not anymore in a single semicolon separated field.
As a result server handle only one cookie. It cause authentication/session issue.
Do you have a reproducer?
https://github.com/VMalko/vertx-cookie-test.git
There is cookieTest which fails as server handle only one cookie ("testName", "testValue")
Steps to reproduce

clone test project
execute cookieTest. Check that web client sends to server http endpoint "/cookieCheck" cookies back in multiple COOKIE headers and not anymore in a single semicolon separated field.
As a result server handle only one cookie ("testName", "testValue").

It is implemented with Vertx server. But external production server do the same - handle only one cookie.
Extra
HTTP protocol version 1.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ? 3.9.1
Context
When using the setSubProtocols method defined in WebSocketConnectOptions and passing those options to rxWebSocket, I expect the websocket request to contain the sub protocols I specified. However, vert.x does instead send the sec-websocket-protocol header in the handshake set to null.
Do you have a reproducer?
No, but should be trivially reproduced in a test.
Steps to reproduce

Define WebSocketConnectOptions with websocket sub protocol.
Establish WebSocket connection with some server.
Print headers in server, you'll see "sec-websocket-protocol" -> "null" among other valid WebSocket handshake headers.

Extra

Java 11, OpenJDK, macOS Catalina
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Add control over websocket headers case
Version
I use quarkus 1.4.1.Final
The related vertx version is :  3.8.5
And it uses the netty-all:5.0.0.Alpha2
Context
Netty set all the headers with the lower case. e.g : sec-websocket-key.
I have a PHP websocket server the handle the header with a specific case :
// check Sec-WebSocket-Key header was received and decoded value length is 16
    if (!isset($headersKeyed['Sec-WebSocket-Key']))
      return false;
This is why I got  : original problem
This is related to this post
An interesting read about headers case : this post
Do you have a reproducer?
Steps to reproduce

Have a WebSocket server which handle the headers is specific case way (PHP in my case)
Create a websocket client with vert.x
Try to make a connection

In whireshark I ve seen that I don't get the 101 Switch Protocol response as expected.
This is due to the wrong header case
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version 3.9.1
Context
I set the max worker execution time at Vertx creation as such:
new VertxOptions()
.setMaxWorkerExecuteTime(500).setMaxWorkerExecuteTimeUnit(TimeUnit.MILLISECONDS)
but then found these warnings in the logs:
Thread Thread[X-threadpool-19,5,main]=Thread[X-threadpool-19,5,main] has been blocked for 12 ms, time limit is 0 ms

on a worker executor created with default options:
WorkerExecutor executor = vertx.createSharedWorkerExecutor("X-threadpool");
This is because the short version of the createSharedWorkerExecutor method uses the specified time amount, but the default time unit. This can be fixed by applying the patch below.
diff --git a/src/main/java/io/vertx/core/impl/VertxImpl.java b/src/main/java/io/vertx/core/impl/VertxImpl.java
index b591fb575..efbfc9887 100644
--- a/src/main/java/io/vertx/core/impl/VertxImpl.java
+++ b/src/main/java/io/vertx/core/impl/VertxImpl.java
@@ -1092,7 +1092,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
 
   @Override
   public synchronized WorkerExecutorImpl createSharedWorkerExecutor(String name, int poolSize, long maxExecuteTime) {
-    return createSharedWorkerExecutor(name, poolSize, maxExecuteTime, TimeUnit.NANOSECONDS);
+    return createSharedWorkerExecutor(name, poolSize, maxExecuteTime, maxWorkerExecTimeUnit);
   }
 
   @Override
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.0
Context
Using the io.vertx.core.net.PfxOptions it is possible to provide a "password". However, later on, in io.vertx.core.net.impl.KeyStoreHelper.create(VertxInternal, KeyCertOptions) this single password is being used for both opening the "key store" as well as opening the "entry" in the key store. However, this can be two different passwords.
So it is not possible to use an existing keystore, which has a different (or missing) password for one of the entries.
Do you have a reproducer?
import java.io.ByteArrayOutputStream;
import java.security.KeyStore;
import java.security.cert.Certificate;

import io.netty.handler.ssl.util.SelfSignedCertificate;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.impl.VertxInternal;
import io.vertx.core.net.KeyCertOptions;
import io.vertx.core.net.PfxOptions;
import io.vertx.core.net.impl.KeyStoreHelper;

public class Application7 {
    public static void main(String[] args) throws Exception {

        var cert = new SelfSignedCertificate();

        final KeyStore result = KeyStore.getInstance("PKCS12");
        result.load(null, null);
        result.setKeyEntry("alias", cert.key(), "foo".toCharArray(), new Certificate[] {cert.cert()});

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        result.store(out, "bar".toCharArray());

        var vertx = Vertx.factory.vertx();
        var opts = new PfxOptions()
                .setPassword("foo")
                .setValue(Buffer.buffer(out.toByteArray()));
        var ks = KeyStoreHelper.create((VertxInternal) vertx, (KeyCertOptions)opts);

    }
}
Steps to reproduce

Run the reproducer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
stack trace
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 2: /C:/Users/***/target/classes/PathForCodeGenProcessor.class
at sun.nio.fs.WindowsPathParser.normalize (WindowsPathParser.java:182)
at sun.nio.fs.WindowsPathParser.parse (WindowsPathParser.java:153)
at sun.nio.fs.WindowsPathParser.parse (WindowsPathParser.java:77)
at sun.nio.fs.WindowsPath.parse (WindowsPath.java:92)
at sun.nio.fs.WindowsFileSystem.getPath (WindowsFileSystem.java:229)
at java.nio.file.Path.of (Path.java:147)
at java.nio.file.Paths.get (Paths.java:69)
at io.vertx.codegen.CodeGenProcessor.fetchSourcePath (CodeGenProcessor.java:152)
at io.vertx.codegen.CodeGenProcessor.loadJsonMappers (CodeGenProcessor.java:197)
at io.vertx.codegen.CodeGenProcessor.init (CodeGenProcessor.java:67)
at com.sun.tools.javac.processing.JavacProcessingEnvironment$ProcessorState. (JavacProcessingEnvironment.java:678)
at com.sun.tools.javac.processing.JavacProcessingEnvironment$DiscoveredProcessors$ProcessorStateIterator.next (JavacProcessingEnvironment.java:778)
at com.sun.tools.javac.processing.JavacProcessingEnvironment.discoverAndRunProcs (JavacProcessingEnvironment.java:873)
at com.sun.tools.javac.processing.JavacProcessingEnvironment$Round.run (JavacProcessingEnvironment.java:1214)
at com.sun.tools.javac.processing.JavacProcessingEnvironment.doProcessing (JavacProcessingEnvironment.java:1326)
at com.sun.tools.javac.main.JavaCompiler.processAnnotations (JavaCompiler.java:1258)
at com.sun.tools.javac.main.JavaCompiler.compile (JavaCompiler.java:936)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The CaseInsensitiveMultiMap implementation duplicates the logic currently in VertxHttpHeaders. The VertxHttpHeaders class is renamed to HeadersMultiMap and uses an optional validator for the entries and can be used instead CaseInsensitiveMultiMap.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you give a proper explanation of what is changed and the reason
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.1
Context
When reading a big number from a JsonObject the result may overflow.
I expect it to fail when it happens. Currently it succeeds silently with wrong value returned.
I believe this is dangerous for the majority of the use-cases. Same applies for JsonArray.
Do you have a reproducer?
var json = new JsonObject("{\"amount\": 21474836470}");
long a1 = json.getLong("amount");    // 21474836470
int  a2 = json.getInteger("amount"); // -10

var array = new JsonArray("[21474836470]");
int a3 = array.getInteger(0); // -10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
do you mind back port to 3.9 branch @mihaico ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Currently, HttpClient does support PUT, POST DELETE and GET. the PATCH method is not supported.
Use cases
Use the HTTPClient to submit patches through the JSON Patch format, using the corresponding HTTP verb.
Contribution
Pr incoming
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
as PATCH is quite rare to use, we haven't included it by default to keep the interface readable.
You can use the generic HttpClient#send(RequestOptions) method and RequestOptions has an HTTP method on it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Note; I see that
  private Buffer append(String str, Charset charset) 

  private Buffer setBytes(int pos, String str, Charset charset)
these method needs some love ,(especially the latter) to save the intermediate allocation to happen but Netty is lacking some util method to make it easy, so I'm deferring fixing these until Netty will be fixed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Http2ServerResponseImpl need some refactoring as well to reduce the need to allocate BufferImpl instances
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vert.x 4.0.0 M5
Context
We use Prometheus both for vert.x and application metrics. So our POM includes:
		<dependency>
			<groupId>io.micrometer</groupId>
			<artifactId>micrometer-registry-prometheus</artifactId>
			<version>${micrometer.version}</version>
		</dependency>

With micrometer.version = 1.3.5 all works, when upgrading to 1.5.1 (current version) vert.x start fails:
Exception in thread "vert.x-eventloop-thread-24" java.lang.NoSuchMethodError: io/micrometer/prometheus/PrometheusConfig.requireValid()V (loaded from file:/Users/stephan/.m2/repository/io/micrometer/micrometer-registry-prometheus/1.5.1/micrometer-registry-prometheus-1.5.1.jar by sun.misc.Launcher$AppClassLoader@edc88549) called from class io.micrometer.prometheus.PrometheusMeterRegistry (loaded from file:/Users/stephan/.m2/repository/io/micrometer/micrometer-registry-prometheus/1.5.1/micrometer-registry-prometheus-1.5.1.jar by sun.misc.Launcher$AppClassLoader@edc88549).
	at io.micrometer.prometheus.PrometheusMeterRegistry.<init>(PrometheusMeterRegistry.java:64)
	at io.micrometer.prometheus.PrometheusMeterRegistry.<init>(PrometheusMeterRegistry.java:58)
	at io.vertx.micrometer.backends.PrometheusBackendRegistry.<init>(PrometheusBackendRegistry.java:45)
	at io.vertx.micrometer.backends.BackendRegistries.lambda$setupBackend$0(BackendRegistries.java:71)
	at io.vertx.micrometer.backends.BackendRegistries$$Lambda$59.000000007CA4AE20.apply(Unknown Source)
	at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660)
	at io.vertx.micrometer.backends.BackendRegistries.setupBackend(BackendRegistries.java:58)
	at io.vertx.micrometer.impl.VertxMetricsFactoryImpl.metrics(VertxMetricsFactoryImpl.java:46)
	at io.vertx.core.impl.VertxFactory.createMetrics(VertxFactory.java:135)
	at io.vertx.core.impl.VertxFactory.vertx(VertxFactory.java:78)
	at io.vertx.core.Vertx.vertx(Vertx.java:86)
	at com.hcl.domino.keep.Launch.lambda$9(Launch.java:235)
	at com.hcl.domino.keep.Launch$$Lambda$41.000000007BD8F820.handle(Unknown Source)
	at io.vertx.core.impl.VertxImpl$1$1.lambda$operationComplete$0(VertxImpl.java:865)
	at io.vertx.core.impl.VertxImpl$1$1$$Lambda$56.000000007951F1D0.run(Unknown Source)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:819)

Steps to reproduce

Add dependency as above with version 1.5.1
Configure vert.x to run with micrometer

private static MicrometerMetricsOptions getMetricsOptions(final JsonObject config) {
    // Performance metrics using Micrometer

    final JsonObject promMetricsConfig =
        config.getJsonObject("prometheusMetrics", new JsonObject());
    final Integer port =8890;
    final HttpServerOptions serverOptions = new HttpServerOptions();
    serverOptions.setPort(port);
    final VertxPrometheusOptions prometheusOptions = new VertxPrometheusOptions(promMetricsConfig)
        .setEmbeddedServerOptions(serverOptions);
    final JsonObject metricsConfig = new JsonObject();
    final MicrometerMetricsOptions metricsOptions = new MicrometerMetricsOptions(metricsConfig)
        .setPrometheusOptions(prometheusOptions)
        .setEnabled(true);
    return metricsOptions;
  }

 options.setMetricsOptions(metricsOptions);
              final Vertx vertx = Vertx.vertx(options);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think there is an typo-kind of error in HttpChannelConnector when assigning http1Weight and http2Weight. HTTP/1.1 weight is using the HTTP/2 pool size, and things are inverted for HTTP/2 as well.
    this.http1Weight = options.getHttp2MaxPoolSize();
    this.http2Weight = options.getMaxPoolSize();
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java#L86-L87
Version
3.9.1 but seems 3.8.5 has the same code so maybe earlier versions are impacted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The metrics SPI supports metrics reported by Vert.x HTTP client. We should abstract this interface so any kind of client performing a request/response can report events that can be derived to compute request/response latencies.
The HTTP client metrics will be reworked to use this generic client metric interface. The endpoint lifecycle is replaced by the usage of the ClientMetrics interface and thus ClientMetrics are created and destroyed when endpoint are created / destroyed by the HTTP client.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While upgrading https://github.com/folio-org/okapi from Vert.x 4.0.0 milestone 4 to milestone 5, we noticed a serious issue with HttpClient connections being thread blocked.. It seems to appear when connection can not be made to a remote host. Using same client and issuing another request that also fails results in a thread blocked warning and a halt of the event loop..
openjdk version "1.8.0_252"
OpenJDK Runtime Environment (build 1.8.0_252-8u252-b09-1ubuntu1-b09)
OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)
and
openjdk version "14.0.1" 2020-04-14
OpenJDK Runtime Environment (build 14.0.1+7-Ubuntu-1ubuntu1)
OpenJDK 64-Bit Server VM (build 14.0.1+7-Ubuntu-1ubuntu1, mixed mode, sharing)
Host: Ubuntu 20.04 amd64
Log:

[INFO] Running org.folio.okapi.common.HttpClientDoubleFail
10:54:37 WARN  ?                    Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 2883 ms, time limit is 2000 ms
10:54:38 WARN  ?                    Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 3883 ms, time limit is 2000 ms
10:54:39 WARN  ?                    Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 4883 ms, time limit is 2000 ms
10:54:40 WARN  ?                    Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 5883 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at io.vertx.core.net.impl.clientconnection.ConnectionManager.getConnection(ConnectionManager.java:46) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientImpl.getConnectionForRequest(HttpClientImpl.java:1288) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.connect(HttpClientRequestImpl.java:422) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.write(HttpClientRequestImpl.java:614) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.end(HttpClientRequestImpl.java:527) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.end(HttpClientRequestImpl.java:521) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at org.folio.okapi.common.HttpClientDoubleFail.lambda$test$2(HttpClientDoubleFail.java:45) ~[test-classes/:?]
	at org.folio.okapi.common.HttpClientDoubleFail$$Lambda$34/1409160703.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.AbstractContext.lambda$dispatch$0(AbstractContext.java:84) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.AbstractContext$$Lambda$52/1790422902.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.EventLoopContext.schedule(EventLoopContext.java:59) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.AbstractContext.schedule(AbstractContext.java:94) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:84) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.handleException(HttpClientRequestImpl.java:97) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl.lambda$connect$2(HttpClientRequestImpl.java:433) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientRequestImpl$$Lambda$37/2097905212.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:181) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientImpl.lambda$getConnectionForRequest$6(HttpClientImpl.java:1292) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpClientImpl$$Lambda$38/1265900909.handle(Unknown Source) ~[?:?]
	at io.vertx.core.net.impl.clientconnection.Endpoint.lambda$getConnection$0(Endpoint.java:51) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.net.impl.clientconnection.Endpoint$$Lambda$43/2130192211.handle(Unknown Source) ~[?:?]
	at io.vertx.core.net.impl.clientconnection.Pool.connectFailed(Pool.java:389) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.net.impl.clientconnection.Pool.access$600(Pool.java:89) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.net.impl.clientconnection.Pool$Holder.lambda$connect$0(Pool.java:130) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.net.impl.clientconnection.Pool$Holder$$Lambda$46/1046834544.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.FutureImpl.doDispatch(FutureImpl.java:127) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.FutureImpl.dispatch(FutureImpl.java:119) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.impl.FutureImpl.tryFail(FutureImpl.java:170) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpChannelConnector.connectFailed(HttpChannelConnector.java:272) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpChannelConnector.lambda$doConnect$0(HttpChannelConnector.java:186) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.http.impl.HttpChannelConnector$$Lambda$51/1800691917.operationComplete(Unknown Source) ~[?:?]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.vertx.core.net.impl.ChannelProvider.lambda$handleConnect$0(ChannelProvider.java:141) ~[vertx-core-4.0.0-milestone5.jar:4.0.0-milestone5]
	at io.vertx.core.net.impl.ChannelProvider$$Lambda$50/214530301.operationComplete(Unknown Source) ~[?:?]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:702) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.49.Final.jar:4.1.49.Final]
	at java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_252]
10:54:41 WARN  ?                    Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 6884 ms, time limit is 2000 ms

Test case:
RunWith(VertxUnitRunner.class)
public class HttpClientFail2Test {
  private Vertx vertx;

  @Before
  public void setUp(TestContext context) {
    vertx = Vertx.vertx();
  }

  @After
  public void tearDown(TestContext context) {
    vertx.close(context.asyncAssertSuccess());
  }

  @Test
  public void test(TestContext context) {
    Async async = context.async();

    HttpClient client = vertx.createHttpClient();
    HttpClientRequest req1 = client.request(
        new RequestOptions().setAbsoluteURI("http://localhost:9292"))
        .exceptionHandler(res1 -> {
          HttpClientRequest req2 = client.request(
              new RequestOptions().setAbsoluteURI("http://localhost:9292"))
              .exceptionHandler(res2 -> async.complete())
              .onSuccess(res2 -> {
                context.fail("unexpected success; something running?");
                async.complete();
              });
          req2.end();
        })
        .onSuccess(
            res1 -> {
              context.fail("unexpected success; something running?");
              async.complete();
            });
    req1.end();
    async.await(5000);
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HTTP client retrying the same host on a failure can self deadlock because it will close the pool after it performs the callback. It should close the pool before so when it retries and fail it does not retry indefinitely.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
There is a bug with multi-file uploads.It may be changed the length of a boundary token.Occasional.
Version
3.9.1
Example
The client
        var request = WebClient.create(Vertx.vertx()).postAbs("http://localhost:8080/test");

        for (var i = 0; i < 50; i++) {

            var body = MultipartForm.create();

            body.binaryFileUpload("files", "1.jpg", "/tmp/xx/a.jpg", "image/jpeg");
            body.binaryFileUpload("files", "2.jpg", "/tmp/xx/b.jpg", "image/jpeg");

            request.sendMultipartForm(body, r -> {

                if (r.failed()) {
                    System.err.println(r.cause());
                    return;
                }
                System.out.println(r.result());
            });
        }
The server(springboot:2.3.1.RELEASE)
    @ResponseBody
    @RequestMapping("/test")
    public Map<String, Object> mail(@RequestParam(value = "files", required = false) MultipartFile[] files) {
        return Collections.EMPTY_MAP;
    }
The error
org.apache.tomcat.util.http.fileupload.MultipartStream$IllegalBoundaryException: The length of a boundary token cannot be changed
	at org.apache.tomcat.util.http.fileupload.MultipartStream.setBoundary(MultipartStream.java:459)
	at org.apache.tomcat.util.http.fileupload.impl.FileItemIteratorImpl.findNextItem(FileItemIteratorImpl.java:244)
	at org.apache.tomcat.util.http.fileupload.impl.FileItemIteratorImpl.<init>(FileItemIteratorImpl.java:131)
	at org.apache.tomcat.util.http.fileupload.FileUploadBase.getItemIterator(FileUploadBase.java:255)
	at org.apache.tomcat.util.http.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:279)
 ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?
vertx-core:3.9.1
Context
We want to use vert.x for HTTP/2 client to connect to a HTTP/2 service.
We are using a single HttpClient's instance to send multiple requests to HTTP/2 service. We observe that if we send multiple GET requests, they get processed but if we send multiple POST requests, only the first one gets processed and the latter ones fail.
Do you have a reproducer?
Yes, i have a reproducer uploaded to github repo : https://github.com/sandeep14-singh/vertxpoc.git
Please read "Steps to reproduce" section  to see how to reproduce this issue from this project

Link to github project/gist
https://github.com/sandeep14-singh/vertxpoc.git

Steps to reproduce

Kindly pull the code : git clone https://github.com/sandeep14-singh/vertxpoc.git
Open the project "vertxpoc" in intellij
Under the project, open "Application" class and run it. This will bring up a HTTP/2 enabled server : https://localhost:8443. We are using Micronaut framework, which brings up the server with self signed certificate.
Goto chrome and perform a quick check to see if HTTP/2 is enabled or not : Open a new tab in chrome, press F12 and open Network tab After this, type in "https://localhost:8443/demo/testGet" in address bar and hit enter.
After this, hit "Advanced" and "Proceed to localhost (unsafe)". You should see the response "Test succeeded on GET" and on you should also see the protocol "h2" being used in the Network tab.
Open VertxGetClient class and run it. This class sends 2 GET requests and they get processed all fine -- this is good enough.
Open VertxPostClient class and run it. This class sends 2 POST requests and the first one gets processed but the second one does not. We get :
Jul 01, 2020 7:31:01 AM io.vertx.core.http.impl.HttpClientRequestImpl
SEVERE: io.vertx.core.VertxException: Connection was closed
In the documentation "https://vertx.io/docs/vertx-core/java/", under "HTTP/2 multiplexing", its stated that :
"HTTP/2 connections will not be closed by the client automatically. To close them you can call close or close the client instance."
So, in our use case also, we do not want to close the connection.
We want to have single connection to send multiple requests, i was hoping this could be achieved by using single client to send multiple requests as shown the project but its not working

Extra
We are using openjdk1.8
Question :
Please confirm if this is a bug. If this is not a bug, please let us know what are we doing wrong in terms of configurations etc.
Please tell us how we can have single connection to send multiple requests. We were hoping this could be achieved by using single client to send multiple requests as shown the project but its not working.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The default HTTP client redirection strategy will decode the redirect location and interpret any percent encoded URL. It should keep the redirect location intact when resolving the URI reference.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently @DataObject annotated are only considered as data object when they provide both a serializer and deserializer which leads to incorrect error message reporting. When a class is annotated and does not provide serializer + deserialized then it should still carry a data object with null serializer and deserializer.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
POSTing many buffers to an echoing server gives thread blocked failures when we use drainHandler+writeQueueFull approach.
The same POST with write and a completion handler does not.
Write with handler is a much simpler strategy, but from documentation it's not clear whether it's an alternative for drainHandler. In any case we cannot explain our thread blocked problems with drainHandler.
What's the best strategy for writing?
Environment
Using vertx-core-4.0.0-milestone4 on Ubuntu 20.04 LTS amd64.
Reproducer
Below is a unit test with test methods drainHandler and  writeHandler. Each test sends 10 times 2 GB to an echoing server (part of unit test).
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientRequest;
import io.vertx.core.http.HttpClientResponse;
import io.vertx.core.streams.Pump;
import io.vertx.core.streams.WriteStream;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import java.util.concurrent.atomic.AtomicLong;

@RunWith(VertxUnitRunner.class)
public class WriteTest {
  Vertx vertx;
  int port = 9210;

  @Before
  public void setUp(TestContext context) {
    vertx = Vertx.vertx();
    vertx.createHttpServer()
        .requestHandler(h -> {
          h.response().setChunked(true);
          h.endHandler(x -> h.response().end());
          Pump.pump(h, h.response()).start();
        }).listen(port, context.asyncAssertSuccess());
  }

  @After
  public void tearDown(TestContext context) {
    vertx.close();
  }

  @Test
  public void drainHandler(TestContext context) {
    testUpload(context, true);
  }

  @Test
  public void writeHandler(TestContext context) {
    testUpload(context, false);
  }

  private void testUpload(TestContext context, boolean useDrain) {
    int bufSz = 200000;
    long bufCnt = 10000;
    long total = bufSz * bufCnt;
    HttpClient client = vertx.createHttpClient();
    for (int loop = 0; loop < 10; loop++) {
      System.out.println("Sending " + total / 1e9 + " GB");
      Async async = context.async();
      HttpClientRequest request = client.postAbs("http://localhost:" + port, res1 -> {
        context.assertTrue(res1.succeeded());
        HttpClientResponse res = res1.result();
        context.assertEquals(200, res.statusCode());
        AtomicLong cnt = new AtomicLong();
        res.handler(h -> cnt.addAndGet(h.length()));
        res.exceptionHandler(ex -> {
          context.fail(ex);
          async.complete();
        });
        res.endHandler(end -> {
          context.assertEquals(total, cnt.get());
          async.complete();
        });
      });
      request.exceptionHandler(ex -> {
        context.fail(ex.getCause());
        async.complete();
      });
      request.putHeader("Content-Type", "text/plain");
      request.setChunked(true);
      Buffer buffer = Buffer.buffer();
      for (int j = 0; j < bufSz; j++) {
        buffer.appendString("X");
      }
      request.setWriteQueueMaxSize(16384);
      if (useDrain) {
        endRequestDrainHandler(request, buffer, 0, bufCnt);
      } else {
        endRequestWriteHandler(request, buffer, 0, bufCnt);
      }
      async.await(50000);
    }
  }

  void endRequestWriteHandler(WriteStream<Buffer> req, Buffer buffer, long i, long cnt) {
    if (i < cnt) {
      req.write(buffer, res -> endRequestWriteHandler(req, buffer, i + 1, cnt));
      return;
    }
    req.end();
  }

  void endRequestDrainHandler(WriteStream<Buffer> req, Buffer buffer, long i, long cnt) {
    req.drainHandler(null);
    while (i < cnt) {
      req.write(buffer);
      i++;
      long next = i;
      if (req.writeQueueFull()) {
        req.drainHandler(res -> endRequestDrainHandler(req, buffer, next, cnt));
        return;
      }
    }
    req.end();
  }
}

Output
Example run:
mvn -Dtest=WriteTest#drainHandler test`

Sending 2.0 GB
Sending 2.0 GB
12:44:27 WARN  ?                    Thread Thread[vert.x-eventloop-thread-6,5,main] has been blocked for 2662 ms, time limit is 2000 ms
12:44:28 WARN  ?                    Thread Thread[vert.x-eventloop-thread-6,5,main] has been blocked for 3663 ms, time limit is 2000 ms
12:44:29 WARN  ?                    Thread Thread[vert.x-eventloop-thread-6,5,main] has been blocked for 4663 ms, time limit is 2000 ms
12:44:30 WARN  ?                    Thread Thread[vert.x-eventloop-thread-6,5,main] has been blocked for 5663 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.isNotWritable(Http1xClientConnection.java:383) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.HttpClientRequestImpl.writeQueueFull(HttpClientRequestImpl.java:221) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at WriteTest.endRequestDrainHandler(WriteTest.java:105) ~[test-classes/:?]
	at WriteTest.lambda$endRequestDrainHandler$8(WriteTest.java:106) ~[test-classes/:?]
	at WriteTest$$Lambda$98/596706728.handle(Unknown Source) ~[?:?]
	at io.vertx.core.http.impl.HttpClientRequestImpl.handleDrained(HttpClientRequestImpl.java:344) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.handleWritabilityChanged(Http1xClientConnection.java:436) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.Http1xClientConnection$$Lambda$74/255332034.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:183) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.impl.EventLoopContext.lambda$execute$0(EventLoopContext.java:42) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.impl.EventLoopContext$$Lambda$39/347978868.run(Unknown Source) ~[?:?]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:510) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:518) ~[netty-transport-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_252]
12:44:31 WARN  ?                    Thread Thread[vert.x-eventloop-thread-6,5,main] has been blocked for 6664 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.isNotWritable(Http1xClientConnection.java:383) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.HttpClientRequestImpl.writeQueueFull(HttpClientRequestImpl.java:221) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at WriteTest.endRequestDrainHandler(WriteTest.java:105) ~[test-classes/:?]
	at WriteTest.lambda$endRequestDrainHandler$8(WriteTest.java:106) ~[test-classes/:?]
	at WriteTest$$Lambda$98/596706728.handle(Unknown Source) ~[?:?]
	at io.vertx.core.http.impl.HttpClientRequestImpl.handleDrained(HttpClientRequestImpl.java:344) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.Http1xClientConnection$StreamImpl.handleWritabilityChanged(Http1xClientConnection.java:436) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.http.impl.Http1xClientConnection$$Lambda$74/255332034.handle(Unknown Source) ~[?:?]
	at io.vertx.core.impl.AbstractContext.emit(AbstractContext.java:183) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.impl.EventLoopContext.lambda$execute$0(EventLoopContext.java:42) ~[vertx-core-4.0.0-milestone4.jar:4.0.0-milestone4]
	at io.vertx.core.impl.EventLoopContext$$Lambda$39/347978868.run(Unknown Source) ~[?:?]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:510) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:518) ~[netty-transport-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.42.Final.jar:4.1.42.Final]
	at java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_252]

Running
mvn -Dtest=WriteTest#writeHandler test

always completes and memory usage is low.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I did a general refresh of the documentation @julianladisch 6124eb7
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
when upload a nonascii named file, there's a field "filename*" in "Content-Disposition" header , then vertx will throw IllegalCharsetNameException
Version
3.8.5
Context
Content-Disposition: form-data; name="eml"; filename="Reminder_ Join the ...Postman 101... Webinar on June 30.eml"; filename*="UTF-8''Reminder_%20Join%20the%20%E2%80%9CPostman%20101%E2%80%9D%20Webinar%20on%20June%2030.eml".
Content-Type: message/rfc822.
Do you have a reproducer?
allways
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
original encounter: 3.8.5
reproducer: 3.9.1
Context
I encountered a suspicious "500 Internal Server Error" when trying to add a "vary" response header with multiple header names in the value using the method add(CharSequence name, Iterable<CharSequence> values) of the MultiMap interface. Trying to create a reproducer (see below) revealed the following exception:
java.lang.ClassCastException: io.netty.util.AsciiString cannot be cast to java.lang.String
        at io.vertx.core.http.impl.headers.VertxHttpHeaders.add(VertxHttpHeaders.java:93)

Do you have a reproducer?
https://github.com/hjhill/vertx-maven-starter/tree/reproducer-multimap-add
master contains the default starter project - please take care to checkout the branch reproducer-multimap-add. In this branch, I have only modified the request handler..
Steps to reproduce

Check out the branch reproducer-multimap-add of the Github repository linked above.
Run it with mvn compile exec:java (see below about using test)
Use any tool to create an HTTP request to http://localhost:8080.

The request will hang and you'll see the exception on the console.
Even simpler: if you use mvn test exec:java the exception will already show up in the test, but the test will then be hanging indefinitely.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.nio.channels.AsynchronousFileChannel (with callback) is faster
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I get the following error when I do setup an HttpClient with ALPN enabled, talking with TLS to an HTTP2 server:
io.vertx.core.http.impl.Http2ClientConnection cannot be cast to io.vertx.core.http.impl.Http1xClientConnection 

This can be reproduce with the following test case (in WebSocketTest.java):
  @Test
  public void testTlsClientWebSocketWithHttp2Server() throws Exception {
    HttpClientOptions clientOptions = new HttpClientOptions();
    // true => error
    // false => works okay
    clientOptions.setUseAlpn(true);
    clientOptions.setSsl(true);
    clientOptions.setTrustAll(true);
    clientOptions.setAlpnVersions(Arrays.asList(HttpVersion.HTTP_2,
                                                HttpVersion.HTTP_1_1));
    //clientOptions.setHttp2ClearTextUpgrade(false);
    client = vertx.createHttpClient(clientOptions);

    HttpServerOptions serverOptions =
      new HttpServerOptions().setPort(DEFAULT_HTTPS_PORT);
    serverOptions.setSsl(true);
    serverOptions.setUseAlpn(true);
    serverOptions.setSni(true);
    //serverOptions.setAlpnVersions(Arrays.asList(HttpVersion.HTTP_2,
    //                                            HttpVersion.HTTP_1_1));
    //serverOptions.setTrustOptions(Cert.SERVER.get());
    serverOptions.setKeyCertOptions(Cert.SERVER_PEM.get());
    server = vertx.createHttpServer(serverOptions);
    server.requestHandler(req -> {
      req.response().setChunked(true).write("connect");
    });
    server.webSocketHandler(ws -> {
      ws.writeFinalTextFrame("ok");
    });
    server.listen(onSuccess(server -> {
      client.request(new RequestOptions().setPort(DEFAULT_HTTPS_PORT)
                                         .setHost(DEFAULT_HTTPS_HOST))
            .onComplete(onSuccess(req -> {
              req.onComplete(onSuccess(resp -> {
                WebSocketConnectOptions wsOptions =
                  new WebSocketConnectOptions();
                //wsOptions.setSsl(true);
                wsOptions.setPort(DEFAULT_HTTPS_PORT);
                wsOptions.setHost(DEFAULT_HTTPS_HOST);
                wsOptions.setURI("/");
                client.webSocket(wsOptions,
                                 onSuccess(ws -> {
                  ws.handler(buff -> {
                    assertEquals("ok", buff.toString());
                    testComplete();
                  });
                }));
              })).end();
            }));
    }));
    await();
  }
I must admit, I was a bit surprised to see that HTTP/2 going on for the websocket connection establishment, IIRC the websocket ConnectionManager in the HttpClient is explicitely configured to mandate HTTP/1.1.
So I was wondering, given that the Vert.x websocket client is bound to HTTP/1.1 (no RFC 8441 support yet), if ALPN should also be disabled automatically for websocket connections...
BTW, I tried this test on the master branch of this repo (Vert.x 4), but I'm seeing the exact same message on Vert.x 3.9.2.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context
Today I noticed that if you set status code after writing to Http1xServerResponse, the status code will be discarded silently. Seems like Http2ServerResponseImpl does check if the header is already written before setting status code: 
  
    
      vert.x/src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
    
    
         Line 158
      in
      b8e58e5
    
  
  
    

        
          
           checkHeadWritten(); 
        
    
  


This confuses me a lot. I think an early exception would be better in this case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Feature description
Provide a DSL (domain specific language) that can be used to execute chain sync and async methods on a context object.  The context object contains the state and provides business methods to manipulate that state.
Sync logic is provided in a classical methods, with the constraint that methods returns void and the outcome is reflexed in the state of the context object.
Async logic is split in 2 business methods.  The first method contains all logic leading up to the async call that gets a Handler<AsyncResult> that is needed to execute the 'technical' async method and in general stops when the technical methods is called.  The second business method is invoked when the result is ready and should processes it, not returning any value but reflex it in the state of the context object.
An example of such an context object:
class Ctx {
    private final String path;
    private String output;

    public void syncBusiness()  { ... }

    public void startAsyncBusiness(Future<HttpResponse<Buffer>> next) { 
        WebClient.create(vertx).get(path).send(next);
    }

    public void processAsyncBusinessResult(HttpResponse<Buffer> result) {
        output = result.body().toString();
    }
 }
Vert.x provides a interface, with implementation, to chain the operations as a simple sequence but also in more complex ways like loops, conditional, ...
An example of such a chaining:
Sequencer.start(new TxnCtx(txn))
    .startVoid(TxnCtx::retrieveInfo)
    .startVoid(TxnCtx::setupConfigParams)
    .split(TxnCtx::getTokenContexts)
    .startAndProcessAsync(TxnTokenCtx::startCreateToken, TxnTokenCtx::processCreateTokenResult)
        .when(TxnTokenCtx::requireSignature)
            .startVoid(TxnTokenCtx::signToken)
        .end()
        .when(TxnTokenCtx::requireEncryption)
            .startVoid(TxnTokenCtx::retrievePublicKeyFromState)
            .when(TxnTokenCtx::requireFetchingOfPublicKeyFromServer)
                .startAndProcessAsync(TxnTokenCtx::startFetchPublicKeyFromServer, TxnTokenCtx::processFetchPublicKeyFromServerResult)
                .startVoid(TxnTokenCtx::savePublicKeyInState)
            .end()
            .startVoid(TxnTokenCtx::encryptToken)
        .end()
    .endForEach(TxnCtx::addTokenToParams)
    .startVoid(TxnCtx::calcBaseUrl)
    .when(TxnCtx::requiresQueryString)
        .startAndProcessAsync(TxnCtx::startCreateQueryString, TxnCtx::processCreateQueryStringResult)
    .end()
    .when(TxnCtx::requiresBody)
        .startAndProcessAsync(TxnCtx::startCreateBody, TxnCtx::processCreateBodyResult)
    .end()
    .finish(TxnCtx::toOperationResponse, response);
Use cases
Async programming is complicated, handlers do not make for very readable code.  Async Coordination helps, but has it limitations.  RxJava2 is a more complete solution but (to my personal flavor) is a little too complex; both when it comes to writing code and understanding the result.
The proposed DSL aims to simply but rich async programming by levering the capabilities of Vert.x core.  The objective is to protect the developer using Vert.x from the difficulties of async programming and result in code that resembles regular programming as much as possible.
Contribution
As you can see from the examples, I have an implementation that I'm willing to share but it definitely needs some refinement and feedback on naming and extra features.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current implementation does copy ByteBuf when it is a direct buffer or a composite buffer. This can produce buffer with a bound max capacity in some cases (e.g chunked encoded HTTP/1 over SSL that slices the HTTP/1 buffer to produce ByteBuf chunks). Such buffers cannot be appended to resulting in trying to write a bounded buffer and throwing a java.lang.IndexOutOfBoundsException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Buffer wrapping a ByteBuf with a bound maxCapacity (usually obtained from a slice operation) should copy the ByteBuf on any operation requiring to increase the capacity larger than the maxCapacity.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We can perform several optimisation of the Buffer usage of the internal ByteBuf.
The Buffer implementation holds a reference on an unreleasable wrapper of the original ByteBuf. The getByteBuf() implementation returns a duplicate of this reference that will duplicate the original ByteBuf and then wrap it with an unreleasable wrapper again. The Buffer can instead hold directly a reference to the original ByteBuf and have the getByteBuf() method returns an unreleasable wrapper of the duplicate, the returned ByteBuf will be the same than in the current case (an unreleasable wrapper of a duplicate). This avoid to instantiate an unreleasable wrapper then a Buffer is created. In addition most Buffer operations will be faster as they will operate on the original ByteBuf instead of the unreleasable wrapper.
In addition the Buffer implementation can optimistically cast Buffer arguments when possible (e.g Buffer#appendBuffer(Buffer)) and use the ByteBuf references instead of calling getByteBuf() resulting in less faster operations and avoid unnecessary unreleasable wrapper duplication.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?

io.vertx:vertx-core:3.9.2
io.vertx:vertx-web-graphql:3.9.2
com.graphql-java:graphql-java:15.0

Context
Trying to implement a GraphQL subscription I'm getting the following error when executing the query (and recieving a 500)
Exception in thread "vert.x-eventloop-thread-1":
java.util.concurrent.CompletionException: io.vertx.core.json.EncodeException: Failed to encode as JSON: No serializer found for class graphql.execution.reactive.CompletionStageMappingPublisher and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.LinkedHashMap["data"])
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:645)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.postFire(CompletableFuture.java:610)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:649)
	at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478)
	at io.vertx.ext.web.handler.graphql.impl.GraphQLHandlerImpl.lambda$null$9(GraphQLHandlerImpl.java:288)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: io.vertx.core.json.EncodeException: Failed to encode as JSON: No serializer found for class graphql.execution.reactive.CompletionStageMappingPublisher and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.LinkedHashMap["data"])
	at io.vertx.core.json.jackson.JacksonCodec.toBuffer(JacksonCodec.java:176)
	at io.vertx.core.json.JsonObject.toBuffer(JsonObject.java:832)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642)
	... 14 more
Here is some code to reproduce
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.subjects.PublishSubject;

PublishSubject<Sign> provider = PublishSubject.create();
Flowable<Sign> publisher = provider.toFlowable(BackpressureStrategy.BUFFER);

RuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()
        .type("Subscription", wiring -> wiring
            .dataFetcher("subscribeSigns", environment -> publisher)
         ).build();

provider.onNext(obj);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Heap Buffer created with Unpooled.buffer(...) are instrumented and maintain a reference counting. This reference counting requires to wrap the current ByteBuf duplicate with an unreleasable wrapper so that the returned duplicate will not affect the actual ByteBuf hold by BufferImpl.
We can optimize these buffers by using instead custom subclasses of UnpooledHeapByteBuf and UnpooledUnsafeHeapByteBuf instead to avoid un-necessary operations. Such classes will be un-instrumented and reference counting methods can be overridden to disable reference counting which avoids to wrap the ByteBuf duplicate with an unreleasable wrapper.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The 3.x NetSocket upgrade API is not entirely satisfying.
This API is synchronous on the server and performs pipeline modifications. This can be racy when using a worker server processor as the pipeline might be decoding buffers while the request handler decides to obtain a NetSocket. We should offer an asynchronous API for this feature.
The HTTP/1.x implementation works for arbitrary requests and the HTTP/2 is restricted to HTTP/2 . The HTTP/1.1 should follow the HTTP/2 behavior, since the API should be used creating TCP tunnels with the client and should not be used otherwise. We might offer in the future to turn an HttpConnection into a NetSocket allowing such behavior instead.
The method will be renamed toNetSocket and back-ported in 3.x as a simple delegate to the existing API. The existing API will be deprecated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The 3.x WebSocket API upgrade is not entirely satisfying.
This API is synchronous on the server and performs pipeline modifications. This can be racy when using a worker server processor as the pipeline might be decoding buffers while the request handler decides to obtain a WebSocket. We should offer an asynchronous API for this feature.
The implementation shall also be improved to buffer the upgrade request in the toWebSocket method instead of being done in Http1xServerRequestHandler. This allow request handlers set to receive all HTTP events when the application decides to not call toWebSocket.
The method will be renamed toWebSocket and back-ported in 3.x as a simple delegate to the existing API. The existing API will be deprecated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #3564
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See #3562
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are a few methods impacting the HTTP response head (like setStatusCode(int)), such methods should throw an exception when the response head has already been written.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP client WebSocket configuration inherits from the client options configuration. When the client options configures ALPN, the WebSocket configuration will therefore try to establish an HTTP/2 connection, when it succeeds it will not work since WebSocket assumes HTTP/1.1 to be used.
The WebSocket configuration should force the usage of ALPN to false.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Shared data local lock maintains a list of waiters, entries are evicted from this list when on lock release. When a lock times out, it does not remove the entry from the list and instead relies on the cooperation of the lock owners to remove the entry from the list. We can improve this and evict the waiter from the waiters list when the timeout fires.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@tsegismont I updated the eviction to handle all cases properly, I haven't added yet tests for such case but I will try (it's not obvious to do so).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
does it need to be in 3.9.3 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Observation
When using vertx HttpClientOptions with the SSL setForceSni option, the server name indicated in the first message of the SSL handshake is the host as specified on the request.
Expectation
Shall be possihble to indicate the server name explicitly.  Example API usage below with "setServerNameIndicator".  This allows a single address to be used with multiple individual server certificates, while avoiding DNS server changes to provision all the different server names.
RequestOptions options = new RequestOptions()
.setMethod(HttpMethod.PUT)
.setHost("proxy.provider.com")
.setPort(8081)
.setURI("/proxy");

HttpClientRequest request = client.request(options);

HttpClientOptions clientOptions = new HttpClientOptions();
clientOptions.setProtocolVersion(HttpVersion.HTTP_2);
clientOptions.setSsl(true);
clientOptions.setUseAlpn(true);
clientOptions.setForceSni(true);
clientOptions.setServerNameIndicator("verizon.provider.com");

Version
3.9.1 and 4.0.0 mil5
Context
Running secure HTTP2 requests into HttpServer with SNI.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'll retry in a better way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When an HTTP client request has been reset soon after it was scheduled, the client will assume that the request was sent and emit a reset event to the metrics implementation. The metrics implementation truthfully assume that a request begin event was previously emitted and it might not be the case leading to an unexpected state. We should only emit a reset event when an HTTP request object has been created.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.2
Context
Websocket converted to a FlowableReadStream no longer signals completion if the socket is closed without the receipt of a close frame.  We noticed this because our metrics told us that we were "leaking" web socket connections after we switched to Vert.x 3.9.x.  The decrement of the value used for this gauge occurs when the FlowableReadStream created from a web-socket (using FlowableHelper.toFlowable) completes for any reason.  However, this is no longer occurring when the socket is closed due to an idle timeout in our Nginx layer.
Do you have a reproducer?
https://gist.github.com/sfitts/395223e48491782e5837378772bc95bf
The referenced test passes on 3.8.5 and fails on 3.9.2.
Extra
This behavior change is due to the fact that the "endHandler" is no longer invoked as part of explicit close processing.  That change was made in commit -- 763b9b5.  Note that prior to this the endHandler was invoked during handleClosed, now it is only invoked on the receipt of an explicit close frame.
If the new behavior is expected/correct, then the FlowableReadStream will need to be modified so that it can terminate when a close occurs in this manner (I'm not sure if it can since I don't see any place to hook when that happens).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
At the moment there is no way to attach arbitrary data to the HttpServerRequest. If you are using Vert.x Web the RoutingContext has the ability to store arbitrary data in the context, it would be very helpful if this was also added to the HttpServerRequest (with the routing context changed so it's attributes are backed by the request, so you don't have two attribute maps).
Some of the use cases we have for this in Quarkus:

The metrics object that is created by io.vertx.core.spi.metrics.HttpServerMetrics#requestBegin is not available to any handlers that want to add data to it, and there is no way to propagate it to these handlers. If we had an attribute map we could store it as an attribute.
We have a QuarkusRequestWrapper that adds some extra functionality (such as configurable SameSite support for cookies), but there is no way to access this object once it has been passed into the router (as the router also wraps the request). If there was an attribute map this would be much easier (at the moment we use a fake Cookie implementation and use the cookies map as an attribute map).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Team ,
please look DSL-JSON library as default option for data binding instead of jackson , its quite faster for serialization/deserialization
https://github.com/ngs-doo/dsl-json
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've applied the "fixes" from the comments and added a few extra checks:

on close, if the shutdown hook is null, avoid enter a synchronized block.
the shutdown hook thread, will not spawn a new thread with deadline to delete the cache if a delete is already in progress.
the resolve file operation will throw ISE if the cache dir is being deleted

All validation tests pass on my side + the issue that was used to identify the problem (vertx-web tests) also pass on my side (no leaks of caches to the CWD or TMP.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
When I use the following code
NetServer server = vertx.createNetServer();
server.connectHandler(socket -> {
  socket.handler(buffer -> {
    System.out.println("I received some bytes: " + buffer.length());
  });
});
The objects I receive are always of type Buffer,Is it possible to add a configuration item to be able to add netty decoders,and adding a method to the NetSocket interface to receive the decoded object.
NetSocket handlerMessage(Handler<Object> obj);
It works like this
    NetServer server = vertx.createNetServer();

    server.configureChannelPipeline(pipeline->{
      //pipeline is io.netty.channel.ChannelPipeline
      pipeline.addFirst("myDecoder", new MyDecoder());
    });

    server.connectHandler(socket -> {
      socket.handlerMessage(msg -> {
        //msg is of type Object
        if(msg instanceof CustomMessage){
          //...
        }
      });
    });
Or is there a way to implement this feature in the current version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj when this PR is approved, I will merge it and cherry-pick to 3.9 branch. Then I will update the master branch to bump the protocol version.
See the Proposal section of #3406.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
This issue has been reproduced in Quarkus, but looks Vert.x specific.
In this use case, the HTTP verticle (start the HTTP server) instances (depending on the machine, but 8 in my case) are configured to listen on the port 0 (so dynamic binding). At the same time as the HTTP verticle start, an MQTT client is created and connect to an MQTT server.
The HTTP server cannot bind to the port, failing with a Bind exception.
Version
The code works with Quarkus 1.7 (Vert.x 3.8.5) and fails with Quarkus 1.8.1 (Vert.x 3.9.2).
Do you have a reproducer?
Reproducer available on:
smallrye/smallrye-reactive-messaging#778
Steps to reproduce

Download an unzip
Start MQTT server - docker run -p 8080:8080 -p 1883:1883 hivemq/hivemq4
mvn compile quarkus:dev
Boom

You can override the Vert.x version by declaring a dependency in the pom.xml file.
Extra

if you start the MQTT client before or after it works
if you debug, it works - probably a timing exception
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation of read/write metric events reports a single event with the total length when the stream lifecycle ends. While this is a correct way to proceed, it lacks of accuracy when streaming happens.
We can improve this behavior and instead report a read/write metric event when the accumulated value gets above a threshold (4K). e.g instead of reporting 17K at once, we might instead report (4K, 8K, 4K, 1K).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you have a look @jotak ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jotak here is the PR for the changes we discussed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj I think there was still an issue with metrics, here's a fix
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
If we set the server to a larger number of max concurrent threads like 250 streams, and only send 100 requests on the webclient, which is using a max pool size of 8, it seems that 8 connections are created instead of using the single connection for all the streams.
Version
3.9.1
Context
See reproducer
Do you have a reproducer?
A reproducer is a simple project hosted on GitHub (or another forge supporting git clone operation) that has a build file that can be executed to reproduce the issue.
Reproducers are very helpful for contributors and will likely help them fixing your bug faster.
https://github.com/pantinor/vertx.issues/blob/main/issues/src/test/java/vertx/demo/StreamsVertxOnlyTest.java
Steps to reproduce
Run the test above, note the failure on the assertion for expecting 1 connection instead of 8.
Extra

Anything that can be relevant such as OS version, JVM version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x provides specialized usage of KeyStore for loading KeyCertOptions and TrustOptions as JksOptions and PfxOptions.
Sometimes it can be desirable to use another implementation such as the ones provided by Bouncy Castle. We can add a more generic KeyStoreOptions to serve that purpose.
Fixes also #3262
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PTAL @pmlopes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
for the moment we cannot accept this as we would like this to avoid using @GenIgnore
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Currently it is only possible to pass DeploymentOptions().setInstances(int x) when deployVerticle(String var1, DeploymentOptions var2) is used. In other words if you have a verticle that has non default empty constructor you can not deploy multiple instaces using DeploymentOptions().setInstances(int x) as you will get error: Can't specify > 1 instances for already created verticle
To bypass this you can create a for loop like this:
for(int i = 0; i < x; i++) {
  vertx.deployVerticle(new SomeVerticle(object1, object2), new DeploymentOptions());
}

Also if you are using javarx2 you can do something like this:
vertx.rxDeployVerticle(new SomeVerticle(object1, object2),
                new DeploymentOptions())
                .repeat(x)
                .toList()
                .ignoreElement();

I would suggest to allow this via DeploymentOptions().setInstances(int x) as clearly end result is same and I don't see the point having this exception.
Expected to work after enhancement:
vertx.deployVerticle(new SomeVerticle(object1, object2), new DeploymentOptions().setInstances(int x));
@pmlopes mentioned on gitter that it is possible to achieve in vertx 4 with Supplier API.
vertx.deployVerticle(() -> new SomeVerticle(object1, object2), deploymentOptions)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClient and HttpServer are omitting to send a WebSocket close frame when a connection a WebSocket. When an HTTP connection is closed, the connection should close the underlying WebSocketBase in order to send the close frame instead of merely closing the HTTP connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx-core: 3.8.5
vertx-web: 3.8.5
vertx-web-client: 3.8.5
Context
We have noticed that WebClient HttpRequest.sendStream() hangs when Server close connection
There are a few steps to catch it:

Execute WebClient HttpRequest.sendStream (https://vertx.io/docs/kdoc/vertx/io.vertx.ext.web.client/-http-request/send-stream.html) to send body as stream to external server. In our case it is Vertx HttpServer.
After some time external HttpServer close connection by some reason (machine restarted/fall down or idleTimeout is reached).
We expect to see that client will catch error "connection was closed". But there are no any errors and client simply hangs... and waiting for response...

That is really strange for us because other method HttpRequest.sendBuffer catch it.
Reproducer
See project on github. Class WebClientSendStreamTest.java and method uploadStreamRequestTest()
https://github.com/VMalko/vertx-send-stream/blob/master/src/test/java/WebClientSendStreamTest.java
Steps to reproduce

Execute method uploadStreamRequestTest() of class WebClientSendStreamTest.java
After 2 sec HttpServer will close connection
Client will hangs on it...
...

Extra
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cool thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using io.vertx:vertx-core:3.9.3 and I have some code in a Verticle that looks similar to this:
assert Vertx.currentContext() == context;
vertx.deployVerticle(someVerticle, new DeploymentOptions().setWorker(true), result -> {
  assert Vertx.currentContext() == context; // <-- AssertionError is thrown here
  ...
});
The second assertion sometimes fails. I expect deployVerticle() to always call the completion handler in the context from where it was called. Was this assumption wrong or is this a bug in Vert.x? The Javadoc does not say anything about it but here is a quote from the manual:

When you call any other methods that takes a handler on a core API from an event loop then Vert.x will guarantee that those handlers, when called, will be executed on the same event loop.

I also noticed that the assertion only seems to fail when the deployment fails with the following reason.

Verticle deployment failed.Could not be added as child of parent verticle

In my experience, this means that the Verticle where I call the method was stopped. When the assertion fails, the context returned by Vertx.currentContext() outside and inside the completion handler are named like EventLoopContext@35d0ced2 and io.vertx.core.impl.WorkerContext@1bf4c13e respectively. (Maybe Vert.x calls the handler from the context of the worker which was about to be started?)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
vertx 4.0.0.beta3
As part of contextual data flow we found that insight inboundInterceptor event, vertx context is null. Following unit test that reproduce the issue:
package io.vertx.ext.contextual.tracing;

import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.impl.ContextInternal;
import io.vertx.core.logging.Log4j2LogDelegateFactory;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;

@ExtendWith(VertxExtension.class)
class EventBusTest2 {
	static{
		System.setProperty("vertx.logger-delegate-factory-class-name",
				Log4j2LogDelegateFactory.class.getName());	
	}
	
	private static final String EVENT_ADDRESS = ".eventbus.test1";
	private static final String CONTEXTUAL_KEY = "val";
	
	private static Logger logger = LogManager.getLogger(EventBusTest2.class);
	
	private static class TestVerticle extends AbstractVerticle {
		
		private static Logger internalLogger = LogManager.getLogger(TestVerticle.class);
		private VertxTestContext testContext;
		
		public TestVerticle(VertxTestContext testContext) {
			this.testContext = testContext;
		}
		
		@Override
		public void start(Promise<Void> startPromise) throws Exception {
			vertx.eventBus().addInboundInterceptor(event ->{
				var value = event.message().headers().get(CONTEXTUAL_KEY);
				if(null != value) {
					logger.trace("put value: {} to context", value);
					put(CONTEXTUAL_KEY, value);
					if(null == Vertx.currentContext()) {
						logger.trace("No context found");
					}
				}
				event.next();
			});
			
			vertx.eventBus().consumer(EVENT_ADDRESS).handler(msg -> {
				logger.trace("msg:{}", msg.body());
				var expected = msg.body().toString();
				var actual = get(CONTEXTUAL_KEY);
				try {
					Assertions.assertEquals(expected, actual, CONTEXTUAL_KEY);
					testContext.completeNow();
				} catch(Throwable t) {
					testContext.failNow(t);
				}
			});
			
			startPromise.complete();
		}
	}
	
	@BeforeEach
	void setUp(Vertx vertx) throws Exception {
		
	}

	@Test
	void testPublish(Vertx vertx, VertxTestContext context) {
		logger.trace("testPublish");
		vertx.runOnContext(nil -> {
			vertx.eventBus().addOutboundInterceptor(event-> {
				var value = get(CONTEXTUAL_KEY);
				if(null != value) {
					logger.trace("put contextual value: {} to header", value);
					event.message().headers().add(CONTEXTUAL_KEY, value);
				}
				event.next();
			});
			vertx.deployVerticle(new TestVerticle(context))
			.map(id -> {
				String value = UUID.randomUUID().toString();
				put(CONTEXTUAL_KEY, value);
				logger.trace("publish:{}", value);
				vertx.eventBus().publish(EVENT_ADDRESS, value);
				return null;
			});
		});	
	}
	
	@Test
	void testSend(Vertx vertx, VertxTestContext context) {
		logger.trace("testSend");
		vertx.runOnContext(nil -> {
			vertx.eventBus().addOutboundInterceptor(event-> {
				var value = get(CONTEXTUAL_KEY);
				if(null != value) {
					logger.trace("put contextual value: {} to header", value);
					event.message().headers().add(CONTEXTUAL_KEY, value);
				}
				event.next();
			});
			vertx.deployVerticle(new TestVerticle(context))
			.map(id -> {
				String value = UUID.randomUUID().toString();
				put(CONTEXTUAL_KEY, value);
				logger.trace("send:{}", value);
				vertx.eventBus().send(EVENT_ADDRESS, value);
				return null;
			});
		});	
	}
	
	private static String put(String key, String value) {
		Objects.requireNonNull(key);
		Objects.requireNonNull(value);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx == null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Attempt to set contextual data from a non Vert.x thread");
			}
			return null;
		} else {
			return contextualDataMap(ctx).put(key, value);
		}
	}

	public static String get(String key) {
		Objects.requireNonNull(key);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx != null) {
			return contextualDataMap(ctx).get(key);
		}
		return null;
	}
	
	private static ConcurrentMap<String, String> contextualDataMap(ContextInternal ctx) {
		Objects.requireNonNull(ctx);
		return (ConcurrentMap<String, String>) ctx.localContextData().computeIfAbsent(EventBusTest2.class, k -> new ConcurrentHashMap<String,String>());
	}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.2
Context
Graphite uses a dot . to separate metric paths into folders. So a metric such as vertx.http.servers.<host>:<port> will be separated into vertx / http / servers / <host>:<port>.
The problem is with the worker thread pool name that is being set in io.vertx.core.impl.VertxImpl:
PoolMetrics workerPoolMetrics = metrics != null ? metrics.createPoolMetrics("worker", "vert.x-worker-thread", options.getWorkerPoolSize()) : null;
Because it uses "vert.x" instead of "vertx" like in other places, it will create the wrong folder structure -
vertx/ pools / worker /vert / x-worker-thread
It would be much better if the dot can be removed from names that are used in metrics.
Extra
I am using vertx-dropwizard-metrics.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@pmlopes this is a draft PR for allowing the creation of an (internal) FileSystem that resolve resources using a classloader.

the FileResolver was refactored to encapsulate cache operations in a FileCache class so 2 instances of a FileResolver will use the same instance to access the Vert.x resolver cache.
the FileSystem was updated to use FileResolver instead of VertxInternal#resolveFile
VertxInternal now can create a FileSystem using a class loader, this shall be used by StaticHandler when passed a class loader
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Verticle deployment has been using the implicit thread context classloader for the VerticleFactory and the io.vertx.core.Context class loader. This classloader is used indirectly by code that needs to resolve file in some places (e.g HttpServerResponse#sendFile(String)). Until now the only possibility to use a specific classloader was the set a temporary thread context classloader in some places (such as deploying a verticle or sending a file).
The DeploymentOptions will now hold an optional classloader that will be passed to the VerticleFactory and associated with the Context. When no classloader is provided, the current thread context classloader is used.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@pmlopes @cescoffier this is the deployment context classloader PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Small improvement to code readability when dealing with Maps/Multimaps
When I want to store a map (after filter, map etc) into a JsonObject I can write
Map myMap = .....;
JsonObject result;

myMap.forEach(result::put);

with a MultiMap I need to write:
MultiMap myMultiMap = .....;
JsonObject result;

myMultiMap.forEach(entry -> result.put(entry.getKey(), entry.getValue());

Letting JsonObject.put accept an Entry<String, Object> would make code for Map and Multimap look similar/nicer
Of course having MultiMap emit (k,v) would be more universal, but a breaking change (which might not be worth it_
Use cases
Clean code
Contribution
I could give it a stab
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am trying to upgrade my vertx 3.6.3 app to vertx 4 and I noticed that there is one issue that might be a problem in this vertx change.
It moved io.vertx.core.spi.VertxFactory to io.vertx.core.impl.VertxFactory, but the file in META-INF/ is still called io.vertx.core.spi.VertxFactory, so, whenever I call ServiceHelper.loadFactory(VertxFactory.class); I get

Cannot find META-INF/services/io.vertx.core.impl.VertxFactory on classpath

Shouldn't the file be renamed too?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping @jotak
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there any reverse proxy solution available from Vertx like Netflix zuul?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Enhance RecordParser to support customer protocols
just like what LengthFieldBasedFrameDecoder in netty does
in vertx 3.9.3
I have used this way to parser my customer protocol that contains length fields in the header
public class ParserVerticle extends AbstractVerticle {
  RecordParser parser = RecordParser.newFixed(4);
  int length = -1;
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    parser.setOutput(b -> {
      if (length == -1){
        length = b.getInt(0);
        parser.fixedSizeMode(length);
      }else {
        String s = b.toString(StandardCharsets.UTF_8);
        System.out.println(s);
        parser.fixedSizeMode(4);
        length = -1;
      }
    });
    byte[] b1 = "dreamlike".getBytes(StandardCharsets.UTF_8);
    byte[] b2 = "ocean".getBytes(Charset.defaultCharset());
    Buffer buffer = Buffer.buffer().appendInt(b1.length + b2.length).appendBytes(b1);
    parser.handle(buffer);
    //Simulate chunk transfer
    parser.handle(Buffer.buffer(b2));
  }
}
Use cases
A more elegant way to parse it
Contribution
I don't have the ability to finish itsorry
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Hey folks, I've seen there have been some important fixes in latest master regarding WebSockets -- I think some of the latest fixes fix some issues I've seen in production. Would it be possible to cut a new beta release? The last one, 4.0.0.Beta3, was released almost two months ago.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
The CVE affects vertx 3.4 through 3.9.4 and all 4.x pre-GA releases including beta1, beta2 and beta3
https://nvd.nist.gov/vuln/detail/CVE-2019-17640
Context
The CVE was issued on Oct 15th. We need to upgrade our dependency to a version that has a fix. The related ticket https://bugs.eclipse.org/bugs/show_bug.cgi?id=567416 shows status resolved but there isn't a release with a fix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Don't disable resource leak detector in netty if the netty system property for the resource leak detector is set. Vertx disables it in a static initializer and it would be best that before disabling it checks if io.netty.leakDetection.level is set. If it is set, then vertx won't disable the resource leak detector.
Use cases
This is useful for those folks that want to check that no resource leaks are ever found in their code using the current vertx release as well as future releases.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Read me
As a user of WebClient, I would like the ability to configure the local source port in addition to the local address, in cases where a ephemeral source port is not acceptable in deployed production environment.
Describe the feature
Addition of setLocalPort on WebClientOptions
Use cases
Some servers may have firewall rules in place that limit certain ports or ranges by the source port of the request.
Contribution
It would be best if the vertx team could implement the feature.  If you need assist for us to contribute please let me know, and provide a pointer or brief description of where this addition is most appropriate for implementing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Vert.x Session issue set-cookie header at per request after session.regenerateId() method invoked
Version
4.0.0.Beta3
Context
final User user = res.result();
ctx.setUser(user);
if (session != null) {
session.regenerateId();
String returnUrl = session.remove(returnURLParam);
if (returnUrl != null) {
ResponseUtils.success(ctx, new JsonObject().put("returnUrl", returnUrl));
}
}
ctx.end("login success");
Steps to reproduce

session.regenerateId();
next request protected restful api always issue set-cookie header

Extra
I think SessionHandlerImpl flush session after remove old session, should set session.renewed = false.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
The VertxImpl implementation uses a ThreadLocal called stickyContext to propagate the context when getOrCreateContext or getContext are called outside of a pool of vert.x threads.
However, there are other ways that the state can be propagated in other executor pools. For example, effect libraries such as Monix have their own way of propagating state local to an execution with TaskLocal -- this is an equivalent mechanism to the context locals that vert.x uses internally to work around the limitation that handlers can be run in different handlers and yet be part of the same semantic execution trace.
I'd like to request that vert.x allows users to bring their own mechanism to propagate the vert.x context.
That can be achieved in two ways:

Making getContext part of the Vertx API just like getOrCreateContext is -- this way, I can create a WrappedVertx extending Vertx, wrapping the default vertx: VertxImpl and overriding getContext and getOrCreateContext.
Adding a new abstraction LocalManager, similar in name and spirit to ClusterManager, that I can implement as a service and that vertx loads through SPI. The default instance of LocalManager will use the thread local sticky context implementation with the weak reference.

I prefer the second solution over the first one. Do you have any thoughts?
Contribution
I can open a pull request implementing this feature.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've just signed the ECA under jorgevc@fastmail.es, the same email address as the one I've used to sign the commits.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
EventBus publish send not work. consumer nerver target.
Version
3.9.4,
4.0.0.Beta3
,4.0.0.CR2,
4.0.0.CR1
Context
EventBus publish send to the address, the handler never target. but request can work.
Do you have a reproducer?
no
Reproducers are very helpful for contributors and will likely help them fixing your bug faster.

Link to github project/gist

Steps to reproduce
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.EventBus;
public class WhatsHappened {
public static void main(String[] args) {
Vertx vertx = Vertx.vertx();
EventBus bus = vertx.eventBus();
vertx.deployVerticle(new NerverTarget());
// bus.consumer("",a->{});
bus.publish("target","1");
bus.send("target","2");
bus.request("target","3");
}
static class NerverTarget extends AbstractVerticle{
@OverRide
public void start() throws Exception {
vertx.eventBus().consumer("target",h->{
System.out.println(h.body());
});
}
}
}
result : 3
open comment : bus.consumer("",a->{});
result: 1,2,3
Extra
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Future type is missing an async transformation that is called independently of the result.
This type already have:

compose(Function<T, Future<U>>,Function<Throwable, Future<U>>)
compose(Function<T, Future<U>>)
recover(Function<Throwable, Future<U>>)

We are missing

eventually(Function<Void, Future<U>>)

This is useful for applying a finally semantic, e.g we have currently in SQL client pool the following code:
return pool.close(). compose(v -> {
  PromiseInternal<Void> promise = context.promise();
  factory.close(promise);
  return promise;
}).onComplete(v -> {
  if (metrics != null) {
    metrics.close();
  }
});
which should actually be:
return pool.close().compose(v -> {
  PromiseInternal<Void> promise = context.promise();
  factory.close(promise);
  return promise;
}, err -> {
  PromiseInternal<Void> promise = context.promise();
  factory.close(promise);
  return promise;
}).onComplete(v -> {
  if (metrics != null) {
    metrics.close();
  }
});
and with the new eventually:
return pool.close().eventually(v -> {
  PromiseInternal<Void> promise = context.promise();
  factory.close(promise);
  return promise;
}).onComplete(v -> {
  if (metrics != null) {
    metrics.close();
  }
});
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.1 but this also happens on latest commit
Context
Since some time we've seen WebClient throwing Connection reset error on first request after a period of inactivity. I know that our gateway closes inactive connections after some time. The question was why WebClient doesn't close such connections, the default keep alive settings should remove inactive connections after 60 seconds. After some debugging I tracked the issue down to Pool having connections that don't have expirationTimestamp set. I believe there's some race condition with how connections are created and consumed. The flow is like this:

First request is started. First connection will be created but it takes significant time for it to be connected.
In the same time a second request is started. A second connection will be created but this one connects instantly.
Second request finishes.
Second connection is now available and it's used to complete the first request.
First connection has finished connecting but the waiter list is empty. It will sit unused in the pool. expirationTimestamp is not set so keep alive settings are ignored.
After some time our gateway closes the inactive connection by sending RST packet.
Third request is started, it will use that first connection (now closed on the gateway side) and throw Connection reset error.

Do you have a reproducer?
See here.
Note that I added a delay in HttpChannelConnector to simulate slow first connection. This reproduces the issue reliably. Of course in our environment I can reproduce the issue with unchanged vertx 3.9.1 and 3.9.4.
Steps to reproduce

Run IssueReproducer.java
Output should look like this

Connection satisfied waiters: 1
Request response: 200
Request response: 200
Connection with expiration
Connection with expiration
Connection with expiration
Connection with expiration
Connection satisfied waiters: 0
Connection with expiration
Connection with no expiration
Connection with expiration
Connection with no expiration
Connection with no expiration
...


A pool now has a connection that won't be removed even if its keep alive time passes (expirationTimestamp of this connection is 0).

Extra
Tested on Linux and macOS. JVM 11.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0.CR2
Context
Sending a message on the event bus with a missing codec throws an exception instead of returning a failed future.
java.lang.IllegalArgumentException: No message codec for type: class com.hiddenswitch.framework.impl.ConfigurationRequest
	at io.vertx.core.eventbus.impl.CodecManager.lookupCodec(CodecManager.java:101)
	at io.vertx.core.eventbus.impl.EventBusImpl.createMessage(EventBusImpl.java:232)
	at io.vertx.core.eventbus.impl.EventBusImpl.request(EventBusImpl.java:109)
	at io.vertx.core.eventbus.EventBus.request(EventBus.java:81)

Do you have a reproducer?
class SomeClass {
}
Vertx.vertx().eventBus().publish("1", new SomeClass());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0.CR2
Context and Reproduction
Depending on when you create e.g. a PgPool, its close hook may run before or after a verticle stop in a way that is unexpected. In particular there are closeable resources you almost always want to run last. This is the case with the clustered event bus, for example, but is not well defined for things like database pools.
In this example, the verticle tries to use the pool while closing. This is okay:
class SomeVerticle extends AbstractVerticle {
  ...
  PgPool pool;
  void start(Promise<Void> promise) {
    ...
    pool = PgPool.pool(vertx, ...);
  }
  void stop(Promise<Void> promise) {
    pool.getConnection()
      .compose(conn -> ...)
      .map((Void)null)
      .onComplete(promise);
  }
}

vertx.deployVerticle(new SomeVerticle())
  .compose(vertx.close());

This will throw an exception that the pool is closed:
class SomeVerticle extends AbstractVerticle {
  ...
  PgPool pool;
  void start(Promise<Void> promise) {
    ...
  }
  void stop(Promise<Void> promise) {
    pool.getConnection()
      .compose(conn -> ...)
      .map((Void)null)
      .onComplete(promise);
  }
}

var pool = PgPool.pool(vertx, ...);
var verticle = new SomeVerticle();
verticle.pool = pool;
vertx.deployVerticle(verticle)
  .compose(vertx.close());

In one case, the pool is closed after the verticle's stop is complete. In another case, the pool is closed before the verticle's stop is complete, and its stop will fail with Pool is closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
public interface User {

  @Fluent
  @Deprecated
  User isAuthorized(String authority, Handler<AsyncResult<Boolean>> resultHandler);

  @Deprecated
  @Fluent
  default User isAuthorised(String authority, Handler<AsyncResult<Boolean>> resultHandler) {
    return isAuthorized(authority, resultHandler);
  }
}

Version
vertx-auth-common:3.9.4
Context
both isAuthorized(String authority, Handler<AsyncResult<Boolean>> resultHandler) and isAuthorised(String authority, Handler<AsyncResult<Boolean>> resultHandler)  declare   @Deprecated
so what method should i use in inteface User to authorise
the entire classpath is io.vertx.ext.auth.User
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Message<T> should have an API like
/**
 * Completable with a reply message, or fails if isSend was false.
 */
<T> Promise<V> reply();

Use cases
eventBus.<T>consumer("address", message -> doAsyncWork().onComplete(message.reply()));

Observe it ought to infer the arguments by the Future<V> returned by doAsyncWork().
It also gives you a handy way to tap into enhancements to Future, like reifying the stack for tracing or transmitting error messages via VertxException, the more APIs that look like this the better!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation of the HTTP 1.x client connection assumes that a client connection will always be used and thus the expiration timestamp is computed when the connection is recycled. In some case, a connection can be created but not used and then immediately stored in the pool. When this happen, the connection in the pool will have a different validity expectation as it will be considered as forever valid.
The connection validity should return a valid value before the connection gets recycled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the Eclipse contributor agreement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A getter for the HTTP/2 stream id of a server request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj can you please review? I will backport to 3.9 after it's merged (see related issue)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The new eventually method on Future returns an incorrect future:
<U> Future<U> eventually(Function<Void, Future<U>);
As we want to have a finally like semantic, the outcome of the future returned by the mapper function should not override the outcome of the original future on which eventually is called. The fixed signature is:
<U> Future<T> eventually(Function<Void, Future<U>>);
The returned future will get the outcome of the original future when the future returned by the mapper function completes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Future type can be improved with this transform method:
<U> Future<U> transform(Function<AsyncResult<T>, Future<U>>);
This method is syntactic sugar for compose(Function<T, Future<U>>, Function<Throwable, Future<U>>).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Get an access to the real remote address when using Proxy Protocol. In the current implementation of proxy protocol, the field remoteAddress is replaced by the source IP from the proxy protocol request (and that shouldn't change). We should add the original source and destination IP somewhere in the context.
Use cases
The proxy protocol is used between a Load Balancer and servers. For security, servers should only accept requests from the Load Balancers to avoid malicious requests. Anyone familiar with this protocol can create requests and pretend to have a different IP.
Here is a plain text example of the protocol:
PROXY TCP4 {source IP} {destination IP} {source port} {destination port}
GET / HTTP/1.1


In this example, allowed requests from IP x.x.x.x should be something like :
PROXY TCP4 x.x.x.x a.a.a.a 58965 443
GET / HTTP/1.1

But a hacker can build wrong requests, for example a requests from h.h.h.h to y.y.y.y (he stole the IP x.x.x.x). The application will think that it was x who made the request. Which is wrong.
PROXY TCP4 x.x.x.x y.y.y.y 58965 443
GET / HTTP/1.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
I have a vertx+rxjava webclient trying to POST to a PHP application
Vertx WebClient > Docker (Caddy > PHP-FPM)
Caddy config:
handle {
	php_fastcgi phpfpm:9000
}

Do you have a reproducer?
MultiMap values = MultiMap.caseInsensitiveMultiMap();
values.add("field1", "value1");
values.add("field2", "value2");
WebClient client = WebClient.create(vertx);
HttpRequest<Buffer> request = client.post(80, "localhost", "/");
HttpResponse<Buffer> response = request
		.rxSendForm(values)
		.blockingGet();
log.info(response.bodyAsString());
client.close();

Results in this HTTP request as seen from Wireshark:
POST / HTTP/1.1
user-agent: Vert.x-WebClient/4.0.0
content-type: application/x-www-form-urlencoded
host: localhost:8080
transfer-encoding: chunked

field1=value1&field2=value2

I never get a response, wireshark never logs a response, the Single never completes, an XDEBUG breakpoint on the first line is never hit, and neither PHP nor Caddy log the request.
I believe the lack of content-length in the request is leaving the PHP server waiting. It appears to tie-up one of the FPM workers as running numerous requests like this concurrently results in an error:
[pool www] server reached pm.max_children setting (5), consider raising it

And all subsequent requests, no matter what the client, hang, at least until I quit the vertx app and wait for all the TCP timeouts to timeout.
I've tried changing the content type to multipart/form-data or using rxSendMultipartForm() but no luck. I did try posting to google.com and I immediately get an error but I think it's because its seeing the POST and rejecting it early.
Changing the request to be a simple POST via rxSend() works fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a start(Future<Void>) in the Vertx Core docs.
But in Vertx 4.0, the start method in the AbstractVerticle and Verticle only accept a Promise<Void> paratmeter.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions

Is this a false positive?
how to supress this warning?

2020-12-14 16:40:57,871 ERROR [vert.x-eventloop-thread-1] io.netty.util.ResourceLeakDetector:reportTracedLeak[319] - LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 
Created at:
	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:96)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178)
	io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:115)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.decodeAttribute(HttpPostStandardRequestDecoder.java:667)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.setFinalBuffer(HttpPostStandardRequestDecoder.java:640)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.parseBodyAttributes(HttpPostStandardRequestDecoder.java:612)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.parseBody(HttpPostStandardRequestDecoder.java:378)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.offer(HttpPostStandardRequestDecoder.java:310)
	io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder.offer(HttpPostStandardRequestDecoder.java:49)
	io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.offer(HttpPostRequestDecoder.java:223)
	io.vertx.core.http.impl.Http1xServerRequest.endDecode(Http1xServerRequest.java:555)
	io.vertx.core.http.impl.Http1xServerRequest.onEnd(Http1xServerRequest.java:543)
	io.vertx.core.http.impl.Http1xServerRequest.handleEnd(Http1xServerRequest.java:535)
	io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:73)
	io.vertx.core.impl.DuplicatedContext.execute(DuplicatedContext.java:189)
	io.vertx.core.http.impl.Http1xServerConnection.onEnd(Http1xServerConnection.java:200)
	io.vertx.core.http.impl.Http1xServerConnection.onContent(Http1xServerConnection.java:187)
	io.vertx.core.http.impl.Http1xServerConnection.handleOther(Http1xServerConnection.java:156)
	io.vertx.core.http.impl.Http1xServerConnection.handleMessage(Http1xServerConnection.java:144)
	io.vertx.core.net.impl.ConnectionBase.read(ConnectionBase.java:151)
	io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:144)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:93)
	io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler.channelRead(WebSocketServerExtensionHandler.java:102)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795)
	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480)
	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)
	io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	java.base/java.lang.Thread.run(Unknown Source)

Version
4.0.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Vertx Rxjava 2 sample, I tried to use all vertx-rx-rxjava2 APIs instead of the vertex core.
But the io.vertx.reactivex.core.Vertx can not be injected in the JUnit 5 methods like the normal Vertx.
My application is based on the following stack:

Vertx 4.0.0
Java 11
Windows 10

I have to wrap it myself like this:
WebClient client = WebClient.create(new io.vertx.reactivex.core.Vertx(vertx));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I added web validaiton and rxjava 2 in my Rxjava project.
I used the  io.vertx.reactivex.ext.web.validation.ValidationHandler.
 ValidationHandler
                .builder(schemaParser)
                .body(Bodies.json(bodySchemaBuilder))
                //.body(Bodies.formUrlEncoded(bodySchemaBuilder))
                .build()
But the build() method returns io.vertx.ext.web.validation.ValidationHandler. I think it should be  io.vertx.reactivex.ext.web.validation.ValidationHandler.
Before applying it to the routing handlers, I have to wrap it again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cannot access vertx.ioERR_SSL_VERSION_OR_CIPHER_MISMATCH
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0.CR1
Context
I have a verticle with example code for loading properties from documentation but nothing is loaded.
resources/conf/raw.properties
server.host=localhost
server.port=8080
multiple.values=1,2,3

code in verticle
ConfigStoreOptions propertyWithRawData = new ConfigStoreOptions()
    .setFormat("properties")
    .setType("file")
    .setConfig(new JsonObject().put("path", "conf/raw.properties").put("raw-data", true).put("hierarchical", true)
    );

ConfigRetriever configRetriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(propertyWithRawData));

After handling of configRetriever.getConfig() the result is empty.
I do have another configuration config.json in resources/conf folder and that one is loaded properly by default.
I have also tried with Directory config store and "*.properties" pattern but with no luck.
Also during investigation I found a typo in io.vertx.config.impl.spi.FileConfigtoreFactory (missing 'S').
Lastly, I found it a bit difficult to use json files as properties source because in case of try/catch situations you can't just quickly comment out the setting if needed or add comments which describes each setting because json doesn't allow comments. That's also reason why I need loading of standard properties. There you can easily comment out the line and have the property loaded from another file due to overloading.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.5
Context
After upgrading the netty to 4.1.51, multipart form attributes is corrupted when file size is larger than buffer size in the netty.
Seems the attribute value is replaced by the file content

Link to github project/gist
https://gist.github.com/ngyukman/c48def66b414881dae919893389dfbd6

Steps to reproduce

start the server from gist
post with multipart and attribute test + a big file afterward (around 10MB is fine)
it returns bytes from binaries in the file with the same length of the sent attribute length, but not the correct value just sent in step 2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is the same issue as #3629 , where the UploadHandler erases the context.
The reproducer from the original ticket: https://github.com/oscarfh/vertx-upload-handler-context is still reproducing the issue.
I am researching to add any new findings on this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we need to have a test for this, otherwise the regression might come again
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.4
Context
JsonObject.getInstant() doesn't work if the date in the JSON contains a timezone other than 'Z'.
JsonObject o = new JsonObject();
o.put("good", "2020-12-17T15:10:11.002Z");
o.put("bad",  "2020-12-17T10:10:11.002-05:00");
//This works...
o.getInstant("good");
//This results in a DateTimeParseException: Text '2020-12-17T10:10:11.002-05:00' could not be parsed at index 23
o.getInstant("bad");

The JavaDoc of the functions says it complies with RFC-7493 so it assumes the date is encoded ISO 8601. RFC-7493 refers to RFC-3339 for definition of ISO 8601, which allows for offset timezones (time-zone = "Z" / time-numoffset).
I see in the code that ISO_INSTANT is used for formatting and parsing. Looks like it cannot parse anything other than Z for timezone. Seems to me that ISO_OFFSET_DATE_TIME would work better for parsing, but I'm not sure I understand all the subtle details between the two.
If the change can't be done, the JavaDoc should change to make it explicit that only dates formatted with the 'Z' timezone are accepted.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a WebSocket is closed by the server, it sends a close frame and  waits until it receives the echo close frame to close the TCP connection. We should have a timeout to close the TCP connection to prevent a server from keeping a WebSocket without receiving a close frame.
NOTE: this will not happen when an idle timeout is configured on the server which is a recommended practice.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClientOptions#DEFAULT_WEBSOCKET_CLOSING_TIMEOUT is 10000, however the value is in seconds and it should be 10 instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HttpClientOptions#webSocketClosingTimeout timeout is disabled when the value is zero or negative. It can be useful to immediately close the connection when the value is set to 0 instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This PR is an implementation for the following feature request: #3720
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
While using the webclient of vertx from the following project: https://github.com/vert-x3/vertx-web I discovered that vertx core has couple of options to enable ssl. It should be of the type KeyCertOptions and TrustOptions. The core library already provides utilities to help the end-user by providing JksOptions, KeyStoreOptions, PemTrustOptions and PfxOptions.
It is providing a-lot ways for the end-user, but I had the feeling that it was missing one option. What if someone wanted to supply a KeyManagerFactory or KeyManager as KeyCertOptions? Or if someone wanted to supply a TrustManagerFactory or TrustManager? That would not be possible out of the box. The end-user needs to implement KeyCertOptions and TrustOptions and provide a custom logic to enable it.
Use cases

This will enable the end-user to supply their own custom constructed key and trust material, for example a trust manager which is able to use multiple different keystore files, for example: Stackoverflow - Registering multiple keystores in JVM
In an existing environment where someone wants to migrate to vertx and has already a keymanager/trustmanager, by just supplying it it doesn't need to use JksOptions, KeyStoreOptions, KeyStoreOptons, PemTrustOptions or PfxOptions to configure vertx. They would be able to supply just only KeyManager, KeyManagerFactory, TrustManager or TrustManagerFactory and adapt much easier.

Contribution
I am volunteering! See here for the PR: #3719
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
When using the mentioned send function the completion handler provided never gets called, as a result if using the generated rxSend(..) function there's never a response provided even if the call succeeds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj the failed test due to usage of fixed ports in tests and is unrelated to my changes. could you please review it and merge if the changes are fine with you?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The link Guide to reactive streams with coroutines in the RxJava interoperability is broken.
Doc link: https://vertx.io/docs/vertx-lang-kotlin-coroutines/kotlin/#_rxjava_interoperability
Broken link: RxJava interoperability
Version: 4.0.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
The server will close the connection without any response.
curl -i 'http://127.0.0.1:8000/?ab c=1'
curl: (52) Empty reply from server

It should reply 400 bad request before close the connection.
It's vulnerable if we put the servers behind nginx.

nginx got a bad request from client.
nginx proxy_pass it to one of the backend servers.
nginx got empy reply from the server.
nginx returns 502 to the client, and remove this server from the backends.
nginx processed more bad request, and has no backend server now.

  private void handleError(HttpObject obj) {
    DecoderResult result = obj.decoderResult();
    Throwable cause = result.cause();
    if (cause instanceof TooLongFrameException) {
      String causeMsg = cause.getMessage();
      HttpVersion version;
      if (obj instanceof HttpRequest) {
        version = ((HttpRequest) obj).protocolVersion();
      } else if (requestInProgress != null) {
        version = requestInProgress.version() == io.vertx.core.http.HttpVersion.HTTP_1_0 ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
      } else {
        version = HttpVersion.HTTP_1_1;
      }
      HttpResponseStatus status;
      if (causeMsg.startsWith("An HTTP line is larger than")) {
        status = HttpResponseStatus.REQUEST_URI_TOO_LONG;
      } else if (causeMsg.startsWith("HTTP header is larger than")) {
        status = HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE;
      } else {
        status = HttpResponseStatus.BAD_REQUEST;
      }
      DefaultFullHttpResponse resp = new DefaultFullHttpResponse(version, status);
      ChannelPromise fut = chctx.newPromise();
      writeToChannel(resp, fut);
      fut.addListener(res -> {
        // fail(result.cause());
        // because of CCE
        fail(result.cause());
      });
    } else {
      // fail(result.cause());
      // because of 


should reply the HttpResponseStatus.BAD_REQUEST too.

      fail(result.cause());
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
i upgraded my project from 3.9.4 to 4.0.0, but i encountered a problem that clustered eventbus cannot work.
Version
4.0.0
Context
i upgraded my project from 3.9.4 to 4.0.0, but i encountered a problem that clustered eventbus cannot work.
env:
verticle a, 192.168.3.55
verticle b, 192.168.3.43
implementation in 3.9.4:
VertxOptions vertxOptions = new VertxOptions();
String local = InetAddress.getLocalHost().getHostAddress();
logger.info("localhost {}", local);
vertxOptions.setClustered(true).setClusterHost(local);
 
Config hazelcastConfig = new Config();
 hazelcastConfig.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
 hazelcastConfig.getNetworkConfig().getJoin().getTcpIpConfig().setMembers(config.cluster.members).setEnabled(true);
hazelcastConfig.getNetworkConfig().setPublicAddress(local);
HazelcastClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);
vertxOptions.setClusterManager(mgr);

vertxOptions.setHAEnabled(true);


verticle a (192.168.3.55) can send to event to virticle b (192.168.3.43)
when i upgraed to 4.0.0, and because api (ertxOptions.setClustered(true).setClusterHost(local)) cannot be used, the current implementation is as below:
String local = InetAddress.getLocalHost().getHostAddress();
logger.info("localhost {}", local);

Config hazelcastConfig = new Config();

hazelcastConfig.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
hazelcastConfig.getNetworkConfig().getJoin().getTcpIpConfig().setMembers(config.cluster.members).setEnabled(true);
hazelcastConfig.getNetworkConfig().setPublicAddress(local);

HazelcastClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);
EventBusOptions eventBusOptions = new EventBusOptions();
eventBusOptions.setClusterPublicHost(local);
ServerSocket socket = new ServerSocket(0);
int port = socket.getLocalPort();
eventBusOptions.setClusterPublicPort(port);
logger.info("eventbus cluster host {}, port {}", local, port);

VertxOptions vertxOptions = new VertxOptions();
vertxOptions.setHAEnabled(true)
.setClusterManager(mgr)
.setEventBusOptions(eventBusOptions);

now verticle a failed to send event to verticle b.
And the logs:
Dec 27, 2020 3:48:21 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.3.55]:5701 [dev] [4.0.2] 

Members {size:2, ver:2} [
	Member [192.168.3.43]:5701 - 0fad8886-16ba-47ef-af20-cb5282b2a3f7
	Member [192.168.3.55]:5701 - c4d566b7-64e6-47a6-a19f-e3658b82dcbf this
]

Dec 27, 2020 3:48:22 PM com.hazelcast.core.LifecycleService
INFO: [192.168.3.55]:5701 [dev] [4.0.2] [192.168.3.55]:5701 is STARTED
[2021-12-27 15:48:22.836][INFO][io.vertx.core.impl.HAManager:] A quorum has been obtained. Any deploymentIDs waiting on a quorum will now be deployed
[2021-12-27 15:48:22.929][INFO][com.futureinteraction.bas.MainVerticle:258] succeeded to deploy mail sender verticle: f57ebf64-2d38-4954-a305-4c21e9430da2
[2021-12-27 15:48:22.965][INFO][com.futureinteraction.bas.MainVerticle:244] succeeded to deploy db verticle: 21623c8f-14ed-43d0-a616-141e2a4bf6af
[2021-12-27 15:48:23.045][INFO][com.futureinteraction.bas.MainVerticle:104] start http server at port: 8080
[2021-12-27 15:48:23.087][INFO][com.futureinteraction.bas.MainVerticle:230] succeeded to deploy rest server verticle: 33fec66d-b940-4437-bcba-485aeb85f498
[2021-12-27 15:48:23.150][ERROR][com.futureinteraction.bas.redis.RedisInit:54] failed to create redis client: Connection refused: /127.0.0.1:7379
[2021-12-27 15:48:23.171][ERROR][com.futureinteraction.bas.redis.RedisInit:54] failed to create redis client: Connection refused: /127.0.0.1:7379
[2021-12-27 15:48:23.194][ERROR][com.futureinteraction.bas.redis.RedisInit:54] failed to create redis client: Connection refused: /127.0.0.1:7379
[2021-12-27 15:48:23.238][ERROR][com.futureinteraction.bas.redis.RedisInit:54] failed to create redis client: Connection refused: /127.0.0.1:7379
[2021-12-27 15:48:23.259][INFO][com.futureinteraction.bas.MainVerticle:273] succeeded to deploy es verticle: f473ec75-73d7-440b-99f9-54fb1888c9b6
[2021-12-27 15:48:23.285][INFO][com.futureinteraction.bas.canal.BaseCanalClient:32] canal max data sync time 300000 ms
[2021-12-27 15:48:23.288][INFO][com.futureinteraction.bas.canal.BaseCanalClient:67] connecting to canal server ...
[2021-12-27 15:48:23.289][INFO][com.futureinteraction.bas.MainVerticle:298] succeeded to deploy canal db sync verticle: 5716e617-f4a1-4304-a040-ff3046d4e3a1
[2021-12-27 15:48:23.296][ERROR][com.futureinteraction.bas.canal.BaseCanalClient:121] process error!
com.alibaba.otter.canal.protocol.exception.CanalClientException: java.net.ConnectException: Connection refused
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.doConnect(SimpleCanalConnector.java:198) ~[canal.client-1.1.4.jar:?]
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.connect(SimpleCanalConnector.java:115) ~[canal.client-1.1.4.jar:?]
	at com.futureinteraction.bas.canal.DataSyncCanalClient.process(DataSyncCanalClient.java:70) ~[classes/:?]
	at java.lang.Thread.run(Thread.java:832) [?:?]
Caused by: java.net.ConnectException: Connection refused
	at sun.nio.ch.Net.connect0(Native Method) ~[?:?]
	at sun.nio.ch.Net.connect(Net.java:503) ~[?:?]
	at sun.nio.ch.Net.connect(Net.java:492) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:751) ~[?:?]
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.doConnect(SimpleCanalConnector.java:150) ~[canal.client-1.1.4.jar:?]
	... 3 more
[2021-12-27 15:48:23.321][ERROR][com.futureinteraction.bas.redis.RedisInit:54] failed to create redis client: Connection refused: /127.0.0.1:7379
[2021-12-27 15:48:23.323][INFO][com.futureinteraction.bas.redis.RedisInit:69] tried to reconnect redis and failed: retried times, 3
[2021-12-27 15:48:23.329][INFO][com.futureinteraction.bas.redis.RedisInit:72] wait 120000 mseconds to reconnect redis
[2021-12-27 15:48:24.382][INFO][com.futureinteraction.bas.canal.BaseCanalClient:134] connection to canal server is closed
[2021-12-27 15:48:24.383][ERROR][com.futureinteraction.bas.canal.BaseCanalClient:29] parse events has an error
java.lang.NullPointerException: null
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.writeWithHeader(SimpleCanalConnector.java:393) ~[canal.client-1.1.4.jar:?]
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.writeWithHeader(SimpleCanalConnector.java:381) ~[canal.client-1.1.4.jar:?]
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.rollback(SimpleCanalConnector.java:363) ~[canal.client-1.1.4.jar:?]
	at com.alibaba.otter.canal.client.impl.SimpleCanalConnector.rollback(SimpleCanalConnector.java:375) ~[canal.client-1.1.4.jar:?]
	at com.futureinteraction.bas.canal.DataSyncCanalClient.process(DataSyncCanalClient.java:128) ~[classes/:?]
	at java.lang.Thread.run(Thread.java:832) [?:?]
[2021-12-27 15:48:41.697][INFO][com.futureinteraction.bas.logging.AccessLogging:53] ws request: POST, path= /push/0.1 source= 127.0.0.1:35582
request data: 
{
    "uuid": "6dc8d9b6-b624-4fbb-a570-8377c2b1788c",
    "msg_type": 16,
    "data": 1
}user id, 1
[2021-12-27 15:48:41.927][INFO][com.futureinteraction.bas.resources.PushResource:131] {"location":{"endpoint":"push"},"metadata":{"service.interface":"com.unitrack.push.proxy.PushProxyVerticle"},"name":"push","registration":"9a1808aa-fbb9-4d00-9311-226dee9e3cbc","status":"UP","type":"eventbus-service-proxy"}
[2021-12-27 15:48:42.001][WARN][io.vertx.core.eventbus.impl.clustered.ConnectionHolder:] Connecting to server 0fad8886-16ba-47ef-af20-cb5282b2a3f7 failed
io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: /192.168.3.43:15701
Caused by: java.net.ConnectException: Connection refused
	at sun.nio.ch.Net.pollConnect(Native Method) ~[?:?]
	at sun.nio.ch.Net.pollConnectNow(Net.java:589) ~[?:?]
	at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:839) ~[?:?]
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) ~[netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) [netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:702) [netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) [netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) [netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.49.Final.jar:4.1.49.Final]
	at java.lang.Thread.run(Thread.java:832) [?:?]


Extra

Arch Linux
java 14
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We had a test in our system that simulates a connection disruption between our system and rabbitMq.
After migrating to vertx 4, the test is broken.
It passes with 3.9.5, but fails with all 4.0.0.X versions.
Here is the reproducer: https://github.com/oscarfh/vertx-rabbit-regression
The first commit is vertx 4 with the failing test, the second is vertx 3.9.5 with the same testing passing.
Explaining the test:

The test starts up a rabbitmq docker container
The test sets up a consumer and a producer
Both will be configured to reestablish the connection to rabbitmq in case of failures
The producer will send messages periodically (every 1s)
The consumer will receive the messages. Upon the reception of the first message, RabbitMq docker container is shutdown and then started up again.
Upon the reception of a second message, which happens after rabbit was restarted, the test completes

Notice how the producer will complain about connection errors until you see the message Container rabbitmq:3.8.6-alpine started in XXX, then it will stop logging the error messages (but you can change the success message log level or add a CLI consumer to check that it is still sending) but the test will not complete.
Downgrade to 3.9.5 and see that the test completes successfully.
/cc @vietj @jekkel @pravussum
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj Hi and happy new year! Could you please tell me what you think of this PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@jvican thx for the revue and the feedback.
About you question, well, as usual it depends on the use case. If you mostly write, CAS operations are more costly than synchronized blocks especially with a lot of concurrent threads but if you mostly read (what I assumed), volatile reads are much more cheaper than synchronized blocks.
For a better understanding, let's say that we want to compare
public boolean isClosed1() {
    return state.get() == CLOSED;
}

with
public synchronized boolean isClosed2() {
    return closed;
}

With one thread on my local machine (MBP 2,8 GHz Intel Core i7), I get:
Benchmark                     Mode   Samples         Mean   Mean error    Units
o.s.MyBenchmark.isClosed1     avgt        10        1,303        0,007    ns/op
o.s.MyBenchmark.isClosed2     avgt        10        2,902        0,185    ns/op

So more than twice faster
With max threads (Runtime.getRuntime().availableProcessors()), I get:
Benchmark                     Mode   Samples         Mean   Mean error    Units
o.s.MyBenchmark.isClosed1     avgt        10        3,723        0,255    ns/op
o.s.MyBenchmark.isClosed2     avgt        10      666,265       57,456    ns/op

So more than 200 times faster
On the other hand, If I want to compare the current init method with this new version under the same conditions, I get:
One Thread:
Benchmark                     Mode   Samples         Mean   Mean error    Units
o.s.MyBenchmark.init1         avgt        10       16,258        0,300    ns/op
o.s.MyBenchmark.init2         avgt        10        8,220        0,199    ns/op

So twice slower
Max Threads:
Benchmark                     Mode   Samples         Mean   Mean error    Units
o.s.MyBenchmark.init1         avgt        10     1686,056      232,578    ns/op
o.s.MyBenchmark.init2         avgt        10      456,712       21,903    ns/op

So more than 3 times slower.
To summarize, it worths it if concurrent calls to isClosed is more likely than concurrent calls to init what I assumed.
I hope it answered your question. Assuming that you still believe that this PR worths it, it would be great If you could also review the other PR of the same type #3727  :-)
Disclaimer: The test scenarios described above are only meant to show, in term of performances, the differences between the current approach (blocking based on synchronized blocks/methods) and this one (lock-free) nothing more.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can we have this PR onto master instead of 3.9 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@gaol you can look at integrating the new pool for mail-client
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Vert.x version 3.9.2 io.vertx.core.spi.metrics.HttpServerMetrics.responseEnd method had a parameter httpResponse which was removed and replaced by bytesReadin 4.0.0 version. This was done in "Update HttpServerMetrics to use observability HttpRequest/HttpResponse" (#3587).
In our application we have a custom SPI and responseEnd is used to measure time of whole request process with additional info such as status code. In version 4.0.0 this information is available only in responseBegin method, which forces us to "change state" of requestMetric parameter for propagating information to responseEnd.
It would be very helpful if instance of new HttpResponse was available in responseEnd. This could be done simply by adding response in Http server implementations or generally by passing custom state between responseBegin/responsePushed and reponseEnd method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This PR should not be merged until all these are checked:

 Create a commit to reduce any line changes in imports reordering from Eclipse (VertxImpl.java)
 Documentation changes required into this or a separate PR (will take further input from review)
 Checkout Clement's branches for latest SmallRye Reactive Messaging Executors and check with him too AssemblyHook gitter
 re-check how Quarkus embedds Vert.x around ExecutorService on most recent version and ask in zulip about outlook similar to above
 Create {@link examples.spi.executor} and link to it from index.adoc#blocking_code
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
Version
Vertx 3.9.5 and Jackson 2.10.4 or 2.11.3
Context
I encountered an exception which looks suspicious while upgrading from Vertx 3.6.3 and Jackson 2.9.3
Do you have a reproducer?
A reproducer is a simple project hosted on GitHub (or another forge supporting git clone operation) that has a build file that can be executed to reproduce the issue.
Reproducers are very helpful for contributors and will likely help them fixing your bug faster.

Link to github project/gist

Steps to reproduce


create unit tests as follows and run:
public void checkRequestOptionsDeserialize() throws JsonProcessingException {
ObjectMapper mapper = new ObjectMapper();
TypeFactory typeFactory = mapper.getTypeFactory();
JavaType javaType =  typeFactory.constructType(RequestOptions.class);
RequestOptions requestOptions = new RequestOptions();
String json = mapper.writeValueAsString(requestOptions);
System.out.println(json);
 WebClientApiConfigurationTest deserializedObject = mapper.readValue(json, javaType);

}


Error results:
Conflicting setter definitions for property "all": io.vertx.core.MultiMap#setAll(1 params) vs io.vertx.core.MultiMap#setAll(1 params)
at [Source: (String)"{"host":"localhost","port":80,"ssl":null,"uri":"","headers":null}"; line: 1, column: 1]
com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property "all": io.vertx.core.MultiMap#setAll(1 params) vs io.vertx.core.MultiMap#setAll(1 params)
at [Source: (String)"{"host":"localhost","port":80,"ssl":null,"uri":"","headers":null}"; line: 1, column: 1]
at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:309)


2nd test
@test
public void checkRequestOptionssnsCanDeserialize() throws JsonProcessingException {
ObjectMapper mapper = new ObjectMapper();
TypeFactory typeFactory = mapper.getTypeFactory();
JavaType javaType =  typeFactory.constructType(RequestOptions.class);
 AtomicReference<Throwable> causeRef = new AtomicReference<>();
 if (! mapper.canDeserialize(javaType, causeRef)) {
     throw new RuntimeException(causeRef.get());
 }

}


results:
com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property "all": io.vertx.core.MultiMap#setAll(1 params) vs io.vertx.core.MultiMap#setAll(1 params)
java.lang.RuntimeException: com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property "all": io.vertx.core.MultiMap#setAll(1 params) vs io.vertx.core.MultiMap#setAll(1 params)
at com.nbcuni.oa.mam.workorder.jackson.JacksonOverloadedSettersTest.checkRequestOptionssnsCanDeserialize(JacksonOverloadedSettersTest.java:154)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:110)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:62)
at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:119)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414)
at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
at java.lang.Thread.run(Thread.java:748)
Caused by: com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property "all": io.vertx.core.MultiMap#setAll(1 params) vs io.vertx.core.MultiMap#setAll(1 params)
Extra

This may be related to a similar issue reported here:

FasterXML/jackson-databind#2757
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Grammar is not correct about Verticles, docs 4.0.0 vertx.core link
Version
4.0.0
Context
public class MyVerticle extends AbstractVerticle {

 private HttpServer server;

 public void start(Future<Void> startFuture) {
   server = vertx.createHttpServer().requestHandler(req -> {
     req.response()
       .putHeader("content-type", "text/plain")
       .end("Hello from Vert.x!");
     });

   // Now bind the server:
   server.listen(8080, res -> {
     if (res.succeeded()) {
       startFuture.complete();
     } else {
       startFuture.fail(res.cause());
     }
   });
 }
}

I couldn't use that in my project,  Future<Void> startFuture param not in AbstractVerticle
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
Testing zipkin tracing repository, I discovered that the traceId and spanId generated when an HTTP request is received on the server are not propagated and stored when communication between microservices are done through EventBusProxies/EventBus.
Steps to reproduce

create vertx project, enable tracing and import io.vertx:vertx-zipkin:4.0.0
send a request to vertx http server
forward request to microservices through EventBusProxies or Eventbus
monitor recorded traces, request sent through Eventbus will not be recorded
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
I had created a webshell with SockJSHandler, In some reason, It should be CORS, So I created a preprocessor to change the origin, The code like this.
The route
        router.route("/terminal/*").handler(this::changeOrigin);
        router.route("/mqttProxy/*").handler(this::changeOrigin);
        router.route("/terminal/*").handler(socketJSHandler);
        router.route("/mqttProxy/*").handler(socketJSHandler);
The preprocessor
    private void changeOrigin(RoutingContext context) {
        context.response().putHeader("Access-Control-Allow-Origin", context.request().getHeader("Origin"));
        context.next();
    }
Init the handler
        SockJSHandlerOptions options = new SockJSHandlerOptions().setHeartbeatInterval(2000).setRegisterWriteHandler(true).setLocalWriteHandler(true);
//        SockJSHandlerOptions options = new SockJSHandlerOptions().setHeartbeatInterval(2000);
        SockJSHandler socketJSHandler = SockJSHandler.create(vertx, options);
        // SocketJs
        Router socketRouter =socketJSHandler.socketHandler(sockJSSocket -> {
            String uri = sockJSSocket.uri();
            if (uri == null) return;
            if (uri.startsWith("/terminal")) {
                systemContext.getWebShellHandler().registerSocket(sockJSSocket);
            } else {
                systemContext.dataBus.mqttClientProxy.registerSocket(sockJSSocket);
            }
        });
I have bind the sockjs channel with local SSH channel ,so I setRegisterWriteHandler(true)to get an id
It works well on Vertx 3.9.5  but failed with a strange error when handshake on 4.0.0


Extra
Running on.
JDK 8u201 Windows 10 & armV7.
How to fix this?  Thanks a lot.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
uploadHandler should be invoked on the same context as the requestHandler of the HttpServer.
This works as expected with HTTP/2 servers but not with HTTP 1.x servers.
One possible impact is the loss of local context data (support of tracing).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use vert.x 4.0.0 java 14 and os x 11.1.
That's a reproducer:
public class Main {
  public static void main(String[] args) {

    var vertx = Vertx.vertx(new VertxOptions()
      .setPreferNativeTransport(true)
    );

    boolean usingNative = vertx.isNativeTransportEnabled();
    System.out.println("Running with native: " + usingNative);
  }
}

Also I have a gradle build with dependencies:
  implementation("io.netty:netty-transport-native-epoll:4.1.49.Final")
  implementation("io.netty:netty-transport-native-kqueue:4.1.49.Final")

During my investigations I found out my app caught: could not load a native library: netty_transport_native_kqueue_x86_64 exception in the io.netty.channel.kqueue.KQueue class.
Do I need something else to add in dependencies or it's a bug?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closed for this #3746
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Should service requests be distributed over cluster in round robin fashion?
Version
3.9.5
Context
In real project I had a problem that after node fails (stopped) requests are still going to it and 1/2 of requests are timeouted. To reproduce this situation I tried to make a toy project with hazlecast, one service verticle and one http verticle.
The service verticle is started as worker with one instance per node. Http is strated in 4 instances per node. I found out that all service requests were handled in one node (main or backup) and requests were not distributed over cluster.
Do you have a reproducer?
Http verticle simply calls service and responds with its reply.
public class HttpVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {

    final TestService testService = TestService.createProxy(
      getVertx(),
      TestService.TEST_ADDRESS,
      new DeliveryOptions());

    final int port = config().getInteger("port");

    vertx.createHttpServer().requestHandler(req -> {

      testService.getTestResult(ar -> {
        if (ar.succeeded()) {
          req.response()
            .putHeader("content-type", "text/plain")
            .end(ar.result().encodePrettily());
        } else {
          ar.cause().printStackTrace();
          req.response()
            .putHeader("Content-Type", "text/plain")
            .setStatusCode(503)
            .end(ar.cause().getMessage());
        }
      });


    }).listen(port, http -> {
      if (http.succeeded()) {
        startPromise.complete();
        System.out.println("HTTP server started on port " + port);
      } else {
        startPromise.fail(http.cause());
      }
    });
  }
}
Service vericle makes fake sleep to pause execution and responds with its node name and current time.
public class TestServiceVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {

    final String name = config().getString("name");

    System.out.println("String test service with name: " + name);

    final TestService service = handler -> {
      try {
        Thread.sleep(2000);
        handler.handle(Future.succeededFuture(new JsonObject()
          .put("name", name)
          .put("tm", System.currentTimeMillis())));
      } catch (InterruptedException e) {
        e.printStackTrace();
        handler.handle(Future.failedFuture(e));
      }
    };


    final ProxyHandler handler = TestService.createHandler(getVertx(), service);
    vertx.eventBus().consumer(TestService.TEST_ADDRESS, handler);

  }
}
Main class startes with two verticles with parameters from command line
public class Main {

  public static void main(String[] args) {
    final ClusterManager mgr = new HazelcastClusterManager();
    final VertxOptions options = new VertxOptions().setClusterManager(mgr);
    Vertx.clusteredVertx(options, res -> {
      if (res.succeeded()) {
        final Vertx vertx = res.result();
        //Test service
        final DeploymentOptions testOptions = new DeploymentOptions()
          .setConfig(new JsonObject().put("name", args[0]))
          .setWorker(true);
        vertx.deployVerticle("com.example.starter.TestServiceVerticle", testOptions);
        //Http
        final DeploymentOptions httpOptions = new DeploymentOptions()
          .setConfig(new JsonObject().put("port", Integer.valueOf(args[1])))
          .setInstances(4);
        vertx.deployVerticle("com.example.starter.HttpVerticle", httpOptions);
      } else {
        // failed!
      }
    });
  }
}
Steps to reproduce

Start one node with two command line parameters:  main 8888
Start second node with two command line parameters:  main 8889
Open two tabs in browser and developer tools. Try two issue request from two tabs nearly at the same moment
See that request comes from the same node. One request takes 2 seconds and the second takes 3 seconds. But two request should take nearly 2 seconds as we have two workers in cluster.

Reduced output from main node
Members {size:1, ver:1} [
	Member [172.18.0.1]:5701 - 21102817-04eb-4a8b-86a9-8f75fbbf6198 this
]

 11, 2021 5:07:12 PM com.hazelcast.core.LifecycleService
INFO: [172.18.0.1]:5701 [dev] [3.12.2] [172.18.0.1]:5701 is STARTED
 11, 2021 5:07:13 PM com.hazelcast.internal.partition.impl.PartitionStateManager
INFO: [172.18.0.1]:5701 [dev] [3.12.2] Initializing cluster partition table arrangement...
String test service with name: main
HTTP server started on port 8888
HTTP server started on port 8888
HTTP server started on port 8888
HTTP server started on port 8888

Reduced ouput from backup node
Members {size:2, ver:2} [
	Member [172.18.0.1]:5701 - 21102817-04eb-4a8b-86a9-8f75fbbf6198
	Member [172.18.0.1]:5702 - 0bc3d2f0-9170-441d-9646-41ecb6b871c6 this
]

 11, 2021 5:07:29 PM com.hazelcast.core.LifecycleService
INFO: [172.18.0.1]:5702 [dev] [3.12.2] [172.18.0.1]:5702 is STARTED
String test service with name: backup
HTTP server started on port 8889
HTTP server started on port 8889
HTTP server started on port 8889
HTTP server started on port 8889

After sending requests from two tabs
One to http://127.0.0.1:8888/ (first node). Request took 2 seconds.
{
  "name" : "backup",
  "tm" : 1610374366696
}

Another to http://127.0.0.1:8889/ (second node). Request took 3.21 seconds.
{
  "name" : "backup",
  "tm" : 1610374368697
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@zyclonite after it's merged, would you mind taking care of follow-up PRs in vertx-infinispan, vertx-hazelcast, vertx-ignite? And file an issue for vertx-zookeeper?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
so I tried myself to do this and my conclusion is that it is not worth doing it because it makes internally code more complex, as the returned certificates have to be transformed back to X509 certificates
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With Vert.x 4.0.0, I have a function that reads:
private Future<Void> getUrlAbsFails(String absUrl) {
    RequestOptions requestOptions = new RequestOptions()
        .setMethod(HttpMethod.GET)
        .setAbsoluteURI(absUrl);
    return client.request(requestOptions)
        .compose(req -> req.end().compose(x -> req.response()))
        .compose(res -> {
          Promise<Void> promise = Promise.promise();
          res.endHandler(d -> {
            if (res.statusCode() != 200) {
              promise.fail("expected 200");
              return;
            }
            promise.complete();
          });
          return promise.future();
        });
 }
This results in IllegalStateException .. checkEnded in HttpClientREsponseImpl.java:150.
The error happens at random.. Sometimes I have to run 10+ times or more.
Of course, there's a server behind an all that.
Here's a very similar method which works fine:
private Future<Void> getUrlAbsOK(String absUrl) {
    RequestOptions requestOptions = new RequestOptions()
        .setMethod(HttpMethod.GET)
        .setAbsoluteURI(absUrl);
    return client.request(requestOptions)
        .compose(req -> req.end()
            .compose(x -> req.response()).compose(res -> {
              Promise<Void> promise = Promise.promise();
              res.endHandler(d -> {
                if (res.statusCode() != 200) {
                  promise.fail("expected 200");
                  return;
                }
                promise.complete();
              });
              return promise.future();
            })
        );
  }
To me it seems like that HttpClientRequest (req) goes out of scope.. something bad may happen. Is the first implementation really faulty?
Can make a unit test upon request, if this really appears to be a bug
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually I think we don't need to have a provider and instead we can use in 3 the Java service loader mechanism.
As we are going to have a single thread factory most of the time and this is a very low level setting we should use java ServiceLoader for this at least in 3.x . When no factory is found then it uses the default thread factory.
Can you rework this PR to use service loader to load the factory and fallback to the regular thread factory when no one is present ? You can make VertxThreadFactory an interface in io.vertx.core.spi package and rename the current VertxThreadFactory to an impl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When Netty's HttpObjectDecoder encounters an invalid message it will create an HttpRequest that follow the same pattern (method: GET, version: 1.0, uri: /bad-request). On such message we should always respond with a 400 status response when no other response was decided before.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0
Context
I get a stack overflow exception while logging a completed CompositeFuture
Do you have a reproducer?
Yes:
import io.vertx.core.CompositeFuture;
import static io.vertx.core.Future.succeededFuture;
import static java.util.Collections.singletonList;
public class Simple {
    public static void main(String[] args) {
        CompositeFuture compositeFuture = CompositeFuture.all(singletonList(succeededFuture()));
        System.out.println(compositeFuture.toString());
    }
}

The code above gives a stack overflow exception
Steps to reproduce
Run program above
Extra
Java 11
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When will vert.x support http3? Do you have a plan yet?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Working with a JSON Stream via the Vert.x Web Client, I get a com.fasterxml.jackson.core.JsonParseException with the message Still have ... undecoded bytes, should not call 'feedInput'.
I dug a bit deeper into io.vertx.core.parsetools.impl.JsonParserImpl and was just wondering if it could be an issue:
JsonParserImpl#handle just calls parser.feedInput() without checking parser.needMoreInput() first.
However, com.fasterxml.jackson.core.async.ByteArrayFeeder, states that "caller must ensure data remains stable until it is fully processed (which is true when needMoreInput returns true)".
Could it be that we need to call needMoreInput() first?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a syntax error which is causing things like es4x to barf.  It is:
SyntaxError: /usr/src/app/node_modules/@vertx/core/options.js:17:65 Expected ; but found SSLEngineOptions KeyCertOptions: Java.type('io.vertx.core.net.KeyCertOptions') SSLEngineOptions: Java.type('io.vertx.core.net.SSLEngineOptions') TrustOptions: Java.type('io.vertx.core.net.TrustOptions')/// <reference types="@vertx/core/options" />
at org.graalvm.sdk/org.graalvm.polyglot.Context.eval(Context.java:347)
at io.reactiverse.es4x.Runtime$1.apply(Runtime.java:103)
at io.reactiverse.es4x.Runtime$1.apply(Runtime.java:58)
at js _load(file:/usr/src/app/node_modules/.lib/es4x-0.14.0.jar!/io/reactiverse/es4x/jvm-npm.js:68-71:2056-2187)

If you open the @vertx/core/options.js file on line 17 , you will notice the semi-colons are missing before SSLEngineOptions and before TrustOptions
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
scoped for 4.1.0 but it could be I think in 4.0.1 as there are no external breaking changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A Vertx instance is configured with a set of service (cluster manager, metrics, tracer, name resolver, etc...)
When a Vertx instance is created:

some of these are loaded using the Java service loading mechanism (e.g cluster manager)
some are hard wired (e.g transport or file resolver)
some can be provided programmatically (e.g cluster manager)

We shall provide a clear and controllable mechanism to create a Vertx instance that is used by Vert.vertx() or the CLI (BareCommand), but that also could be used directly to override services before or after the initialization has been performed, e.g to specify an alternative transport configuration or a different file resolver when Vert.x is embedded.
It also provides a unified way to load service providers and replace the existing Java service loading mechanisms.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MessageTagExtractor uses peer.service tag name for eventbus address. According to the conventions doc, it should be message_bus.destination.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The default implementation of the Buffer by index accessors (e.g getInt(int)) relies on ByteBuf to check the index respects the upper bound. Since this is an absolute operation for this buffer, the ByteBuf capacity is used instead which allows to access data beyond the Buffer length.
We need this implementation of Buffer to perform a check against the ByteBuf writer index to ensure the correctness.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version 4.0
I deploy most of the vertices as services with a json service descriptor.
When moving from 3.x to 4  I noticed that services that are marked as 'worker:true' are not being deployed as worker vertices and are executed in a even loop thread.
How to reproduce:
1.- Deploy any service verticle as a worker verticle (worker:true in the json descriptor in the 'options' section)
2.- The easiest way to verify if it is a worker verticle is to log something and check the thread name. Otherwise, you can use VertxThread.isWorker()
Seems to be an issue with the code in the service Factory, when it merges the config from the context.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
We need a way to automatically reload certificates from files when they're expired.
Use cases
In Kubernetes and other orchestration platforms it's very common to have a system that automagically rotate self-signed TLS certificates when expired https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/. These systems simply replace the .ca and .key files with new valid values.
Prior art in Golang: https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/
Possible solutions
Every time a certificate is requested during the TLS handshake, Vert.x could check if the actual certificate is expired and, if that's the case, it can try reload it from file.
Another solution could be a more generic method like GetCertificate in Golang that is invoked every time a new certificate is requested. Inside it, the user can do whatever it wants (reload every time from file, have some cache that refreshes the certificate asynchronously, etc)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
right, it was introduced by 25bbc9f#diff-38e15c129e2f81ad425c1bbe0005b26df5a661c05b6c2938d774d95879959cef
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I built RestEasy server under Netty and Vert.x
Now I transfer a huge file from the server's database to the client wia java stream
Client and network too slow for this huge file, and Netty consume all memory while allocating io.netty.channel.ChannelOutboundBuffer$Entry. It occured because RestEasy and Vert.x don't communicate with Netty about flood control.
Maybe exists some techniques for such flooding?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
HttpClient encounters io.vertx.core.http.impl.NoStackTraceTimeoutException (the timeout I set is 3 seconds) when sending a request. After being caught by the exceptionHandler, this exception is printed in the exceptionHandler, but then io.vertx.core is captured. VertxException: Connection was closed (the idle time I set was 10 minutes), which caused me to print two exceptions. Why did Connection was closed appear after NoStackTraceTimeoutException?
Version
3.9.4
HttpClientRequest outgoingRequest = httpClient.requestAbs(incomingRequest.method(), fullUrl)
                .setFollowRedirects(true)
                .handler(clientResponse -> handleProxyResponse(pc, clientResponse))
                .exceptionHandler(t -> {
                    //NoStackTraceTimeoutExceptionConnection was closedNoStackTraceTimeoutException
                    log.error("handle proxying error, traceId {}, original request {}, proxying request {}", pc.traceId(), incomingRequest.absoluteURI(), fullUrl);
                    quickCloseResponse(pc, t);
                });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
websocket conentcion:  client ->  nginx -> sever (websocket)
when network  barrier between client and nginx.   and server call WebSocet close() function, closeHandler will not be invoked.
in previous version, it will invoked, and i notice this issue: #3531
this will be fine when network is OK.  in my secene (network barrier, cannot ping to client), this will not work, due to no close frame echo back.
can i have some other close() funciton to invoke clsoeHandler directly?
Version
3.9.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This applies to Vert.x 4.0.0
Reproduction steps:

deploy a verticle with shared worker pool name set in DeploymentOptions
do some work
undeploy

Expected:
The shared worker pool name can be reused
Actual:
The shared worker pool is terminated and remains in the shared worker map.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There are a few places where Vert.x does not release ByteBuf.
We should release those ByteBuf to avoid leaks and return them to the pool or free the direct memory.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it looks fine but can you describe the issue that is solved in addition of describing what you do instead of what was done in your commit message ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The following code will run a bunch of blocking tasks all with ordered=true
public static void main(String[] args){
Context context0 = Vertx.vertx().getOrCreateContext();
context0.runOnContext(ignored0 -> {
	Vertx vertx = Vertx.currentContext().owner();
	vertx.eventBus().consumer("eb_address", m -> runTask(m.body().toString()));
	runTask("Task 1");
	runTask("Task 3");
	vertx.eventBus().publish("eb_address", "Task 2");
	vertx.setTimer(1, t -> {
		runTask("Task 4");
		vertx.eventBus().publish("eb_address", "Task 5");
	});
});
}

public static void runTask(String name){
        Vertx.currentContext().executeBlocking(promise -> {
	        System.out.println(name + " start");
	        try {
		        Thread.sleep(1000);
	        }catch(Exception e){
		        promise.fail(e);
		        return;
	        }
	        System.out.println(name + " done");
	        promise.complete();
        }, true);
}
This is the output:
Task 1 start
Task 2 start
Task 5 start
Task 1 done
Task 3 start
Task 2 done
Task 5 done
Task 3 done
Task 4 start
Task 4 done

Given that ordered=true, the output is odd, as conventional wisdom (and the documentation) would say that for any Task n start the message that should always follow it is Task n done. Of course ordering is only the case when the calls take place within the same context, and they all are called from the same context. Right?
I know that's not the case, but for any person that hasn't read the implementation, they should reasonably expect that everything that I wrote above is all run from the same context. That's the core of this issue, certain handlers are called with a DuplicatedContext and it causes unusual behavior because it creates a view of the parent context with the blocking TaskQueue being independant of the parent. Also, these side effects are completely undocumented.
I understand why DuplicatedContext exists, and I also know why we made the DuplicatedContext use its own TaskQueue, but I don't think the different TaskQueue was a good idea. It will cause issues for developers that will not be discovered immediately and in its current form make implementing the scheduler for RxJava imposible (For reasons why see: vert-x3/vertx-rx#245 (comment)) Personally I think it should be removed, and jdbc-client should revert back to the old solution (it appears to be the only thing that should use TaskQueue, but it doesn't look like it was properly implemented, see:  vert-x3/vertx-jdbc-client#203 (comment)). Even though that is what I think, I don't think that is something that is going to happen, so I have a simpler solution. Do not create a seperate TaskQueue unless explicitly specified. This way the DuplicatedContext behaves exactly like its parent for all actions (though of course the localData map is not preserved between the two)
I'm already busy on a PR to make a couple of changes around DuplicatedContext
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
System.setErr(new PrintStream(new ByteArrayOutputStream())) has to leak. The ByteArrayOutputStream has a buffer buf which limit would always grow. In order to prevent the buffer from growing infinitelly you have to override the write(int b) and write(byte b[], int off, int len) methods to be empty.
IMO you used ByteArrayOutputStream because you did not want to crearte a new class. I am the Apache developer who develops Surefire Plugin. My recommendation for you is to follow the hint in Surefire and implement the same NullOutputStream and use it instead of ByteArrayOutputStream.
Version
4.0.2
Context
I am going to implement my own DelegateFactory for slf4j-simple and I have found the implementation of SLF4JLogDelegateFactory in the JAR of the core.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpServerRequest should provide a way to access the server request it is currently associated with.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this seems like a lot of changes and additions, I'll have a look myself
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.2
Context
Processing of forms with large attribute values is not possible in Vert.x 4 because maximum attribute size is hardcoded to 1024 in NettyFileUploadDataFactory / VertxAttribute class. It works without problems in Vert.x 3.9.5 or when setMaxSize() argument is changed to bigger value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
We ported our service to use Vert.x awhile ago. While using Vert.x we still used Apache HTTP client without problems. However, now I tried to port also this functionality to Vert.x and I hit a problem.
It seems that Vert.x HttpClient does not allow to set a proxy per request, only on the client level. We use 1000+ proxies simultaneously to scrape websites.
Is there any workaround? How feasible is to create an instance per request?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx-core 4.0.0
vertx-micrometer-metrics 4.0.0
Context
We noticed that one of our positive-only metric is having negative values on several instances.
Using micrometer library, metric is named vertx_http_server_active_connections
This problem is however related to vertx-core metric abstraction. More precisely, how vertx-core handles connection opening and active connections metric increase.
Steps to reproduce
Reproducer: https://github.com/Mersenne255/vertx_issue_3796_reproducer
We've been able to easily reproduce metric going into negative values using vertx HTTP/2.0 server with SSL enabled.
But I believe this issue is relevant for all types of connections.
Idea how to reproduce is to close the TCP connection right after it was initialized, but connection number wasn't increased yet.
Connections metric decrease is abstracted inside class io.vertx.core.net.impl.ConnectionBase, so even when the connection count wasn't increased on connection open, it would still be decreased on connection close.

Start HTTP/2.0 vertx server over SSL
Run a client of this service, with io.vertx.core.net.TCPSSLOptions#sslHandshakeTimeout of ~100-200ms (for local run) - this might take multiple tries, as client closing connection must hit precisely timeframe within server processing, when connection was already established, but metrics not yet increased

Extra
JVM 15
OS version: fedora-coreos-31
Hosted on AWS EC2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0-milestone5
Change clustered registration model
Context
Clustered application crashes in production since upgrading to VertX 4.0.1.
This application uses a WebSocket to EventBus bridge creating MessageConsumers 1:1 to websocket connections.
These Websockets are used by end-user UI and therefore has to scale on both establishing connections and active connection dimensions.
In VertX 3.9.5 up to M5 this was not an issue because registration only happend on a per node basis.
Do you have a reproducer?
https://github.com/DemonicTutor/vertx-clustereventbus-performance
Steps to reproduce

clustered VertX application
deploy 2 or more nodes
create consumers / localConsumers or unregister them - both trigger the issue

Extra
openJdk 15
Details
previously ClusteredEventBus ignored localOnly

https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java#L128
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java#L147

a) this seems useless to me because Selector filters localOnly out again
b) because of this there is no easy way to simply avoid the cluster-overhead
Selectors implementation evaluates all registrations on update - does not scale if adding more consumers
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/spi/cluster/impl/selector/Selectors.java#L75
also in case of adding nodes / startup of the entire cluster this approach seems wasteful ?
when one node is running and another starts up the first node would get each created consumer via update - reading the entire clustered map for each update.
So if we create 10 consumers in an application it would

update 1
read 1
update 2
read 2
and so on...
and because the clustered Map is based on address it reads every node
so if you have a cluster of 10 nodes - add node 11 - you fetch data from all 11 nodes.

Update Event only allows updating all registrations
https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/spi/cluster/RegistrationUpdateEvent.java
SubsMapHelper does not scale - uses a LOT of network / cpu
https://github.com/vert-x3/vertx-hazelcast/blob/master/src/main/java/io/vertx/spi/cluster/hazelcast/impl/SubsMapHelper.java
While only adding a few consumers this is fine.
But if you either need "a lot" of consumers or need to create them dynamically (as is our case) this simply does not scale
for every single added consumer the entire map is read and triggers the update.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version did you encounter this bug? 4.0.2
Context
I'm using Vert.x Verticles to process messages sequentially per given address, up to 3.9.5 a consumer would only process messages in a sequential order but now they seem to be doing that concurrently.
Do you have a reproducer?
Yes, here is a simple unit test, it passes with 3.9.5 and fails with 4.0.2:
https://gist.github.com/guidomedina/ff20d1531bf59e046dd5fd5599918052
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A runtime embedding might want to have Vert.x uses a specific subclass of VertxThread. This is a port of #3749 using the Vert.x 4 service provider mechanism and with a simplification of the factory responsibility.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@geoand @FroMage this is the port of the thread customization to 4, can you have a look?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if there is an exception then the test fails.

On Fri, Feb 12, 2021 at 12:20 PM Guido Medina ***@***.***> wrote:
 ***@***.**** commented on this pull request.
 ------------------------------

 In src/test/java/io/vertx/core/ContextTest.java
 <#3802 (comment)>:

 > +    ContextInternal worker = ((VertxInternal)vertx).createWorkerContext();
 +    ContextInternal[] contexts = new ContextInternal[] { worker.duplicate(), worker.duplicate()};
 +    waitFor(contexts.length);
 +    AtomicBoolean owner = new AtomicBoolean();
 +    CountDownLatch latch = new CountDownLatch(contexts.length);
 +    for (ContextInternal context : contexts) {
 +      task.accept(context, () -> {
 +        try {
 +          assertTrue(owner.compareAndSet(false, true));
 +          Thread.sleep(200);
 +        } catch (InterruptedException e) {
 +          Thread.currentThread().interrupt();
 +        } finally {
 +          owner.set(false);
 +        }
 +        latch.countDown();

 Actually, now I remember why I have 2 try blocks, here is how I would had
 that code:

 try {
   assertTrue(owner.compareAndSet(false, true));
   try {
     Thread.sleep(200);
   } catch (InterruptedException e) {
     Thread.currentThread().interrupt();
   } finally {
    // if we reach this finally the owner was successfully set to true by this thread
     owner.set(false);
   }
 } finally {
   // Regardless of success or any exception always decrement the latch
   latch.countDown();
 }

 
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#3802 (comment)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AABXDCSIPXZIP3F4NUEZAJ3S6UFILANCNFSM4XOORDNA>
 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
The io.vertx.core.http.RequestOptions in Vert.x 4.0.0 allows to set up instance with absolute Uri as a String via RequestOptions().setAbsoluteUri(...).  Could be this extended also for providing Uri as a java.net.URL ?
Use cases
In our calls we have a request uri directly in java.net.URL . For creating RequestOptions instance, we have to convert URL to String, enabling us to call setAbsoluteUri. But inside of this String is immediately parsed back to URL via RequestOptions.parseUrl() which is ineffective (as parseUrl correctly mentions it in Note).
Contribution
I have zero experience with contributing to any library but this could be easy done via splitting setAbsoluteUri into parsing and processing method:
  public RequestOptions setAbsoluteURI(String absoluteURI) {
    Objects.requireNonNull(absoluteURI, "Cannot set a null absolute URI");
    return this.setAbsoluteURI(parseUrl(absoluteURI));
  }

  public RequestOptions setAbsoluteURI(URL url) {
    Objects.requireNonNull(absoluteURI, "Cannot set a null absolute URI");
    Boolean ssl = false;
    int port = url.getPort();
    String relativeUri = url.getPath().isEmpty() ? "/" + url.getFile() : url.getFile();
    String protocol = url.getProtocol();
    switch (protocol) {
      case "http":
        if (port == -1) {
          port = 80;
        }
        break;
      case "https": {
        ssl = true;
        if (port == -1) {
          port = 443;
        }
        break;
      }
      default:
        throw new IllegalArgumentException();
    }
    this.uri = relativeUri;
    this.port = port;
    this.ssl = ssl;
    this.host = url.getHost();
    return this;
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A custom Launcher is often used when you want to setup things like metrics options programmatically before Vert.x is started.
Since #3771 , it is no longer possible to do this because the builder init method is invoked before the Launcher callback.
Then it's too late to customize the metrics implementation.
This applies to other special options too, I think (e.g. tracing, cluster manager).
EDIT: actually, it's no longer possible to activate some metrics options with sysprops. From Dropwizard docs:
-Dvertx.metrics.options.enabled=true -Dvertx.metrics.options.jmxEnabled=true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
httpclient sets connecttimeout, when the connection fails (possibly due to network jitter or upstream performance issues), the duration of connect failed callback may be less than the connecttimeout.
CircuitBreaker '****' recorded an error: 'io.netty.channel.ConnectTimeoutException: connection timed out: */'. Elapsed time: 1 ms
io.netty.channel.ConnectTimeoutException: connection timed out: **
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267)
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Version
3.6.x - 3.9.x
Do you have a reproducer?
https://gist.github.com/jinwik/569938388962a457a93ee87d9b9c6732
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@cescoffier ping
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the test fails is that expected ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@cescoffier ping, here is the order mechanism in master
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@lordvlad can you please sign the Eclipse Contributor Agreement?
https://www.eclipse.org/legal/ECA.php
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx-core 4.0.2
Context
We have encoured an issue whereby after a variable amount of subsequent reqeuests using HttpClientRequest, it appears that the subsequent response handlers are not called, and the request hangs.
We had used a variation of this pre vertx-core 4.0.0 which we cannot reproduce the issue on.
It appears to fail quicker when keep-alives are enabled, and quicker with a larger response size (256K and above).
This appears to only happen when running in a worker verticle, it is not reproducable when DeploymentOptions has worker set to false.
Do you have a reproducer?
https://github.com/russthom/vertx-httpclientrequest-issue
Steps to reproduce

mvn package
serve up 'testfile' on localhost:8080 (I generate a random 512K, e.g 'head -c 512K </dev/urandom > testfile')
run the jar (java -jar target/vertx-httpclient-test-0-jar-with-dependencies.jar)
it will hang on the request after 2/3rd run

Extra

Java 11, but also reproducable with Java 15.
Running on RHEL 8, but also reproducable on Arch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,  I am new to vert.x, and I want to  find out Transaction on vert.x.
In akka's can do this. user STM, Coordinated transactions.
Scenario:
A user tranfers 100$ to B user. A's account deduct 100$, B's account increase 100$.
When B's increase fail, roll back A 's 100$.
I think transaction is very important for a reliable system. Does vertx miss this feature?
How can I do with Vertx, please help
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Question
when i do not use "put("raw-data", true)"  ,if my config is :
password=123456
I get a value "123456.0" by this method config.getString("password");
but
when I use  "put("raw-data", true)", this problem is ok but i have an other config
port=80
I get an error  when i use config.getInteger("port")because it was not supported.
Version
4.0.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
Version
4.0.2
Context
We tried to migrate our services from Legacy JDBC Client or SqlClient. For Postgres dbms everything works fine as expected, but with Oracle the following exception is signaled:
stream error java.sql.SQLException: Nicht untersttzte Funktion: getMetaData Feb. 18, 2021 7:03:02 VORM. io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
SEVERE: Failed in deploying verticle
java.sql.SQLException: Nicht untersttzte Funktion: getMetaData
at oracle.jdbc.driver.ArrayDataResultSet.getMetaData(ArrayDataResultSet.java:1080)
at io.agroal.pool.wrapper.ResultSetWrapper.getMetaData(ResultSetWrapper.java:460)
at io.vertx.jdbcclient.impl.actions.JDBCQueryAction.decodeReturnedKeys(JDBCQueryAction.java:182)
at io.vertx.jdbcclient.impl.actions.JDBCQueryAction.decode(JDBCQueryAction.java:59)
at io.vertx.jdbcclient.impl.actions.JDBCPreparedQuery.execute(JDBCPreparedQuery.java:69)
at io.vertx.jdbcclient.impl.actions.JDBCPreparedQuery.execute(JDBCPreparedQuery.java:39)
at io.vertx.ext.jdbc.impl.JDBCConnectionImpl.lambda$schedule$3(JDBCConnectionImpl.java:217)
at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:179)
at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:96)
at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$1(ContextImpl.java:177)
at io.vertx.core.impl.TaskQueue.run(TaskQueue.java:76)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:834)
A similar error was described here: https://groups.google.com/g/vertx/c/H6jGDlkx9No/m/07et_foRDwAJ
Do you have a reproducer?
A reproducer is a simple project hosted on GitHub (or another forge supporting git clone operation) that has a build file that can be executed to reproduce the issue.
Reproducers are very helpful for contributors and will likely help them fixing your bug faster.

https://github.com/ukr15/sql-client-error

Steps to reproduce

Unpack archive
Move to src/main/java/de/testVertx4JdbcTest
The program is configured for a postgres database. Configure it for an Oracle Database
mvn clean install
java -jar target/vertx4-jdbc-test-1.0.0-fat.jar  one ore more records should be printed in dependence on the database

Extra

Testet under MacOS and some linux (oracle testing has been done by another party
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The main problem is that the commit does not say what is improved and what changes. The linked issue references Jackson where you advocate to not use it and instead use the to/from JSON and does not seem related directly to the commit.
From what I can observe, I can see that the code uses HttpMethod.valueOf() as improvement and also implement missing headers conversion. I haven't look at it carefully.
My point is that we need to have the commit to describe what I said above, otherwise I cannot review that commit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add a config property to AddressResolverOptions.
When round robin is enabled, use Netty's RoundRobinInetAddressResolver to enable load balancing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.0-4.0.3-SNAPSHOT
Context
I used JsonParser.pause() and JsonParser.resume() methods between time-consuming operations with Vert.X v. 3.9.4.
Since I upgraded to v. 4.0.0 I started to get NullPointerException.
I've checked out latest snapshot version 4.0.3 but the problem is still there.
Do you have a reproducer?

Link to github project/gist

https://github.com/egorapolonov/vertx-4.0.0-jsonparser-issue/tree/master/vertx-4.0.0-jsonparser-issue
See JsonParserAsyncFileTest.java
Steps to reproduce

Try to parse JSON structure like "{...}{...}...{...}"
Have more than 2 objects there in JSON
See errors

java.lang.NullPointerException: Cannot invoke "io.vertx.core.parsetools.impl.JsonParserImpl$TokenParser.close()" because "this.buffer" is null
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:433)
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:388)
   at io.vertx.core.parsetools.impl.JsonParserImpl.checkPending(JsonParserImpl.java:241)
   at io.vertx.core.parsetools.impl.JsonParserImpl.fetch(JsonParserImpl.java:84)
   at io.vertx.core.parsetools.impl.JsonParserImpl.resume(JsonParserImpl.java:74)
   at com.vertx.reproducer.JsonParserAsyncFileTest.lambda$parseWithExceptionHandler$0(JsonParserAsyncFileTest.java:58)
   at io.vertx.core.parsetools.impl.JsonParserImpl.handleEvent(JsonParserImpl.java:121)
   at io.vertx.core.parsetools.impl.JsonParserImpl.lambda$objectValueMode$2(JsonParserImpl.java:285)
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:432)
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:388)
   at io.vertx.core.parsetools.impl.JsonParserImpl.checkPending(JsonParserImpl.java:241)
   at io.vertx.core.parsetools.impl.JsonParserImpl.fetch(JsonParserImpl.java:84)
   at io.vertx.core.parsetools.impl.JsonParserImpl.resume(JsonParserImpl.java:74)
   at com.vertx.reproducer.JsonParserAsyncFileTest.lambda$parseWithExceptionHandler$0(JsonParserAsyncFileTest.java:58)
   at io.vertx.core.parsetools.impl.JsonParserImpl.handleEvent(JsonParserImpl.java:121)
   at io.vertx.core.parsetools.impl.JsonParserImpl.lambda$objectValueMode$2(JsonParserImpl.java:285)
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:432)
   at io.vertx.core.parsetools.impl.JsonParserImpl$BufferingHandler.handle(JsonParserImpl.java:388)
   at io.vertx.core.parsetools.impl.JsonParserImpl.checkPending(JsonParserImpl.java:241)
   at io.vertx.core.parsetools.impl.JsonParserImpl.handle(JsonParserImpl.java:207)
   at io.vertx.core.parsetools.impl.JsonParserImpl.handle(JsonParserImpl.java:41)
   at io.vertx.core.file.impl.AsyncFileImpl.handleBuffer(AsyncFileImpl.java:425)
   at io.vertx.core.file.impl.AsyncFileImpl.lambda$new$0(AsyncFileImpl.java:110)
   at io.vertx.core.streams.impl.InboundBuffer.handleEvent(InboundBuffer.java:240)
   at io.vertx.core.streams.impl.InboundBuffer.write(InboundBuffer.java:130)
   at io.vertx.core.file.impl.AsyncFileImpl.lambda$doRead$5(AsyncFileImpl.java:407)
   at io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:125)
   at io.vertx.core.impl.future.FutureBase.lambda$emitSuccess$0(FutureBase.java:53)
   at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
   at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
   at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
   at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
   at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
   at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
   at java.base/java.lang.Thread.run(Thread.java:832)

Feb 23, 2021 10:20:27 PM com.vertx.reproducer.JsonParserAsyncFileTest
INFO: Successfully parsed 4 items of 4

Process finished with exit code 255

Extra

Ubuntu 20.04 x86_64, JVM openjdk-15.0.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vert.x 4.0.0
Context
The implementation of the JSON RFCs (#3197) removed the type checking from methods JsonObject.put(String, Object) and JsonArray.add(int, Object) in order to allow future POJO mappings. Nevertheless the methods Json{Object|Array}.copy() are still checking types. This leads to the situation that developers are able to successfully create Json{Object|Array}s that cannot be copied afterwards.
When using the following piece of code for creating valid JsonObjects
  try {
    jsonObject.put(key, value);
  }
  catch (IllegalStateExcveption e) {
    jsonObject.put(key, value.toString());
  }

which are copied afterwards, #3197 breaks that piece of code and is not backward compatible.
Do you have a reproducer?
A small reproducer can be found at https://github.com/riemenschneider/JDBCPreparedQueryTest. The test fails with Vert.x 4.0.0 and runs successful using Vert.x 3.9.5.
Steps to reproduce

Clone the reproducer mentioned above.
Run gradlew test.
Change Vert.x dependency in build.gradle to io.vertx:vertx-core:3.9.5 and run again gradlew test.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP server request has an hardcoded bound of 1024 bytes for form upload attributes. It should be configurable in HTTP server options and have a greater default value (2048).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you please sign the ECA and sign-off your commit?
After signing the ECA you can do:
git commit -s --amend
git push --force
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Is this a bug?

Version
4.0.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.2
Context
Cloning a vertx options that sets the tracer object fails.
var defaultOptions = new VertxOptions()
				.setTracingOptions(new OpenTracingOptions(GlobalTracer.registerIfAbsent(...)))
var vertxOptions = new VertxOptions(defaultOptions);
assertNotNull(vertx.getTracingOptions());
// throws
var vertx = Vertx.vertx(vertxOptions);

Do you have a reproducer?
(self explanatory)
Steps to reproduce

Create a VertxOptions with a tracing agent set in OpenTracingOptions.
Copy it using the new VertxOptions(existingOptions)
Construct an vertx from the copied options.
Observe it fails with the below exception because the tracer field in OpenTracingOptions is not copied.

Service name must not be null or empty
java.lang.IllegalArgumentException: Service name must not be null or empty
	at io.jaegertracing.internal.JaegerTracer$Builder.checkValidServiceName(JaegerTracer.java:691)
	at io.jaegertracing.Configuration.<init>(Configuration.java:196)
	at io.jaegertracing.Configuration.fromEnv(Configuration.java:208)
	at io.jaegertracing.Configuration.fromEnv(Configuration.java:204)
	at io.vertx.tracing.opentracing.OpenTracingTracer.createDefaultTracer(OpenTracingTracer.java:43)
	at io.vertx.tracing.opentracing.OpenTracingOptions.buildTracer(OpenTracingOptions.java:38)
	at io.vertx.tracing.opentracing.OpenTracingTracerFactory.tracer(OpenTracingTracerFactory.java:28)
	at io.vertx.core.impl.VertxFactory.createTracer(VertxFactory.java:154)
	at io.vertx.core.impl.VertxFactory.vertx(VertxFactory.java:78)
	at io.vertx.core.Vertx.vertx(Vertx.java:86)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current HTTP/1.x client connection simply ignores any message that is received when there is no request in progress to handle this message. When it happens the connection should be closed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
In version 4.0.2 the Vert.x Web API Contract is deprecated and the document suggested using Vert.x OpenAPI but I noticed it has no support for RxJava2 API.
If you consider this as a feature, please give me some information about it so I can implement and contribute.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Read me
the interface WebSocketFrame do not have type(),when i need to judge if a frame was a PingFrame,i can only do it like this:
WebSocketFrameImpl webSocketFrameIml = null;
if (webSocketFrame instanceof WebSocketFrameImpl) {
webSocketFrameIml = (WebSocketFrameImpl) webSocketFrame;
}
if (webSocketFrameIml.type().name().equals(FrameType.PING.name())) {
pongSocketFrameHandler(webSocket, channelId, webSocketFrameIml);
}
Describe the feature
i expect to add method type() in WebSocketFrame, if i want to know pingframe i can use type() to judge.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
I get an IOException when handling long attributes values in POSTed forms, which I had not on 3.9
Version
Vertx core/web 4.0.2
Context
When using BodyHandler I get an IOException on long parameters values
"IOException Size exceed allowed maximum capacity"
This seems to be a regression, I had not the problem on 3.9.X
Do you have a reproducer?
No but offending line seems to be on file NettyFileUploadDataFactory, line 82 :
 private static class VertxAttribute extends MemoryAttribute {
    public VertxAttribute(String name, long definedSize) {
      super(name, definedSize);
      setMaxSize(1024); //// here the netty attribute is limited in size, but not the definedSize
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Version
<vertx.version>4.0.2</vertx.version>

JDK1.8
code
``
Router router = Router.router(vertx);
//noticie the empty string in the head
router.route("   /api/wallet/v1/userInfo/byAddress").handler(context -> context.json(
new JsonObject()
.put("code", 0)
.put("msg", "HELLO WORLD")
.put("data", 854940268259348481L)
));
`
`
Extra
this will leading to block on start ,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we can achieve the same without the boolean and simply setting the cached query to null
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.3
Context
In the logs of one server instance (that hosts a vertx-web based rest api) i see the following NPE every second with some pauses in between where the exception is not logged:
ContextImpl       vert.x-eventloop-thread-4  Unhandled exception
java.lang.NullPointerException: Cannot invoke "io.vertx.core.http.impl.Http1xServerRequest.metric()" because "request" is null
    at io.vertx.core.http.impl.Http1xServerConnection.reportResponseComplete(Http1xServerConnection.java:260)
    at io.vertx.core.http.impl.Http1xServerConnection.responseComplete(Http1xServerConnection.java:206)
    at io.vertx.core.http.impl.Http1xServerResponse.end(Http1xServerResponse.java:409)
    at io.vertx.core.http.impl.Http1xServerResponse.end(Http1xServerResponse.java:388)
    at io.vertx.core.http.impl.Http1xServerResponse.end(Http1xServerResponse.java:444)
    at io.vertx.core.streams.impl.PipeImpl.handleSuccess(PipeImpl.java:116)
    at io.vertx.core.streams.impl.PipeImpl.lambda$to$2(PipeImpl.java:102)
    at io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:124)
    at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
    at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
    at io.vertx.core.impl.future.PromiseImpl.tryComplete(PromiseImpl.java:23)
    at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:96)
    at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:59)
    at io.vertx.core.http.impl.HttpEventHandler.handleEnd(HttpEventHandler.java:76)
    at io.vertx.core.http.impl.HttpClientResponseImpl.handleEnd(HttpClientResponseImpl.java:250)
    at io.vertx.core.http.impl.Http2ClientConnection$StreamImpl.handleEnd(Http2ClientConnection.java:433)
    at io.vertx.core.http.impl.VertxHttp2Stream.lambda$new$1(VertxHttp2Stream.java:62)
    at io.vertx.core.streams.impl.InboundBuffer.handleEvent(InboundBuffer.java:240)
    at io.vertx.core.streams.impl.InboundBuffer.write(InboundBuffer.java:130)
    at io.vertx.core.impl.EventLoopContext.emit(EventLoopContext.java:52)
    at io.vertx.core.impl.DuplicatedContext.emit(DuplicatedContext.java:194)
    at io.vertx.core.http.impl.VertxHttp2Stream.onEnd(VertxHttp2Stream.java:134)
    at io.vertx.core.http.impl.Http2ClientConnection$Stream.onEnd(Http2ClientConnection.java:277)
    at io.vertx.core.http.impl.VertxHttp2Stream.onEnd(VertxHttp2Stream.java:129)
    at io.vertx.core.http.impl.Http2ConnectionBase.onDataRead(Http2ConnectionBase.java:316)
    at io.netty.handler.codec.http2.Http2FrameListenerDecorator.onDataRead(Http2FrameListenerDecorator.java:36)
    at io.netty.handler.codec.http2.Http2EmptyDataFrameListener.onDataRead(Http2EmptyDataFrameListener.java:49)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:318)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:422)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:251)
    at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
    at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:181)
    at io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder.decodeFrame(DecoratingHttp2ConnectionDecoder.java:63)
    at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378)
    at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:447)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
    at io.vertx.core.http.impl.VertxHttp2ConnectionHandler.channelRead(VertxHttp2ConnectionHandler.java:376)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
    at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1534)
    at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1283)
    at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1330)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:447)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.base/java.lang.Thread.run(Thread.java:832)

As the StackTrace contains only classes from vertx and netty I don't know what to do about it or what might cause it, and as it's a NPE I think it might be interesting.
Extra
Windows Server 2019
AdoptOpenJDK 15.0.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.3
Context
I encountered an exception while processing an HTTP request.
Do you have a reproducer?
The issue can be reproduced with https://github.com/TNG/keycloak-mock/tree/test/update-spring-boot
Steps to reproduce

Check out branch test/update-spring-boot
Run test com.tngtech.keycloakmock.examplebackend.AuthenticationTest in module example-backend
See a NullPointerException:

java.lang.NullPointerException: cause
	at io.netty.util.internal.ObjectUtil.checkNotNull(ObjectUtil.java:33) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:278) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.DefaultChannelPipeline.fireExceptionCaught(DefaultChannelPipeline.java:907) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.vertx.core.net.impl.ConnectionBase.fail(ConnectionBase.java:117) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.http.impl.Http1xServerConnection.handleError(Http1xServerConnection.java:531) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.http.impl.Http1xServerConnection.handleError(Http1xServerConnection.java:524) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.http.impl.Http1xServerConnection.handleMessage(Http1xServerConnection.java:125) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.net.impl.ConnectionBase.read(ConnectionBase.java:153) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:154) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:93) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler.channelRead(WebSocketServerExtensionHandler.java:102) ~[netty-codec-http-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.vertx.core.http.impl.Http1xUpgradeToH2CHandler.channelRead(Http1xUpgradeToH2CHandler.java:115) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324) ~[netty-codec-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296) ~[netty-codec-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:61) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:38) ~[vertx-core-4.0.3.jar:4.0.3]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]
	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_282]

Extra
As far as I can tell, the issue is caused by io.vertx.core.http.impl.Http1xServerConnection#handleMessage comparing the DecoderResult by value. With netty/netty@3f23f59 (released with Netty 4.1.61), Netty now creates its own HttpMessageDecoderResult instance, which is no longer value-equal to DecoderResult.SUCCESS.
This is not (yet) an issue with the netty version referenced in your project, but when used in combination with Spring boot 2.4.5, which pulls Netty 4.1.63, the issue arises.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
upgrading from 3.9.4 to 3.9.7
Context
A unit test case to deploy two vertical
    VertxUtils
        .blockDeploy(SharedVertxFactory.getSharedVertx(), TestServerVerticle.class, new DeploymentOptions());
    VertxUtils
        .blockDeploy(SharedVertxFactory.getSharedVertx(), TestClientVerticle.class, new DeploymentOptions());

got NullPointerException
java.lang.NullPointerException: cause
	at io.netty.util.internal.ObjectUtil.checkNotNull(ObjectUtil.java:33)
	at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:278)
	at io.netty.channel.DefaultChannelPipeline.fireExceptionCaught(DefaultChannelPipeline.java:907)
	at io.vertx.core.net.impl.VertxHandler.fail(VertxHandler.java:88)
	at io.vertx.core.net.impl.ConnectionBase.fail(ConnectionBase.java:86)
	at io.vertx.core.http.impl.Http1xServerConnection.handleError(Http1xServerConnection.java:495)
	at io.vertx.core.http.impl.Http1xServerConnection.handleError(Http1xServerConnection.java:488)
	at io.vertx.core.http.impl.Http1xServerConnection.handleMessage(Http1xServerConnection.java:121)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)
	at io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:229)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:164)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:93)
	at io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler.channelRead(WebSocketServerExtensionHandler.java:102)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.vertx.core.http.impl.Http1xUpgradeToH2CHandler.channelRead(Http1xUpgradeToH2CHandler.java:109)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.end(Http1xOrH2CHandler.java:61)
	at io.vertx.core.http.impl.Http1xOrH2CHandler.channelRead(Http1xOrH2CHandler.java:38)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

and cause application hang in second deployment.
Do you have a reproducer?
https://github.com/apache/servicecomb-java-chassis/blob/master/metrics/metrics-core/src/test/java/org/apache/servicecomb/metrics/core/TestVertxMetersInitializer.java
Steps to reproduce
see above
Extra
Check the lastest version, seems related to this change in the latest version:  957e9a5#diff-6066745d72c6f938f3c9b5b7f76471ede6d87c6372f30f2e104e62d083637e4a
if (request.decoderResult() != DecoderResult.SUCCESS) {

got true.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.3
Context
We noticed an odd ClassLoading failure when running the MP Rest Client TCK against Resteasy Reactive, on investigation it turned out that the TCCL of the Vert.x thread was null.
Do you have a reproducer?
If you checkout Quarkus you can uncomment microprofile-rest-client-reactive in tcks/pom.xml and run e.g.
mvn clean install -Ptcks -pl tcks,tcks/microprofile-rest-client-reactive -Dtest=SslMutualTest
If you debug and set a breakpoint for ServiceConfigurationError you will see the TCCL is null. If you set <vertx.disableTCCL>true</vertx.disableTCCL> the test will pass.
Extra
The offending code seems to be in io.vertx.core.impl.AbstractContext#endDispatch(), which will null out the TCCL if the previous context is null, instead of returning it to the previous value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ping @cescoffier @stuartwdouglas
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
3.9.x
Context
Log is not logged
Do you have a reproducer?
No.
Steps to reproduce
This is coming from conversation here: https://groups.google.com/g/vertx/c/CZaPXYk2MA0
Add LoggerHandlerImpl to your route as early as possible. Make sure immediate is false, so that the log gets loged at the end of the request to ensure that context.addBodyEndHandler(v -> log(context, timestamp, remoteClient, version, method, uri)); is used.
Have client connect and drop close the connection before response is returned.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the Eclipse agreement @toir427 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
when i deploy an httpserver like this:
HttpServer server = vertx.createHttpServer(); server.requestHandler(router).listen(80),result ->{}).exceptionHandler(hr ->{});
it sometimes give an error like this:
16:01:44.158 [vert.x-acceptor-thread-0] WARN  i.n.util.concurrent.DefaultPromise - An exception was thrown by io.vertx.core.net.impl.TCPServerBase$$Lambda$103/478839936.operationComplete() java.lang.IllegalStateException: null
Version
vertx-core-4.0.3
Context
I encountered an exception which looks suspicious while ...
Do you have a reproducer?
step 1Add breakpoint at IllegalStateException line 44
step 2Add breakpoint at CloseHooks line 82
step 3start application


Extra
when i remove exceptionHandler,the error is gone,like this
HttpServer server = vertx.createHttpServer(); server.requestHandler(router).listen(Integer.parseInt(config().getString("web.http.port")),result ->{});
and How did I find this problemi deploy it in Linux the server cannot startso i find this problembut in my computer , i must Add breakpoint to reproducer this problem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
The Cookie Interface should have a method to access the maxAge property of a cookie. Right now, one can only set the max age of a cookie. but not read it.
Use cases
Give complete access to the wrapped netty default cookie. This is the only attribute one cannot read/write.
We would use this feature in a http proxy, where only a session cookie should be sent to the user agent and all other cookies from proxied requests/responses are stored in the proxy. To comply with RFC6265, we have to remove cookies from the storage when the maxAge is set to 0.
Contribution
I'd volunteer to implement this feature.
Implementation suggestion

add method getMaxAge() to Cookie interface
implement method getMagAge() in CookieImpl class
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Following the discussion in the following google group thread: https://groups.google.com/g/vertx/c/uRU6PYd3CKs/m/2nRuqCaEAgAJ
I would like to remove the redundant System.setProperty("io.netty.noJdkZlibDecoder", "false")
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On version 4.0.3, the constructor of the class RoutingContextImpl requires an HttpServerRequest object but this one will be cast later to HttpServerRequestInternal throwing a ClassCastException.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the Eclipse Contributor Agreement ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation of JsonParser is not able to handle parsing of several json objects when the parser is paused since we might not have consumed all the input of the internal parser.
The JsonParser instead should consume all tokens of the internal parser and buffer the corresponding events.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj don't forget to close #3886
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Read me
Read this first before creating an issue:

do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
you shall create a feature request only when it is general purpose enough.
make sure that the feature is not already

Describe the feature
Add the jrt protocol to FileResolver.unpackUrlResource() method, so that vert.x can read files from resources when the app is a (jlink) run-time image.
Use cases
Jlink generated images
Contribution
private File unpackUrlResource(URL url, String fileName, ClassLoader cl, boolean isDir) {
String prot = url.getProtocol();
switch (prot) {
case "file":
return unpackFromFileURL(url, fileName, cl);
case "jar":
return unpackFromJarURL(url, fileName, cl);
case "bundle": // Apache Felix, Knopflerfish
case "bundleentry": // Equinox
case "bundleresource": // Equinox
case "jrt": // java run-time (JEP 220)    <<<================== Add jrt case
case "resource":  // substratevm (graal native image)
return unpackFromBundleURL(url, isDir);
default:
throw new IllegalStateException("Invalid url protocol: " + prot + " for url: " + url);
}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As a user of Vert.x (in Java) it would make things a lot easier if Vert.x followed a semantic versioning policy. Excuse me if if that is already the policy.. If it is, it is not followed. Vert.x currently deprecates APIs and changes behavior within a patch release. And also bug fixes are not fixed in patches but moved to feature releases.
I know it's hard to do and there are always corner cases, where it's hard to judge whether a bug fix is really a breaking change or major change.. a bug fix is a deliberate change  - for a better behavior.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Version: 4.0.3
Context
RFC 6265 HTTP State Management Mechanism, 5.3 Storage Model, Step 11 defines the tuple (name, domain, path) as the cookie identifier.
However, the implementation of Http1xServerResponse and Http2ServerResponse use only the cookie name as identifier.
Steps to reproduce

Set two cookies with the same name but different path in a response header with

public void handle(RoutingContext ctx) {
  Cookie cookie = Cookie.cookie("SOME_NAME", "foo").setPath("/");
  Cookie sameCookieWithDifferentPath = Cookie.cookie("SOME_NAME", "bar").setPath("/somePath");

  ctx.response().addCookie(cookie);
  ctx.response().addCookie(sameCookieWithDifferentPath);
  ctx.response().end();
}

Expect 2 cookies on the client, but only get 1.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vert.x 4.0.3
Steps to reproduce
The implementation of hashCode() in JsonObject and JsonArray just returns the underlying list or map's hashCode() value. However, the corresponding equals() function in each class doesn't just return the underlying list or map's equals() value. Instead, a custom implementation is used. Specifically, numerical values have special handling in the equals() function in order to allow, e.g., Float and Integer objects to compare as equal if their underlying primitive values are equal. CharSequence objects are also have special handling.
This means that two objects could compare equal via equals() but return different hashCode() values. This violates the Java contract for equals() and hashCode(). This can be an issue when storing JsonObject and JsonArray objects in a HashSet or HashMap collection, since these collections assume that objects with different hashCode() values are not equal.
The recommended solution is to create a custom hashCode() implementation in both JsonObject and JsonArray that mimics the equals() implementation and so returns the same hashCode() value for any two objects if equals() returns true when called on those two objects.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vsevel @cescoffier here is the proxy support enhancements for 4.1, do you mind having a look ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Hi, I deploy a worker verticle,, but i find that the worker verticle is execute by multi thread concurrently,
I am not sure if it is a multi-thread worker verticle or else.
follow is the description of worker verticle from vertx

Worker verticle instances are never executed concurrently by Vert.x by more than one thread, but can executed by different threads at different times.

Version
4.0.2
Context
here is my code, the count is less than 10000, does my code have error?
class MyVerticle extends AbstractVerticle {
    int count = 0;

    @Override
    public void start() throws Exception {
        this.vertx.eventBus().localConsumer("test_address", message -> {
            count++;
            message.reply(null);
        });
        this.vertx.eventBus().localConsumer("print", message -> {
            System.out.println(count);
        });
    }
}
import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Vertx;

import java.util.concurrent.CountDownLatch;

public class VertxTest {
    public static void main(String[] args) throws InterruptedException {
        Vertx vertx = Vertx.vertx();
        CountDownLatch latch = new CountDownLatch(10000);
        Future<String> stringFuture = vertx.deployVerticle(MyVerticle.class, new DeploymentOptions().setWorker(true));
        stringFuture.onComplete(result -> {
            for (int i = 0; i < 10000; i++) {
                vertx.eventBus().request("test_address", 123, message -> {
                    latch.countDown();
                });
            }
        });
        latch.await();
        vertx.eventBus().send("print", 123);
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version

4.0.0
4.0.2
4.0.3
4.1.0.Beta1

Context
I encountered an exception which looks suspicious while executeBlocking when handling received message in EventBus MessageConsumer
Do you have a reproducer?
This is a test you can add it in LocalEventBusTest
  @Test
  public void testFuture() throws IOException {
    String path = File.createTempFile("vertx", ".json").toPath().toString();
    Function<String, Buffer> data = d -> new JsonObject().put("key", d).toBuffer();
    System.out.println(path);
    eb.<String>consumer(ADDRESS1)
      .handler((Message<String> msg) -> vertx.executeBlocking(
        p -> p.handle(vertx.fileSystem().writeFile(path, data.apply(msg.body())).map(ignore -> path)),
        ar -> {
          if (ar.failed()) {
            System.out.println("FAILED: " + ar.cause());
            return;
          }
          msg.reply(ar.result());
        }));
    eb.request(ADDRESS1, "whatever", ar -> {
      assertTrue(ar.succeeded());
      assertEquals(path, ar.result().body());
      testComplete();
    });
    await();
  }
It is exception when I debug in my project, hope this help
java.util.concurrent.RejectedExecutionException: Task io.vertx.core.impl.TaskQueue$$Lambda$337/1063462894@6ccba607 rejected from java.util.concurrent.ThreadPoolExecutor@22ad0c08[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 13]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at io.vertx.core.impl.TaskQueue.execute(TaskQueue.java:93)
	at io.vertx.core.impl.ContextImpl.executeBlocking(ContextImpl.java:190)
	at io.vertx.core.impl.DuplicatedContext.executeBlockingInternal(DuplicatedContext.java:158)
	at io.vertx.core.file.impl.FileSystemImpl$BlockingAction.run(FileSystemImpl.java:1143)
	at io.vertx.core.file.impl.FileSystemImpl.writeFile(FileSystemImpl.java:428)
	at io.zero88.qwe.file.TextFileOperatorImpl.lambda$null$6(TextFileOperatorImpl.java:47)
	at io.vertx.core.impl.future.Composition.onSuccess(Composition.java:38)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
	at io.vertx.core.impl.future.Mapping.onSuccess(Mapping.java:40)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
	at io.vertx.core.impl.future.Composition$1.onSuccess(Composition.java:62)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
	at io.vertx.core.impl.future.Mapping.onSuccess(Mapping.java:40)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
	at io.vertx.core.impl.future.Composition$1.onSuccess(Composition.java:62)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.FutureImpl.tryComplete(FutureImpl.java:179)
	at io.vertx.core.impl.future.Composition$1.onSuccess(Composition.java:62)
	at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
	at io.vertx.core.impl.future.SucceededFuture.addListener(SucceededFuture.java:82)
	at io.vertx.core.impl.future.Composition.onSuccess(Composition.java:43)
	at io.vertx.core.impl.future.FutureBase.lambda$emitSuccess$0(FutureBase.java:54)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
running checks to merge it for 4.1.0.CR1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
When complete error is regarded as a normal result, the Listener's complete result is inconsistent
Version
current(4.0.3)
Do you have a reproducer?
    public static void main(String[] args) {

        Promise<Object> promise = Promise.promise();
        promise.future()
                .onSuccess(v -> {
                    System.out.println("1.succeeded ");
                })
                .onFailure(v -> {
                    System.out.println("1.failed");
                });
        promise.complete(new RuntimeException());

        promise.future()
                .onSuccess(v -> {
                    System.out.println("2.succeeded ");
                })
                .onFailure(v -> {
                    System.out.println("2.failed ");
                });
    }

result
1.succeeded 
2.failed 

expect
1.succeeded 
2. succeeded
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have two vertx micro services running in cluster and communicate with each other using a headless service(link) in on premise cloud. Whenever I do a rolling deployment I am facing connectivity issue within services. When I analysed the log I can see that old node/pod is getting removed from cluster list but the event bus is not removing it and using it in round robin basis. I am pretty sure that event is passed to hazelcast but not to event bus. I am not sure if there is any listener that I could listen and remove dead pods.
Below is the member group information before deployment
Member [192.168.4.54]:5701 - ace32cef-8cb2-4a3b-b15a-2728db068b80        //pod 1
Member [192.168.4.54]:5705 - f0c39a6d-4834-4b1d-a179-1f0d74cabbce this
Member [192.168.101.79]:5701 - ac0dcea9-898a-4818-b7e2-e9f8aaefb447      //pod 2

When deployment is started, pod 2 gets removed from the member list,
[192.168.4.54]:5701 [dev] [4.0.2] Could not connect to: /192.168.101.79:5701. Reason: SocketException[Connection refused to address /192.168.101.79:5701]
Removing connection to endpoint [192.168.101.79]:5701 Cause => java.net.SocketException {Connection refused to address /192.168.101.79:5701}, Error-Count: 5
Removing Member [192.168.101.79]:5701 - ac0dcea9-898a-4818-b7e2-e9f8aaefb447

And new member is added
Member [192.168.4.54]:5701 - ace32cef-8cb2-4a3b-b15a-2728db068b80
Member [192.168.4.54]:5705 - f0c39a6d-4834-4b1d-a179-1f0d74cabbce this
Member [192.168.94.85]:5701 - 1347e755-1b55-45a3-bb9c-70e07a29d55b  //new pod
All migration tasks have been completed. (repartitionTime=Mon May 10 08:54:19 MST 2021, plannedMigrations=358, completedMigrations=358, remainingMigrations=0, totalCompletedMigrations=3348, elapsedMigrationTime=1948ms, totalElapsedMigrationTime=27796ms

I have two vertx micro services running in cluster and communicate with each other using a headless service(link) in on premise cloud. Whenever I do a rolling deployment I am facing connectivity issue within services. When I analysed the log I can see that old node/pod is getting removed from cluster list but the event bus is not removing it and using it in round robin basis.
Below is the member group information before deployment
    Member [192.168.4.54]:5701 - ace32cef-8cb2-4a3b-b15a-2728db068b80        //pod 1
    Member [192.168.4.54]:5705 - f0c39a6d-4834-4b1d-a179-1f0d74cabbce this
    Member [192.168.101.79]:5701 - ac0dcea9-898a-4818-b7e2-e9f8aaefb447      //pod 2

When deployment is started, pod 2 gets removed from the member list,
[192.168.4.54]:5701 [dev] [4.0.2] Could not connect to: /192.168.101.79:5701. Reason: SocketException[Connection refused to address /192.168.101.79:5701]
    Removing connection to endpoint [192.168.101.79]:5701 Cause => java.net.SocketException {Connection refused to address /192.168.101.79:5701}, Error-Count: 5
    Removing Member [192.168.101.79]:5701 - ac0dcea9-898a-4818-b7e2-e9f8aaefb447

And new member is added,
Member [192.168.4.54]:5701 - ace32cef-8cb2-4a3b-b15a-2728db068b80
    Member [192.168.4.54]:5705 - f0c39a6d-4834-4b1d-a179-1f0d74cabbce this
    Member [192.168.94.85]:5701 - 1347e755-1b55-45a3-bb9c-70e07a29d55b  //new pod
All migration tasks have been completed. (repartitionTime=Mon May 10 08:54:19 MST 2021, plannedMigrations=358, completedMigrations=358, remainingMigrations=0, totalCompletedMigrations=3348, elapsedMigrationTime=1948ms, totalElapsedMigrationTime=27796ms)

But when a request is made to the deployed service, event though old pod is removed from member group the event bus is using the old pod/service reference(ac0dcea9-898a-4818-b7e2-e9f8aaefb447)
`[vert.x-eventloop-thread-1] DEBUG io.vertx.core.eventbus.impl.clustered.ConnectionHolder - tx.id=f9f5cfc9-8ad8-4eb1-b12c-322feb0d1acd Not connected to server ac0dcea9-898a-4818-b7e2-e9f8aaefb447 - starting queuing`
### Version

I am using vertx 4.0.3 and hazelcast kubernetes 1.2.2. My verticle class is extending AbstractVerticle and deploying using,
Vertx.clusteredVertx(options, vertx -> {
vertx.result().deployVerticle(verticleName, deploymentOptions);
Sorry for the long post, any help is highly appreciated.
As mentioned earlier this happens only on deployment and if I restart the pods the issue is not getting reproduced.
This happens only on vertx4 4.0.3 and with vertx3 i haven't seen this issue.
Also I am not able to find event bus functionality that I can use it to removes the node info.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For context, I asked this question originally for Quarkus (see:  https://quarkusio.zulipchat.com/#narrow/stream/187030-users/topic/Any.20way.20to.20specify.20SSL.20key.20alias.20when.20using.20a.20keystore.20.3F ) and was asked to raise an issue for a Vert.x change.
There is currently no way to choose the SSL key alias for cases where a java key store may contain more than one key, thus no way to ensure the correct key is used when presenting the server certificate for SSL.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.3
Context
In Http1xServerConnection.handleMessage, line 124 compares DefaultHttpRequest.decoderResult() with DecoderResult.SUCCESS
if (request.decoderResult() != DecoderResult.SUCCESS) {
In the latest version of Netty, these can be two different instances of DecoderResult and therefore may not be equal even if they are both SUCCESS.
DecoderResult.SUCCESS is of type DecoderResult. request.decoderResult is of type HttpMessageDecoderResult. Two instances of different classes cannot be the same.
Do you have a reproducer?
Could make one if it would be helpful.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
At the moment you can enable compression for HTTP responses, however this will compress every response. This means that responses that are already compressed such as images or videos will be doubly compressed, wasting lots of CPU cycles.
Use cases
This will allow end users to control which responses are compressed.
I propose that when compression is enabled we use a virtual header: X-Vertx-Disable-Compression. We can override beginEncode in `HttpChunkContentCompressor, and if this header is present remove it and disable compression.
Contribution
I can do it if you are ok, with the implementation. I don't particularly like the suggestion however I don't really see any other way to pass this info to Netty.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current HTTP direction handler needs to remove the content-length header of the next HTTP request.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An HTTP redirected request will have its headers propagated by the client after the redirect handler has provided the next request options. Instead the redirect handler needs to take care of the headers propagation so the redirect handler has full control over the next request.
This is a breaking change for existing handlers that should propagate the headers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this brings some coupling between SSLHelper and JksOptions which is something I would like to avoid. When an alias is used, I think we could create a new KeyStore that contains the alias we extract from the original KeyStore instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we can avoid it since, the user simply should not set an alias on a
client JKS options

On Wed, May 19, 2021 at 3:56 PM Thomas Segismont ***@***.***> wrote:
 ***@***.**** commented on this pull request.
 ------------------------------

 In src/main/java/io/vertx/core/net/KeyCertOptions.java
 <#3933 (comment)>:

 > @@ -39,6 +39,17 @@
     */
    KeyManagerFactory getKeyManagerFactory(Vertx vertx) throws Exception;

 +  /**
 +   * Like ***@***.*** #getKeyManagerFactory}, except the underlying keystore can be filtered.
 +   * <p>
 +   * This should be called only when creating a ***@***.*** KeyManagerFactory} for a TCP or HTTP server.
 +   *
 +   * @param vertx the vertx instance
 +   * @return the key manager factory
 +   * @see JksOptions#setAlias(String)
 +   */
 +  KeyManagerFactory getKeyManagerFactory(Vertx vertx, boolean filter) throws Exception;

 Yes

 
 You are receiving this because your review was requested.
 Reply to this email directly, view it on GitHub
 <#3933 (comment)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AABXDCTOCDSH2AQREAFGAG3TOO7SFANCNFSM45EWQSYQ>
 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
When ExecutorServiceFactory.createExecutor() is called, provide a method on the API to distinguish the type of executor being created. Maybe it's as simple as passing the name the ThreadFactory is created with?
Use cases
In Quarkus we want the ability to replace the default Executor in some situations, such as the Vert.x worker thread pool, with a shared pool we've created, but other pools create their own Executor instance.
Contribution
Happy to contribute a PR once it's determined the best way to provide an indicator to differentiate the pool types
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The sec-websocket-location header value sent by the server during the handshake of WebSocket V00 protocol has an incorrect scheme (wss and ws are swapped).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java has deprecated SslSession#peerCertificateChains method for a long time. Recent Java versions will thrown an exception when calling it. These methods are deprecated in favor of peerCertificates() which return a List<java.security.cert.Certificate> on HttpConnection, WebSocketBase and NetSocket.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ensure that Vert.x core (as part of the stack) build and is tested for Java 16. This is preparation work for the next Java 17 LTS.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use cases
To extend configuration and CLI option in BareCommand and RunCommand without rewrite too much code, then I'd like to make some function is more flexible and able to extend in sub class.

  
    
      vert.x/src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java
    
    
        Lines 202 to 214
      in
      2f690d7
    
  
  
    

        
          
           JsonObject optionsJson = getJsonFromFileOrString(vertxOptions, "options"); 
        

        
          
            
        

        
          
           EventBusOptions eventBusOptions; 
        

        
          
           VertxBuilder builder; 
        

        
          
           if (optionsJson == null) { 
        

        
          
             eventBusOptions = getEventBusOptions(); 
        

        
          
             builder = new VertxBuilder(); 
        

        
          
           } else { 
        

        
          
             eventBusOptions = getEventBusOptions(optionsJson.getJsonObject("eventBusOptions")); 
        

        
          
             builder = new VertxBuilder(optionsJson); 
        

        
          
           } 
        

        
          
           options = builder.options(); 
        

        
          
           options.setEventBusOptions(eventBusOptions); 
        
    
  



  
    
      vert.x/src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
    
    
        Lines 346 to 399
      in
      24c4e2a
    
  
  
    

        
          
           // Prepend the command. 
        

        
          
           args.add("run"); 
        

        
          
           args.add("--vertx-id=" + vertxApplicationBackgroundId); 
        

        
          
           args.addAll(executionContext.commandLine().allArguments()); 
        

        
          
           // No need to add the main-verticle as it's part of the allArguments list. 
        

        
          
           if (cluster) { 
        

        
          
             args.add("--cluster"); 
        

        
          
           } 
        

        
          
           if (clusterHost != null) { 
        

        
          
             args.add("--cluster-host=" + clusterHost); 
        

        
          
           } 
        

        
          
           if (clusterPort != 0) { 
        

        
          
             args.add("--cluster-port=" + clusterPort); 
        

        
          
           } 
        

        
          
           if (clusterPublicHost != null) { 
        

        
          
             args.add("--cluster-public-host=" + clusterPublicHost); 
        

        
          
           } 
        

        
          
           if (clusterPublicPort != -1) { 
        

        
          
             args.add("--cluster-public-port=" + clusterPublicPort); 
        

        
          
           } 
        

        
          
           if (ha) { 
        

        
          
             args.add("--ha"); 
        

        
          
           } 
        

        
          
           if (haGroup != null && !haGroup.equals("__DEFAULT__")) { 
        

        
          
             args.add("--hagroup=" + haGroup); 
        

        
          
           } 
        

        
          
           if (quorum != -1) { 
        

        
          
             args.add("--quorum=" + quorum); 
        

        
          
           } 
        

        
          
           if (classpath != null && !classpath.isEmpty()) { 
        

        
          
             args.add("--classpath=" + classpath.stream().collect(Collectors.joining(File.pathSeparator))); 
        

        
          
           } 
        

        
          
           if (vertxOptions != null) { 
        

        
          
             // Pass the configuration in 2 steps to quote correctly the options if it's an inlined json string 
        

        
          
             args.add("--options"); 
        

        
          
             args.add(vertxOptions); 
        

        
          
           } 
        

        
          
           if (config != null) { 
        

        
          
             // Pass the configuration in 2 steps to quote correctly the configuration if it's an inlined json string 
        

        
          
             args.add("--conf"); 
        

        
          
             args.add(config); 
        

        
          
           } 
        

        
          
           if (instances != 1) { 
        

        
          
             args.add("--instances=" + instances); 
        

        
          
           } 
        

        
          
           if (worker) { 
        

        
          
             args.add("--worker"); 
        

        
          
           } 
        

        
          
           if (systemProperties != null) { 
        

        
          
             args.addAll(systemProperties.stream().map(s -> "-D" + s).collect(Collectors.toList())); 
        

        
          
           } 
        

        
          
            
        

        
          
           // Enable stream redirection 
        

        
          
           args.add("--redirect-output"); 
        
    
  


Also, configuration must be processed in nature order as almost the common CLI:

From config file
From system properties
From environment variable (it can be switch between system properties, but Vert.x in default doesn't provide this option)
From CLI option

Example
If I want to add some CLI option like cluster-conf in BareCommand and make it works, I have to override method startVertx.

  
    
      vert.x/src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java
    
    
         Line 201
      in
      2f690d7
    
  
  
    

        
          
           protected Vertx startVertx() { 
        
    
  


It is too long for implementation and if vertx changed any line this method, I will have to update over and over.
I can do a trick to update VertxOptions in beforeStartingVertx method but it is not nice when split build configuration in several places.
Also, if I want to do configureFromSystemProperties, I need to rewrite also, due to "private lock"

  
    
      vert.x/src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java
    
    
         Line 351
      in
      949d129
    
  
  
    

        
          
           private static final ThreadLocal<Logger> configureFromSystemProperties = new ThreadLocal<>(); 
        
    
  


Then I provide a set of methods to easy buildVertxOptions in sub class, and users can decide which part they want to override:
protected VertxOptions buildVertxOptions() {
    JsonObject optionsJson = getJsonFromFileOrString(vertxOptions, "options");
    VertxOptions vertxOptions = optionsJson == null ? new VertxOptions() : new VertxOptions(optionsJson);
    configureFromSystemProperties(vertxOptions);
    // configureFromEnv(vertxOptions);
    overrideFromCommandOption(vertxOptions);
    return vertxOptions;
  }

Contribution
I will open a PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Should cherry-pick to v3 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Can we use ObjectMapper::findModules() to register Jackson module automatically? (Instead of just new ObjectMapper())
Use cases
Now the default jackson mapper io.vertx.core.json.jackson.DatabindCodec.prettyMapper() and io.vertx.core.json.jackson.DatabindCodec.mapper() without any module registered.
When we use vertx-lang-kotlin, the jackson kotlin module will be added, but we have to register manually.
Contribution
I can create a pr for it, if it's ok.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks this is great
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
In our applicatioin, we all upload multiple files using http and using Pump to write contents to HttpClientRequest. And we upgrade from vert.x 3.9.4 to 4.0.3(also tried 4.1.0.RC1) the tests case fails randomly.  The updated code to write multiple files
to HttpClientRequest is:
  private void attachFile(String boundary, Iterator<Entry<String, Part>> uploadsIterator) {
    if (!uploadsIterator.hasNext()) {
      request.write(boundaryEndInfo(boundary));
      request.end();
      return;
    }
    Entry<String, Part> entry = uploadsIterator.next();
    // do not use part.getName() to get parameter name
    // because pojo consumer not easy to set name to part
    String name = entry.getKey();
    Part part = entry.getValue();
    String filename = part.getSubmittedFileName();

    LOGGER.info("Start attach file [{}:{}].", name, filename);
    request.write(fileBoundaryInfo(boundary, name, part)).compose(v ->
        Future.fromCompletionStage(new PumpFromPart(context, part).toWriteStream(request, throwableHandler)))
        .onComplete(r -> {
          if (r.failed()) {
            LOGGER.warn("Failed attach file [{}:{}].", name, filename, r.cause());
            asyncResp.consumerFail(r.cause());
            return;
          }

          LOGGER.info("Finish attach file [{}:{}].", name, filename);
          attachFile(boundary, uploadsIterator);
        });
  }

see details here
Version
4.0.3 and above
Context
After look code at PumpIml
  PumpImpl(ReadStream<T> rs, WriteStream<T> ws) {
    this.readStream = rs;
    this.writeStream = ws;
    drainHandler = v-> readStream.resume();
    dataHandler = data -> {
      writeStream.write(data);
      incPumped();
      if (writeStream.writeQueueFull()) {
        readStream.pause();
        writeStream.drainHandler(drainHandler);
      }
    };
  }

I guess the problem happends because vert.x 4.x change
writeStream.write(data);

to asynchronouse and not make sure if the data is actually written. And in our context, previously we check if a file successfully by ReadStream endHanlder, now the check can not make sure if the upload is successfully and cause the problem.
Do you have a reproducer?
see questions.
Steps to reproduce
see questions.
Extra
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a change that done in Vert.x 4 as we considered that ordering could be achieved on the duplicate context (which is correct in most situations) but can be unexpected for some.
We should change to the previous behavior and possibly later introduce an option to order on the duplicate context (e.g per HTTP request).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version

4.1.0-SNAPSHOT
4.1.0-CR2
4.1.0-CR1

Context
Using VertX HttpClient to execute Http Requests via HTTP 2.
(HTTP without SSL is not affected)
Do you have a reproducer?

https://github.com/DemonicTutor/vertx-httpclient-410-regression

Steps to reproduce

HttpClient for HTTP/2
execute first request against WireMock returning a Fault (throws exception as expected)
execute second request against WireMock returning 200 OK also throws Exception

Extra

OpenJDK 16.0.1
used RxJava-3 as dependency - but you can trust me it works with VertX 4.0.0 - i tried it :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
In class io.vertx.core.Context : methods getLocal, putLocal, removeLocal all require a key of type String.
Would be great to relax this requirement and accept any object types (Object?).
Use cases
We have to store a custom object with sub-scope identifiers as well; the current API is forcing us to encode additional scope as post-fixes on a shared root String, but this implies we have to allocate new String instances on each access.
Being able to use a composite object would still require allocation, but encoding of parts of scoping would be really cheap. Not leat, String comparison isn't very efficient when we have to use a shared prefix.
Contribution
I'm happy to contribute, if I can be guided towards which solutions are acceptable. It seems it might just be a matter of changing the signature on the API, but I'm not sure of the implications or additional requirements. For example, is this state supposed to be serializable?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#3956
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The implementation of DuplicatedContext#executeBlocking(Handler<Promise<T>> block, boolean ordered) ignores the ordered value and always order blocking task execution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when you haved a list of verticle that hope to run on the same context to avoid data race, you can used VerticleGroup
Use cases
  public class CompositeVerticleGroup extends AbstractVerticleGroup {

    @Override
    public List<Verticle> verticles() {
      return Arrays.asList(new VerticleA(), new VerticleB(), new VerticleC());
    }


    static class VerticleA extends AbstractVerticle {}

    static class VerticleB extends AbstractVerticle {}

    static class VerticleC extends AbstractVerticle {}

  }
  
 vertx.deployVerticle(CompositeVerticleGroup)
VerticleA, VerticleB, VerticleC and CompositeVerticleGroup will run on the same context.
Contribution
yes, I haved create an pr
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm developing a web application base on Vertx-v4.0.3
It is normal when running in the development environment of Intelli idea, but after packaging it into a jar, it reports an error Resource not found. The following is my configuration and package detail
router.route("/web/*").handler(StaticHandler.create("webroot"));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.1.0
Context
See https://github.com/blindpirate/local-consumer-bug for reproduction
In short, if a local consumer and non-local consumer with same address are registered, the local consumer also receives message from other Vertx cluster node.
Steps to reproduce
This is reproducible with both ZK and Hazelcast cluster manager, so I think it's more likely to be a Vertx core issue.

ZooKeeper:

Run ./gradlew installDist to package the application.
Start ZooKeeper at 2181, e.g. docker run -d -p 2181:2181 zookeeper:3.6.2
Run PORT=8080 CONSUMER=1 app/build/install/app/bin/app start the event consumer.
In another terminal, run PORT=8081 app/build/install/app/bin/app to start the event producer.
No message displayed in event consumer. This is expected because now only local consumer is registered.
Now kill the consumer and producer.
Run PORT=8080 CONSUMER=1 ENABLE_DISTRIBUTED_CONSUMER=1 app/build/install/app/bin/app start the event consumer.
In another terminal, run PORT=8081 ENABLE_DISTRIBUTED_CONSUMER=1 app/build/install/app/bin/app to start the event producer.
Now you can see the local consumer gets a message from distributed event bus.


Hazelcast:

Run ./gradlew installDist to package the application.
Run PORT=8080 CONSUMER=1 MANAGER=hazelcast app/build/install/app/bin/app start the event consumer.
In another terminal, run PORT=8081 MANAGER=hazelcast app/build/install/app/bin/app to start the event producer.
No message displayed in event consumer. This is expected because now only local consumer is registered.
Now kill the consumer and producer.
Run PORT=8080 CONSUMER=1 MANAGER=hazelcast ENABLE_DISTRIBUTED_CONSUMER=1 app/build/install/app/bin/app start the event consumer.
In another terminal, run PORT=8081 MANAGER=hazelcast ENABLE_DISTRIBUTED_CONSUMER=1 app/build/install/app/bin/app to start the event producer.
Now you can see the local consumer gets a message from distributed event bus.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Do not use this issue tracker to ask questions, instead use one of these channels. Questions will likely be closed without notice.
Version
4.1.0
Context
I encountered an exception which looks suspicious while I was building my application with Graal 21.1,0 using native-image:
Unable to initialize BouncyCastleAlpnSslUtils. 
java.lang.ClassNotFoundException: org.bouncycastle.jsse.BCSSLEngine
        at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:471)
        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:589)
        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
        at java.base/java.lang.Class.forName0(Native Method)
        at java.base/java.lang.Class.forName(Class.java:315)
        at io.netty.handler.ssl.BouncyCastleAlpnSslUtils.<clinit>(BouncyCastleAlpnSslUtils.java:63)
        at java.base/jdk.internal.misc.Unsafe.ensureClassInitialized0(Native Method)
        at java.base/jdk.internal.misc.Unsafe.ensureClassInitialized(Unsafe.java:1042)
        at jdk.unsupported/sun.misc.Unsafe.ensureClassInitialized(Unsafe.java:698)
        at com.oracle.svm.hosted.classinitialization.ConfigurableClassInitialization.ensureClassInitialized(ConfigurableClassInitialization.java:176)
        at com.oracle.svm.hosted.classinitialization.ConfigurableClassInitialization.computeInitKindAndMaybeInitializeClass(ConfigurableClassInitialization.java:614)
        at com.oracle.svm.hosted.classinitialization.ConfigurableClassInitialization.computeInitKindAndMaybeInitializeClass(ConfigurableClassInitialization.java:129)
        at com.oracle.svm.hosted.classinitialization.ConfigurableClassInitialization.shouldInitializeAtRuntime(ConfigurableClassInitialization.java:157)
        at com.oracle.svm.hosted.SVMHost.isInitialized(SVMHost.java:296)
        at com.oracle.graal.pointsto.meta.AnalysisType.isInitialized(AnalysisType.java:789)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.maybeEagerlyInitialize(BytecodeParser.java:4454)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.genInvokeStatic(BytecodeParser.java:1658)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.genInvokeStatic(BytecodeParser.java:1651)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.processBytecode(BytecodeParser.java:5448)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.iterateBytecodesForBlock(BytecodeParser.java:3451)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.processBlock(BytecodeParser.java:3258)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.build(BytecodeParser.java:1125)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.BytecodeParser.buildRootMethod(BytecodeParser.java:1019)
        at jdk.internal.vm.compiler/org.graalvm.compiler.java.GraphBuilderPhase$Instance.run(GraphBuilderPhase.java:84)
        at com.oracle.svm.hosted.phases.SharedGraphBuilderPhase.run(SharedGraphBuilderPhase.java:76)
        at jdk.internal.vm.compiler/org.graalvm.compiler.phases.Phase.run(Phase.java:49)
        at jdk.internal.vm.compiler/org.graalvm.compiler.phases.BasePhase.apply(BasePhase.java:212)
        at jdk.internal.vm.compiler/org.graalvm.compiler.phases.Phase.apply(Phase.java:42)
        at jdk.internal.vm.compiler/org.graalvm.compiler.phases.Phase.apply(Phase.java:38)
        at com.oracle.graal.pointsto.flow.AnalysisParsedGraph.parseBytecode(AnalysisParsedGraph.java:113)
        at com.oracle.svm.hosted.SVMHost.parseBytecode(SVMHost.java:647)
        at com.oracle.graal.pointsto.meta.AnalysisMethod.ensureGraphParsed(AnalysisMethod.java:592)
        at com.oracle.graal.pointsto.flow.MethodTypeFlowBuilder.parse(MethodTypeFlowBuilder.java:163)
        at com.oracle.graal.pointsto.flow.MethodTypeFlowBuilder.apply(MethodTypeFlowBuilder.java:304)
        at com.oracle.graal.pointsto.flow.MethodTypeFlow.createTypeFlow(MethodTypeFlow.java:313)
        at com.oracle.graal.pointsto.flow.MethodTypeFlow.ensureTypeFlowCreated(MethodTypeFlow.java:302)
        at com.oracle.graal.pointsto.flow.MethodTypeFlow.addContext(MethodTypeFlow.java:103)
        at com.oracle.graal.pointsto.DefaultAnalysisPolicy$DefaultVirtualInvokeTypeFlow.onObservedUpdate(DefaultAnalysisPolicy.java:227)
        at com.oracle.graal.pointsto.flow.TypeFlow.notifyObservers(TypeFlow.java:470)
        at com.oracle.graal.pointsto.flow.TypeFlow.update(TypeFlow.java:542)
        at com.oracle.graal.pointsto.BigBang$2.run(BigBang.java:547)
        at com.oracle.graal.pointsto.util.CompletionExecutor.lambda$execute$0(CompletionExecutor.java:173)
        at java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1426)
        at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
        at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
        at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
        at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
        at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

Do you have a reproducer?

https://github.com/aws-samples/reactive-refarch-cloudformation/
https://gist.github.com/smoell/70a0f5af8221d8a0749b8fc100aec48a

Steps to reproduce

Clone repository using git clone https://github.com/aws-samples/reactive-refarch-cloudformation/
cd reactive-refarch-cloudformation/services/tracking-service/reactive-vertx
Replace pom.xml in directory with https://gist.github.com/smoell/70a0f5af8221d8a0749b8fc100aec48a
docker image build -f ./Dockerfile-native -t smoell/reactive-vertx-native:2.0 .

Extra

Vert.x version 4.1.0
GraalVM version 21.1.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
does't vertx support java16?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried to load an ECDSA key that is formatted using the following delimiter:
-----BEGIN EC PRIVATE KEY-----
... private key comes here ...
-----END EC PRIVATE KEY-----

This is what I'm getting as a result:
2021-06-04 16:18:22,180 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.RuntimeException: Missing -----BEGIN PRIVATE KEY----- or -----BEGIN RSA PRIVATE KEY----- delimiter
	at io.vertx.core.net.impl.KeyStoreHelper.loadPrivateKey(KeyStoreHelper.java:274)
	at io.vertx.core.net.impl.KeyStoreHelper.loadKeyCert(KeyStoreHelper.java:238)
	at io.vertx.core.net.PemKeyCertOptions.getHelper(PemKeyCertOptions.java:447)
	at io.vertx.core.net.PemKeyCertOptions.getKeyManagerFactory(PemKeyCertOptions.java:465)
	at io.vertx.core.net.impl.SSLHelper.getKeyMgrFactory(SSLHelper.java:341)
	at io.vertx.core.net.impl.SSLHelper.createContext(SSLHelper.java:294)
	at io.vertx.core.net.impl.SSLHelper.getContext(SSLHelper.java:511)
	at io.vertx.core.net.impl.SSLHelper.validate(SSLHelper.java:536)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:284)
	at io.vertx.core.http.impl.HttpServerImpl.listen(HttpServerImpl.java:205)
	at io.quarkus.vertx.http.runtime.VertxHttpRecorder$WebDeploymentVerticle.setupTcpHttpServer(VertxHttpRecorder.java:919)
	at io.quarkus.vertx.http.runtime.VertxHttpRecorder$WebDeploymentVerticle.start(VertxHttpRecorder.java:900)
	at io.vertx.core.Verticle.start(Verticle.java:66)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$9(DeploymentManager.java:556)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:834)
	at com.oracle.svm.core.thread.JavaThreads.threadStartRoutine(JavaThreads.java:519)
	at com.oracle.svm.core.posix.thread.PosixJavaThreads.pthreadStartRoutine(PosixJavaThreads.java:192)

As you can see from the stack trace, this is from a Quarkus application that is running on java-11-openjdk.
$ mvn dependency:tree | grep vertx
[INFO] |  +- io.quarkus:quarkus-vertx-http:jar:1.13.3.Final:compile
[INFO] |  |  +- io.quarkus:quarkus-vertx-http-dev-console-runtime-spi:jar:1.13.3.Final:compile
[INFO] |  |  +- io.quarkus:quarkus-vertx-core:jar:1.13.3.Final:compile
[INFO] |  |  |  \- io.vertx:vertx-core:jar:3.9.6:compile
[INFO] |  |  \- io.vertx:vertx-web:jar:3.9.6:compile
[INFO] |  |     +- io.vertx:vertx-web-common:jar:3.9.6:compile
[INFO] |  |     +- io.vertx:vertx-auth-common:jar:3.9.6:compile
[INFO] |  |     \- io.vertx:vertx-bridge-common:jar:3.9.6:compile
[INFO] |  |  +- io.quarkus:quarkus-vertx-http-dev-console-spi:jar:1.13.3.Final:test
From the enhancement request #2547, I see that support for parsing ECDSA key is already there, so I guess it would be just a matter of adding the relevant switch execution path.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
please sign the eclipse agreement and resubmit a PR
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj sharing a draft PR to get some feedback first and see what CI says.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?
4.0.1
Context
the method invokes:
in setupCallback:
if (callbackURL == null) {
// warn that the setup is probably wrong
LOG.warn("OAuth2AuthHandler was created without a origin/callback URL, setup is NO-OP");
return this;
}
this breaks previous implementations in vertx 3
"return this" should be removed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/3999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The slf4j supports the log format e.g. {} then {} and {}, where you may log the message with var-args LOG.info("{}{}{}", "1", 2, 3).
Can we have the same programming paradigm in  Vert.x?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Joining / leaving a multicast group without a specified network interface will most of the time result in an uncaught NullPointerException. In this case the implementation could try reusing the multicast network interface when it is set otherwise guess the network interface from the bind address, otherwise properly report that no network interface could be used for membership management.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The event-bus consumer clears the metric hand-back object on unregistration causing event-bus metrics event to signal events (messageDelivered and discardMessage) with a null hand-back leading to potential metric corruption.
We should avoid to eagerly set the metrics hand-back to null and instead let the garbage collector handle it when the message consumer is garbaged.
This is the root cause of #4033
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using the WebClient component to send a request and the following log occurs. How can I solve the problem?
"2021-08-06 18:58:46.372 [vert.x-eventloop-thread-1] WARN io.netty.resolver.dns.DnsServerAddressStreamProviders-Can not find io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider in the classpath , fallback to system defaults. This may result in incorrect DNS resolutions on MacOS.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?
Vert.x: 4.1.2
Context
I encountered an exception which looks suspicious while trying to use UDP packet sending on MacOS.
Do you have a reproducer?
Yes, I hope it is helpful. I spent a lot of time to make it configurable and to try to demonstrate the scenario I'm trying to accomplish and show you the error I am getting.
I tried to give as much documentation as possible..

https://github.com/tmulle/VertxNettyUDP6Tester

Steps to reproduce

Follow README in the repo

Extra

All information is in the README
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Also use it for vertx-core tests
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The handling of a pooled HTTP/2 client connection might race and leak a connection when the server sends immediately a GO_AWAY frame. The client pool integration might set the eviction handler after the connection has been evicted when the connect action is done outside of the event-loop thread.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Closing in favor of just mentioning the typo in Discord.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
NetClientOptions now support specific algorithm for host name verification.
Is it possible to support custom host name similar to the uses of javax.net.ssl.HostnameVerifier?
Use cases
Besides the default verification which compares the common name in the SubjectDN in the SSL server's digital certificate with the host name of the SSL server, one would want to verify other behaviors.
My uses case is that we use a vertx client to talk to a server whose cert's common name isn't a valid host name. So we want to verify one fixed field in the SubjectDN. Currently we disable the host name verification to skip this because vertx asks a specific algorithm for the verification, but our case needs a more complex logic.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version: 4.1.0
I encountered an exception while shutting down my spring application ((AbstractApplicationContext) context).close() (https://www.baeldung.com/spring-boot-shutdown)


I have created a mock server which is running at 8000 port while my application runs at 8090 port. I did below to start the mock server,
ResultHandler startHandler = new ResultHandler<>();
server =
vertx
.createHttpServer(options)
.requestHandler(router)
.exceptionHandler(t -> LOG.error("Exception while processing request", t))
.listen(startHandler);
startHandler.await();


So before closing the spring boot application, i executed the below
server.close();
or
public void stop() {
if (server != null) {
ResultHandler stopHandler = new ResultHandler<>();
server.close(stopHandler);
stopHandler.await();
server = null;
}
}


After executing ((AbstractApplicationContext) context).close() line, i am getting below error,


11:59:44.574 [http-nio-8090-exec-2] ERROR o.s.w.servlet.HandlerExecutionChain "" - HandlerInterceptor.afterCompletion threw exception
java.lang.NullPointerException: null
at org.springframework.boot.actuate.metrics.web.servlet.LongTaskTimingHandlerInterceptor.stopLongTaskTimers(LongTaskTimingHandlerInterceptor.java:123)
at org.springframework.boot.actuate.metrics.web.servlet.LongTaskTimingHandlerInterceptor.afterCompletion(LongTaskTimingHandlerInterceptor.java:79)
at org.springframework.web.servlet.HandlerExecutionChain.triggerAfterCompletion(HandlerExecutionChain.java:178)
at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1156)
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1077)
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:665)
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:750)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at com.atlassian.oai.validator.springmvc.OpenApiValidationFilter.doFilterInternal(OpenApiValidationFilter.java:58)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticatedActionsFilter.doFilter(KeycloakAuthenticatedActionsFilter.java:57)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter.doFilter(KeycloakSecurityContextRequestFilter.java:61)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.keycloak.adapters.springsecurity.filter.KeycloakPreAuthActionsFilter.doFilter(KeycloakPreAuthActionsFilter.java:96)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticationProcessingFilter.successfulAuthentication(KeycloakAuthenticationProcessingFilter.java:214)
at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:232)
at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at com.gbst.services.common.springrest.logging.MDCServletFilter.doFilter(MDCServletFilter.java:28)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at com.gbst.services.async.filter.ResettableStreamRequestServletFilter.doFilterInternal(ResettableStreamRequestServletFilter.java:27)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327)
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115)
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)
at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126)
at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:105)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticatedActionsFilter.doFilter(KeycloakAuthenticatedActionsFilter.java:74)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter.doFilter(KeycloakSecurityContextRequestFilter.java:92)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103)
at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticationProcessingFilter.successfulAuthentication(KeycloakAuthenticationProcessingFilter.java:214)
at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:232)
at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.keycloak.adapters.springsecurity.filter.KeycloakPreAuthActionsFilter.doFilter(KeycloakPreAuthActionsFilter.java:96)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)
at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110)
at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)
at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211)
at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183)
at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:93)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
at ch.qos.logback.access.tomcat.LogbackValve.invoke(LogbackValve.java:256)
at org.keycloak.adapters.tomcat.AbstractAuthenticatedActionsValve.invoke(AbstractAuthenticatedActionsValve.java:67)
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)
at org.keycloak.adapters.tomcat.AbstractKeycloakAuthenticatorValve.invoke(AbstractKeycloakAuthenticatorValve.java:181)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)
at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)
at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707)
at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
at java.lang.Thread.run(Thread.java:748)
null - - [12/Aug/2021:11:59:44 +1000] "null null null" 500 - "-" "-" "-"
However, if I remove this mock server and try shutting down, it went gracefully.
Could you help me with this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
In vertx 3.x RoutingContextImplBase did not log at error/info level when an exception occurred in a handler, now it logs twice:
[ERROR] [] i.v.e.w.RoutingContext: Unhandled exception in router + stacktrace
[INFO] [] i.v.e.w.RoutingContext: RoutingContext failure (500) + stacktrace
This is too much noise in the logs. Now i could disable the whole logger from logging but it is slightly an overkill. Furthermore i do not need these logs since i have an error handler on a router which logs already everything i need the way i need.
Use cases

Reduce noise in logs
If error is already properly handled these logs provide little value

Also it logs failures and stacktraces everytime there is a call to fail() which also pollutes logs, disabling this logger is the only solution i am aware right now
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc @Sanne
@vietj I checked the documentation, there is no need for a change. If this is merged, I will create an entry in the breaking changes page.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I met a deadlock issue recently on Vertx version 4.1.1 and after investigated and looked into the VertxImpl, CloseFuture, WorkerExecutorImpl, it looks like the deadlock happened in Vertx, please take a look:
In my case, the deadlock issue is hit when the vertx.close and workerExecutor.close happened to be called at same time, one from main thread and another from eventloop thread. (the workerExecutor is created by the vertx.createSharedWorkerExecutor)
Backtrace printed by jstack:
Found one Java-level deadlock:
=============================
"main":
  waiting to lock monitor 0x00007fa958116580 (object 0x00000000b3329eb8, a io.vertx.core.impl.WorkerExecutorImpl),
  which is held by "vert.x-eventloop-thread-0"
"vert.x-eventloop-thread-0":
  waiting to lock monitor 0x00007fa89c01ae80 (object 0x00000000b3329f58, a io.vertx.core.impl.VertxImpl),
  which is held by "main"

Java stack information for the threads listed above:
===================================================
"main":
        at io.vertx.core.impl.WorkerExecutorImpl.close(WorkerExecutorImpl.java:90)
        - waiting to lock <0x00000000b3329eb8> (a io.vertx.core.impl.WorkerExecutorImpl)
        at io.vertx.core.impl.CloseFuture.close(CloseFuture.java:117)
        at io.vertx.core.impl.VertxImpl.close(VertxImpl.java:578)
        - locked <0x00000000b3329f58> (a io.vertx.core.impl.VertxImpl)
        at io.vertx.reactivex.core.Vertx.close(Vertx.java:433)
...
"vert.x-eventloop-thread-0":
        at io.vertx.core.impl.VertxImpl$SharedWorkerPool.close(VertxImpl.java:1080)
        - waiting to lock <0x00000000b3329f58> (a io.vertx.core.impl.VertxImpl)
        at io.vertx.core.impl.WorkerExecutorImpl.close(WorkerExecutorImpl.java:93)
        - locked <0x00000000b3329eb8> (a io.vertx.core.impl.WorkerExecutorImpl)
        at io.vertx.core.impl.WorkerExecutorImpl.close(WorkerExecutorImpl.java:78)
        at io.vertx.core.impl.WorkerExecutorImpl.close(WorkerExecutorImpl.java:84)
        at io.vertx.reactivex.core.WorkerExecutor.close(WorkerExecutor.java:207)
        at io.vertx.reactivex.core.WorkerExecutor.close(WorkerExecutor.java:214)
...

Found 1 deadlock.

Checked vertx 4.1.1 code and find:
When closing WorkerExecutor, it will do:

Lock self (WorkerExecutorImpl)
Remove self from CloseFuture
Close SharedWorkerPool, which require lock Vertx

When closing Vertx, it will do:

Lock self (VertxImpl)
Close CloseFuture, which synchronized copy the list of callbacks and invoke them outside of the synchronized block, one of the callback is to close the same WorkerExecutorImpl instance as above

So, when the copy of callbacks in CloseFuture happened before removing the WorkerExecutorImpl from CloseFuture, it will still be called and cause deadlock



Time
Main thread
Eventloop thread




T1
Start close Vertx, locked VertxImpl instance



T2

Start close WorkerExecutor, locked WorkerExecutorImpl instance


T3
In CloseFuture, the list of callbacks are copied



T4

Remove WorkerExecutorImpl instance from CloseFuture. But since the callback is already copied in T3, this doesn't prevent the callback from being called


T5
The callback of close WorkerExecutorImpl instance is called. This require lock on the WorkerExecutorImpl instance, which was acquired by eventloop thread at T2. So it is waiting for the lock to be released by eventloop thread



T6

Close SharedWorkerPool, and this require lock on the VertxImpl instance, which was acquired by main thread at T1. So it is waiting for the lock to be released by main thread



Deadlock
Deadlock



The issue seems still exist in 4.1.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't know if we want this. I would prefer we go down the Supplier<ClassLoader> route that gives us explicit control over the threads.
The issue is that if something somewhere breaks the TCCL of a vert.x thread (e.g. the finalizer issue we saw) then everything falls apart, and it is incredibly difficult to debug why the TCCL is now wrong (as you don't get the error at the code that has set the wrong TCCL, but generally on the next task the thread performs).
I think that safety is more important than saving a few cycles here. If we want this for benchmarks then I am ok with it, but I don't think we want this in the general sense.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.1.2
Context
I try to create a server streaming a chunked response, and test it using the Vertx HTTP client. The client throws NullPointerException on receiving response if no headers were added in the Request.
If any header is set, then the test hangs infinitely  the HttpClientResponse never ends and receives the body.
In the first case, this is the NPEs stack trace:

NPE stack trace

Caused by: java.lang.NullPointerException
	at io.vertx.core.http.impl.Http1xClientConnection.handleResponseBegin(Http1xClientConnection.java:747)
	at io.vertx.core.http.impl.Http1xClientConnection.handleHttpMessage(Http1xClientConnection.java:674)
	at io.vertx.core.http.impl.Http1xClientConnection.handleMessage(Http1xClientConnection.java:649)
	at io.vertx.core.net.impl.ConnectionBase.read(ConnectionBase.java:155)
	at io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:154)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:311)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:432)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)



Do you have a reproducer?
Heres a simple test-case written in Kotlin, test without the header hack, with header hack to avoid NPE, and another one using async-http-client. Only the async-http-client one passes.
silmeth/vertx-chunked-reproducer
Steps to reproduce

Clone the repo linked above.
Run ./gradlew test from the repos directory.

The code is in src/test/kotlin/chunked/reproducer/ChunkedTest.kt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HttpClient tunnel creation assumes when it gets the server response that the request always sent headers and the headers multimap is never null which leads to an NPE when no headers was sent.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When an HttpClient tunnel cannot be established the connection should switch the isConnect field to false so that the response will be normally processed. Otherwise the response will be processed as if a tunnel was established and the last HTTP chunk event will not be signaled to the response end handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP/1.1 client stream close handler can be called twice leading to recycling the connection to the pool more than it should triggering the pool guard against it
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
a client is not attached to a given context.

the event-loop it will use depends on the usage and not when the client was
created.

On Tue, Aug 24, 2021 at 11:28 AM Thomas Segismont ***@***.***> wrote:
 ***@***.**** commented on this pull request.
 ------------------------------

 In src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
 <#4079 (comment)>:

 > @@ -120,6 +112,7 @@


    private final VertxInternal vertx;
 +  private final ContextInternal context;

 what's the issue? it would depend on a context only when shared

 
 You are receiving this because your review was requested.
 Reply to this email directly, view it on GitHub
 <#4079 (comment)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AABXDCW7TYAN3LS45ZMZXATT6NQ3JANCNFSM5CU3FPJA>
 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using kotlin coroutines the use of NoStackTraceThrowable causes problems that are really hard to find.
This code will not catch the error
    try {
        pool.preparedQuery("select true = $1").execute(Tuple.of(12)).await()
    } catch (e: Exception) {
        LOG.error("Expected: {}", e.toString())
    }
to catch the error we would need to catch Throwable which forces us to check if it's an Error.
When using futures directly, this isn't as much of a problem I guess.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it is not clear how this relates to the current logging option
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.1.2
Context
When setTimer is called with delay <1, it will throw IllegalArgumentException.
This behavior is unacceptable as it can easily take down the whole service.
Instead, it simply needs to do max(delay, 1).
Note that node.js doesn't throw in this case. There is no sane argument why it should throw. setTimer(0) simply means execute as soon as possible.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cc @Sanne @cescoffier
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Read me
Describe the feature
EventBus.registerDefaultCodec currently allows to register a default message coded for a given class T. We would like to reuse the same message codec to send them over the wire. However EventBus.registerDefaultCodec does not have a MessageCodec<? super T, ?> and thus does not allow it.
Use cases
Imagine having multiple "Ducks" that you want to send via the wire:

GreatDuck
SmallDuck
DuckyMcDuck

All ducks implement the Duck interface and a toJson method.
The idea would be to implement one DuckMessageCodec which can handle any duck by calling the toJson object. Currently you cannot register this one codec for all the ducks, because:
DuckMessageCodec duckMessageCodec = new DuckMessageCodec();
eventBus.registerDefaultCodec(GreatDuck.class, duckMessageCodec);
eventBus.registerDefaultCodec(SmallDuck.class, duckMessageCodec);
eventBus.registerDefaultCodec(DuckyMcDuck.class, duckMessageCodec);

Contribution
It is a one line change thus it could be contributed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you add a test for this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP server request events will notify observability events incorrectly when processing pipelined requests. The request begin event will be omitted and the request end event will be emitted independently of the application request handling.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
right thanks!

On Mon, Sep 13, 2021 at 10:56 AM Francois Steyn ***@***.***> wrote:
 ***@***.**** commented on this pull request.
 ------------------------------

 In src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
 <#4091 (comment)>:

 > @@ -558,6 +566,25 @@ private void onEnd() {
      }
    }

 +  private void reportRequestComplete(Http1xServerRequest request) {

 No need for parameter anymore
 ------------------------------

 In src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
 <#4091 (comment)>:

 > @@ -558,6 +566,25 @@ private void onEnd() {
      }
    }

 +  private void reportRequestComplete(Http1xServerRequest request) {
 +    HttpServerMetrics metrics = conn.metrics;
 +    if (metrics != null) {
 +      metrics.requestEnd(request.metric(), request, request.bytesRead());
 +      conn.flushBytesRead();
 +    }
 +  }
 +
 +  private void reportRequestBegin(Http1xServerRequest request) {

 No need for parameter anymore

 
 You are receiving this because you were assigned.
 Reply to this email directly, view it on GitHub
 <#4091 (review)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AABXDCWHDNJUNGMIIFEVDZLUBW4DRANCNFSM5D5HNPBA>
 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Java 17 (LTS) will be released soon, do you know if Verx 4.X is supported under this JDK version.
Related to: #3961
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
The Handle() method definition does not throw an exception, which sometimes makes the code look verbose and cumbersome.
E.g:
        vertx.executeBlocking(promise -> {
            try {
                File file = writeZipFile(policies);
            } catch (IOException | JAXBException e) {
                promise.fail(e);
            }
        });
Exception catching seems redundant here, because the promise can be automatically set to fail when the program is error.
        // Concise code
        vertx.executeBlocking(promise -> writeZipFile(policies));
I think can use PromiseHandler<T> to replace Handler<Promise<T>>. Of course this is not a good solution, it's just my idea.
public interface PromiseHandler<T> extends Handler<Promise<T>> {

    @Override
    default void handle(Promise<T> promise) {
        try {
            handle0(promise);
        } catch (Exception e) {
            promise.fail(e);
        }
    }

    void handle0(Promise<T> promise) throws Exception;
}
Use cases
Contribution
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?
4.1.3
Context
Vertx openapi gives 400 http status code, when uploading file with multipart/form-data
Do you have a reproducer?
https://github.com/ebadta81/test
Steps to reproduce
After starting the test project, load the http://localhost:8443/web/index.html#/upload/upload-image url in your browser, and  send a request with swagger ui.
You will get 400 | Error: Bad Request
Extra
MacOs 11.5.2
openjdk 11.0.10 2021-01-19
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you sign the ecilpse contributor agreement @toir427 ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Latest 4.x
Steps to reproduce
Go to https://vertx.io/docs/apidocs/io/vertx/core/dns/AddressResolverOptions.html#DEFAULT_CACHE_MAX_TIME_TO_LIVE
Observe this says

public static final int DEFAULT_CACHE_MIN_TIME_TO_LIVE
The default value for the negative cache min TTL = 0

Observe that 
  
    
      vert.x/src/main/java/io/vertx/core/dns/AddressResolverOptions.java
    
    
        Lines 239 to 259
      in
      11ab144
    
  
  
    

        
          
             /** 
        

        
          
              * @return the cache min TTL in seconds 
        

        
          
              */ 
        

        
          
             public int getCacheMinTimeToLive() { 
        

        
          
               return cacheMinTimeToLive; 
        

        
          
             } 
        

        
          
            
        

        
          
             /** 
        

        
          
              * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL, 
        

        
          
              * use this to set a minimum value to all responses TTL. 
        

        
          
              * 
        

        
          
              * @param cacheMinTimeToLive the cache min TTL in seconds 
        

        
          
              * @return a reference to this, so the API can be used fluently 
        

        
          
              */ 
        

        
          
             public AddressResolverOptions setCacheMinTimeToLive(int cacheMinTimeToLive) { 
        

        
          
               if (cacheMinTimeToLive < 0) { 
        

        
          
                 throw new IllegalArgumentException("cacheMinTimeToLive must be >= 0"); 
        

        
          
               } 
        

        
          
               this.cacheMinTimeToLive = cacheMinTimeToLive; 
        

        
          
               return this; 
        

        
          
             } 
        
    
  

 is actually a positive cache TTL (positive=cache hit) to cache successful responses
Same for https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/dns/AddressResolverOptions.java#L41-L49
I believe that the negative part was just left over from copying and pasting the comment, it's for cache hits. DEFAULT_CACHE_NEGATIVE_TIME_TO_LIVE is the only constant that's actually a negative TTL for cache misses
Desired Behavior
Update javadoc in  https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/dns/AddressResolverOptions.java#L41-L49 to remove negative from
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think we can reasonably do that in Vert.x 4.2 and mention this is a breaking change that requires recompilation but I think application should not be changed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This PR is now extended with a few extra features:

Fixes #3654
Speed up on known missing classpath resources.

For every classpath resource that is missing, we keep track of the resource name in a bloom filter, if further resolutions use that name again, we avoid going over the class path search and extract
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
In javascript, the Promise API provides two useful utility methods Promise.resolve and Promise.reject for quickly turning a value into something wrapped by a promise. It would be nice to have this feature included with the core Promise.java class.
Use cases
For example, I've seen the following code snippet used in the codebase
protect void myFunc () {
  // ...
  Promise<String> promise = Promise.promise();
  promise.complete("Some val");
  return promise.future();
}
which is rather verbose. It would be nice if I could just write
return Promise.resolve("Some val").future();
for those last three lines.
Contribution
Who should implement this feature ? are you volunteering for implementing this feature or
do you know that is able and willing implement this feature ?
TBD
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x uses a file cache to hold resources from the class path. This allows vert.x to get better performance on file IO and users to safely pack resources with their applications.
Given that such cache is per vert.x instance, we cannot rely on system properties to know where is the location of the instance cache. For this, users have been using a non specified behavior VertxInternal#resolveFile("") to compute the location.
This has several problems:

It is not guaranteed to work when cache is disabled
It doesn't respect the vertx.cwd variable
it is expensive as it may go over the classpath file resolution

For this we should add an internal API to return the path or null if cache is disabled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When resolving resources from the classpath, vert.x needs to make use of class loaders. This can be an expensive task. When a resource exists, it gets extracted to the cache and any further resolution is just a simple file system access.
However if there are misses, they always go over the classpath. To reduce the number of classpath scans, the resolver should make use of a inverted bloom filter. On each miss the miss is added to the filter. Given that the filter can return possible false negatives the consistency of the valid cases is guaranteed and we may end doing a few redundant checks which already is a good improvement.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.1.0-Beta1
Context
I ran into a Java deadlock in a large application, and based on the stack trace of the blocked threads, it seems to be caused by each thread running WorkerExecutor.executeBlocking on the same two WorkerExecutor instances, but in a different order. One thread looked like this:
 "vert.x-eventloop-thread-0":
         at io.vertx.core.impl.WorkerExecutorImpl.executeBlocking(WorkerExecutorImpl.java:69)
         - waiting to lock <0x00000000d60dd340> (a io.vertx.core.impl.WorkerExecutorImpl)
         at io.vertx.reactivex.core.WorkerExecutor.executeBlocking(WorkerExecutor.java:118)
         at io.vertx.reactivex.core.WorkerExecutor.lambda$rxExecuteBlocking$2(WorkerExecutor.java:166)
         at io.vertx.reactivex.core.WorkerExecutor$$Lambda$1166/0x0000000840a2b440.accept(Unknown Source)
         at io.vertx.reactivex.impl.AsyncResultMaybe.subscribeActual(AsyncResultMaybe.java:44)
         at io.reactivex.Maybe.subscribe(Maybe.java:4174)
         at io.reactivex.internal.operators.maybe.MaybeFlatten$FlatMapMaybeObserver$InnerObserver.onComplete(MaybeFlatten.java:129)
...
         at io.reactivex.internal.operators.maybe.MaybeFilter$FilterMaybeObserver.onComplete(MaybeFilter.java:102)
         at io.vertx.reactivex.impl.AsyncResultMaybe.lambda$subscribeActual$0(AsyncResultMaybe.java:52)
         at io.vertx.reactivex.impl.AsyncResultMaybe$$Lambda$325/0x0000000840303840.handle(Unknown Source)
         at io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:124)
         at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
         at io.vertx.core.impl.future.FutureImpl.addListener(FutureImpl.java:164)
         at io.vertx.core.impl.future.PromiseImpl.addListener(PromiseImpl.java:23)
         at io.vertx.core.impl.future.FutureImpl.onComplete(FutureImpl.java:132)
         at io.vertx.core.impl.future.PromiseImpl.onComplete(PromiseImpl.java:23)
         at io.vertx.core.impl.WorkerExecutorImpl.executeBlocking(WorkerExecutorImpl.java:71)
         - locked <0x00000000d8e22a10> (a io.vertx.core.impl.WorkerExecutorImpl)
         at io.vertx.reactivex.core.WorkerExecutor.executeBlocking(WorkerExecutor.java:118)
         at io.vertx.reactivex.core.WorkerExecutor.lambda$rxExecuteBlocking$2(WorkerExecutor.java:166)
         at io.vertx.reactivex.core.WorkerExecutor$$Lambda$1166/0x0000000840a2b440.accept(Unknown Source)
         at io.vertx.reactivex.impl.AsyncResultMaybe.subscribeActual(AsyncResultMaybe.java:44)

And the other like this:
"vert.x-eventloop-thread-2":
         at io.vertx.core.impl.WorkerExecutorImpl.executeBlocking(WorkerExecutorImpl.java:69)
         - waiting to lock <0x00000000d8e22a10> (a io.vertx.core.impl.WorkerExecutorImpl)
         at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.execute(ContextScheduler.java:161)
         at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.schedule(ContextScheduler.java:155)
         - locked <0x00000000d9a520b8> (a io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction)
         at io.vertx.reactivex.ContextScheduler$ContextWorker$TimedAction.access$100(ContextScheduler.java:135)
         at io.vertx.reactivex.ContextScheduler$ContextWorker.schedule(ContextScheduler.java:109)
         at io.vertx.reactivex.ContextScheduler$ContextWorker.schedule(ContextScheduler.java:100)
         at io.reactivex.internal.operators.flowable.FlowableSubscribeOn.subscribeActual(FlowableSubscribeOn.java:48)
...
         at io.reactivex.internal.operators.maybe.MaybeFilter$FilterMaybeObserver.onSuccess(MaybeFilter.java:89)
         at io.vertx.reactivex.impl.AsyncResultMaybe.lambda$subscribeActual$0(AsyncResultMaybe.java:50)
         at io.vertx.reactivex.impl.AsyncResultMaybe$$Lambda$325/0x0000000840303840.handle(Unknown Source)
         at io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:124)
         at io.vertx.core.impl.future.FutureBase.emitSuccess(FutureBase.java:62)
         at io.vertx.core.impl.future.FutureImpl.addListener(FutureImpl.java:164)
         at io.vertx.core.impl.future.PromiseImpl.addListener(PromiseImpl.java:23)
         at io.vertx.core.impl.future.FutureImpl.onComplete(FutureImpl.java:132)
         at io.vertx.core.impl.future.PromiseImpl.onComplete(PromiseImpl.java:23)
         at io.vertx.core.impl.WorkerExecutorImpl.executeBlocking(WorkerExecutorImpl.java:71)
         - locked <0x00000000d60dd340> (a io.vertx.core.impl.WorkerExecutorImpl)
         at io.vertx.reactivex.core.WorkerExecutor.executeBlocking(WorkerExecutor.java:118)
         at io.vertx.reactivex.core.WorkerExecutor.lambda$rxExecuteBlocking$2(WorkerExecutor.java:166)
         at io.vertx.reactivex.core.WorkerExecutor$$Lambda$1166/0x0000000840a2b440.accept(Unknown Source)
         at io.vertx.reactivex.impl.AsyncResultMaybe.subscribeActual(AsyncResultMaybe.java:44)

WorkerExecutorImpl.executeBlocking looks like this:
  public synchronized <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<T>> asyncResultHandler) {
    Future<T> fut = executeBlocking(blockingCodeHandler, ordered);
    if (asyncResultHandler != null) {
      fut.onComplete(asyncResultHandler);
    }
  }
If that fut.onComplete call runs after the blockingCodeHandler has finished, the asyncResultHandler will be executed right away on the current thread. This means that we stay inside of the synchronized block as we continue on. If one thread does
we1.executeBlocking(...) followed by we2.executeBlocking(...), and another thread does it in the reverse order, and the first call each thread makes ends up running asyncResultHandler right away, you deadlock.
Do you have a reproducer?
Here is a simple JUnit test that reproduces it:
  public static class TestV extends AbstractVerticle {
    private final CyclicBarrier b;
    private final WorkerExecutor we1;
    private final WorkerExecutor we2;

    public TestV(WorkerExecutor we1, WorkerExecutor we2, CyclicBarrier b) {
      this.we1 = we1;
      this.we2 = we2;
      this.b = b;
    }

    @Override
    public void start(Promise<Void> p) throws BrokenBarrierException, InterruptedException {
      b.await();
      we1.executeBlocking(a -> a.complete("a"), false, ign -> 
          we2.executeBlocking(a -> a.complete("a"), false, ign2 -> p.complete())
      );
    }
  }

  @Test
  public void test(TestContext context) {
    var async = context.strictAsync(2);
    CyclicBarrier b = new CyclicBarrier(2);
    var we1 = vertx.createSharedWorkerExecutor("test1");
    var we2 = vertx.createSharedWorkerExecutor("test2");
    vertx.deployVerticle(new TestV(we1, we2, b), ign -> async.countDown());
    vertx.deployVerticle(new TestV(we2, we1, b), ign -> async.countDown());
  }
Note that you also need to add a breakpoint on this line in WorkerExecuteImpl.executeBlocking, to ensure that the blockingCodeHandler always finishes before fut.onComplete runs:
    if (asyncResultHandler != null) {

I used the Intellij "Evaluate and log" breakpoint option to insert a 200ms sleep on this line, which lead to consistent reproductions when executing the above test.
Steps to reproduce
I suspect this is hard to reliably reproduce outside of a carefully constructed test, because the timing requirements are so specific.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Updated the original proposal from List to Set.
The cookie jar should contain unique cookies, using a list would not solve the problem. Given that a cookie unique identifier according to the spec is the tuple <name, domain, path> having the interface implement the Comparable interface too allows us to use a TreeSet to hold the cookies, which will ensure that addition and uniqueness according to the rules are enforced.
This also works for the case where users work with the set directly instead of the helper methods.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.1.4
Context
Again testing a server streaming a chunked response. When using Vertx HTTP client, if the futures from .connect() call and the one from .body() call are converted to java.util.concurrent.CompletableFuture by .toCompletionStage().toCompletableFuture(), then the client loses a few (23) first chunks of the response body. The same happens with just .toCompletionStage()  but I have included the .toCompletableFuture() step in the test too, as I do use that in the actual code where I first noticed this.
Do you have a reproducer?
A modified version of the reproducer from #4072  with new test added that does the conversion. The old tests all pass, but the new one fails on body assertions because of the lost chunks with something like
org.opentest4j.AssertionFailedError: expected: <chunk 1chunk 2chunk 3final chunk> but was: <final chunk>

silmeth/vertx-chunked-reproducer
Steps to reproduce

Clone the repo linked above.
Run ./gradlew test from the repos directory.

The code is in src/test/kotlin/chunked/reproducer/ChunkedTest.kt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj I can make that change, but can you respond to this comment I made in the issue?

@vietj That change does fix the issue, but it still leaves a race condition where close() gets called after that synchronized block, but before the work can actually be scheduled with the SharedWorkerPool. Putting a synchronized block on the entire executeBlocking(Handler blockingCodeHandler, boolean ordered) method also fixes the deadlock issue, but protects against the close() race condition. Is that the better option?

Isn't there still a race condition with the change you're suggesting, or am I missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you elaborate when this happens and add a test for this ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
When I try to connect a public server with no auth required, it always throws an exception with:
"WebSocket connection attempt returned HTTP status code 403"
Version
4.0.3
Context
I encountered an exception which looks suspicious while ...
`       Vertx vertx = Vertx.vertx();
    HttpClientOptions options = new HttpClientOptions();
    options.setTrustAll(true).setVerifyHost(false);
    options.setSsl(true);


    HttpClient client = vertx.createHttpClient(options);
    client.webSocket(443, "bsc-ws-node.nariox.org", "/").onSuccess(webSocket -> {
        webSocket.handler(data -> {
            log.debug("data:{}", data);
        });
    }).onFailure(err -> {
        log.debug("error:", err);
    });`

Steps to reproduce
the code above will throws:

Extra
and in my nodejs code, it is working without any problem with following code:
`const WebSocket = require('ws');
async function main() {
console.log("hallo world ...");
const ws = new WebSocket('wss://bsc-ws-node.nariox.org:443');

ws.on('open', function open() {
    console.log("connected ...")
});

ws.on('message', function incoming(message) {
  console.log('received: %s', message);
});

}
main().catch(console.log)`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @vietj ,
I have closed the old PR here is the new one I have re signed the eca still issue remains
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to the lack of signature Logger.error(Throwable t) but Logger.error(Object message), all the logs that written like log.error(ex) do not output stack trace.
example:

  
    
      vert.x/src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
    
    
         Line 87
      in
      67cd979
    
  
  
    

        
          
           log.error(t);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
The problems occurs with versions 3.8.5, 3.9.9 and 4.1.4
Context
When handlers are registered at the eventBus for the same address with localConsumer() and consumer(), the behaviour is not as expected:

When the localConsumer() is registered first, the consumer() will never get called for messages, which were published on other cluster nodes.
When the consumer() is registered first, the localConsumer() will always get called even for messages, which are not local, but were published on other cluster nodes.

The expected behaviour would be, that a localConsumer() only gets called for local messages and the consumer() gets called for all messages, even if registered for the same address.
Reproducer
Message Receiver:
import java.util.concurrent.CountDownLatch;

import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.EventBusOptions;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

public class Receiver {
	public static Vertx vertx;

	public final static String FIRST_ADDRESS = "first.address";

	public final static String SECOND_ADDRESS = "second.address";

	public static void main(String[] args) throws InterruptedException {
		int port = 6151;
		CountDownLatch waitLatch = new CountDownLatch(1);

		VertxOptions vertxOptions = new VertxOptions();
		vertxOptions.setClusterManager(new HazelcastClusterManager());

		EventBusOptions eventbus = vertxOptions.getEventBusOptions();
		eventbus.setHost("0.0.0.0");
		eventbus.setPort(port);
		eventbus.setClusterPublicHost("0.0.0.0");
		eventbus.setClusterPublicPort(port);

		Vertx.clusteredVertx(vertxOptions, result -> {
			vertx = result.result();

			EventBus eventBus = vertx.eventBus();

			eventBus.localConsumer(FIRST_ADDRESS, message -> {
				System.out.println("Event to " + FIRST_ADDRESS + " handled with local consumer");
			});

			eventBus.consumer(FIRST_ADDRESS, message -> {
				System.out.println("Event to " + FIRST_ADDRESS + " handled with consumer");
			});

			eventBus.consumer(SECOND_ADDRESS, message -> {
				System.out.println("Event to " + SECOND_ADDRESS + " handled with consumer");
			});

			eventBus.localConsumer(SECOND_ADDRESS, message -> {
				System.out.println("Event to " + SECOND_ADDRESS + " handled with local consumer");
			});

			System.out.println("Awaiting messages");
		});

		waitLatch.await();
	}
}

Message Sender:
import java.util.concurrent.CountDownLatch;

import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.EventBusOptions;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

public class Sender {
	public static Vertx vertx;

	public final static String FIRST_ADDRESS = "first.address";

	public final static String SECOND_ADDRESS = "second.address";

	public static void main(String[] args) throws InterruptedException {
		int port = 6152;
		CountDownLatch waitLatch = new CountDownLatch(1);

		VertxOptions vertxOptions = new VertxOptions();
		vertxOptions.setClusterManager(new HazelcastClusterManager());

		EventBusOptions eventbus = vertxOptions.getEventBusOptions();
		eventbus.setHost("0.0.0.0");
		eventbus.setPort(port);
		eventbus.setClusterPublicHost("0.0.0.0");
		eventbus.setClusterPublicPort(port);

		Vertx.clusteredVertx(vertxOptions, result -> {
			vertx = result.result();

			EventBus eventBus = vertx.eventBus();

			System.out.println("Sending messages");

			eventBus.publish(FIRST_ADDRESS, null);
			eventBus.publish(SECOND_ADDRESS, null);
		});

		waitLatch.await();
	}
}

Steps to reproduce:

Start the Message Receiver
Wait until the message receiver prints "Awaiting messages"
Start the sender
Sender will print "Sending messages" and then publish two messages
Receiver will handle the second message with both the localConsumer and the consumer, but will not handle the first message at all
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you have a look @pmlopes ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have build cron framework in our service to run some task at particular time durations.
We have used set vertx.setPeriodic for to schedule these tasks. But we are observing strange behaviour after upgrading to 3.9.7. set periodic stops working after 14, 15 days of service uptime.
Earlier we were on 3.5.2 and everything were working fine
Version 3.9.7
Which version(s) did you encounter this bug ?
Version 3.9.7
Discussion on this bug.
https://groups.google.com/g/vertx/c/meqT7zGYCsc/m/fzRQmwqsAAAJ?utm_medium=email&utm_source=footer
We are using Open JDK Java 15
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I actually meant in a fork of Vert.x and not in the community version. Sorry for lacking of clarity.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Motivation
Vert.x EventBus codec manager resolves a body codec based on the type of the body returned by getClass(). Registering a codec to multiple java types based on inheritance is not support and requires the user to register the same codec for each class or interface object with multiple instances of the same codec (since the code name needs to be unique).
Proposal
Modify the body codec resolution based on the type returned by getClass() to lookup the codec with the class or interface defined by the class or its parent class.

Resolution is performed after system codec resolution, e.g a codec for Number will not be used to encode java.lang.Integer because there is a system codec for this type
Binding java.lang.Object is forbidden

The change should not introduce regression since this was not supported previously and sending a message with a body resolved with a codec on a parent class of the body would either fail or work because the class for this body is registered already.
Non goals

any kind of reification support (e.g Foo<String>)
resolution based on implemented interfaces rather than classes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
e.g server.headers().contains("connection", "upgrade", true) is actually server.headers().contains("connection", "upgrade", false)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It can be useful sometimes to have the server ignore WebSocket and let it handle HTTP WebSocket upgrades itself, e.g a reverse proxy implementation can disable Vert.x HTTP Server WebSocket handling and simply handle it at the wire level and let the inbound server (the server reached by the proxy) handle it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HTTP client provides an API to connect to a server and perform an opaque conversation after the connect is successful. It supports HTTP CONNECT method and HTTP connection upgrade. The HTTP connection upgrade assumes that the header value is Upgrade sensitively, it should be insensitive instead.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The client calls the HTTP client metrics SPI for HTTP/1.1 requests which have been allocated but not yet sent: every request that is created by HttpClient#request that has not yet been sent calls back the SPI when it should not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm implementing support for https://github.com/netty/netty-incubator-transport-io_uring on Vert-x Transport, see https://github.com/franz1981/vert.x/tree/4.2.1_iouring for some initial experiment.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I should add some check re domain socket support on JUnit tests
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Unexpected error IllegalStateException: File handle is closed.
Version
vert.x 4.1.4
Context
We have a web server which is built on top of vertx-web. The web server uses BodyHandler to handle file uploads. It looks like if the upload is using HTTP/1.1 protocol, sometimes the following error occurs. It looks like the AsyncFileImpl was already closed when the BodyHandlerImpl tries to cancel the upload.
java.lang.IllegalStateException: File handle is closed
    at io.vertx.core.file.impl.AsyncFileImpl.checkClosed(AsyncFileImpl.java:544)
    at io.vertx.core.file.impl.AsyncFileImpl.check(AsyncFileImpl.java:539)
    at io.vertx.core.file.impl.AsyncFileImpl.drainHandler(AsyncFileImpl.java:271)
    at io.vertx.core.file.impl.AsyncFileImpl.drainHandler(AsyncFileImpl.java:54)
    at io.vertx.core.streams.impl.PipeImpl.close(PipeImpl.java:138)
    at io.vertx.core.http.impl.HttpServerFileUploadImpl.cancelStreamToFileSystem(HttpServerFileUploadImpl.java:223)
    at io.vertx.ext.web.impl.FileUploadImpl.cancel(FileUploadImpl.java:72)
    at io.vertx.ext.web.handler.impl.BodyHandlerImpl$BHandler.cancelAndCleanupFileUploads(BodyHandlerImpl.java:323)
    at io.vertx.ext.web.handler.impl.BodyHandlerImpl$BHandler.lambda$new$2(BodyHandlerImpl.java:219)
    at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:100)
    at io.vertx.core.http.impl.HttpEventHandler.handleException(HttpEventHandler.java:89)
    at io.vertx.core.http.impl.Http1xServerRequest.handleException(Http1xServerRequest.java:639)
    at io.vertx.core.http.impl.Http1xServerConnection.lambda$handleClosed$5(Http1xServerConnection.java:448)
    at io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:71)
    at io.vertx.core.impl.DuplicatedContext.execute(DuplicatedContext.java:163)
    at io.vertx.core.impl.AbstractContext.execute(AbstractContext.java:58)
    at io.vertx.core.http.impl.Http1xServerConnection.handleClosed(Http1xServerConnection.java:447)
    at io.vertx.core.net.impl.VertxHandler.channelInactive(VertxHandler.java:144)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.handler.stream.ChunkedWriteHandler.channelInactive(ChunkedWriteHandler.java:137)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:81)
    at io.netty.handler.codec.http.HttpContentEncoder.channelInactive(HttpContentEncoder.java:313)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:389)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:354)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248)
    at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:831)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Unknown Source)

Do you have a reproducer?
I don't have a readily available reproducer.
Extra

It happens on both JDK 14 and JDK 17, so it should not be JDK version specific.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An HTTP client request begins a trace with the HTTP method as trace operation, we can provide in RequestOptions an override for this value, so the user can set the operation to use instead of the HTTP method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
that would change the current behavior
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In vert.x 3.x the value set via the vertx.cacheDirBase Java system property had been used to create a temporary directory for resolving files from the classpath as follows:
"${vertx.cacheDirBase}/file-cache-" + UUID.randomUUID().toString()
In vert.x 4.x the semantics has changed to now create a directory as:
"${vertx.cacheDirBase}-" + UUID.randomUUID().toString()
With vert.x 3.x it was possible to e.g. provide the vert.x process with write access to /tmp and set -Dvertx.cacheDirBase=/tmp so that vert.x would create a sub-directory under /tmp during startup.
Using the same system property value under vert.x 4 will fail during startup if the vert.x process does not have write access to the root file system (/) because vert.x will try to create folder /tmp-UUID instead of /tmp/file-cache-UUID in this case.
The online documentation regarding this system property and how its value is being used is also wrong for versions 3.9.10, 4.0.3, 4.1.6 and 4.2.1
This (breaking) change also hasn't been documented in the Migration Guide for upgrading to vert.x 4.
I see two ways of dealing with this. Either keep the breaking change in the code base and amend the Migration Guide accordingly or reinstate the vert.x 3 behavior in the vert.x 4 code base. I can provide a pull request for any of these options as you see fit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Which version(s) did you encounter this bug ?
4.0.3
Context
When a vertx server is closed gracefully in a clustered vertx (all consumers unregistered, verticles undeployed, vertx closed), there are consumers in other servers that receive a timeout ReplyException. We would have expected that those consumers did not have to wait for the timeout to expire, and immediately receive an other error such as VertxException : Connection was closed.
I assume that when a verticle (or a consumer) is unregistered, vertx knows what are the pending requests, would it be possible to make them fail with an adequate exception instead of letting them expire in the sender ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am running this code on 8 core machine with 16 event loop. However the webclient is not using all the event loop and all webclient request are running on single event loop. Am I doing it incorrectly or is it a bug ?
Also there was some documentation I read long back on how to use Vertx to create standalone application (not using verticles). Can someone share the link for that ?
pom.xml
        <dependency>
            <groupId>io.vertx</groupId>
            <artifactId>vertx-web-client</artifactId>
        </dependency>
        <dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-tcnative-boringssl-static</artifactId>
            <scope>compile</scope>
            <optional>false</optional>
        </dependency>
        <dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-transport-native-epoll</artifactId>
            <classifier>linux-x86_64</classifier>
            <scope>compile</scope>
            <optional>false</optional>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-slf4j-impl</artifactId>
            <version>2.14.1</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.22</version>
            <scope>provided</scope>
        </dependency>


import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.impl.cpu.CpuCoreSensor;
import io.vertx.core.net.OpenSSLEngineOptions;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.client.WebClientOptions;

import java.time.Instant;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VertxFuture {
  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(VertxFuture.class);
  public static AtomicInteger atomicInteger = new AtomicInteger();
  public static AtomicInteger outerAtomicInteger = new AtomicInteger();

  public static void main(String[] args) {
    System.setProperty("vertx.disableDnsResolver", "true");
    Vertx vertx = Vertx.vertx(new VertxOptions().setEventLoopPoolSize(2 * CpuCoreSensor.availableProcessors()).setPreferNativeTransport(true));
    try {
      Instant now = Instant.now();
      WebClient webclient = WebClient.create(vertx, new WebClientOptions()
              .setTryUseCompression(true)
              .setVerifyHost(false)
              .setReuseAddress(true)
              .setReusePort(true)
              .setTcpFastOpen(true)
              .setTcpNoDelay(true)
              .setTcpQuickAck(true)
              .setKeepAlive(true)
              .setMaxPoolSize(100)
              .setOpenSslEngineOptions(new OpenSSLEngineOptions().setSessionCacheEnabled(false)));
      List<Future> collect = IntStream.range(0, 100).mapToObj(x -> (new VertxFuture()).request(webclient, now)).collect(Collectors.toList());
      System.out.println("Started: " + now);
      CompositeFuture.all(collect).toCompletionStage().toCompletableFuture().get();
      System.out.println("Completed: " + Instant.now());
      System.out.println("Inner Counter: " + atomicInteger.get());
      System.out.println("Outer Counter: " + outerAtomicInteger.get());
    } catch (Exception e) {
      e.printStackTrace();
    }

  }

  public Future request(WebClient webClient, Instant instant) {
    return webClient.get(443,
                    "application-dev.test.com",
                    "/test/0cd7729e-ab1b-445e-ad9f-22a7214305b1/details")
            .ssl(true)
            .putHeader("trace_id", "test12341")
            .putHeader("span_id", "test12341")
            .send()
            .flatMap(new Function<HttpResponse<Buffer>, Future<io.vertx.ext.web.client.HttpResponse<Buffer>>>() {
              @Override
              public Future<io.vertx.ext.web.client.HttpResponse<Buffer>> apply(HttpResponse<Buffer> bufferHttpResponse) {
                log.info("Running on event loop");
                outerAtomicInteger.incrementAndGet();
                if (Instant.now().isBefore(instant.plusSeconds(10))) {
                  atomicInteger.incrementAndGet();
                  return request(webClient, instant);
                } else {
                  return Future.<io.vertx.ext.web.client.HttpResponse<Buffer>>succeededFuture(bufferHttpResponse);
                }
              }
            });
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.0.3 (Java), Clustered
Context
When a request is send to the cluster with a timeout set in the options, it might happen (especially when heavily loaded) that vertx issues a "Result is already complete" exception when applying the response to its internal promise, if the timeout has been triggered at the same time.
Here's the stack trace:
java.lang.IllegalStateException: Result is already complete at io.vertx.core.Promise.complete(Promise.java:67) at io.vertx.core.eventbus.impl.ReplyHandler.dispatch(ReplyHandler.java:94) at io.vertx.core.eventbus.impl.HandlerRegistration$InboundDeliveryContext.next(HandlerRegistration.java:163) at io.vertx.core.eventbus.impl.HandlerRegistration$InboundDeliveryContext.dispatch(HandlerRegistration.java:128) at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:107) at io.vertx.core.eventbus.impl.HandlerRegistration.dispatch(HandlerRegistration.java:104) at io.vertx.core.eventbus.impl.ReplyHandler.doReceive(ReplyHandler.java:75) at io.vertx.core.eventbus.impl.HandlerRegistration.lambda$receive$0(HandlerRegistration.java:54) at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748)
I suppose that the "complete" statement in the reply handler should be replaced by a tryComplete() or should detect that it already timed out
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
I used gravitee api gateway, The production environment encountered a block problem, "[vertx-blocked-thread-checker] [] WARN ivcore.impl.BlockedThreadChecker-Thread Thread[vert.x-eventloop-thread-10,5,main] has been blocked for 2075 ms, time limit is 2000" I want to change warningExceptionTime 1 second print VertxException StackTrace, Please help me
Version
JDK:1.8.0_144
Gravitee:1.20.15
Vertx:3.5.4
Do you have a reproducer?
1Local IntelliJ Idea jvm startup args:
-Dgravitee.home=/Users/daipeng/workspace_longfor/gravitee-home-local -server -Xmx128m -Xms128m -Xmn64m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelInitialMarkEnabled -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+ParallelRefProcEnabled -XX:MaxTenuringThreshold=8 -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:+PrintReferenceGC -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=10M -verbose:gc -Xloggc:/Users/daipeng/logs/gc-%t.log -Dvertx.options.warningExceptionTime=1000000000
2Gravitee process request main thread sleep(3000)
3Console log still none print VertxException StackTrace Information, due to sleep time less than VertxOptions.DEFAULT_WARNING_EXCEPTION_TIME
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HTTP client uses event loops provided by actual requests to assign connection event-loops. In some case it is desirable to have the client use its own event loop as a pool, like when it is shared between verticles or statically.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When deploying verticle in Vert.X, if we want to deploy multiple instances of the specified verticle, we can only deploy by name of the verticle, otherwise an exception like this will be thrown: "can't specify > 1 instances for already created verticle".
However, the way of deploying by name calls the constructor without parameters of the verticle instance by default. In this way, if there are non static field in the verticle instance, they will not be initialized correctly as expected. In this case, we can only change the field in the verticle instance to static, but if we want to deploy multiple verticle instances with different values of one of itself non-static field, how should we implement this in the current Vert.x 4.x? I look forward to your response. Thanks in advance!
Here is my sample code
@SpringBootApplication
@Configuration
public class Application {
    @Value("${ws.port}")
    private int wsPort;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @EventListener(classes = {ApplicationReadyEvent.class})
    public void afterStarted(final ApplicationReadyEvent applicationReadyEvent) {
        final ConfigurableApplicationContext applicationContext = applicationReadyEvent.getApplicationContext();
        VerticleUtils.deployVerticle(WebSocketServerVerticle.class, false, 1, applicationContext);
        WebSocketClientVerticle.setWsPort(wsPort);
        VerticleUtils.deployVerticle(WebSocketClientVerticle.class.getName(), false, 10, applicationContext);
        VerticleUtils.deployVerticle(WebSocketClient2Verticle.class, false, 1, applicationContext);
    }
}
@Slf4j
@Component
public class WebSocketClientVerticle extends AbstractVerticle {
    //@Value("${ws.port}")
    private static int wsPort;

    @Override
    public void start() throws Exception {
        HttpClient client = vertx.createHttpClient();
        client.webSocket(wsPort, "127.0.0.1", "/ws/123", asyncResult -> {
            WebSocket webSocket = asyncResult.result();
            webSocket.writeTextMessage("ping");
            webSocket.textMessageHandler(message -> {
                log.info("Recieve message From WebSocket Server{}", message);
                if("pong".equals(message)) {
                    webSocket.writeTextMessage("ping");
                }
            });
        });
    }

    public static void setWsPort(int wsPort) {
        WebSocketClientVerticle.wsPort = wsPort;
    }
}
Vert.x version: 4.2.1
JDK version: 1.8.0_241
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context
All data that previously has been persisted in the context, available in next iteration of thread.
Following test:
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.impl.ContextInternal;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;

@ExtendWith(VertxExtension.class)
public class WorkingContextTest {
	
	private static final String CONTEXTUAL_KEY = "val";
	
	@Test
	void test(Vertx vertx, VertxTestContext ctx) {
		vertx.deployVerticle(new AbstractVerticle() {
			@Override
			public void start() throws Exception {
				AtomicInteger cnt = new AtomicInteger();
				vertx.setPeriodic(100, id -> {
					var actual = get(CONTEXTUAL_KEY);
					if(null == actual) {
						var expected = UUID.randomUUID().toString();
						put(CONTEXTUAL_KEY, expected);
						
						if(cnt.incrementAndGet() > 100) {
							ctx.completeNow();
						}
					} else {
						vertx.cancelTimer(id);
						ctx.failNow("context not empty. value:" + actual);
					}
				});
			}
		});
	}
	
	private static String put(String key, String value) {
		Objects.requireNonNull(key);
		Objects.requireNonNull(value);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx == null) {
			return null;
		} else {
			return contextualDataMap(ctx).put(key, value);
		}
	}

	public static String get(String key) {
		Objects.requireNonNull(key);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx != null) {
			return contextualDataMap(ctx).get(key);
		}
		return null;
	}
	
	private static ConcurrentMap<String, String> contextualDataMap(ContextInternal ctx) {
		Objects.requireNonNull(ctx);
		return (ConcurrentMap<String, String>) ctx.localContextData().computeIfAbsent(WorkingContextTest.class, k -> new ConcurrentHashMap<String,String>());
	}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Inside runOnContext handler of Context, all previously persisted contextual data are not available.
Following test:
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.core.impl.ContextInternal;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;

@ExtendWith(VertxExtension.class)
public class WorkingContextTest {
	
	private static final String ADDRESS = "foo";
	private static final String CONTEXTUAL_KEY = "val";
	
	
	@Test
	void copyContextualDataTest(Vertx vertx, VertxTestContext ctx) {
		var expected = UUID.randomUUID().toString();
		
		vertx.deployVerticle(new AbstractVerticle() {
			@Override
			public void start() throws Exception {
				vertx.eventBus().consumer(ADDRESS, msg -> {
					put(CONTEXTUAL_KEY, expected);
					context.runOnContext(nil -> {
						var actual = get(CONTEXTUAL_KEY);
						
						if(null == actual) {
							ctx.failNow("contextual data not copied");
						} else {
							ctx.completeNow();
						}
					});
				});
			}
		}).map(id -> {
			vertx.eventBus().send(ADDRESS, id);
			return null;
		});
	}
	
	private static String put(String key, String value) {
		Objects.requireNonNull(key);
		Objects.requireNonNull(value);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx == null) {
			return null;
		} else {
			return contextualDataMap(ctx).put(key, value);
		}
	}

	public static String get(String key) {
		Objects.requireNonNull(key);
		ContextInternal ctx = (ContextInternal) Vertx.currentContext();
		if (ctx != null) {
			return contextualDataMap(ctx).get(key);
		}
		return null;
	}
	
	private static ConcurrentMap<String, String> contextualDataMap(ContextInternal ctx) {
		Objects.requireNonNull(ctx);
		return (ConcurrentMap<String, String>) ctx.localContextData().computeIfAbsent(WorkingContextTest.class, k -> new ConcurrentHashMap<String,String>());
	}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Friends, After investigations of miss behavior of contextual tracing, I think that we found regression.
Following details:
Several eventbus events have a single (shared) context local data.
This happened in worker verticle and in inboundInterceptor of Reply.
Following the reproduce test:
  @Test
  void testRequestReceive(Vertx vertx, VertxTestContext ctx) {
    logger.trace("testRequestReceive");
    
    vertx.runOnContext(nil -> {
      vertx.eventBus().addOutboundInterceptor(event-> {
        var value = get(CONTEXTUAL_KEY);
        if(null != value) {
          logger.trace("put contextual value: {} to header", value);
          event.message().headers().add(CONTEXTUAL_KEY, value);
        }
        event.next();
      });
      
      vertx.eventBus().addInboundInterceptor(event-> {
        var value = event.message().headers().get(CONTEXTUAL_KEY);
        if(null != value) {
          put(CONTEXTUAL_KEY, value);
        }
        event.next();
      });
      
      vertx.deployVerticle(new AbstractVerticle() {
        public void start(Promise<Void> startPromise) throws Exception {
          vertx.eventBus().consumer(EVENT_ADDRESS, message -> {
            message.reply(message.body());
          });
          
          startPromise.complete();
        }
      }, new DeploymentOptions().setWorker(true))
      .compose(noig -> vertx.deployVerticle(new AbstractVerticle() {
        public void start(Promise<Void> startPromise) throws Exception {
          final int max = 100;
          AtomicInteger cnt = new AtomicInteger();
          AtomicBoolean failed = new AtomicBoolean(); 
          for (int i = 0; i < max; i++) {
            logger.trace("send:{}", i);
            var value = String.valueOf(i);
            put(CONTEXTUAL_KEY, value);
            vertx.eventBus().request(EVENT_ADDRESS, value, res -> {
              try {
                if(! failed.get()) {
                  var expectedValue = (String)res.result().body();
                  var actualValue = get(CONTEXTUAL_KEY);
                  
                  Assertions.assertEquals(expectedValue, actualValue);
                  logger.trace("received: message:{}, context:{}", expectedValue, actualValue);
                  if(cnt.incrementAndGet() >= max) {
                    ctx.completeNow();
                  }
                }
              } catch (Throwable e) {
                if(failed.compareAndSet(false, true)) {
                  ctx.failNow(e);
                }
              }
            });
          };
          
          startPromise.complete();
        }
      }, new DeploymentOptions().setWorker(true)));
    });  
  }
  
  private static String put(String key, String value) {
    Objects.requireNonNull(key);
    Objects.requireNonNull(value);
    ContextInternal ctx = (ContextInternal) Vertx.currentContext();
    if (ctx == null) {
      if (logger.isTraceEnabled()) {
        logger.trace("Attempt to set contextual data from a non Vert.x thread");
      }
      return null;
    } else {
      return contextualDataMap(ctx).put(key, value);
    }
  }

  public static String get(String key) {
    Objects.requireNonNull(key);
    ContextInternal ctx = (ContextInternal) Vertx.currentContext();
    if (ctx != null) {
      return contextualDataMap(ctx).get(key);
    }
    return null;
  }
  
  private static ConcurrentMap<String, String> contextualDataMap(ContextInternal ctx) {
    Objects.requireNonNull(ctx);
    return (ConcurrentMap<String, String>) ctx.localContextData().computeIfAbsent(EventBusTest2.class, k -> new ConcurrentHashMap<String,String>());
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Facing issue with webclient
Having following stackstrace


SEVERE io.vertx.core.net.impl.ConnectionBase Connection reset


java.net.SocketException: Connection reset
at java.base/sun.nio.ch.SocketChannelImpl.throwConnectionReset(SocketChannelImpl.java:345)
at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:376)
at io.netty.buffer.PooledByteBuf.setBytes(PooledByteBuf.java:253)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:350)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:151)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:832)


SEVERE io.vertx.core.http.impl.HttpClientRequestImpl io.vertx.core.VertxException: Connection was closed


above error logs are printed in production logs
it was clearly working with 3.9.1.
When same api tried from local env it works. no errors are returned.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a clustered event-bus is shutdown, it will close all its connection to its peers. We could introduce a shutdown sequence, that sends a close frame before TCP connection close that indicates the server will not be available anymore.
This would allow peers to fail eagerly the pending requests and perhaps other use cases.
This would require a modification of the event-bus protocol so it would be a breaking change.
See #4183
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current event-bus protocol is versioned but does not allow to versions to interoperate. It should be improved in a way that a server can operate with an older version and remain compatible with its peer.
When the peer connects to another peer, it sends the version but it should receive a frame that indicates the version that was agreed between the peers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx 4.2.0
Context
Values for gauge metric vertx_net_client_active_connections are not being decreased on http connection closed.
Do you have a reproducer?
https://github.com/Mersenne255/vertx_issue_4185_reproducer
Reproducer submits single http request and ends afterwards.
vertx_net_client_active_connections keeps showing value of 1, http metric vertx_http_client_active_connections is correctly decreased to 0.
Extra
JVM 17.0.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is related to this commit in the vertx-config repo: 47fb7a669b5e68e319d94ce10b6fdea39ed8686a
After this change, vertx-config handles numeric values as BigInteger or BigDecimal. The type checking used by LocalMap, however, doesn't allow these types: Checker.java#L24
Version
4.1.6
Context
Values read from a properties file via vertx-config were being put into a LocalMap. This worked fine in 3.9.x but after the linked change to vertx-config, it throws an IllegalArgumentException.
Do you have a reproducer?
No
Steps to reproduce

Read numerical values from Vertx Config (prop file, etc)
Iterate config JSON object and put those values into a LocalMap

Extra

I noticed that there is a different implementation of checkType in the implementation of SharedData SharedDataImpl.java#L194. This version allows anything that implements Serializable, which in this case I believe would have avoided the problem since that would apply to BigInteger and BigDecimal. Is there a reason that can't be supported in all instances of SharedData's collections?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.2.1
Context
We were using (in version 3.9.9) HttpServerResponse.addCookie to set cookie irrespective of whether the cookie was already present (came from browser) and when we iterate over cookies using RoutingContext.cookieMap() we would get a single cookie with that name (i.e. cookie info was updated)
After upgrading to 4.2.1, calling RoutingContext.cookieMap() fails with this exception stack trace
This method assumes cookies are unique by name. However the implementation for addCookie() always adds a cookie to collection (this seems to be a feature request).
default Map<String, Cookie> cookieMap() {
    return cookies()
      .stream()
      .collect(Collectors.toMap(Cookie::getName, cookie -> cookie));
  }

Do you have a reproducer?
No.
Steps to reproduce
Create sample web app that renders simple form and addCookie("test", "somevalue"). On form submit, call addCookie("test", "anothervalie") to modify the cookie value without removing it first. Then invoke RoutingContext.cookieMap() to get all cookies.
Extra
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.2.1
Context
when Http1xServerRequest.reportRequestBegin() throw exception. will cause a NPE on Http1xServerRequest.handleException (line 621),
because response not initialized.
Steps to reproduce

enable vertx-micrometer-metrics .
config MicrometerOptions like: new MicrometerOptions().setRequestsTagsProvider(req -> {
List tags = new ArrayList<>();
tags.add(Tag.of("uri", req.absoluteURI()));
return tags;
})
startup http server .
curl -v 'http://host:port/path?a=fetch&content=die(@md5(HelloThinkCMF))'  (contains some illegal query-char)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Inspecting with developer tools Chrome uses http/1.1 when getting resources from my vert.x server even though https://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerOptions.html states http/2.0 should be prioritized.
I haven't been able to find any information about Chrome doing something weird and when checking other sites h2 (i.e. http/2.0) is used.
I also haven't been able to find any information in the vert.x documentation about configuring the server-side for http/2.0. Only the client-side.
Am I missing something or is it a bug?
Version
Vertx 4.2.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version: Vert.x 4.2.1
As the title, Lindex command requires only one redis key to be passed in. Why does lindex function in RedisAPI class requires two String parameters to be passed in? Is there anything MISSING in my understanding, or is there a defect in the design of the RedisAPI? I will appreciate your response, Thanks in advance!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
e.g options.toJson().getLong("reconnectInterval") returns null instead of the actual value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
4.2.1
Context
After an http2 connection is reset the WebClient that uses that connection can't recover and I see no way to fix this besides recreating the WebClient instance but that goes against the recommendation to create a single webclient instance.
Do you have a reproducer?
No.
Steps to reproduce
I'm using the native transport (I'm not sure that it matters).

Run WebClient that does periodic http2 call
Reset the http2 server
WebClient will not recover from this error

2021-12-09 08:08:06 ERROR io.vertx.core.http.impl.HttpClientRequestImpl - Stream closed before write could take place
io.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before write could take place
at io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:172) ~[]
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.cancel(DefaultHttp2RemoteFlowController.java:481) []
at io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.onStreamClosed(DefaultHttp2RemoteFlowController.java:105) []
at io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:357) []
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:1007) []
at io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.deactivate(DefaultHttp2Connection.java:963) []
at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:515) []
at io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:521) []
at io.netty.handler.codec.http2.Http2ConnectionHandler.closeStream(Http2ConnectionHandler.java:613) []
at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onRstStreamRead(DefaultHttp2ConnectionDecoder.java:444) []
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readRstStreamFrame(DefaultHttp2FrameReader.java:509) []
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:259) []
at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:159) []
at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:173) []
at io.netty.handler.codec.http2.DecoratingHttp2ConnectionDecoder.decodeFrame(DecoratingHttp2ConnectionDecoder.java:63) []
at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378) []
at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438) []
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) []
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446) []
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) []
at io.vertx.core.http.impl.VertxHttp2ConnectionHandler.channelRead(VertxHttp2ConnectionHandler.java:378) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) []
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) []
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1372) []
at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1235) []
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1284) []
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) []
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446) []
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) []
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) []
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) []
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) []
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) []
at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:795) []
at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:480) []
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378) []
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) []
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) []
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) []
at java.lang.Thread.run(Thread.java:829) [?:?]
2021-12-09 08:08:06 ERROR io.vertx.core.net.impl.ConnectionBase - writeAddress(..) failed: Connection reset by peer
2021-12-09 08:08:06 ERROR io.vertx.core.http.impl.HttpClientRequestImpl - Connection was closed
io.vertx.core.VertxException: Connection was closed

Extra
I'm using vertx in a scala app.
openjdk version "11.0.13" 2021-10-19 LTS
OpenJDK Runtime Environment 18.9 (build 11.0.13+8-LTS)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.13+8-LTS, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if we merge this we should apply best practices concerning serializable
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We already have this on master. We needs to backport to 4.0 and 3.9 still and same across remaining repos
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
Cannot find the symbol with vert.x 4.1.6
Context
Trying to upgrade the vertx homebrew formula to the latest (4.1.6 or 4.2.1), but run into some test failure for the build.
  ==> /opt/homebrew/Cellar/vert.x/4.2.1/bin/vertx run HelloWorld.java
  Picked up _JAVA_OPTIONS: -Duser.home=/Users/brew/Library/Caches/Homebrew/java_cache -Djava.io.tmpdir=/private/tmp
  OpenJDK 64-Bit Server VM warning: Option UseBiasedLocking was deprecated in version 15.0 and will likely be removed in a future release.
  OpenJDK 64-Bit Server VM warning: Option BiasedLockingStartupDelay was deprecated in version 15.0 and will likely be removed in a future release.
  /private/tmp/vert.x-test-20211209-76640-dyiq21/HelloWorld.java:1: error: cannot find symbol
  import io.vertx.core.AbstractVerticle;
                      ^
    symbol:   class AbstractVerticle
    location: package io.vertx.core 
  /private/tmp/vert.x-test-20211209-76640-dyiq21/HelloWorld.java:2: error: cannot find symbol
  public class HelloWorld extends AbstractVerticle {
                                  ^
    symbol: class AbstractVerticle 
  /private/tmp/vert.x-test-20211209-76640-dyiq21/HelloWorld.java:5: error: cannot find symbol
      vertx.close();
      ^
    symbol:   variable vertx
    location: class HelloWorld 
  Failed in deploying verticle 
  java.lang.RuntimeException: Compilation failed

relates to Homebrew/homebrew-core#90888
Do you have a reproducer?
captured in the build log in here, https://github.com/Homebrew/homebrew-core/runs/4489473453
Extra

Anything that can be relevant such as OS version, JVM version

macOS 12
openJDK 17
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The HTTP client will create a TCPMetrics and a HttpClientMetrics and only update the HttpClientMetrics, leaving an incorrect TCPMetrics.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@vietj
Hello , I'm sorry that I closed #4199 because of my mis-operation of git to rebase. Here I forked & committed  again ,
would you like to merge this to 4.2.3?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Some methods in CompositeFuture missing the wildcard type parameters, such as:
static CompositeFuture all(List<Future> futures))
static CompositeFuture any(List<Future> futures)
In java, raw use of parameterized class is not suggested, maybe those methods should append a wildcard type parameters?
(Unfortunately List<Future> could not assigned to List<Future<?>>, as the worst case we need another name for those methods or another CompositeFuture interface...)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Ah,sorry, I see there is one #4203 already, closed it. :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Description
Using the Vert.x HTTP client, when a connection takes too long and reaches its time out, we get this exception :
io.vertx.core.VertxException: Connection was closed

This does not help in understanding the connection timeout has been reached.
So I would prefer to have either :

a dedicated Exception carrying this information (so we can react accordingly)
an explicit error message to be able to investigate easily

Use cases

Easier bug investigation
Ability to react to timed out connection accordingly

Contribution
I've investigated a bit and found out the issue was at the interface of Netty and Vertx : io.vertx.core.net.impl.ConnectionBase. On Idle connection event, Vert.x simply closes the connection.
/**
 * Called by the Netty handler when the connection becomes idle. The default implementation closes the
 * connection.
 * <p/>
 * Subclasses can override it to prevent the idle event to happen (e.g when the connection is pooled) or
 * perform extra work when the idle event happens.
 */
protected void handleIdle(IdleStateEvent event) {
  chctx.close();
}
Maybe something like that would be better :
protected void handleIdle(IdleStateEvent event) {
  chctx.close(new HttpClientTimeoutException("Connection timed out"));
}
I may try to implement this solution. Let me know whether my solution sounds interesting to you or not.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
When using HazelcastClusterManager, it would thrown RejectedExecutionException sometimes after closed the vertx instance:
2021-12-21 11:05:30,529 (:) [ERROR][io.vertx.core.impl.ContextImpl] Unhandled exception
java.util.concurrent.RejectedExecutionException: Task io.vertx.core.impl.ContextImpl$$Lambda$210/0x0000000800ece910@554cbcc6 rejected from java.util.concurrent.ThreadPoolExecutor@5b8b481f[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 8]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065) ~[?:?]
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833) ~[?:?]
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365) ~[?:?]
	at io.vertx.core.impl.ContextImpl.executeBlocking(ContextImpl.java:172) ~[vertx-core-4.2.2.jar:4.2.2]
	at io.vertx.core.impl.ContextImpl.executeBlocking(ContextImpl.java:137) [vertx-core-4.2.2.jar:4.2.2]
	at io.vertx.core.impl.EventLoopContext.executeBlocking(EventLoopContext.java:22) [vertx-core-4.2.2.jar:4.2.2]
	at io.vertx.core.Vertx.executeBlocking(Vertx.java:581) ~[vertx-core-4.2.2.jar:4.2.2]
	at io.vertx.spi.cluster.hazelcast.impl.Throttling.lambda$run$5(Throttling.java:100) ~[vertx-hazelcast-4.2.2.jar:4.2.2]

The executeBlocking method throw the exception at ContextImpl#L179 when failed to execute the command (because the workerPool closed earlier then the netty event loop, the timer on netty eventloop still works and called executeBlocking after workerPool closed, according  VertxImpl.java#L809-L813), is it works as intended? Maybe we should wrapped the exception with a failed future instead, thus the caller could handle the exception or just ignore it.
Version
4.2.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As the title, I am using caffeine with Vert.x 4.x, I want to load the value from redis and then put it into caffeine cache after the cache vale was out of time. But All provided API in the Redis Client are asynchronous, however the load function in LoadingCache return the value of Generic V, it was synchronization operation, how can I to do that I can load the redis value using the Vert.x Redis Client API? Anyone's response will be greatly appreciated.
Here is my code as blow:
public static <K, V> LoadingCache<K, V> createLoadingCache(String cacheName, Long timeToLiveSeconds, Long timeToIdleSeconds, Integer initialCapacity,
                                                               Integer maximumSize, boolean recordStats) {
        Caffeine<K, V> cacheBuilder = (Caffeine<K, V>) Caffeine.newBuilder();
        if (timeToLiveSeconds != null && timeToLiveSeconds > 0) {
            cacheBuilder.expireAfterWrite(timeToLiveSeconds, TimeUnit.SECONDS);
        }
        if (timeToIdleSeconds != null && timeToIdleSeconds > 0) {
            cacheBuilder.expireAfterAccess(timeToIdleSeconds, TimeUnit.SECONDS);
        }
        
        cacheBuilder.initialCapacity(initialCapacity);
        cacheBuilder.maximumSize(maximumSize);

        if (recordStats) {
            cacheBuilder.recordStats();
        }
        LoadingCache<K, V> loadingCache = cacheBuilder.build(new CacheLoader<K, V>() {
            @Override
            public V load(K key) throws Exception {
                //at here, I want to get a value from redis by synchronization way, how can I to do that?
                return null;
            }
        });
        return loadingCache;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Http2Settings max header list size setting is ignored by the conversion to the actual Netty settings.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 4.2.1
JDK 1.8.0_241
I create a AutoDeployCustomVerticle to depoly other verticle with customized @verticle annotation, but after depoly the other verticles, the asyncResult.succeeded() returned by callback function handler was always false, I am wonder how it happends.
Here's my code to reproduce the problem
public class AutoDeployCustomVerticle extends AbstractVerticle {
    private static Logger log = LoggerFactory.getLogger(AutoDeployCustomVerticle.class);

    private String[] verticleScanPackages;

    private String[] excludedVerticleClasses;

    public AutoDeployCustomVerticle(String[] verticleScanPackages) {
        this(verticleScanPackages, null);
    }

    public AutoDeployCustomVerticle(String[] verticleScanPackages, String[] excludedVerticleClasses) {
        this.verticleScanPackages = verticleScanPackages;
        this.excludedVerticleClasses = excludedVerticleClasses;
    }

    @Override
    public void start(Promise<Void> startPromise) throws Exception {
        VerticleLauncher.setVertxWithDeploy(vertx, verticleScanPackages, excludedVerticleClasses, (asyncResult) -> {
            if (asyncResult.succeeded()) {
                startPromise.complete();
                log.info("Vert.x had already deployed the verticle instances with @Verticle annotation successfully, verticleScanPackages:{}",
                        String.join(",", verticleScanPackages));
            } else {
               //It always goes to this else case.
                startPromise.fail(asyncResult.cause());
                log.error("Vert.x had already deployed the verticle instances with @Verticle annotation failed, verticleScanPackages:{}",
                        String.join(",", verticleScanPackages));
            }
        });
    }

    public void setVerticleScanPackages(String[] verticleScanPackages) {
        this.verticleScanPackages = verticleScanPackages;
    }
}
//setVertxWithDeploy function uses to deploy the other verticle with @verticle annotation
public static void setVertxWithDeploy(Vertx vertx, String[] verticleScanPackages, String[] excludedVerticleClasses, Handler<AsyncResult<String>> completionHandler) {
        if(null == verticleScanPackages || verticleScanPackages.length <= 0) {
            log.info("verticleScanPackages was empty, so Verticle instance deployed had been skipped.");
            return;
        }
        Reflections reflections = new Reflections(verticleScanPackages);
        ReflectUtils.setGlobalReflections(reflections);
        Set<Class<?>> verticleClasses = reflections.getTypesAnnotatedWith(Verticle.class);
        if(null == verticleClasses || verticleClasses.size() <= 0) {
            log.info("There are no verticles with @Verticle annotation in packages:[{}].", String.join(",", verticleScanPackages));
            return;
        }
        Set<String> verticleClassNames = verticleClasses.stream().map(clazz -> clazz.getName()).collect(Collectors.toSet());
        Set<String> finalVerticleClassNames = verticleClassNames;
        if(null != excludedVerticleClasses && excludedVerticleClasses.length > 0) {
            Arrays.stream(excludedVerticleClasses).forEach(excludedVerticleClass -> {
                if(finalVerticleClassNames.contains(excludedVerticleClass)) {
                    finalVerticleClassNames.remove(excludedVerticleClass);
                }
            });
        }
        verticleClasses.stream().forEach(clazz -> {
            boolean isThisVerticleExcluded = false;
            Class<io.vertx.core.Verticle> verticleClass = (Class<io.vertx.core.Verticle>)clazz;
            if(null != finalVerticleClassNames && finalVerticleClassNames.size() > 0) {
                String verticleClassName = verticleClass.getName();
                if(!finalVerticleClassNames.contains(verticleClassName)) {
                    isThisVerticleExcluded = true;
                }
            } else {
                isThisVerticleExcluded = true;
            }
            boolean isVerticleSubClass = ReflectUtils.isImplementSpecifiedInterface(verticleClass, io.vertx.core.Verticle.class);
            if(isVerticleSubClass && !isThisVerticleExcluded) {
                DeploymentOptions deploymentOptions = new DeploymentOptions();
                Verticle verticleAnnotation = verticleClass.getAnnotation(Verticle.class);
                if(null != verticleAnnotation) {
                    boolean workerVerticle = verticleAnnotation.worker();
                    int verticleInstances = verticleAnnotation.instances();
                    boolean autoDeploy = verticleAnnotation.autoDeploy();
                    if(autoDeploy) {
                        deploymentOptions.setInstances(verticleInstances);
                        deploymentOptions.setWorker(workerVerticle);
                        io.vertx.core.Verticle deployingVerticle = SpringUtils.getBean(verticleClass);
                        if(null == deployingVerticle) {
                            //This is the point.
                            vertx.deployVerticle(verticleClass, deploymentOptions, completionHandler);
                        } else {
                            vertx.deployVerticle(deployingVerticle, deploymentOptions, completionHandler);
                        }
                    }
                }
            }
        });
    }
This is the code of @verticle annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Verticle {
   //to identify whether it is a worker verticle
    boolean worker() default false;
    
    //to identify how many instances to be auto deployed
    int instances();

    /**to identify whether it needs to be auto deployed*/
    boolean autoDeploy() default true;
}
When System starts up, it will initinalize the Vertx instance, meanwhile, deploy the AutoDeployCustomVerticle Verticle.
public static void initVertx(final Vertx vertx) {
        AutoDeployCustomVerticle autoDeployCustomVerticle = SpringUtils.getBean(AutoDeployCustomVerticle.class);
        //handler.succeeded() also always return false, why? 
        vertx.deployVerticle(autoDeployCustomVerticle, handler -> {
            log.info("vertx deploy [AutoDeployCustomVerticle] state: " + handler.succeeded());
        });
    }
I will appreciate your response, thanks in advance!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Vert.x 4.2.1
JDK 1.8.0_241
@Bean("webClientOptions")
    public WebClientOptions webClientOptions() {
        WebClientOptions webClientOptions = new WebClientOptions();
        webClientOptions.setUserAgentEnabled(true);
        webClientOptions.setUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36");
        webClientOptions.setConnectTimeout(connectionTimeout);
        webClientOptions.setDefaultPort(80);
        webClientOptions.setIdleTimeout(idleTimeout);
        webClientOptions.setIdleTimeoutUnit(TimeUnit.SECONDS);
        webClientOptions.setKeepAliveTimeout(keepAliveTimeout);
        webClientOptions.setMaxPoolSize(maxPoolSize);
        webClientOptions.setMaxWaitQueueSize(maxWaitQueueSize);
        webClientOptions.setSendBufferSize(sendBufferSize);
        webClientOptions.setReceiveBufferSize(receiveBufferSize);
        webClientOptions.setKeepAlive(keepAliveEnable);
        webClientOptions.setFollowRedirects(followRedirects);
        webClientOptions.setMaxRedirects(maxRedirects);
        webClientOptions.setMaxHeaderSize(maxHeaderSize);
        webClientOptions.setMaxWebSockets(maxWebSockets);
        webClientOptions.setMaxWebSocketFrameSize(maxWebSocketFrameSize);
        webClientOptions.setMaxWebSocketMessageSize(maxWebSocketMessageSize);
        webClientOptions.setWebSocketClosingTimeout(webSocketClosingTimeout);
        webClientOptions.setSsl(httpSSLEnable);
        webClientOptions.setTrustAll(httpSSLTrustAll);
        webClientOptions.setVerifyHost(httpSSLVerifyHost);
        webClientOptions.setReadIdleTimeout(readIdleTimeout);
        webClientOptions.setWriteIdleTimeout(writeIdleTimeout);
        return webClientOptions;
    }
webclient:
    connection-timeout: 5000
    idle-timeout: 60
    keepalive-enable: true
    keepalive-timeout: 60
    max-poolsize: 128
    max-wait-queuesize: 1024
    send-buffersize: 2097152
    receive-buffersize: 2097152
    follow-redirect-enable: true
    max-redirects: 3
    max-headersize: 8192
    max-websockets: 2048
    max-websocket-framesize: 65536
    max-websocket-messagesize: 262144
    websocket-closing-timeout: 10
    http-ssl-enable: true
    http-ssl-verify-host: false
    http-ssl-trust-all: true
    read-idle-timeout: 120
    write-idle-timeout: 120
public static <T>void getAbs(WebClient webClient, String requestUrl, long requestTimeout, ResponseBodyType responseBodyType, Class<T> targetClass, Map<String, String> headerMap,
                           Handler<T> successHandler, Handler<Throwable> failureHandler) {

        HttpRequest<T> getRequest = (HttpRequest<T>)webClient.getAbs(requestUrl);
        getRequest = handleResponseBodyType(responseBodyType, targetClass, getRequest);
        if(null != headerMap && headerMap.size() > 0) {
            for(Map.Entry<String, String> entry : headerMap.entrySet()) {
                getRequest.putHeader(entry.getKey(), entry.getValue());
            }
        }
        requestTimeout = reviseTimeoutValue(requestTimeout);
        getRequest.timeout(requestTimeout).send()
                .onSuccess(response -> {
                    if(null != successHandler) {
                        successHandler.handle(response.body());
                    }
                })
                .onFailure(ex -> {
                    if(null != failureHandler) {
                        failureHandler.handle(ex);
                    }
                });
    }
Here is a screenshot of the stacktrace information as blow:

It always thrown the exception: failed to create ssl connection, after I request the url: https://api.coinbase.com/v2/exchange-rates?currency=USD
I have set ssl to true, trustAll to true and verifyHost to false for WebClientOptions, why it still thrown the same exception, Can anyone tell me why this happended, and how to figure out this problems? It may also be something I have misunderstood, please feel free to enlighten me. Thanks in advance!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
The OAuth2WebClient will always do a refresh if the current user is expired. But that is not correct in case of OAuth2FlowType.CLIENT.
See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.3. So that is no refresh token in this case.
I will like to see that when there is no refresh token or  type OAuth2FlowType.CLIENT that it will just authenticate itself again to get the new token.
The code that needs to be changed is al in OAuth2AwareInterceptor class.
Version
Vert.X  4.2.1 (quarkus 2.6.1)
Context
I encountered an exception which looks suspicious while ...
Do you have a reproducer?
Not needed

Link to github project/gist

Steps to reproduce
Not needed
Extra

Java 11
Quarkus 2.6.1
Windows
Maven 3.8.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
when WebSockets handshake failed, the client send another request from the pooled TCP connection, the server can not be notified.
Version
4.2.2
Context
if a WebSockets handshake failed, the TCP connection becomes unreadable.
Do you have a reproducer?
Main.java
  import io.netty.handler.codec.http.HttpResponseStatus;
  import io.vertx.core.Promise;
  import io.vertx.core.Vertx;
  import io.vertx.core.http.HttpServer;
  import io.vertx.core.http.impl.ServerWebSocketImpl;
  
  
  public class Main {
    public static void main(String[] args) {
      // crete a http server
      HttpServer server = Vertx.vertx().createHttpServer();
      // and set ws handler, that always handshake failed.
      server.webSocketHandler(
          ctx -> {
            Promise<Integer> promise = Promise.promise();
            ServerWebSocketImpl webSocket = (ServerWebSocketImpl) ctx;
            webSocket.setHandshake(promise.future());
            Vertx.vertx()
                .setTimer(
                    1000,
                    id -> {
                      promise.complete(HttpResponseStatus.UNAUTHORIZED.code());
                    });
          });
      server.listen(8080);
    }
  }

WSTest.java
  import java.util.concurrent.TimeUnit;
  import okhttp3.OkHttpClient;
  import okhttp3.Request;
  import okhttp3.Response;
  import okhttp3.WebSocket;
  import okhttp3.WebSocketListener;
  
  public class WSTest {
    public static void main(String[] args) {
      // create a ws client and try to connect server.
      OkHttpClient client = new OkHttpClient.Builder().readTimeout(10, TimeUnit.SECONDS).build();
      Request request = new Request.Builder().url("ws://localhost:8080/").build();
      test(client, request);
    }
  
    public static void test(OkHttpClient client, Request request) {
      client.newWebSocket(
          request,
          new WebSocketListener() {
  
            @Override
            public void onFailure(WebSocket webSocket, Throwable t, Response response) {
              t.printStackTrace();
              try {
                Thread.sleep(1000);
              } catch (InterruptedException e) {
                e.printStackTrace();
              }
              test(client, request);
            }
          });
    }
  }

pom.xml
<properties>
  <maven.compiler.source>8</maven.compiler.source>
  <maven.compiler.target>8</maven.compiler.target>
</properties>

<dependencies>
  <dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-web</artifactId>
    <version>4.2.2</version>
  </dependency>
  <dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>3.12.1</version>
  </dependency>
</dependencies>

Steps to reproduce

run Main.main()
run wsTest.main()
you got 401
wait 10 seconds, you got read timeout

Extra
My service is used behind an Nginx server, they use TCP connection pool connects to me, it has the same issue .

Anything that can be relevant such as OS version, JVM version
mac os 12.1 and Linux
OpenJDK version "1.8.0_312"
OpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07)
OpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
In the io.vertx.core.datagram.impl.DatagramSocketImpl the following code is used:
if (options.getLogActivity()) {
channel.pipeline().addLast("logging", new LoggingHandler());
}
This means the netty request payload is always using the  ByteBufFormat.HEX_DUMP.
Would be very nice if we could set this ByteBufFormat to SIMPLE as well.
Use cases
We don;t want the request payload to include a hex dump
Contribution
I could.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
We get rare NPE's on high load in Http1xClientConnection
Vert.x: 4.2.3
Stacktrace:
java.lang.NullPointerException: null
	at io.vertx.core.http.impl.HttpClientImpl.lambda$doRequest$8(HttpClientImpl.java:631)
	at io.vertx.core.net.impl.pool.Endpoint.lambda$getConnection$0(Endpoint.java:52)
	at io.vertx.core.http.impl.ClientHttpEndpointBase.lambda$requestConnection$0(ClientHttpEndpointBase.java:46)
	at io.vertx.core.http.impl.SharedClientHttpStreamEndpoint$Request.handle(SharedClientHttpStreamEndpoint.java:162)
	at io.vertx.core.http.impl.SharedClientHttpStreamEndpoint$Request.handle(SharedClientHttpStreamEndpoint.java:123)
	at io.vertx.core.impl.EventLoopContext.emit(EventLoopContext.java:50)
	at io.vertx.core.impl.EventLoopContext.lambda$emit$1(EventLoopContext.java:57)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
A race can happen in the pool when it delivers a lease. Leases are created as pool post actions and sometimes can read a connection from a slot that became null in the meantime the post action is executed.
This leads in an NPE in the HttpClient that instead should not get non null closed connection, instead of a null connection. (reported here #4220 (comment))
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The pool implementation checks incorrectly whether the waiter is enqueued in the list leading to an incorrect waiter list size.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
After upgrading from netty 3.9.8 to 3.9.12, an error accured to load netty_tcnative .
2021-12-23T08:45:35.3662076Z 2021-12-23 08:45:35,231 [ERROR] [vert.x-eventloop-thread-3] -  (ClientVerticle.java:38)
2021-12-23T08:45:35.3663026Z io.vertx.core.VertxException: OpenSSL is not available
2021-12-23T08:45:35.3664335Z 	at io.vertx.core.net.impl.SSLHelper.resolveEngineOptions(SSLHelper.java:76)
2021-12-23T08:45:35.3665692Z 	at io.vertx.core.net.impl.SSLHelper.<init>(SSLHelper.java:174)
2021-12-23T08:45:35.3666811Z 	at io.vertx.core.net.impl.NetClientImpl.<init>(NetClientImpl.java:73)
2021-12-23T08:45:35.3668012Z 	at io.vertx.core.net.impl.NetClientImpl.<init>(NetClientImpl.java:67)
2021-12-23T08:45:35.3669303Z 	at io.vertx.core.impl.VertxImpl.createNetClient(VertxImpl.java:302)
2021-12-23T08:45:35.3671334Z 	at org.apache.servicecomb.foundation.vertx.client.tcp.NetClientWrapper.<init>(NetClientWrapper.java:39)
2021-12-23T08:45:35.3675175Z 	at org.apache.servicecomb.foundation.vertx.client.tcp.AbstractTcpClientPoolFactory.createClientPool(AbstractTcpClientPoolFactory.java:38)
2021-12-23T08:45:35.3679333Z 	at org.apache.servicecomb.foundation.vertx.client.ClientPoolManager.createClientPool(ClientPoolManager.java:60)
2021-12-23T08:45:35.3682320Z 	at org.apache.servicecomb.foundation.vertx.client.ClientVerticle.start(ClientVerticle.java:35)
2021-12-23T08:45:35.3684185Z 	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:108)
2021-12-23T08:45:35.3685214Z 	at io.vertx.core.Verticle.start(Verticle.java:66)
2021-12-23T08:45:35.3686397Z 	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$9(DeploymentManager.java:552)
2021-12-23T08:45:35.3687843Z 	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
2021-12-23T08:45:35.3689282Z 	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
2021-12-23T08:45:35.3691179Z 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
2021-12-23T08:45:35.3693680Z 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
2021-12-23T08:45:35.3695526Z 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:503)
2021-12-23T08:45:35.3697121Z 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
2021-12-23T08:45:35.3698836Z 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
2021-12-23T08:45:35.3700534Z 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
2021-12-23T08:45:35.3701847Z 	at java.lang.Thread.run(Thread.java:748)
2021-12-23T08:45:35.3703028Z Caused by: java.lang.IllegalArgumentException: Failed to load any of the given libraries: [netty_tcnative_linux_x86_64, netty_tcnative_linux_x86_64_fedora, netty_tcnative_x86_64, netty_tcnative]
2021-12-23T08:45:35.3705067Z 	at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:107)
2021-12-23T08:45:35.3706844Z 	at io.netty.handler.ssl.OpenSsl.loadTcNative(OpenSsl.java:705)
2021-12-23T08:45:35.3707896Z 	at io.netty.handler.ssl.OpenSsl.<clinit>(OpenSsl.java:146)
2021-12-23T08:45:35.3709238Z 	at io.vertx.core.net.impl.SSLHelper.resolveEngineOptions(SSLHelper.java:75)
2021-12-23T08:45:35.3710612Z 	at io.vertx.core.net.impl.SSLHelper.<init>(SSLHelper.java:134)
2021-12-23T08:45:35.3711760Z 	at io.vertx.core.http.impl.HttpClientImpl.<init>(HttpClientImpl.java:132)
2021-12-23T08:45:35.3713126Z 	at io.vertx.core.impl.VertxImpl.createHttpClient(VertxImpl.java:338)
2021-12-23T08:45:35.3715919Z 	at org.apache.servicecomb.foundation.vertx.client.http.HttpClientPoolFactory.createClientPool(HttpClientPoolFactory.java:40)
2021-12-23T08:45:35.3720067Z 	at org.apache.servicecomb.foundation.vertx.client.http.HttpClientPoolFactory.createClientPool(HttpClientPoolFactory.java:29)
2021-12-23T08:45:35.3722456Z 	... 14 common frames omitted
2021-12-23T08:45:35.3726072Z 	Suppressed: java.lang.IllegalStateException: Multiple resources found for 'META-INF/native/libnetty_tcnative_linux_x86_64.so': [jar:file:////home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so, jar:file:/home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so]
2021-12-23T08:45:35.3729843Z 		at io.netty.util.internal.NativeLibraryLoader.getResource(NativeLibraryLoader.java:253)
2021-12-23T08:45:35.3731760Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:151)
2021-12-23T08:45:35.3733770Z 		at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:98)
2021-12-23T08:45:35.3735156Z 		... 22 common frames omitted
2021-12-23T08:45:35.3736102Z 	Suppressed: java.lang.UnsatisfiedLinkError: could not load a native library: netty_tcnative_linux_x86_64_fedora
2021-12-23T08:45:35.3737549Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:217)
2021-12-23T08:45:35.3739931Z 		at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:98)
2021-12-23T08:45:35.3741319Z 		... 22 common frames omitted
2021-12-23T08:45:35.3742375Z 	Caused by: java.io.FileNotFoundException: META-INF/native/libnetty_tcnative_linux_x86_64_fedora.so
2021-12-23T08:45:35.3743809Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:164)
2021-12-23T08:45:35.3744864Z 		... 23 common frames omitted
2021-12-23T08:45:35.3745720Z 		Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative_linux_x86_64_fedora in java.library.path
2021-12-23T08:45:35.3746884Z 			at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3747882Z 			at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3748749Z 			at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3750077Z 			at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3751996Z 			at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:319)
2021-12-23T08:45:35.3753840Z 			at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:139)
2021-12-23T08:45:35.3754888Z 			... 23 common frames omitted
2021-12-23T08:45:35.3755738Z 			Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative_linux_x86_64_fedora in java.library.path
2021-12-23T08:45:35.3756888Z 				at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3757866Z 				at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3758718Z 				at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3760034Z 				at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3761656Z 				at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2021-12-23T08:45:35.3763179Z 				at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2021-12-23T08:45:35.3765044Z 				at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2021-12-23T08:45:35.3766488Z 				at java.lang.reflect.Method.invoke(Method.java:498)
2021-12-23T08:45:35.3767694Z 				at io.netty.util.internal.NativeLibraryLoader$1.run(NativeLibraryLoader.java:353)
2021-12-23T08:45:35.3775692Z 				at java.security.AccessController.doPrivileged(Native Method)
2021-12-23T08:45:35.3777555Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibraryByHelper(NativeLibraryLoader.java:345)
2021-12-23T08:45:35.3779758Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:311)
2021-12-23T08:45:35.3780984Z 				... 24 common frames omitted
2021-12-23T08:45:35.3781785Z 	Suppressed: java.lang.UnsatisfiedLinkError: could not load a native library: netty_tcnative_x86_64
2021-12-23T08:45:35.3783366Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:217)
2021-12-23T08:45:35.3785374Z 		at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:98)
2021-12-23T08:45:35.3786760Z 		... 22 common frames omitted
2021-12-23T08:45:35.3787863Z 	Caused by: java.io.FileNotFoundException: META-INF/native/libnetty_tcnative_x86_64.so
2021-12-23T08:45:35.3789243Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:164)
2021-12-23T08:45:35.3790308Z 		... 23 common frames omitted
2021-12-23T08:45:35.3791112Z 		Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative_x86_64 in java.library.path
2021-12-23T08:45:35.3792232Z 			at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3793202Z 			at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3794049Z 			at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3795388Z 			at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3797389Z 			at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:319)
2021-12-23T08:45:35.3799235Z 			at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:139)
2021-12-23T08:45:35.3800309Z 			... 23 common frames omitted
2021-12-23T08:45:35.3801112Z 			Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative_x86_64 in java.library.path
2021-12-23T08:45:35.3802232Z 				at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3803188Z 				at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3804055Z 				at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3805383Z 				at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3806969Z 				at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2021-12-23T08:45:35.3808551Z 				at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2021-12-23T08:45:35.3810401Z 				at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2021-12-23T08:45:35.3811952Z 				at java.lang.reflect.Method.invoke(Method.java:498)
2021-12-23T08:45:35.3813185Z 				at io.netty.util.internal.NativeLibraryLoader$1.run(NativeLibraryLoader.java:353)
2021-12-23T08:45:35.3814590Z 				at java.security.AccessController.doPrivileged(Native Method)
2021-12-23T08:45:35.3816452Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibraryByHelper(NativeLibraryLoader.java:345)
2021-12-23T08:45:35.3818662Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:311)
2021-12-23T08:45:35.3819854Z 				... 24 common frames omitted
2021-12-23T08:45:35.3820654Z 	Suppressed: java.lang.UnsatisfiedLinkError: could not load a native library: netty_tcnative
2021-12-23T08:45:35.3822052Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:217)
2021-12-23T08:45:35.3824069Z 		at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:98)
2021-12-23T08:45:35.3825452Z 		... 22 common frames omitted
2021-12-23T08:45:35.3826409Z 	Caused by: java.io.FileNotFoundException: META-INF/native/libnetty_tcnative.so
2021-12-23T08:45:35.3827808Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:164)
2021-12-23T08:45:35.3828852Z 		... 23 common frames omitted
2021-12-23T08:45:35.3829660Z 		Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative in java.library.path
2021-12-23T08:45:35.3830778Z 			at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3831735Z 			at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3832589Z 			at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3833905Z 			at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3835935Z 			at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:319)
2021-12-23T08:45:35.3837786Z 			at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:139)
2021-12-23T08:45:35.3838833Z 			... 23 common frames omitted
2021-12-23T08:45:35.3839639Z 			Suppressed: java.lang.UnsatisfiedLinkError: no netty_tcnative in java.library.path
2021-12-23T08:45:35.3840731Z 				at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1875)
2021-12-23T08:45:35.3841706Z 				at java.lang.Runtime.loadLibrary0(Runtime.java:872)
2021-12-23T08:45:35.3842554Z 				at java.lang.System.loadLibrary(System.java:1124)
2021-12-23T08:45:35.3843892Z 				at io.netty.util.internal.NativeLibraryUtil.loadLibrary(NativeLibraryUtil.java:38)
2021-12-23T08:45:35.3845498Z 				at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2021-12-23T08:45:35.3847024Z 				at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2021-12-23T08:45:35.3848890Z 				at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2021-12-23T08:45:35.3850422Z 				at java.lang.reflect.Method.invoke(Method.java:498)
2021-12-23T08:45:35.3851705Z 				at io.netty.util.internal.NativeLibraryLoader$1.run(NativeLibraryLoader.java:353)
2021-12-23T08:45:35.3853125Z 				at java.security.AccessController.doPrivileged(Native Method)
2021-12-23T08:45:35.3854969Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibraryByHelper(NativeLibraryLoader.java:345)
2021-12-23T08:45:35.3857179Z 				at io.netty.util.internal.NativeLibraryLoader.loadLibrary(NativeLibraryLoader.java:311)
2021-12-23T08:45:35.3858397Z 				... 24 common frames omitted

From the stack trace, seems the error casused by
2021-12-23T08:45:35.3726072Z 	Suppressed: java.lang.IllegalStateException: Multiple resources found for 'META-INF/native/libnetty_tcnative_linux_x86_64.so': [jar:file:////home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so, jar:file:/home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so]
2021-12-23T08:45:35.3729843Z 		at io.netty.util.internal.NativeLibraryLoader.getResource(NativeLibraryLoader.java:253)
2021-12-23T08:45:35.3731760Z 		at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:151)
2021-12-23T08:45:35.3733770Z 		at io.netty.util.internal.NativeLibraryLoader.loadFirstAvailable(NativeLibraryLoader.java:98)

The class loader got two resources
jar:file:////home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so, 
jar:file:/home/runner/.m2/repository/io/netty/netty-tcnative-boringssl-static/2.0.46.Final/netty-tcnative-boringssl-static-2.0.46.Final.jar!/META-INF/native/libnetty_tcnative_linux_x86_64.so

Version
3.9.12 + netty 4.1.72
Context
when openssl enabled and running in linux(Ubuntu)
Do you have a reproducer?
This error failed when running test cases in servicecomb
Steps to reproduce
Extra

I am not sure if this error caused by netty or vert.x. From the stack trace, problem may related to vert.x ContextClassLoader or netty implementation.
I run other branch test cases using vert.x 4.1.7 + netty 4.1.72, do not have this problem. (In same machine and test case)
I run other branch test cases using vert.x 3.9.8 + netty 4.1.67, do not have this problem. (In same machine and test case)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vertx Core 4.2.5
Context
I encountered an exception when using JsonObject class from vertx and Kotlin. Specifically, when initializing a JsonObject() with an immutable Map.
Do you have a reproducer?
JsonObject(mapOf("foo" to "bar")).put("this", "that")
throws the following exception stacktrace:
java.lang.UnsupportedOperationException
	at java.base/java.util.AbstractMap.put(AbstractMap.java:209)
	at io.vertx.core.json.JsonObject.put(JsonObject.java:642)
	at io.vertx.ext.mongo.impl.codec.json.JsonObjectCodec.generateIdIfAbsentFromDocument(JsonObjectCodec.java:52)
	at io.vertx.ext.mongo.impl.codec.json.JsonObjectCodec.generateIdIfAbsentFromDocument(JsonObjectCodec.java:26)

Extra

Kotlin JVM 1.6.10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
The log disk is full.Thread of eventloop disappears
Version
version is 3.9.8
Context
I encountered an exception which looks suspicious while ...
Do you have a reproducer?
A reproducer is a simple project hosted on GitHub (or another forge supporting git clone operation) that has a build file that can be executed to reproduce the issue.
Reproducers are very helpful for contributors and will likely help them fixing your bug faster.

Link to github project/gist

Steps to reproduce

...
...
...
...

Extra

Anything that can be relevant such as OS version, JVM version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Describe the feature
Allows HttpClient send a request on a specified HttpConnection.
Use cases

for reversed proxy we could bound the client connection to upstream connection (load balance or keeping the authentication context).

Contribution
may be something like:
new io.vertx.core.http.RequestOptions()
         .setConnection(HttpConnection or HttpClientConnection) // currently HttpClientConnection is defined at io.vertx.core.http.impl
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vertx 4.1.7
Context
I encountered some issues when using RecordParser with concatMapCompletable and observeOn like the following code to process records one by one on worker thread:
RecordParser.newDelimited(delimiter, asyncFile)
  .toFlowable()
  .concatMapCompletable(data -> Completable.complete()
    .observeOn(blockingScheduler(executor))
    .andThen(process(data))
  )
The issues including:

Sometime the RecordParser will suddenly stop emitting record, there's no error and not reached end of file and it is not disposed... it just stuck there.
Sometime a MissingBackpressureException is thrown

After investigated and tried create a unit test for this issue, it looks like a race condition on RecordParserImpl:
Usually the record is emitted from RecordParserImpl on event loop thread. (RecordParserImpl.handle)
However, when backpressure exists (concatMapCompletable here), it can be the thread running on downstream to request item from upstream. (RecordParserImpl.fetch)
In my case, the inner stream of concatMapCompletable is switched to a worker thread using observeOn, so it will be the worker thread requesting item from RecordParserImpl during backpressure.
When the RecordParserImpl.handle running on event loop thread and the RecordParserImpl.fetch running on worker thread are called at same time, race condition happens because RecordParserImpl is not written in thread-safe way.
The race condition includes but not limited to:

In RecordParserImpl.handleParsing(), both thread may passed the parsing check and do the parsing concurrently
demand could be modified concurrently and result in unexpected value
When RecordParserImpl.handle has filled all demand and paused upstream, but before parsing is set to false, the RecordParserImpl.fetch could add demand and exit quickly due to parsing is true, and then it will stuck - upstream is paused so RecordParserImpl.handle will not be called again, downstream has requested item and is waiting for next item.

Steps to reproduce
Here's a unit test that could reproduce the issue:
  @Test
  public void testBackpressure4() throws Throwable {
    Logger LOG = LogManager.getLogger();
    String fileName = "/tmp/testBackpressure";
    FileWriter writer = new FileWriter(fileName);
    for (int i = 0; i < 300; i++) {
      writer.write(String.format("%1000d\n", i));
    }
    writer.close();

    int count = 100;
    for (int i = 0; i < count; i++) {
      LOG.info("{}: Start", i);
      Vertx vertx = Vertx.vertx();
      WorkerExecutor executor = vertx.createSharedWorkerExecutor("shared-worker", 1);
      Throwable err = Single.just(i)
          .flatMapCompletable(n -> vertx.fileSystem()
              .rxOpen(fileName, new OpenOptions().setWrite(false).setRead(true))
              .flatMapCompletable(f -> RecordParser.newDelimited("\n", f).toFlowable()
                  .map(data -> {
                    final String dataString = data.toString().trim();
                    LOG.info("{}: Read record {}", n, dataString);
                    return dataString;
                  })
                  .concatMapCompletable(data -> Completable.complete()
                    .observeOn(blockingScheduler(executor))
                    .doOnComplete(() -> LOG.info("{}: processed record {}", n, data))
                  )
                  .onErrorResumeNext(e -> f.rxClose().andThen(Completable.error(e)))
                  .andThen(Completable.defer(f::rxClose))
              )
          )
          .timeout(5, TimeUnit.SECONDS)
          .blockingGet();

      vertx.close();

      if (err == null) {
        LOG.info("{}: Success", i);
      } else {
        LOG.error("{}: failure", i, err);
        if (!(err instanceof TimeoutException)) { // it will fail the case when issue 2 happens, remove the "!" to fail the case when issue 1 happens
          throw err;
        }
      }
    }
  }
In the printed log, we can see the xx: Read record yy log can sometime be printed on event loop thread (RecordParserImpl.handle) and sometime be printed on shared worker thread (due to backpressure, RecordParserImpl.fetch)
The backtrace for issue 1 looks like:
The source did not signal an event for 5 seconds and has been terminated.java.util.concurrent.TimeoutException: The source did not signal an event for 5 seconds and has been terminated.
	at io.reactivex.internal.operators.completable.CompletableTimeout$DisposeTask.run(CompletableTimeout.java:109)
	at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)
	at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

The backtrace for issue 2 looks like:
io.reactivex.exceptions.MissingBackpressureException: Queue full?!
	at io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable$ConcatMapCompletableObserver.onNext(FlowableConcatMapCompletable.java:121)
	at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:68)
	at io.vertx.reactivex.impl.FlowableReadStream.lambda$subscribeActual$2(FlowableReadStream.java:86)
	at io.vertx.core.parsetools.impl.RecordParserImpl.handleParsing(RecordParserImpl.java:214)
	at io.vertx.core.parsetools.impl.RecordParserImpl.handle(RecordParserImpl.java:285)
	at io.vertx.core.parsetools.impl.RecordParserImpl.handle(RecordParserImpl.java:27)
	at io.vertx.core.file.impl.AsyncFileImpl.handleBuffer(AsyncFileImpl.java:425)
	at io.vertx.core.file.impl.AsyncFileImpl.lambda$new$0(AsyncFileImpl.java:110)
	at io.vertx.core.streams.impl.InboundBuffer.handleEvent(InboundBuffer.java:240)
	at io.vertx.core.streams.impl.InboundBuffer.write(InboundBuffer.java:130)
	at io.vertx.core.file.impl.AsyncFileImpl.lambda$doRead$5(AsyncFileImpl.java:407)
	at io.vertx.core.impl.future.FutureImpl$3.onSuccess(FutureImpl.java:141)
	at io.vertx.core.impl.future.FutureBase.lambda$emitSuccess$0(FutureBase.java:54)
	at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
	at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
	at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base@11.0.7/java.lang.Thread.run(Thread.java:834)

Not sure if it is a problem in RecordParser or concatMapCompletable (is it expected for upstream to be requested on worker thread in this case?) or maybe it is not a desired to use them in this way?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi i am using vertx mutual authentication mechanism.
Client and server , both of them requires SSL cert to access server.
But i want to log "ip" address of SSLHandshakeException.
also i want to log "ip" address of http socket connections.
I can handle cert requirement with , SSLHandshakeException , i catch
    httpServer.exceptionHandler(new Handler<Throwable>() {
        @Override
        public void handle(Throwable throwable) {
            if(throwable instanceof SSLHandshakeException) {
                logger.info("Connection failure due invalid certificate");
            }
        }
    });

But i want to catch the ip address of the user like.
    httpServer.exceptionHandler(new Handler<Throwable>() {
        @Override
        public void handle(Throwable throwable, String ipAddress) {
            if(throwable instanceof SSLHandshakeException) {
                logger.info("Connection failure due invalid certificate {}" , ipAddress );
            }
        }
    });

It would be good feature
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
Vertx core 3.6.3 AND 3.7.0
NGINX 1.19.9
Context
Vertx 3.6.3
We use NGINX 1.19.9 to proxy requests to our services in Kubernetes. One such service is a client manager that creates web sockets. For paths where the user in unauthorized, we call client.reject(403).
Let's say client 1 connects to the service using wss://myuri.com/api and gets a valid 403. Great.
Now when client 2 connects to the service, the request handler appears to be re-using the request headers from client 1. The same is true for client 3, 4, 5, etc. Now all of our clients are in a bad state.
We've determined that it seems to be an interplay between nginx and vertx/netty. When we change upstream-keepalive-timeout to 0, the issue goes away. Only client 1 gets the 403. When we get rid of nginx entirely, the issue is also gone.
https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-timeout
Do you have a reproducer?
Vertx 3.7.0
Reproducer code: https://github.com/NguyenVoDev/pure-vertx-js/blob/main/src/main/java/org/example/Server.java
Note this won't work if you try and repro locally, only if using nginx with keepalive set to > 0 (we have 60s). It could actually just be the headers nginx is adding to the request though
Instead of clients receiving headers from the existing web socket connection (like in 3.6.3), now the connections just hang and the websocket handler isn't even called.
Extra
Are we supposed to be closing websockets after rejecting them?

Java 11, Adopt openJDK
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi everybody,
I have an app that use multiple databases, so I create multiple connections and keep them in a concurrenthashmap.
If a connection doesn't exist I simply create a new one and put it into that map, and we will close and remove some of the client if that task get done.
After many rounds of the create-close-remove operations, exception happens while close some of that client, it says thread has been blocked.
Why close a mongo client  end up with thread block for that long period of time,  how can I avoid this problem from happen?
THX!
Vertx version: 4.2.3
Java version : 1.8.0_201
02:10:05.626 WARN  i.v.core.impl.BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-27,5,main] has been blocked for 5058 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
at sun.misc.Unsafe.park(Native Method)
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
at com.mongodb.internal.connection.AsynchronousChannelStream$FutureAsyncCompletionHandler.get(AsynchronousChannelStream.java:317)
at com.mongodb.internal.connection.AsynchronousChannelStream$FutureAsyncCompletionHandler.getRead(AsynchronousChannelStream.java:312)
at com.mongodb.internal.connection.AsynchronousChannelStream.read(AsynchronousChannelStream.java:151)
at com.mongodb.internal.connection.InternalStreamConnection.receiveResponseBuffers(InternalStreamConnection.java:648)
at com.mongodb.internal.connection.InternalStreamConnection.receiveMessageWithAdditionalTimeout(InternalStreamConnection.java:513)
at com.mongodb.internal.connection.InternalStreamConnection.receiveCommandMessageResponse(InternalStreamConnection.java:356)
at com.mongodb.internal.connection.InternalStreamConnection.sendAndReceive(InternalStreamConnection.java:280)
at com.mongodb.internal.connection.CommandHelper.sendAndReceive(CommandHelper.java:83)
at com.mongodb.internal.connection.CommandHelper.executeCommand(CommandHelper.java:33)
at com.mongodb.internal.connection.InternalStreamConnectionInitializer.initializeConnectionDescription(InternalStreamConnectionInitializer.java:107)
at com.mongodb.internal.connection.InternalStreamConnectionInitializer.initialize(InternalStreamConnectionInitializer.java:62)
at com.mongodb.internal.connection.InternalStreamConnection.open(InternalStreamConnection.java:144)
at com.mongodb.internal.connection.UsageTrackingInternalConnection.open(UsageTrackingInternalConnection.java:51)
at com.mongodb.internal.connection.DefaultConnectionPool$PooledConnection.open(DefaultConnectionPool.java:431)
at com.mongodb.internal.connection.DefaultConnectionPool.get(DefaultConnectionPool.java:115)
at com.mongodb.internal.connection.DefaultConnectionPool.get(DefaultConnectionPool.java:100)
at com.mongodb.internal.connection.DefaultServer.getConnection(DefaultServer.java:92)
at com.mongodb.internal.session.ServerSessionPool.endClosedSessions(ServerSessionPool.java:156)
at com.mongodb.internal.session.ServerSessionPool.close(ServerSessionPool.java:103)
at com.mongodb.internal.async.client.AsyncMongoClientImpl.close(AsyncMongoClientImpl.java:119)
at com.mongodb.reactivestreams.client.internal.MongoClientImpl.close(MongoClientImpl.java:65)
at io.vertx.ext.mongo.impl.MongoClientImpl$MongoHolder.close(MongoClientImpl.java:1283)
at io.vertx.ext.mongo.impl.MongoClientImpl.close(MongoClientImpl.java:132)
at io.vertx.ext.mongo.impl.MongoClientImpl.close(MongoClientImpl.java:1243)
at io.vertx.reactivex.ext.mongo.MongoClient.close(MongoClient.java:1921)
at io.vertx.reactivex.ext.mongo.MongoClient.close(MongoClient.java:1928)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
VertX 4.2.5 - did not check prior versions
Context
Using HTTP 1 / 1.1 the endHandler of ServerResponse is not invoked.
Steps to reproduce
Vertx.vertx().createHttpServer()
  .requestHandler(request -> request.response().endHandler(nothing -> System.err.println("never happens")).sendFile("file.txt"))
  .listen();

Extra

openjdk 17
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Questions
-1 is the default value of clusterPublicPort in EventBusOptions, but setting this default value will fail:
  @Test
  public void testEventBusOptions() {
    VertxOptions vertxOptions1 = new VertxOptions();
    JsonObject json = vertxOptions1.toJson();
    VertxOptions vertxOptions2 = new VertxOptions(json);  //  <== this line leads to exception
    assertEquals(json, vertxOptions2.toJson());
  }
The exception is:
java.lang.IllegalArgumentException: clusterPublicPort p must be in range 0 <= p <= 65535
	at io.vertx.core.eventbus.EventBusOptions.setClusterPublicPort(EventBusOptions.java:651)
	at io.vertx.core.eventbus.EventBusOptionsConverter.fromJson(EventBusOptionsConverter.java:55)
	at io.vertx.core.eventbus.EventBusOptions.<init>(EventBusOptions.java:165)
	at io.vertx.core.VertxOptionsConverter.fromJson(VertxOptionsConverter.java:45)
	at io.vertx.core.VertxOptions.<init>(VertxOptions.java:181)
	at io.vertx.core.VertxOptionsTest.testEventBusOptions(VertxOptionsTest.java:321)
This does not make sense as we cannot re-construct the VertxOptions using the JsonObject exported from a default VertxOptions instance.
Version
latest master branch
Do you have a reproducer?
Please refer to https://gist.github.com/gaol/7593cebcb2d1328d4ed50ece5ee1ac70 for more detail.
Contribution
I will provide PR for the fix
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Updated to remove clusterPublicPort from the result of toJson() method if the value is -1.
I am not sure if it is possible to have codegen supports ignore default value, that will be even better solution if it can support. :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently using Vert.x version 4.2.2
We are using client_credentials to authenticate a WebClient request, the response from the Identity provider (Idp) does not include any refresh_token and assumes that you request a new token as soon the current access_token will expire.
Now when current access_token expires a refresh_token grant request with empty refresh_token is made to the Idp. This will result in failed request which will then try to request a new token using the client_credential grant again as desired. This is there for not causing any huge issue but is causing noise in logs and unnecessary request to the Idp.
The issue is locted here:
https://github.com/vert-x3/vertx-web/blob/master/vertx-web-client/src/main/java/io/vertx/ext/web/client/impl/OAuth2AwareInterceptor.java#L88,L97
What has to be done is to check if the authenticated User has any refresh_token before trying to refresh the token.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks a lot @gaol
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Many DNS servers do not send partial results when the answer is larger then will fit in a reply packet.  This can happen when using AWS ElastiCache with a large cluster size, or when connecting to a host that exposes a large number of results as the above.
Example host: bidcast-bcserver-gce-sc-multifo.bidswitch.net. (From https://unix.stackexchange.com/questions/545055/unable-to-run-dns-queries-when-response-is-bigger-than-512-bytes-and-truncated)
The problem results in a confusing / misleading error message, such as when opening a Redis connection:
Cannot connect to endpoint: io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'SNIP' failed to resolve 'SNIP' after 2 queries  

A quick check of Google and Route53 DNS resolvers shows that they provide no partial results when the answer will exceed the max.  Vert.x seems to cap at lower than the standard UDP 512, but I haven't found the source of that cap.
First pass would be to enhance the error message to detect the truncation bit in the response and illuminate the nature of the problem.
A further improvement would be to retry the request via TCP if the UDP answer was empty and the truncate bit was set.
Netty seems to have added support for DNS-over-TCP per  netty/netty#9139 .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version
vert.x-core 4.2.5
Context
I was trying to increase stability of a connection made with websockets. One of the measures is, to reliably connect to the remote server or to retry when the connection cannot be established within a specific period of time, i.e. a classic timeout.
I have found one scenario, where none of the available options work: If the server accepts the TCP connection, but does not respond in any way.
I've tried:

HttpClientOptions.connectTimeout
HttpClientOptions.idleTimeout
WebSocketConnectOptions.requestTimeout

Do you have a reproducer?
Demonstrating unit test:

https://gist.github.com/inno-steffg/ded493b7cb6150ed42ff2b25b2258822

Steps to reproduce

Start a netsocket server, which accepts any connection request, but does not respond in any way.
Try to connect with a Vert.x http client websocket request to this server: no async result is happening ever.

Extra

Windows 10 64bit
openjdk version "17.0.2" 2022-01-18
OpenJDK Runtime Environment (build 17.0.2+8-86)
OpenJDK 64-Bit Server VM (build 17.0.2+8-86, mixed mode, sharing)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello! First of all, I'm not sure if this is a problem with my use or if it's a bug:
I tried to use Vertx4.2.5 and OpenJdk 17.0.2 create a simple http application.
Code
public static void main(String[] args) {
        HttpServer server = Vertx.vertx(new VertxOptions()).createHttpServer();

        server.requestHandler(request -> {

            // This handler gets called for each request that arrives on the server
            HttpServerResponse response = request.response();
            response.putHeader("content-type", "text/plain");

            // Write to the response and end it
            response.end("Hello World!");
            response.close();
        });

        server.listen(8080);
    }

As you see, I'm using the example from the official documentation. And I request http://localhost:8080/ :

No response. The browser show ERR_EMPTY_RESPONSED.
I initially thought it was my version of Vertx that was incompatible with the JDK version, So I tried to lower the Vertx version 4.2.4.
Its work.
Are there any changes to httpServer creation in 4.2.5? If yes, can you give an example? Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/eclipse-vertx/vert.x/issues/4314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

