https://github.com/redisson/redisson
https://github.com/redisson/redisson/issues/1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implement with binary insertion algorithm
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just an idea, would this be possible? Still new to Redis / Redisson.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be great to see TIME supported.
See also #19 in lettuce.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think this is a critical need as soon as you are using async API, could it be possible ti have this contribution reviewed ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/7
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
I could not find a way to set expiry for the contents of the cache from within Java. Is this true, or did I miss something?
Thank you
Jozsef
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/9
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I just imported redisson 1.0.3 via maven, set up a redis-server on localhost on default port and wanted to try the redisson redis client. My test code looks as following:
Redisson redis = Redisson.create();
Map m = redis.getMap("someMap");

But I'm getting an Error:
java.lang.NoSuchFieldError: WRITE_BIGDECIMAL_AS_PLAIN
    at org.redisson.codec.JsonJacksonCodec.createObjectMapper(JsonJacksonCodec.java:90)
    at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:43)
    at org.redisson.Config.<init>(Config.java:44)
    at org.redisson.Redisson.create(Redisson.java:85)
    at ...

Am I doing something wrong or is this a dependency problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/10
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mp911de thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/11
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in RedisClient.java
try {
        final ConnectionWatchdog watchdog = new ConnectionWatchdog(bootstrap, channels, timer);

        ChannelFuture connect = null;
        // TODO use better concurrent workaround
        synchronized (bootstrap) {
            connect = bootstrap.handler(new ChannelInitializer<Channel>() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(watchdog, handler, connection);
                }
            }).connect();
        }
        connect.sync();

        watchdog.setReconnect(true);

        return connection;
    } catch (Throwable e) {
        throw new RedisException("Unable to connect", e);
    }

this "synchronized " protect what?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/12
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have test code for the load balance, but only the first instance got the load:
public static void main(String[] args) {
Config config = new Config();
//config.setConnectionPoolSize(100); // default 100
// Redisson will use load balance connections between listed servers
String[] redisInstances = new String[]{"192.168.9.101:6379", "192.168.9.102:6379"};
config.addAddress(redisInstances);
    Redisson redisson = Redisson.create(config);
    Queue<Integer> q = redisson.getQueue("QUEUE");

    for (int i = 0; i < 1_000_000; i++) {
        q.add(i);
        if (i % 10000 == 0) {
            System.out.println("put: " + i);
        }
    }

    System.out.println("DONE.");
    redisson.shutdown();
}

Do I miss any thing?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/13
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be nice if the Redisson class exposed its connection manager.  The use case is to access low level redis commands using the same pool of connections as the high-level redisson abstractions.  Currently its protected and private which means I have to resort to ugly hacks to get to it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/14
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The eval method does not seem to work for me.  I traced the cause to this line in theRedisAsyncConnection:eval() method:
args.addValue(script).add(keys.length).addKeys(keys).addValues(values)
It should instead be:
args.add(script).add(keys.length).addKeys(keys).addValues(values)
In its current form, the script is escaped with double quotes and cannot be interpreted by redis.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/15
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
See GIST: https://gist.github.com/mathieucarbou/21051be4a2abd7cc1006
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/16
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I do not have Jackson and do not want to use it. Sadly, the Config class has a hard pointer on it:
private RedissonCodec codec = new JsonJacksonCodec();
Thus when creating a new Config instance I have the exception:
Caused by: java.lang.NoSuchFieldError: WRITE_BIGDECIMAL_AS_PLAIN
    at org.redisson.codec.JsonJacksonCodec.createObjectMapper(JsonJacksonCodec.java:90)
    at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:43)
    at org.redisson.Config.<init>(Config.java:44)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:408)
    at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)

Codecs should be made optional or at least the default should be the Serializer codec which only depends on the JDK, or a simple String <=> String codec.
For now I cannot use Redisson properly :-(
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/17
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Pub a message doesn't require a pubsub connection, however get a RTopic does. There are many cases just want to publish a message, get a RTopic from Redisson will automatically subscribe on the channel, which is unnecessary and there is no safe way to close topic after publish message since there may be some listeners are actually interested in the topic.
BTW, RedisConnection has a method  publish(K channel, V message)
Unfortunelty the underlying connection manager is not exposed, see issue #13
Provide access to the underlying connection manager
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/18
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be really nice if you can add support for PFADD | PFCOUNT | PFMERGE commands in Redisson.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/19
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I want to use this inside Android, is it supported?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/20
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
why do you have imported lettuce code into your project instead of referencing it via artifact?
The approach your library works is quite cool providing collections. It's just somehow annoying having no access to the underlying RedisClient. Redisson.create(RedisClient client) or even redisson.getList(RedisClient client, String name) etc. would be a way opener approach. The current way, it's Redisson who manages all the Redis stuff for you. I see Redisson as a sort of valueable add-on.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/21
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Nikita, when I ran some load test, ConnectionWatchdog did not restore PubsubConnection correctly (my env is redis 2.8.3, java 1.7.0_45,Netty 4.0.19 final, OSX 10.9.2). After some digging, I found a couple of problems,

When ChannelInitilizor ChannelInitializer.initChannel is called,           pipeLine.get(CommandHandler.class) and pipeLine.get(RedisAsyncConnection.class) return null, I guess the old ChannelPipeline had been destroyed.
The connection retry and backoff doesn’t seem right, the connection attempt seems only fired when the channel is inactive, if re-connect did not work, no further attempt will be fired.
RedissonTopic.promise.get().setSuccess(true) will throw IllegalStateException: complete already when PubsubConnection is re established.
4)Though this is not a bug, it seems unnecessary to use a dedicated HashedTimeWheel to schedule reconnection task.

I will push a patch later.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/22
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry Nikita, I didn't realise git pull will create an issue automatically, please close one of 21/22. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/23
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
When we create a Redisson object, I would also need to execute some Redis commands.
What is the best way ? Do I need to create another ConnectionManager completely separate from the one in the Redisson class, or it would be better to access the one created on the Redisson object, so that we can re-use it ?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/24
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does reddison support the ability to add both a master and slave addresses and only write to the master?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/25
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/27
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson clusters may return a 'MOVED' if a key is on another shard, does redisson handle that?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/28
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After running for a week or two, the scores collapsed to zeros or nead zero (10^-300) and we encountered an infinite loop in redisson when adding (it couldnt settle on a score). So we will manage the score ourselves.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/29
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I just added requirepass and masterauth to my configuration for 3 slaves and a master.  Using 1.5 I am able to write just fine, but when I tried Map::get I get a RedisException: "NOAUTH Authentication required."
I've tried just using a single connection to the master, a 'useMasterSlaveConnection' with only 'setMasterAddress', and a 'useMasterSlaveConnection' with all hosts configured.
When I connect with a tool like Redis Desktop Manager I am able to view the updated values just fine.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/30
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/31
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/32
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Same client code worked with 1.4 but not 1.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/33
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2014-06-09T22:04:34.459669+00:00 app[web.1]: WARN DefaultChannelPipeline [nioEventLoopGroup-2-1] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
2014-06-09T22:04:34.459678+00:00 app[web.1]: java.lang.NullPointerException: null
2014-06-09T22:04:34.459681+00:00 app[web.1]:    at com.lambdaworks.redis.pubsub.RedisPubSubConnection.channelRead(RedisPubSubConnection.java:119)
2014-06-09T22:04:34.459684+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341)
2014-06-09T22:04:34.459686+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327)
2014-06-09T22:04:34.459688+00:00 app[web.1]:    at com.lambdaworks.redis.pubsub.PubSubCommandHandler.decode(PubSubCommandHandler.java:43)
2014-06-09T22:04:34.459691+00:00 app[web.1]:    at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:51)
2014-06-09T22:04:34.459692+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341)
2014-06-09T22:04:34.459694+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327)
2014-06-09T22:04:34.459695+00:00 app[web.1]:    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
2014-06-09T22:04:34.459697+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341)
2014-06-09T22:04:34.459699+00:00 app[web.1]:    at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327)
2014-06-09T22:04:34.459700+00:00 app[web.1]:    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:785)
2014-06-09T22:04:34.459702+00:00 app[web.1]:    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:126)
2014-06-09T22:04:34.459703+00:00 app[web.1]:    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:507)
2014-06-09T22:04:34.459734+00:00 app[web.1]:    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464)
2014-06-09T22:04:34.459736+00:00 app[web.1]:    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:378)
2014-06-09T22:04:34.459737+00:00 app[web.1]:    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:350)
2014-06-09T22:04:34.459739+00:00 app[web.1]:    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
2014-06-09T22:04:34.459740+00:00 app[web.1]:    at java.lang.Thread.run(Thread.java:724)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/34
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis monitor shows the setex followed by the get
1402351706.438560 [0 107.21.134.1:43779] "SETEX" "\x03\x01api:sessions:dE9K23ZT4de6MHMn2V-mg\xf7" "2591977" "\xae\x02\x01o\x01\x00\xa4\x84\xe7\xaa\xd0Q\x01dE9K23ZT4de6MHMn2V-mg\xf7\xc6\x84\xe7\xaa\xd0Q\x01207.253.217.242,10.226.123.45, 54.87.64.23\xb0\x80\xb4\xbc\x02\x05\xaf\x02\x01\x01okoMskkfJxo9JcOzF7Bpi\xf7"
1402351707.163372 [0 107.21.134.1:43779] "GET" "\x03\x01api:sessions:dE9K23ZT4de6MHMn2V-mg\xf7"

the code:
        RBucket<StoredSession> bucket = redisson.<StoredSession>getBucket(PREFIX + id);
        try {
            return bucket.get();
        } catch (RuntimeException e) {
            LOGGER.log(Level.WARNING, "Removing malformed session " + id + ": " + e.getMessage(), e);
            bucket.delete();
            return null;
        }

code returns null.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/36
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/37
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/38
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think it's better to extend api if it possible, which commands do you need?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/41
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
1.Sentinel not support auth password.（I have solve this problem）
2.When redis sentinel occur failover，redisson can not failover to new master automatic。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/42
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Operates with async methods only. Code example:
RBatch batch = redisson.createBatch();

RMap<Integer, Integer> map = redisson.getMap("map");
map.fastPutAsync(1, 2);
map.putAsync(2, 3);
map.fastPutAsync(3, 4);

List<Future<?>> futures = batch.execute();
// or
Future<List<Future<?>>> futures = batch.executeAsync();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/43
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/44
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/45
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/46
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/47
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public interface IRedisson {
    <V> RBucket<V> getBucket(String name);
    <V> RHyperLogLog<V> getHyperLogLog(String name);
    <V> RList<V> getList(String name);
    <K, V> RMap<K, V> getMap(String name);
    .
    .
    .
}
public class Redisson implements IRedisson {

    private final ConnectionManager connectionManager;
    private final Config config;

    private final UUID id = UUID.randomUUID();
    .
    .
    .
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/48
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko What do you think about this suggestion?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/50
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/51
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/52
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/54
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use hmget
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/55
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/56
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/57
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/58
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ability to register event listeners for sentinel server events
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/59
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I don't see
<<<<<<<<<<<<<<<<<<<<< any way to configure a timeout or select a database. Am I missing something?<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/60
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonList.subList() doesn't conform to the specifications of java.util.List, which states that subList() returns a view backed by the current list.
On a related note, it would be nice to also have access to some of the buffered collections in addition to the redisson wrapper collections. If you're expecting to read all or most of a list, it would be wasteful to have to call RedissonList.get() for each element, resulting in another redis query each time. (Currently you can get a buffered list by calling subList(), but that's a workaround unique to the list collection, and it shouldn't really work that way - as mentioned above.)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/61
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I ran into an issue in which I found if I remove a listener from an RTopic, it will unsubscribe the entire channel, which will kill the connection for all listeners and RTopic subscribed to the same channel. Following is the code in question.
RedissonTopic.class
@OverRide
public void removeListener(int listenerId) {
PubSubConnectionEntry entry = connectionManager.getEntry(getName());
if (entry == null) {
return;
}
synchronized (entry) {
if (entry.isActive()) {
entry.removeListener(getName(), listenerId);
connectionManager.unsubscribe(getName());
return;
}
}
    // entry is inactive trying add again
    removeListener(listenerId);
}

I am not quite sure whether I am using Redisson RTopic in the right way. Would you please help me to understand what’s the reason to unsubscribe the channel when removing one listener? And if I need to have multiple listeners subscribed on the same channel and the list of listeners will change dynamically (since it’s used on the application server to propagate changes to clients), what’s the right way to use RTopic?
Your help will be greatly appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/62
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey folks, I'm seeing this error on redisson 1.1.5 and it seems completely sporadic
WARN  [2014-08-04 04:10:21,672] io.netty.channel.DefaultChannelPipeline: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
! java.lang.NullPointerException: null
! at com.lambdaworks.redis.protocol.CommandOutput.decodeAscii(CommandOutput.java:110) ~[redisson-1.1.5.jar:na]
! at com.lambdaworks.redis.output.StatusOutput.set(StatusOutput.java:26) ~[redisson-1.1.5.jar:na]
! at com.lambdaworks.redis.protocol.RedisStateMachine.decode(RedisStateMachine.java:89) ~[redisson-1.1.5.jar:na]
! at com.lambdaworks.redis.protocol.CommandHandler.decode(CommandHandler.java:71) ~[redisson-1.1.5.jar:na]
! at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:52) ~[redisson-1.1.5.jar:na]
! at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:785) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:126) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:507) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:378) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:350) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
! at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116) [netty-common-4.0.19.Final.jar:4.0.19.Final]
! at java.lang.Thread.run(Thread.java:744) [na:1.8.0]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/63
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/65
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have created a cluster with 3 master and 3 slave.
port 7000 seems to be myself,master.
If 7000 goes down I get a connection refused exception with Redisson. Ideally it should shift to its slave.
I am copying the exception here
com.lambdaworks.redis.RedisConnectionException: Unable to connect /127.0.0.1:7000
at com.lambdaworks.redis.RedisClient.connect(RedisClient.java:183)
at com.lambdaworks.redis.RedisClient.connectAsync(RedisClient.java:143)
at com.lambdaworks.redis.RedisClient.connectAsync(RedisClient.java:104)
at org.redisson.connection.ClusterConnectionManager.(ClusterConnectionManager.java:54)
at org.redisson.Redisson.(Redisson.java:56)
at org.redisson.Redisson.create(Redisson.java:82)
Is it a known issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/66
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to distinguish between empty and non-existent collections? (Or some way to invoke the EXISTS command?)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/67
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How is it ever safe to rely on RedissonList.size() when each invocation can technically return a different value? This would mean that calling subList(0, size()), or even two consecutive calls to hasNext() on the iterator (which is normally what happens) can potentially cause an exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/68
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fixed! thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/69
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys!
When I get some error, eg: redis servers down, in getAsync and setAsync the connection is not released, once the release is done in a Promise listener, that never executes, can you check this please?
Regards,
Marcio
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/70
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was working with redisson adding data to the data store.  I was having issues, so I went to the command line to check what was in the data store and couldn't find my structures (although the program seemed to find them OK).  So I listed the keys and got this:
127.0.0.1:6379> keys *

""resource""
""processedMap""
""agentCounter""
""processCounter""
""routedMap""

then from the cli, I entered "set foo bar" and listed the keys again and got this:
127.0.0.1:6379> keys *

""resource""
""processedMap""
"foo"
""agentCounter""
""processCounter""
""routedMap""

it seems that redisson is surrounding the key names with quotes before storing them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/72
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Invocation of init method failed; nested exception is java.lang.StackOverflowError
WARN  org.redisson.connection.RoundRobinLoadBalancer Can't connect to /192.168.1.203:6379, trying next connection!
2014-08-26 14:35:21,194 WARN  org.redisson.connection.RoundRobinLoadBalancer Slave subscribe-connection pool gets exhausted! Trying to acquire connection again...
2014-08-26 14:36:21,197 WARN  org.redisson.connection.RoundRobinLoadBalancer Can't connect to /192.168.1.203:6379, trying next connection!
2014-08-26 14:36:21,197 WARN  org.redisson.connection.RoundRobinLoadBalancer Slave subscribe-connection pool gets exhausted! Trying to acquire connection again...
2014-08-26 14:37:21,200 WARN  org.redisson.connection.RoundRobinLoadBalancer Can't connect to /192.168.1.203:6379, trying next connection!
2014-08-26 14:37:21,200 WARN  org.redisson.connection.RoundRobinLoadBalancer Slave subscribe-connection pool gets exhausted! Trying to acquire connection again...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/73
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey, I was wondering if there is any way to execute a LUA script in redisson. I can do it through the connection manager, using something like this:
ConnectionManager cm;

try{
    Field field = Redisson.class.getDeclaredField("connectionManager");
    field.setAccessible(true);
    cm = (ConnectionManager) field.get(redisson);
}
catch(Exception e){}

cm.connectionReadOp(0).eval(script, type, keys);
But obviously that's not the cleanest solution. Would it be possible to add a public evalScript() method, or something of the sort to the Redisson class? Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/74
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/75
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/76
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The RedisPubSubConnection class already had a psubscribe and punsubscribe methods for dispatching commands to Redis, but they are not hooked up to anything
The RTopic interface should get a new addPListener and removePListener and all the underlying changes necessary to propagate down to RedisPubSubConnection
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/77
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/78
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
i.n.channel.DefaultChannelPipeline [151] - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.lang.NullPointerException: null
at com.lambdaworks.redis.protocol.CommandOutput.decodeAscii(CommandOutput.java:110) ~[redisson-1.1.5.jar:na]
at com.lambdaworks.redis.output.StatusOutput.set(StatusOutput.java:26) ~[redisson-1.1.5.jar:na]
at com.lambdaworks.redis.protocol.RedisStateMachine.decode(RedisStateMachine.java:89) ~[redisson-1.1.5.jar:na]
at com.lambdaworks.redis.protocol.CommandHandler.decode(CommandHandler.java:71) ~[redisson-1.1.5.jar:na]
at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:52) ~[redisson-1.1.5.jar:na]
at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:341) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:327) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:785) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:126) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:507) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:378) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:350) [netty-transport-4.0.19.Final.jar:4.0.19.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116) [netty-common-4.0.19.Final.jar:4.0.19.Final]
at java.lang.Thread.run(Thread.java:744) [na:1.7.0_51]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/79
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/80
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/81
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/82
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/85
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/86
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/90
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/91
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/92
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/94
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/96
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/97
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/98
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/99
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(1) Using Redission how to achieve LRU?
(2) How to set expiry for one particular object of the Bucket or List or Set ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis version: redis-3.0.0
./src/redis-cli -c -p 7001 cluster nodes
9d97b7a1ee8cc52446a234f7f721e144aceacde3 10.126.53.98:7001 myself,slave a9b71c24f6dc8dca99969f82762904eef69947a9 0 0 2 connected
a9b71c24f6dc8dca99969f82762904eef69947a9 10.126.53.98:7004 master - 0 1431933896610 10 connected 5461-10922
0f92aa118812a4d9f96a1e41ae81ca34313d929f 10.126.53.98:7003 slave 9dd564ac496ebb8ac68af0b2268892debd643b86 0 1431933897111 9 connected
a112df8ccae1f29a1906d6e4f3ae94c92066a507 10.126.53.98:7002 master - 0 1431933895104 3 connected 10923-16383
8099cffcd53498ca95a17bef552ee58e09f969a0 127.0.0.1:7100 handshake - 1431933893297 0 0 disconnected
9dd564ac496ebb8ac68af0b2268892debd643b86 10.126.53.98:7000 master - 0 1431933897111 7 connected 0-5460
7ad08971115b10af5e3e0324582ce7e3ea361ffa 10.126.53.98:7005 slave a112df8ccae1f29a1906d6e4f3ae94c92066a507 0 1431933896109 8 connected
f333c6ead44fe826b1e1f9b019244e1740a47fba 10.126.53.98:7100 master,fail - 1431933882171 1431933881184 0 disconnected
when redisson was created :
Exception in thread "main" java.lang.IllegalArgumentException: No enum const class org.redisson.connection.ClusterNodeInfo$Flag.HANDSHAKE
at java.lang.Enum.valueOf(Enum.java:196)
at org.redisson.connection.ClusterNodeInfo$Flag.valueOf(ClusterNodeInfo.java:1)
at org.redisson.connection.ClusterConnectionManager.parse(ClusterConnectionManager.java:246)
at org.redisson.connection.ClusterConnectionManager.extractPartitions(ClusterConnectionManager.java:188)
at org.redisson.connection.ClusterConnectionManager.(ClusterConnectionManager.java:62)
at org.redisson.Redisson.(Redisson.java:53)
at org.redisson.Redisson.create(Redisson.java:80)
at com.lambdaworks.redis.ClusterTest.main(ClusterTest.java:29)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
JsonJacksonCodec performance is not so Good  , suggest  StringCodec as default Codec .
JsonJacksonCodec VS StringCodec ：
server 8core16G , one redis node , concurrent 200 ,total task 2000*1000,each task set 128byte to redis
=====JsonJacksonCodec========
Requests per second:   13479.335--QPS
======StringCodec=========
Requests per second:   34479.335--QPS
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi,
i keep seeing occasional null pointer exceptions in RedissonExpriable, line 37 (when i try to extend the lifetime of a bucket). i only see this in one environment, not on a second one and not on my local. i am assuming that i am having some connectivity issues there. could that be a cause? why is it an NPE?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We encountered an issue when using Redisson to connect our application running on Ubuntu to Amazon ElastiCache for Redis.
When performing any operation Redisson throws a RedisConnectionException: Unable to connect xxxx.cache.amazonaws.com/10.xxx.xxx.xxx:6379. However, after installing the redis-tools package (using apt-get) the issue goes away and everything works correctly.
Does Redisson requires the redis-cli binary or the redis-tools package? Did anyone had a similar issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Between client restarts, KyroCodec serialisation randomly fails with exception;
com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 46
at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:119)
at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:666)
at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:777)
at org.redisson.codec.KryoCodec.decode(KryoCodec.java:92)
at org.redisson.codec.KryoCodec.decodeValue(KryoCodec.java:140)
at org.redisson.codec.RedisCodecWrapper.decodeValue(RedisCodecWrapper.java:42)
at com.lambdaworks.redis.output.MapScanOutput.set(MapScanOutput.java:19)
at com.lambdaworks.redis.protocol.RedisStateMachine.decode(RedisStateMachine.java:112)
at com.lambdaworks.redis.protocol.CommandHandler.decode(CommandHandler.java:71)
at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:52)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:745)
Prior to release this feature, did you run some regression tests for it? Also do you have any comment about the exception?
P.S: Content of the redis and the classes are same between restarts and I am simply applying Predicate upon RMap.
Edit: Between restarts, Kyro is sweeping the classes and give them uniqueIds in order to identify and serialise/deserialise them. I used to give Kyro exact list of classes in the exact order but with the auto discovery I think class loading order causes this issue right now.
IMHO, best solution would be to provide an interface for registering the Kyro classes to the underlying KyroCodec impl.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've got a problem with iterating over a RSet, the following code throws a ClassCastException when using the StringCodec:
RSet<Object> test = r.getSet("test");

test.add("test1");
test.add("test2");
test.add("test3");

test.forEach(System.out::println);
Stacktrace:
java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number
    at com.lambdaworks.redis.output.ValueSetScanOutput.set(ValueSetScanOutput.java:17)
    at com.lambdaworks.redis.protocol.RedisStateMachine.decode(RedisStateMachine.java:112)
    at com.lambdaworks.redis.protocol.CommandHandler.decode(CommandHandler.java:71)
    at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:52)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
    at java.lang.Thread.run(Thread.java:745)

With a List everything works.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis 3.0.1
Redisson 1.2.0
I got a problem.
Firstly , in redis client , I put a set named "hello", the set numbers are "hello1"  and "hello2"
Second,in Redisson , I get this set .
    RSet  hello = redisson.getSet("hello");
    Iterator it = hello.iterator();
    System.out.println(it.next());
    System.out.println(it.next());

WARN 11:36:59 warn(Slf4JLogger.java:151) - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.lang.IllegalStateException: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'hello2': was expecting ('true', 'false' or 'null')
at [Source: [B@9df354; line: 1, column: 32]
at org.redisson.codec.JsonJacksonCodec.decodeMapValue(JsonJacksonCodec.java:146)
at org.redisson.codec.RedisCodecWrapper.decodeMapValue(RedisCodecWrapper.java:67)
at com.lambdaworks.redis.output.ValueSetScanOutput.set(ValueSetScanOutput.java:19)
at com.lambdaworks.redis.protocol.RedisStateMachine.decode(RedisStateMachine.java:112)
at com.lambdaworks.redis.protocol.CommandHandler.decode(CommandHandler.java:71)
at com.lambdaworks.redis.protocol.CommandHandler.channelRead(CommandHandler.java:52)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:130)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:619)
Caused by: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'hello2': was expecting ('true', 'false' or 'null')
at [Source: [B@9df354; line: 1, column: 32]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1419)
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:508)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._reportInvalidToken(UTF8StreamJsonParser.java:3201)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._handleUnexpectedValue(UTF8StreamJsonParser.java:2360)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:794)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:690)
at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:3090)
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3036)
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2225)
at org.redisson.codec.JsonJacksonCodec.decodeMapValue(JsonJacksonCodec.java:144)
... 19 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do you have a plan to develop  the client to be able to use  unix sockets instead of tcp.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson library version: 1.2.1
Hi,
We are using SentinelServersConfig and during the tests we observed that if a slave is down, and sentinel properly reports this by putting the s_down flag, Redisson still considers it at initialization and during the operation tries to connect to it.
This affects badly the performance, since RoundRobin tries periodically send though that slave.
WARN  o.r.c.RoundRobinLoadBalancer - Can't connect to /192.168.150.163:6379, trying next connection!
As I see, the SentinelConnectionManager constructor does not check for the "s_down" flag when initializes the list of available slaves, thus the Redisson snapshot of slave status does not reflects the status of slave servers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class RedissonLock extends RedissonObject implements RLock {
...
private Long tryLockInner() {
final LockValue currentLock = new LockValue(id, Thread.currentThread().getId());
currentLock.incCounter();
    return connectionManager.write(getName(), new SyncOperation<LockValue, Long>() {

        @Override
        public Long execute(RedisConnection<Object, LockValue> connection) {
            Boolean res = connection.setnx(getName(), currentLock);
            if (!res) {
                connection.watch(getName());

in RedissonLock.java Line 291, if Boolean res is null, the 291 line if(!res)  throw java.lang.NullPointerException.
java.lang.NullPointerException
at org.redisson.RedissonLock$2.execute(RedissonLock.java:291)
at org.redisson.RedissonLock$2.execute(RedissonLock.java:286)
at org.redisson.connection.MasterSlaveConnectionManager.write(MasterSlaveConnectionManager.java:274)
at org.redisson.connection.MasterSlaveConnectionManager.write(MasterSlaveConnectionManager.java:263)
at org.redisson.RedissonLock.tryLockInner(RedissonLock.java:286)
at org.redisson.RedissonLock.tryLock(RedissonLock.java:349)
at org.redisson.RedissonLock.tryLock(RedissonLock.java:397)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It worth to expose the async operation to these data straction eg:
Future<V> popAsync(timeout),Future<Collection> popAsync(Int maxNumber,timeout) etc,maybe add something like AsyncList,AsncQueue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
val bytes = queue.poll(10, TimeUnit.SECONDS)
java.lang.NullPointerException
at org.redisson.RedissonBlockingQueue$2.execute(RedissonBlockingQueue.java:74)
at org.redisson.connection.MasterSlaveConnectionManager.write(MasterSlaveConnectionManager.java:296)
at org.redisson.connection.MasterSlaveConnectionManager.write(MasterSlaveConnectionManager.java:285)
at org.redisson.RedissonBlockingQueue.poll(RedissonBlockingQueue.java:71)
at service.StatisticWorker$$anonfun$receive$1.applyOrElse(StatisticService.scala:143)
at akka.actor.Actor$class.aroundReceive(Actor.scala:467)
at service.StatisticWorker.aroundReceive(StatisticService.scala:103)
at akka.actor.ActorCell.receiveMessage(ActorCell.scala:516)
at akka.actor.ActorCell.invoke(ActorCell.scala:487)
at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:238)
at akka.dispatch.Mailbox.run(Mailbox.scala:220)
at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(AbstractDispatcher.scala:397)
at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)
at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)
at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)
at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can i specify the redis database in Redisson?
Thanks for reading.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today attempted to migrate Redisson from version 1.2.1 to 1.3.0 and that caused the 2.1.6 version of the DataStax Java driver to write a WARN + stack trace instead of an INFO to the log.
With org.redisson:redisson:1.2.1, I see:
INFO  [com.datastax.driver.core.NettyUtil] (MSC service thread 1-2) Did not find Netty's native epoll transport in the classpath, defaulting to NIO.

With org.redisson:redisson:1.3.0, I see:
WARN  [com.datastax.driver.core.NettyUtil] (MSC service thread 1-1) Found Netty's native epoll transport in the classpath, but epoll is not available. Using NIO instead.: java.lang.UnsatisfiedLinkError: no netty-transport-native-epoll in java.library.path
    at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1857) [rt.jar:1.8.0_25]
    at java.lang.Runtime.loadLibrary0(Runtime.java:870) [rt.jar:1.8.0_25]
    at java.lang.System.loadLibrary(System.java:1119) [rt.jar:1.8.0_25]
    at io.netty.util.internal.NativeLibraryLoader.load(NativeLibraryLoader.java:168) [netty-common-4.0.29.Final.jar:4.0.29.Final]
    at io.netty.channel.epoll.Native.<clinit>(Native.java:50) [netty-transport-native-epoll-4.0.29.Final.jar:4.0.29.Final]
    at io.netty.channel.epoll.Epoll.<clinit>(Epoll.java:30) [netty-transport-native-epoll-4.0.29.Final.jar:4.0.29.Final]
    at java.lang.Class.forName0(Native Method) [rt.jar:1.8.0_25]
    at java.lang.Class.forName(Class.java:260) [rt.jar:1.8.0_25]
    at com.datastax.driver.core.NettyUtil.<clinit>(NettyUtil.java:68) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.NettyOptions.eventLoopGroup(NettyOptions.java:101) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.Connection$Factory.<init>(Connection.java:698) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.Cluster$Manager.init(Cluster.java:1244) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.Cluster.init(Cluster.java:159) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.Cluster.connect(Cluster.java:249) [cassandra-driver-core-2.2.0-rc1.jar:]
    at com.datastax.driver.core.Cluster.connect(Cluster.java:282) [cassandra-driver-core-2.2.0-rc1.jar:]
    ...

I also tried version 2.2.0-rc1 of the DataStax Java driver and see the same thing.
I also tried adding a dependency on io.netty:netty-transport-native-epoll:4.0.29.Final, which I believe contains the linux-x86_64 jars but still see the same thing.
For reference, I'm deploying to Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-44-generic x86_64).
Please advise.
Thanks,
Peter Luttrell
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when call shutdown(),it cause these error again and again and never stop the application.
I single the JVM via Ctrl + D and there is a shutdown() hooked in Play's lifecycle's onShutdown() callback.
  lazy val get: Redisson = {
    val redissonConfig = parseRedissonConfig(config)
    val redisson = Redisson.create(redissonConfig)
    lifecycle.addStopHook(() => Future.successful {
      redisson.shutdown()
    })
    redisson
  }
[warn] - io.netty.channel.AbstractChannel - Force-closing a channel whose registration task was not accepted by an event loop: [id: 0x76514d59]
java.util.concurrent.RejectedExecutionException: event executor terminated
    at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:672) ~[io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:264) ~[io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:655) ~[io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.channel.AbstractChannel$AbstractUnsafe.register(AbstractChannel.java:458) ~[io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.channel.SingleThreadEventLoop.register(SingleThreadEventLoop.java:68) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.channel.SingleThreadEventLoop.register(SingleThreadEventLoop.java:56) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.channel.MultithreadEventLoopGroup.register(MultithreadEventLoopGroup.java:75) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:324) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.bootstrap.Bootstrap.doResolveAndConnect(Bootstrap.java:157) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at io.netty.bootstrap.Bootstrap.connect(Bootstrap.java:113) [io.netty.netty-all-4.1.0.Beta5.jar:4.1.0.Beta5]
    at com.lambdaworks.redis.RedisClient.connect(RedisClient.java:176) [org.redisson.redisson-1.3.0.jar:na]
    at com.lambdaworks.redis.RedisClient.connectAsync(RedisClient.java:149) [org.redisson.redisson-1.3.0.jar:na]
    at com.lambdaworks.redis.RedisClient.connect(RedisClient.java:132) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:127) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:770) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.connection.MasterSlaveConnectionManager.writeAsync(MasterSlaveConnectionManager.java:249) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.connection.MasterSlaveConnectionManager.writeAsync(MasterSlaveConnectionManager.java:217) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.RedissonList.addAllAsync(RedissonList.java:156) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.RedissonList.addAll(RedissonList.java:148) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.RedissonList.add(RedissonList.java:96) [org.redisson.redisson-1.3.0.jar:na]
    at org.redisson.RedissonQueue.offer(RedissonQueue.java:43) [org.redisson.redisson-1.3.0.jar:na]
    at service.Pumper$$anonfun$receive$1.applyOrElse(StatisticService.scala:59) [cn.q-game.statisticserver-1.0-SNAPSHOT-sans-externalized.jar:na]
    at akka.actor.Actor$class.aroundReceive(Actor.scala:475) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at service.Pumper.aroundReceive(StatisticService.scala:53) [cn.q-game.statisticserver-1.0-SNAPSHOT-sans-externalized.jar:na]
    at akka.actor.ActorCell.receiveMessage(ActorCell.scala:516) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at akka.actor.ActorCell.invoke(ActorCell.scala:487) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:256) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at akka.dispatch.Mailbox.run(Mailbox.scala:223) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at akka.dispatch.Mailbox.exec(Mailbox.scala:233) [com.typesafe.akka.akka-actor_2.11-2.4-M2.jar:na]
    at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260) [org.scala-lang.scala-library-2.11.7.jar:na]
    at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339) [org.scala-lang.scala-library-2.11.7.jar:na]
    at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979) [org.scala-lang.scala-library-2.11.7.jar:na]
    at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107) [org.scala-lang.scala-library-2.11.7.jar:na]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Extract async interfaces for all redisson objects. This is necessary for further development of batch operations feature support.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add migrate and move commands to RedissonObject class
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it would be great to  add some java doc here:
https://github.com/mrniko/redisson/blob/master/src/main/java/org/redisson/codec/RedissonCodec.java
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Look the below smaple code, the compiled Java Regex looses its flags once you keep your object in Redis.  The below code Prints 2 before put operation, But Prints 0 after put operation to Redisson Map.
import org.redisson.Redisson;
import org.redisson.core.RMap;
import java.util.regex.Pattern;
public class RedisExample
{
public static void main(String[] args)
{
Redisson redisson = Redisson.create();
RMap<String, MyObject> m = redisson.getMap("mymap");
    MyObject mo = new MyObject("pattern",Pattern.compile("testpattern", Pattern.CASE_INSENSITIVE));
    System.out.println(mo.getPattern().flags());

    m.put("test", mo);

    mo = m.get("test");
    System.out.println(mo.getPattern().flags());
}

}
class MyObject
{
private String name;
private Pattern pattern;
public MyObject()
{
}

public MyObject(String name, Pattern p)
{
    this.name = name;
    this.pattern = p;
}

public Pattern getPattern()
{
    return pattern;
}

public void setPattern(Pattern pattern)
{
    this.pattern = pattern;
}

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried to do this:
    @Test
    public void test6() {
        String id = UUID.randomUUID().toString();
        RSet<Set<Integer>> testSet = redisson.getSet(id);

        List<Integer> collection = Arrays.asList(1, 2, 3, 23, 6, 22, 25, 8, 27, 10, 26, 11);
        Set<Integer> set1 = ImmutableSet.copyOf(collection);
        testSet.add(set1);

        Collections.shuffle(collection);
        Set<Integer> newSet = ImmutableSet.copyOf(collection);

        assertEquals(set1.hashCode(), newSet.hashCode());
        assertEquals(set1, newSet);
        assertTrue(testSet.contains(newSet));
    }

The test fails on the line "assertTrue(testSet.contains(newSet));", that is, testSet.contains(newSet) return false, but set1 equals newSet and set1.hashCode() equals newSet.hashCode().
Redisson version is 1.2.1.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
any method to know if redisson client is connected or not? i have a "connection is closed" error and i don"t know when re-use the same client or should create new one...
com.lambdaworks.redis.RedisConnectionClosedException: Connection is closed
at com.lambdaworks.redis.RedisAsyncConnection.dispatch(RedisAsyncConnection.java:1246)
at com.lambdaworks.redis.RedisAsyncConnection.eval(RedisAsyncConnection.java:308)
at org.redisson.RedissonScript$2.execute(RedissonScript.java:68)
at org.redisson.async.ResultOperation.execute(ResultOperation.java:27)
at org.redisson.connection.MasterSlaveConnectionManager.writeAsync(MasterSlaveConnectionManager.java:252)
at org.redisson.connection.MasterSlaveConnectionManager.writeAsync(MasterSlaveConnectionManager.java:223)
at org.redisson.RedissonScript.evalAsync(RedissonScript.java:65)
at org.redisson.RedissonMap.putAsync(RedissonMap.java:248)
at org.redisson.RedissonMap.put(RedissonMap.java:121)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With release 2.0.0, while using sample cluster setup using the create-cluster script from redis (http://redis.io/topics/cluster-tutorial) and this Redisson sample code:
Config config = new Config();
    config.useClusterServers()
      .setScanInterval(2000) // sets cluster state scan interval
      .addNodeAddress("127.0.0.1:30001");
Redisson redisson = Redisson.create(config);

I always get the following NPE:
[main] INFO org.redisson.connection.ClusterConnectionManager - master: //127.0.0.1:30001 for slot range: 0-5460 added
Exception in thread "main" java.lang.NullPointerException
    at org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:130)
    at org.redisson.connection.MasterSlaveEntry.<init>(MasterSlaveEntry.java:61)
    at org.redisson.connection.SingleEntry.<init>(SingleEntry.java:33)
    at org.redisson.connection.ClusterConnectionManager.addMasterEntry(ClusterConnectionManager.java:90)
    at org.redisson.connection.ClusterConnectionManager.<init>(ClusterConnectionManager.java:64)
    at org.redisson.Redisson.<init>(Redisson.java:74)
    at org.redisson.Redisson.create(Redisson.java:102)
    ....
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, while developing using redisson some problems with timeouts and cache times are experienced.

Consider the following scenario:

try {
     node = configCacheBusinessLogic.get();
} catch (RedisException e) {
     log.warn("Failed to get from cache, fall back to database", e);
     node = configService.get();
}


In ConfigCacheBusinessLogic:

@Cacheable(value = CACHE_NAME, key = CACHE_KEY_SPEL)
public JsonNode get() throws AbstractCustomException {
    //configService.get() is database logic wrapped in @Transactional
    return configService.get();
}


@Cacheable uses a class that extends Spring's Cache:

@Override
public ValueWrapper get(Object key) {
   PerformanceLogHelper.startTimer(CACHE_TIME);
   try {
       RBucket bucket = redisson.getBucket((String) key);
       Object value = bucket.get();
       return toWrapper(value);
    } finally {
        PerformanceLogHelper.stopTimer(CACHE_TIME);
    }
}

Now there are several problems here. Timeout exceptions are being thrown, but seemingly at random times ignoring the timeout setting of redisson. It is also somehow being affected by ttl setting as the shorter ttl yields lower cache times, as well as the frequency of hitting the cache. You can see it from the following graphs of CACHE_TIME timer:

Long TTL setting, and around 4-5 queries per minute (cache time goes as high as 800,000 ms):

2 . With long TTL setting and around 200 queries per minute, cache times also go as high as 800,000 ms but there are fewer spikes than in case 1 (sorry no screenshot)
Short TTL setting, around 4-5 queries per minute (cache time goes as high as 800 ms):

Short TTL setting, around 200 queries per minute (cache time goes as high as 1000 ms but very rarely):


So to summarize:



TTL
Queries per minute
Max cache time
Cache time spikes
Picture in the previous list




Long
4-5
800,000
Many
1


Long
~200
800,000
Few
2 (no pic)


Short
4-5
800
Many
3


Short
~200
1000
Few
4



In all cases the timeout was set to 100ms, 3 attempts with 100ms interval. In all the cases in the end requests succeed to fall over to the database (either through a timeout error or through returning null). Regardless, the timeout is not being thrown according to the settings. Please let me know if you might know the cause of the issue. Thoroughly investigated the code on this side and it seems like the issue is in redisson. Let me know if you need more context
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm contributing a redis integration to infinispan and am investigating the use of Redisson to use as the client.
I need an efficient way to retrieve a list of all keys and iterate over them for processing, but because Redis can store millions of records, I wanted to avoid a list/queue of data pulled from the Redis server and held in memory on the client as this could wind up exhausting resources on the client.
Will getBuckets, findKeysByPattern or findKeysByPatternAsync retrieve the keys in an efficient manor, like a database cursor stepping over each record, or is there another approach that is recommended to efficiently cater for this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
add findKeysByPatternIterator, findKeysByPatternIteratorAsync, getKeysIterator, getKeysIteratorAsync methods. Move keys operations to RKeys object
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi,
when i put the "toto" object in the MAP there is no problem but when i do a get operation i get an exception
error when deserialize object, simply because i used jackson for other operation and i forced property to "type"
@JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="type")
public abstract class toto{
}

Exception :
Caused by: com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (END_OBJECT), expected FIELD_NAME: missing property '@class' that is to contain type id  (for class java.lang.Object)
 at [Source: io.netty.buffer.ByteBufInputStream@26c2e23; line: 1, column: 621]
at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)
at com.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:927)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:151)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:103)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:167)
at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:500)
at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:42)
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3564)
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2650)
at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:101)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:167)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:370)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Introduce redisson-all.jar to have ability to run it as standalone node.

Add isAnonymousClass checking for Runnable param
Add ability to inject RedissonClient object into task
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add slot checking for MasterSlaveEntry. Fire an error if correspond entry for slot not found.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this would be nice
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add links to object interfaces
Add low-level Redis client usage example
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you add ping in Redisson which helps in healthcheck?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Was wondering if its possible to include RSortedSet as part of batch commands
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh, big Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks in advance :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson redisson = getClient();
    RTopic<String> topic = redisson.getTopic("__keyevent@0__:expired");
    topic.addListener(new MessageListener<String>() {
        @Override
        public void onMessage(String channel, String msg) {
            // no output,but redis-cli command line tool can work
            System.out.println(channel);
            System.out.println(msg);
        }
    });

    RBucket<String> bucket = redisson.getBucket("message");
    bucket.set("someValue", 1, TimeUnit.SECONDS);
    Thread.sleep(1000 * 10);
    redisson.shutdown();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Cluster mode Redisson client running out of files (sockets) in communicating with Redis.
This occurs even when the Redisson client is not receiving any requests.  It must be a problem with cluster mode connectivity.
To reproduce, I simply made two calls to my server using Redisson to set a simple value on Redis and then retrieve a simple value.  Then we did nothing at all.
It appears the Redisson in cluster mode is continually opening new socket connections but not closing existing ones.
After about an hour, we started seeing the following exceptions in our server logs.
Note:  I am may have seen a similar behavior in sentinel mode.  We recently upgraded Redisson to 2.1.0 from 1.1.5.  Could this be a more general problem?  We will upgrade to 2.1.1 and test again.
Thank you very much.
--Michael

test machine
Aug 14, 2015 8:49:18 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run
SEVERE: Socket accept failed
java.net.SocketException: Too many open files
at java.net.PlainSocketImpl.socketAccept(Native Method)
at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:398)
at java.net.ServerSocket.implAccept(ServerSocket.java:530)
at java.net.ServerSocket.accept(ServerSocket.java:498)
at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)
at java.lang.Thread.run(Thread.java:745)
Aug 14, 2015 8:49:18 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run
SEVERE: Socket accept failed
java.net.SocketException: Too many open files
at java.net.PlainSocketImpl.socketAccept(Native Method)
at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:398)
at java.net.ServerSocket.implAccept(ServerSocket.java:530)
at java.net.ServerSocket.accept(ServerSocket.java:498)
at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)
at java.lang.Thread.run(Thread.java:745)
Aug 14, 2015 8:49:18 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run

Connections on the Redis server continually increase:
[root@qa-mq01.artfact.local ~ $ date; netstat -an | grep 192.168.10.135 | wc -l
Tue Aug 18 09:55:51 EDT 2015
2523
[root@qa-mq01.artfact.local ~ $ date; netstat -an | grep 192.168.10.135 | wc -l
Tue Aug 18 09:56:04 EDT 2015
2536
[root@qa-mq01.artfact.local ~ $ date; netstat -an | grep 192.168.10.135 | wc -l
Tue Aug 18 10:12:13 EDT 2015
3490

Another instance just now from the test machine
Aug 18, 2015 10:29:36 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run
SEVERE: Socket accept failed
java.net.SocketException: Too many open files
at java.net.PlainSocketImpl.socketAccept(Native Method)
at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:398)
at java.net.ServerSocket.implAccept(ServerSocket.java:530)
at java.net.ServerSocket.accept(ServerSocket.java:498)
at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)
at java.lang.Thread.run(Thread.java:745)
Aug 18, 2015 10:29:36 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run
SEVERE: Socket accept failed
java.net.SocketException: Too many open files
at java.net.PlainSocketImpl.socketAccept(Native Method)
at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:398)
at java.net.ServerSocket.implAccept(ServerSocket.java:530)
at java.net.ServerSocket.accept(ServerSocket.java:498)
at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)
at java.lang.Thread.run(Thread.java:745)
Aug 18, 2015 10:29:36 AM org.apache.tomcat.util.net.JIoEndpoint$Acceptor run
SEVERE: Socket accept failed
java.net.SocketException: Too many open files
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a reason that RCountDownLatch doesn't implement RExpirable? I'd like to be able to create a CountDownLatch that goes to 0 or is deleted if countDown isn't called the desired number of times before a timeout.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It seems that in the following test, RObject#delete() will always return false, even though it appears the delete call should be synchronous.
public class TryRedisson {

  private Redisson redisson;

  @Before
  public void setupRedisson() {
    Config config = new Config();
    config.useSingleServer().setAddress("127.0.0.1:6379");
    this.redisson = Redisson.create(config);
  }

  @Test
  public void testRedissonLockTimeout() throws InterruptedException {
    String id = UUID.randomUUID().toString();
    RCountDownLatch latch = redisson.getCountDownLatch(id + "-latch");
    boolean deleted = latch.delete();
    assertTrue(deleted);
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Duplicate to #226
:)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sorry，you can delete this pull request. I operate error.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: ERR Error running script (call to f_2d027cdc209d32fe7dade9ba284110f88d497180): @user_script:1: WRONGTYPE Operation against a key holding the wrong kind of value . channel: [id: 0x24baaaa8, /192.168.99.1:64875 => /192.168.99.100:6379]
ENV: redis 3.0.3/2.8.3
REDISSON: 2.1.1/1.3.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do you encounter any problem without it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use redisson 2.1.3 the ubuntu's load average is 1.8 ~ 2.3; but I use 2.1.4 or greater, the load average is often greater than 3.00, my java application often overload.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version 2.2.3 under load doing simple asynchronous set operation with small string value is running out of heap.  Heap dump shows a large number of promise objects.  I will post more details soon.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Aliyun(http://www.aliyun.com/?spm=5176.383338.278239.2.N5cZbC&lang=en) redis use redis v2.8.19 and not support LUA script(eg. command EVAL EVALSHA SCRIPT EXISTS SCRIPT FLUSH SCRIPT KILL SCRIPT LOAD),  Redisson's RLock RList RMap use EVAL command, so I
can not use Redisson in the Aliyun redis.
How can I do a branch from  redisson v2.1.3 and remove the LUA script to resolve this problem ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RBucket bucket = redis.getBucket("aa");
bucket.set("aaa");
bucket.expire(10, TimeUnit.SECONDS);
RTopic topic = redis.getTopic("keyevent@0:expired");
topic.addListener(new MessageListener(){
@OverRide
public void onMessage(String channel, String msg) {
log.debug(channel+":"+msg);
}
});
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. (io.netty.channel.DefaultChannelPipeline)
io.netty.handler.codec.DecoderException: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'aa': was expecting ('true', 'false' or 'null')
at [Source: io.netty.buffer.ByteBufInputStream@1f3211c1; line: 1, column: 5]
Is it an issue ? or a mistake made by me? thx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
config.setCodec(StringCodec.INSTANCE);
...
RedissonClient redisson = Redisson.create(config);
......
lock.tryLock();

............................
Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
at org.redisson.RedissonLock$1.onMessage(RedissonLock.java:95)
at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:67)
at org.redisson.client.handler.CommandDecoder.handleMultiResult(CommandDecoder.java:263)
at org.redisson.client.handler.CommandDecoder.decodeMulti(CommandDecoder.java:228)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:203)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:100)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:370)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
can you add this feature with load balance control between serveral slaves.
this is important when the cluster have non uniform performance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonBlockingQueue#pollLastAndOfferFirstTo(String queueName, long timeout, TimeUnit unit) does not seem to behave as defined in http://redis.io/commands/brpoplpush
I'm expecting the invocation in this piece of code to block until there is an element in myqueue. Instead it continues after 1 second and returns null.
RBlockingQueue<Object> queue = redisson.getBlockingQueue("myqueue");
Object obj = queue.pollLastAndOfferFirstTo("myotherqueue", 0, TimeUnit.SECONDS);
// stops blocking after 1 second
System.out.println(obj); // "null"
a different time interval doesn't change the behavior either.
i've also tried using the lower level functions:
Future<T> res = commandExecutor.writeAsync(name, connectionManager.getCodec(), BRPOPLPUSH, name, otherName, 10);
res.get();
this should wait 10 seconds before returning null on an empty list, however it fails because of a RedisTimeoutException
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a simple code:

    Config config = new Config();
config.setCodec(new JsonJacksonCodec());
    config.useSingleServer().setAddress("127.0.0.1:6379");

    RedissonClient redisson = Redisson.create(config);

    RMap<String, Integer> map = redisson.getMap("getAll");
    map.put("str", 100);

    Integer res = map.addAndGet("str", 12);
    System.out.println(res);
    res = map.get("str");
    System.out.println(res);

    RMap<String, Double> map2 = redisson.getMap("getAll2");
    map2.put("str", new Double(100.2));

    Double res2 = map2.addAndGet("str", new Double(12.1));
    System.out.println(res2);
    res2 = map2.get("str");
    System.out.println(res2);

    redisson.shutdown();

    Look at the attach picture..RMap<String, Integer> generate two key:str and "str", It seems to be a bug..But RMap<Integer, Integer> will be all right..
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the error like this:
"ERR unknown command eval. channel: [id: 0x73e1562f, /10.47.102.114:35465 => 126748df08bd4eea.m.cnhza.kvstore.aliyuncs.com/100.99.113.11:6379] command: CommandData [promise=DefaultPromise@40a65eef(incomplete), command=(EVAL), params=[local v = redis.call('hget', KEYS[1], ARGV[1]); redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); return v, 1, loginInfo, admin, com.expresscne.parcelconfig.data.model.UserAndPermission.UserPermissionObject@175b609e], codec=org.redisson.codec.JsonJacksonCodec@5bcaeaef]",
"path": "/system/userPermissionEndPoint"
I ask Ali's tech support about it. He told me this issue was caused by AliyunRedis not supported EVAL operation.
How can I do?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here is the code:
RMap<String, Objcet> pool = redisson.getMap("test");
    Iterator<String> iterator = pool.keyIterator();
    while (iterator.hasNext()) {
        System.out.println(key);
    }

the loop is endless!!! I am sure there is only one Object in this map because program prints same key in the console !!
How to deal with it!?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the  public Future putIfAbsentAsync(K key, V value)
return null or value , can you  add  fastPutIfAbsent  return 0 or 1 for fast put?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use RedisAtomicDouble with spring data redis ,but redisson only implement RedissonAtomicLong
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
these codes will throw NullPointerException. but data has save into redis
127.0.0.1:6379[1]> keys *

"A3":

    Config config = new Config();
    //config.setCodec(StringCodec.INSTANCE);
    config.useSentinelServers()
            .setMasterName("mymaster")
            .setDatabase(1)
            .setMasterConnectionPoolSize(200)
            .setSlaveConnectionPoolSize(200)
            .setTimeout(6000)
            .addSentinelAddress("127.0.0.1:26379");
    RedissonClient redisson = Redisson.create(config);
    RBatch batch = redisson.createBatch();
    batch.getBucket("A1").setAsync("001");
    batch.getBucket("A2").setAsync("001");
    batch.getBucket("A3").setAsync("001");
    batch.getKeys().deleteAsync("A1");
    batch.getKeys().deleteAsync("A2");
    List result = batch.execute();

but these codes work properly.：
    redisson.getBucket("A1").setAsync("1");
    redisson.getBucket("A2").setAsync("2");
    redisson.getBucket("A3").setAsync("3");
    redisson.getKeys().deleteAsync("A1");
    redisson.getKeys().deleteAsync("A2");

io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:425)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:556)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:406)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:282)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:190)
at org.redisson.client.handler.CommandDecoder.handleCommandsDataResponse(CommandDecoder.java:136)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:370)
... 18 more
Exception in thread "main" org.redisson.client.RedisTimeoutException: Redis server response timeout during command batch execution. Channel: [id: 0xa75e9bb2, /127.0.0.1:6213 => /127.0.0.1:6379]
at org.redisson.command.CommandBatchService$6.run(CommandBatchService.java:319)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:581)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:655)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:367)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can you add the method in RList?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
http://redis.io/commands/smove
I think this would be a good addition to the RSet family.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
oh, how can i miss so useful command?! Thanks a lot for your contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
    config.setCodec(StringCodec.INSTANCE);
    config.useSentinelServers()
            .setMasterName("mymaster")
            .setDatabase(1)
            .setMasterConnectionPoolSize(200)
            .setSlaveConnectionPoolSize(200)
            .setTimeout(6000)
            .addSentinelAddress("192.168.1.200:26379");
    RedissonClient redisson = Redisson.create(config);

    RMap<String, String> rmap = redisson.getMap("TestRMap01");
    rmap.delete();
    rmap.put("A", "1");
    rmap.put("B", "1");

    System.out.println("************** *****************");
    System.out.println("A:" + rmap.get("A"));
    System.out.println("B:" + rmap.get("B"));

    System.out.println("************** *****************");
    Iterator<Map.Entry<String, String>> iterator = rmap.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> next = iterator.next();
        System.out.println(next.getKey() + ":" + next.getValue());
    }

    redisson.shutdown();

these codes work right in 2.2.4,but  in 2.2.5 will throw Exception:
Exception in thread "main" io.netty.util.IllegalReferenceCountException: refCnt: 0
at io.netty.buffer.AbstractByteBuf.ensureAccessible(AbstractByteBuf.java:1177)
at io.netty.buffer.AbstractByteBuf.checkIndex(AbstractByteBuf.java:1120)
at io.netty.buffer.AbstractByteBuf.getByte(AbstractByteBuf.java:337)
at io.netty.buffer.ByteBufUtil.hashCode(ByteBufUtil.java:188)
at io.netty.buffer.AbstractByteBuf.hashCode(AbstractByteBuf.java:1077)
at java.util.HashMap.hash(HashMap.java:338)
at java.util.HashMap.put(HashMap.java:611)
at org.redisson.RedissonMapIterator.convert(RedissonMapIterator.java:66)
at org.redisson.RedissonMapIterator.hasNext(RedissonMapIterator.java:53)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am trying to connect to redis using RedissonClient. When I create the client without any configuration it works. However, whenever I try to pass the configuration as parameter it gives the following error,
" org.redisson.client.RedisConnectionException: Can't init enough connections amount! from /127.0.0.1:6397"
By default it is using the same port and host. But when I try to enter it using the config param it gives me the error.
Following is the code snippet,
Config config = new Config();
String address = "127.0.0.1:6397";
config.useSingleServer().setAddress(address).setConnectionPoolSize(10);
client = Redisson.create(config);
Redis version : 3.0.6
Redisson version: 2.2.4
Jdk 1.8
Any suggestion?
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonSet  has toArray() method to invoke readAllAsync (SMEMBERS) , it is return Arrays.
I want add a method directly return Set or List to local, then I can use these collections in local, don't need to access the redis anymore.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: org.redisson.client.RedisConnectionException: Can't init enough connections amount! from /192.168.1.87:6379
This exception  appeared sometimes.
who can tell me how to solve this problerm?
server:redis-3.0.6
client:redisson2.2.5
 public Redisson getMasterSlaveClient(String addr, String hosts) {
        Config config = new Config();
        String[] hostarr = hosts.split(",");
        config.useMasterSlaveServers().setMasterAddress(addr).setLoadBalancer(
            new RandomLoadBalancer()) 
.addSlaveAddress(hostarr).setMasterConnectionPoolSize(10000).setSlaveConnectionPoolSize(
            10000).setConnectTimeout(2000);
        Redisson redisson = (Redisson)Redisson.create(config);
        return redisson;
    }
stacktrace:
Caused by: org.redisson.client.RedisConnectionException: Can't init enough connections amount! from /192.168.1.87:6379
    at org.redisson.misc.ConnectionPool$2.operationComplete(ConnectionPool.java:95)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
    at io.netty.util.concurrent.DefaultPromise$2.run(DefaultPromise.java:592)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:358)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am trying to connect to the localhost redis client as follows:
RedissonClient redisson = Redisson.create();
But I do get the following error, not sure what is the issue.
Thanks for your help.
SEVERE: Servlet.service() for servlet [XXXServlet] in context with path [] threw exception [Filter execution threw an exception] with root cause
java.lang.NoClassDefFoundError: Could not initialize class org.redisson.codec.JsonJacksonCodec
at org.redisson.Config.(Config.java:62)
at org.redisson.Redisson.(Redisson.java:89)
at org.redisson.Redisson.create(Redisson.java:130)
at org.redisson.Redisson.create(Redisson.java:120)
at .xxxx.filter.XXXFilter.doFilter(XXXFilter.java:154)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98)
at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:950)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)
at org.apache.coyote.ajp.AjpProcessor.process(AjpProcessor.java:193)
at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:607)
at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:313)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi.
I want to use this -> http://redis.io/topics/cluster-spec#multiple-keys-operations
but when cluster mode, RedissonClient#loadBucketValues return unsupported error.
how can I use it?
thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when i tried with codes below
Config config = new Config();
config.useClusterServers().setPassword("pass01").setScanInterval(3000)
.addNodeAddress("192.22.1.189:3382");
RedissonClient redisson = Redisson.create(config);
RList strList = redisson.getList("strList");
i got this exception
Exception in thread "main" org.redisson.client.RedisException: NOAUTH Authentication required.. channel: [id: 0x236ed784, /192.20.178.31:62174 => /192.22.1.189:3382] command: CommandData [promise=DefaultPromise@294633e1(incomplete), command=(CLUSTER NODES), params=[], codec=null]
and i debuged into redisson code ,it seems exception is throwed when doing a sync operation while creating a ClusterConnectionManager,
public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
    isReadFromSlaves = cfg.isReadFromSlaves();
    connectListener = new ClusterConnectionListener(cfg.isReadFromSlaves());
    init(config);

    this.config = create(cfg);
    init(this.config);

    for (URI addr : cfg.getNodeAddresses()) {
        RedisConnection connection = connect(cfg, addr, true);
        if (connection == null) {
            continue;
        }

        String nodesValue = connection.sync(RedisCommands.CLUSTER_NODES);//throws here

....
my redisson version is 2.2.5
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using this client in a dropwizard service and I want to add a healthcheck. Jedis has a PING command, here using the RedissonClient I can't issue a ping command. I need to create a instance of RedisClient for the same. I should be able to retrieve instance of RedisClient from RedissonClient, or suggest me a way to perform a healthCheck for the same.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From @jackygurui: Since there are still people prefers to just use hazelcast as cluster manager but use redisson for other tasks, it would be wise to make redisson cluster manager implementation into a sparate jar and use can just pick and choose themselves.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my config as following:
jdk1.6
redisson 2.2.5
Caused by: org.redisson.client.RedisConnectionException: Can't connect to servers!
at org.redisson.cluster.ClusterConnectionManager.(ClusterConnectionManager.java:91)
at org.redisson.Redisson.(Redisson.java:97)
at org.redisson.RedissonExt.(RedissonExt.java:73)
at org.redisson.RedissonExt.create(RedissonExt.java:41)
... 1 more
ClusterConnectionManager.java
if (lastPartitions.isEmpty()) {
throw new RedisConnectionException("Can't connect to servers!");
}
before if (lastPartitions.isEmpty()) ,  maybe  lastPartitions is not initialed ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: org.redisson.client.RedisException: ERR unknown command 'SELECT'. channel: [id: 0x9d9fb2c3, /192.168.1.112:7378 => /192.168.1.200:26379] command: CommandData [promise=DefaultPromise@36a98b5d(incomplete), command=(SELECT), params=[1], codec=null]

i do "mvn clean" before start tomcat
redis version：Redis-x64-3.0.500
private RedissonClient createRedissonClient() {
    Config config = new Config();
    config.setCodec(objectCodec);
    config.useSentinelServers()
            .setMasterName(this.masterName)
            .setDatabase(this.database)
            .setMasterConnectionPoolSize(this.masterConnectionPoolSize)
            .setSlaveConnectionPoolSize(this.slaveConnectionPoolSize)
            .setTimeout(this.timeout)
            .addSentinelAddress(sentinelAddress);
    RedissonClient redisson = Redisson.create(config);
    return redisson;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
build CacheConfig Map is hard and more code，I expect use these config:
<bean id="redisCacheManager" class="org.redisson.spring.cache.RedissonCacheManager"
      c:_0-ref="redisson"
      c:_1-ref="myCustomCodec"
      c:_2="classpath*:/redissonCacheConfig.json">
</bean>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Those methods were deleted in a07e4d4ebdf0a2c2436942c8e537eebe48aee7f5 commit.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
config.useSentinelServers()
    .setMasterName("mymaster")
    .addSentinelAddress("127.0.0.1:26389");
Redisson redisson = Redisson.create(config);

if there are no slaves on SentinelConnectionManager:82 we have a List<Map<String, String>> sentinelSlaves = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SLAVES, cfg.getMasterName()); which returns just Map not List of Maps.
So, the exception I get is:
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1014)
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:545)
... 41 more
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is java.lang.ClassCastException: java.util.HashMap cannot be cast to java.util.List
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)
... 53 more
Caused by: java.lang.ClassCastException: java.util.HashMap cannot be cast to java.util.List
at org.redisson.connection.SentinelConnectionManager.(SentinelConnectionManager.java:82)
at org.redisson.Redisson.(Redisson.java:96)
at org.redisson.Redisson.create(Redisson.java:131)
at com.atl.csc.conf.RedisConfig.redissonClient(RedisConfig.java:122)
You may argue that it is not correct if there are no slaves, but, this cut config is used on test machines and not on production (which is fully configured with slaves). So, would be nice to handle this error.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
            config.useSentinelServers()
                  .setRetryInterval(redisReconnectDelay.get())
                  .setMasterConnectionPoolSize(redisConnectionPoolSize.get())
                  .setTimeout(redisTimeout.get())
                  .setRetryAttempts(redisRetryCount.get())
                  .setSlaveConnectionPoolSize(redisConnectionPoolSize.get())
                  .setPassword(redisPassword)
                  .setMasterName(redisMasterName.get());

            // Add sentinel server addresses
            for (String sentinelServerAddress : redisSentinelServers.get().split("\\s*,\\s*")) {
                config.useSentinelServers().addSentinelAddress(sentinelServerAddress);
            }

 ...
 redisson = Redisson.create(config);
Stacktrace:
11:53:31.747-main-INFO o.r.Version:42 - Redisson 2.2.7

org.redisson.client.RedisException: ERR unknown command 'AUTH'. channel: [id: 0xfa3297ed, /192.168.0.2:55117 => redis01.ops.aol.com/192.168.0.3:26379] command: CommandData [promise=DefaultPromise@4b8a3643(incomplete), command=(AUTH), params=[PASSWORD_REMOVED], codec=null]
    at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:190)
    at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:105)
    at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:376)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
11:53:32.049-main-ERROR c.a.u.RedisConnectionProvider:184 - ERR unknown command 'AUTH'. channel: [id: 0xfa3297ed, /192.168.0.2:55117 => redis01.ops.aol.com/192.168.0.3:26379] command: CommandData [promise=DefaultPromise@4b8a3643(incomplete), command=(AUTH), params=[PASSWORD_REMOVED], codec=null]
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)

    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:840)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
    at java.lang.Thread.run(Thread.java:745)

java.lang.ExceptionInInitializerError
    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
    at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
    at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: java.lang.RuntimeException: Failed to connect to redis sentinel servers redis01.ops.aol.com:26379,redis02.ops.aol.com:26379,redis03.ops.aol.com:26379
    at com.aol.util.RedisConnectionProvider.connect(RedisConnectionProvider.java:194)
    at com.aol.util.RedisConnectionProvider.config(RedisConnectionProvider.java:129)
    at com.aol.util.RedisConnectionProvider.getInstance(RedisConnectionProvider.java:92)
    at com.aol.ido.aws.config.ServiceConfig.<init>(ServiceConfig.java:82)
    at com.aol.ido.aws.TestBase.<clinit>(TestBase.java:153)
    ... 25 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi mrniko,
since upgrading to 2.2.6 from 2.1.4, suddenly the Rmap only returns 10 elements - although it reports size correctly to 1000. Below is my test scenario - please help! I have attached output log.
Map<String, Object> properties = new HashMap<>();
properties.put("redis.hostname", "127.0.0.1");
properties.put("redis.port", "6379");
properties.put("redis.pool.size", "100");
properties.put("redis.compression", "false");
properties.put("redis.localslave", "false");
properties.put("redis.registration", "true");
    RedissonRepository redissonRepository = RedissonRepository.getInstance(properties);
    RMap rMap = redissonRepository.getMap("123",new JsonJacksonCodec());

    for (int i = 0; i < 1000; i++) {
        rMap.put(i,i);
    }

    int counter = 0;
    for (Object key : rMap.keySet()) {
        System.out.println("key = " + key);
        counter++;
        System.out.println(counter);
    }

redisson.txt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks a lot!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I want to stop receiving the default debug logs in my tomcat logs, how do I change the log level?
Sorry for the noob question, thanks in advance!
Regards,
Balaji B R
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Doing some load testing I found that this line:
exceptionRef.set(new RedisTimeoutException("Command execution timeout for command: " + command + " with params: " + Arrays.toString(params)));
in CommandExecutorService can do a lot of string allocation and generate garbage. Could this exception be improved so the array is only built when necessary?
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Methods to get master and slave nodes are needed too.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Oh, I missed that! Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
But checkstyle plugin already plugged
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
When I am trying to read all the values of set I get the following exception. Let me know if you require more details.
Version: 2.2.7
Code:
RSet set = redisson.getSet(setname);
Set members = set.readAll();
Exception in thread "main" org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:222)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:88)
at org.redisson.RedissonObject.get(RedissonObject.java:49)
at org.redisson.RedissonSet.readAll(RedissonSet.java:154)
at RedisHelper.getMembersOfSet(RedisHelper.java:218)
at RedisHelper.main(RedisHelper.java:596)
Caused by: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'png': was expecting ('true', 'false' or 'null')
at [Source: io.netty.buffer.ByteBufInputStream@6bbd4bac; line: 1, column: 7]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1581)
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:533)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._reportInvalidToken(UTF8StreamJsonParser.java:3451)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._handleUnexpectedValue(UTF8StreamJsonParser.java:2610)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:841)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:737)
at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:3776)
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3721)
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2796)
at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:68)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:201)
at org.redisson.client.handler.CommandDecoder.decodeMulti(CommandDecoder.java:220)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:210)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:105)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:376)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:840)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:745)
Feb 11, 2016 5:18:26 PM io.netty.channel.DefaultChannelPipeline$TailContext exceptionCaught
WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:431)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:244)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:307)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:293)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:840)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
at org.redisson.client.handler.CommandDecoder.decoder(CommandDecoder.java:317)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:201)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:96)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:376)
... 18 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my OS is win7, so i use MSOpenTech/redis 3.0.1 and running redis under cluster mode.
i learn from redisson topic and use redisson.getTopic("anyTopic"), it is working well.
but only redisson.getTopic("connect") not working!?
i changed redisson.getTopic("connect") to redisson.getTopic("connected") or use redissonConfig.useSingleServer() it is still working well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Race-condition during ack checking is possible. For example, ack timeout = 1000 ms:

worker receives Request in 999 ms sends ack, but it comes in 1010ms or something like that.
client checks ack in 1000 ms and throws RemoteServiceAckTimeoutException
worker invokes method

To solve this problem ackObject was introduced. Worker or client set it to 1 via SETNX command. Worker set it during ack sending. Client during ack receiving.
Client check ackObject only if ack timeout has occurred. If client can't set it means that worker have done it already. So client should poll an element from queue again.
If worker can't set ackObject then it means that ack timeout already occurred on client side and invocation should skipped.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was in a hurry. Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Finally we have finished it! :D
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After updating to version 2.2.14 RKeys.getKeysByPattern is doing infinite scans when there is not even 1 key by this pattern. It was working fine earlier.
1464601787.027739 [0 127.0.0.1:53406] "SCAN" "14" "MATCH" "XXX__"
1464601787.027892 [0 127.0.0.1:53405] "SCAN" "0" "MATCH" "XXX__"
1464601787.028022 [0 127.0.0.1:53401] "SCAN" "14" "MATCH" "XXX__"
1464601787.028161 [0 127.0.0.1:53402] "SCAN" "0" "MATCH" "XXX__"
1464601787.028317 [0 127.0.0.1:53407] "SCAN" "14" "MATCH" "XXX__"
1464601787.028456 [0 127.0.0.1:53406] "SCAN" "0" "MATCH" "XXX__"
1464601787.028631 [0 127.0.0.1:53405] "SCAN" "14" "MATCH" "XXX__"
1464601787.028775 [0 127.0.0.1:53401] "SCAN" "0" "MATCH" "XXX__"
1464601787.028944 [0 127.0.0.1:53402] "SCAN" "14" "MATCH" "XXX__"
1464601787.029096 [0 127.0.0.1:53407] "SCAN" "0" "MATCH" "XXX__"
1464601787.029262 [0 127.0.0.1:53406] "SCAN" "14" "MATCH" "XXX_*"
It works fine when there is at least 1 key with this pattern
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When redis master-slave switch,my project throw exception.
org.redisson.client.RedisTimeoutException: Redis server response timeout (10000 ms) occured for command: (EVAL) with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; return redis.call('pttl', KEYS[1]);, 1, carreport:triggerTasklock, 60000, ac3e8c0c-ae1c-4e4f-8276-fb521dfb9db2:59] channel: [id: 0x4b899b90, /172.31.11.194:53918 => /172.31.11.129:7001]
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:475) ~[redisson-2.2.8.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:581) ~[netty-common-4.0.34.Final.jar:4.0.34.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:655) ~[netty-common-4.0.34.Final.jar:4.0.34.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:367) ~[netty-common-4.0.34.Final.jar:4.0.34.Final]
at java.lang.Thread.run(Thread.java:745) ~[na:1.7.0_60]
I ues redisson 2.2.8 and cluster mode.
Thank you very much.
--Marck
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps:

Redis Server up.
Client is up connecting and connected to Redis Server. It required AUTH password
Redis Server down and passed the failedAttemps, so the server is excluded.
Redis goes back up
Client is trying to reconnect, but the mechanism to check if server is alive is broken for password protected server.

I think the following line of code can be improved by including authentication:
https://github.com/mrniko/redisson/blob/master/src/main/java/org/redisson/connection/pool/ConnectionPool.java#L329
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am getting below error while creating instance of config through json ObjectMapper.
Exception in thread "main" com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property "masterAddress": org.redisson.MasterSlaveServersConfig#setMasterAddress(1 params) vs org.redisson.MasterSlaveServersConfig#setMasterAddress(1 params)
I tried both yml and json but still facing the same issue with both.
Please let me know, what I am missing in config.
Thanks,
Sid
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
map.keySet().size() should be used instead, but it seems it doesn't work. I will fix it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add TYPE command RKeys interface
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm using Redisson version2.1.5. Writing (Synchronously) to Redis has failed without throwing an exception. Is there any known issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The current JacksonJsonCodec embeds the class information into the json payload, therefore coupling the redis data with the java client.
What do you think about me adding a codec dedicated to a specific type, so we can get away with clean json?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2016-06-23 19:59:45,137 ERROR [nioEventLoopGroup-2-1] io.netty.util.ResourceLeakDetector Slf4JLogger.java:171 error LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 2
#2:
    io.netty.buffer.AdvancedLeakAwareByteBuf.toString(AdvancedLeakAwareByteBuf.java:741)
    org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:212)
    org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114)
    io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:368)
    io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:243)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:335)
    io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:327)
    io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:335)
    io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:327)
    io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1336)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:335)
    io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:911)
    io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
    io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:544)
    io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:485)
    io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:399)
    io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:371)
    io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742)
    io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:145)
    java.lang.Thread.run(Thread.java:745)

#1:
    io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:603)
    io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:827)
    io.netty.handler.codec.ReplayingDecoderByteBuf.readBytes(ReplayingDecoderByteBuf.java:577)
    org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:212)
    org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114)
    io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:368)
    io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:243)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:335)
    io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:327)
    io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:335)
    io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:327)
    io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1336)
    io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You don't need -DtravisEnv=true if you are running the test locally.
-DtravisEnv=true is a flag to trigger the surefire to stop redis server and redisson instance at the end of each single test case and start a fresh instance before starts the next test case. With out the flag, the surefire will just do a db flush to reset the redis back to initial state.
This is necessary in travis environment because flush db seems to take really long time and may cause timeout exception randomly.
I apologies not have included any info in a document.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm building a real-time text based chat program where people can chat with ONLY 1 other person.
Each person can chat with 1 other person, but the aim is they can chat with Many people at once. (i.e. MANY one to one chats with different people). The aim is to have it scaleable, not necessarily to snapchat's level, but enough for 1 City.
I'm just wondering what is more scaleable:

Having 1 channel for the entire application and filtering who the message is for and who sent the message based on the data encoded in the message

OR

Having 1 channel for each person and all the different people sending messages to that person send their messages through that channel with data encoding who sent the message

OR

Have an individual channel for EACH Chat between 2 people.

OR

For Option 1 (1 channel for entire app), perhaps an intermediate solution of having 1 channel per city.

I'm wondering what approach is best for Java and Redis. If there is no clear cut answer, what the conditions/criteria are for making the decision.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If you create a RMapCache with a TTL entry then delete the map, the idle_set is left behind.  This should be deleted too.
E.g.  On a clean redis instance, this leaves the ZSET redisson__idle__set__{testRMapCacheValues}
    final RMapCache<String, String> map = redis.getMapCache( "testRMapCacheValues" );
    try
    {
        map.put( "1234", "5678", 0, TimeUnit.MINUTES, 60, TimeUnit.MINUTES );

        System.out.println( map.values() );
    }
    finally
    {
        map.delete();
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
500 num cur time
org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (PUBLISH) with params: [dispatch_except, com.corundumstudio.socketio.store.pubsub.DispatchMessage@11dd736] channel: [id: 0xd8161b77, L:/10.1.5.114:9741 - R:10.1.6.20/10.1.6.20:7091]
at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:510) ~[redisson-2.2.17-SNAPSHOT.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:581) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:655) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:367) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at java.lang.Thread.run(Thread.java:745) [na:1.7.0_65]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi! Thanks for your PR! But I don't see changes for RSetReactive class
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to utilize ConnectionListener to monitor connections to redis servers. The way I add connection listener is pretty similar to the sample code showing in wiki 9.1:
NodesGroup nodesGroup = redisson.getNodesGroup();
nodesGroup.addConnectionListener(new ConnectionListener() {
    public void onConnect(InetSocketAddress addr) {
       // Redis server connected
    }
    public void onDisconnect(InetSocketAddress addr) {
       // Redis server disconnected
    }
});

The way I test it:

start two redis server on port 6379, 6380, let server on port 6380 to be the slave
setup and start redis client. I am using ElasticacheServersConfig here.
Once all connections are stable, kill redis master server and check output.

However, what I saw is onDisconnect() of my listener is never invoked after I shut down my redis server. If I restart my redis server again, I can see connectionEventHub.fireConnect() is called. But since the check maps.get(addr) == Status.CONNECTED always return true, my listener.onConnect() is also not invoked.
Can anybody help explain why this happens? Did I misunderstand what connection listeners should be used for? Thanks in advance.
The version I am using is redisson-2.2.13
Below is the console output after master is down.
DEBUG [2016-07-05 20:19:31,715] org.redisson.connection.ElasticacheConnectionManager: Current master: //127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,924] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@274136027 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0x767c23f5, 0.0.0.0/0.0.0.0:56141]] to /127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,925] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@315015763 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0xe02beb0c, 0.0.0.0/0.0.0.0:56145]] to /127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,925] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@37417717 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0xba92b187, 0.0.0.0/0.0.0.0:56146]] to /127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,926] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@1396687106 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0x4d0ceba1, 0.0.0.0/0.0.0.0:56143]] to /127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,926] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@1472480975 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0x3fa13888, 0.0.0.0/0.0.0.0:56144]] to /127.0.0.1:6379
DEBUG [2016-07-05 20:19:31,926] org.redisson.client.handler.ConnectionWatchdog: reconnecting RedisConnection@505461609 [redisClient=[addr=/127.0.0.1:6379], channel=[id: 0x3e7120a1, 0.0.0.0/0.0.0.0:56142]] to /127.0.0.1:6379
ERROR [2016-07-05 20:19:32,718] org.redisson.connection.ElasticacheConnectionManager: Command execution timeout for /127.0.0.1:6379
! org.redisson.client.RedisTimeoutException: Command execution timeout for /127.0.0.1:6379
! at org.redisson.client.RedisConnection.await(RedisConnection.java:128) ~[redisson-2.2.13.jar:na]
! at org.redisson.client.RedisConnection.sync(RedisConnection.java:147) ~[redisson-2.2.13.jar:na]
! at org.redisson.connection.ElasticacheConnectionManager$1.run(ElasticacheConnectionManager.java:134) ~[redisson-2.2.13.jar:na]
! at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_92]
! at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:126) [netty-all-4.0.34.Final.jar:4.0.34.Final]
! at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:236) [netty-all-4.0.34.Final.jar:4.0.34.Final]
! at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137) [netty-all-4.0.34.Final.jar:4.0.34.Final]
! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_92]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I met similar problem these days online  used  of sub/pub.
org.redisson.client.RedisConnectionException: Connection pool exhausted!  Disconnected hosts: [10.25.63.47/10.25.63.47:7091]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:169) ~[redisson-2.2.17.jar:na]
at org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:25) ~[redisson-2.2.17.jar:na]
at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:371) ~[redisson-2.2.17.jar:na]
at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:600) ~[redisson-2.2.17.jar:na]
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:401) ~[redisson-2.2.17.jar:na]
at org.redisson.command.CommandAsyncService$7.run(CommandAsyncService.java:450) ~[redisson-2.2.17.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:581) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:655) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:367) ~[netty-common-4.1.0.Final.jar:4.1.0.Final]
at java.lang.Thread.run(Thread.java:745) [na:1.7.0_65]
The version I use is 2.2.17, I have 2 redis server, one master and one slave, in sentinel mode. It is in test environment so net work and cpu usage is low.
This error appears about every 1 day.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My program often occured the following error：
Redis server response timeout (3000 ms) occured for command: (GET) with params: [434674] channel: [id: 0xa1712254, L:/10.10.10.30:44844 - R:yygz-40.gzserv.com/10.10.10.40:6379
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello!
Thank you for using Travis CI for your testing needs.
We noticed, however, that currently this repository configures 180 jobs for each push. This puts undue burden on the system, not to mention long waits for each build to complete.
I have marked the user @mrniko as an offender to prevent further queueing of builds from this repository at this time.
I apologize for the inconvenience. Please send email to support@travis-ci.com when the jobs are sufficiently consolidated.
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@lefay1982 please rebase your changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I started getting RedisTimeoutException("Command execution timeout for command") for put operation on RMap. I have been using Redisson in production for 6 months. I'm seeing this exception now. I'm using Sentine mode with the following configuration.
Timeout : 5s
RetryInterval: 5s
RetryAttempts:5
What could be the reason for it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Starting from netty 4.0.38 java.lang.UnsupportedOperationException occurs during command batch usage. This is issue related to netty/netty#5581
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Because of this issue RemoteServiceAckTimeoutException could be thrown prior the end of ackTimeout
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The map is a regular <Integer, String> map, and by calling a get on some key we see the following thread trace:
{code}
"catalina-exec-140" #1291 daemon prio=5 os_prio=0 tid=0x00007fa0f0c21000 nid=0x7977 waiting on condition [0x00007fa0df19a000]
java.lang.Thread.State: WAITING (parking)
at sun.misc.Unsafe.park(Native Method)
- parking to wait for  <0x0000000685c35698> (a java.util.concurrent.CountDownLatch$Sync)
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:93)
at org.redisson.RedissonObject.get(RedissonObject.java:55)
at org.redisson.RedissonMap.get(RedissonMap.java:138)
at com.datorama.core.service.dist.impl.redis.RedisDistributedMapImpl.get(RedisDistributedMapImpl.java:78)
{code}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson version:2.2.21
implement code:
public class DistributedLock {
private static Logger logger = LoggerFactory.getLogger(DistributedLock.class);
private static Config config = new Config();
private static RedissonClient redisson = null;

private static void init() {
    if (redisson == null) {
        config.useSingleServer().setAddress("ip:port");
        redisson = Redisson.create(config);
    }
}

public static void lock(String key){
    init();

    logger.info("try to lock : " + key);
    try {
        RLock mylock = redisson.getLock(key);

        while (mylock.isLocked()) {
            Thread.sleep(10);
        }

        mylock.lock();
        logger.info("to lock : " + key + " success...");
    } catch (Exception e) {
        logger.warn("DistributedLock lock :" + key + "error:" + e.getMessage());
    }
}

public static boolean tryLock(String key) {
    init();

    logger.info("try to lock : " + key);
    try {
        RLock mylock = redisson.getLock(key);

        while (mylock.isLocked()) {
            Thread.sleep(10);
        }

        mylock.lock(10, TimeUnit.SECONDS);// 10s超时
        logger.info("try to lock : " + key + " success...");
        return true;
    } catch (Exception e) {
        logger.warn("DistributedLock try lock :" + key + "error:" + e.getMessage());
        return false;
    }
}

public static boolean tryLock(String key, long timeout) {
    init();

    logger.info("try to lock : " + key);
    try {
        RLock mylock = redisson.getLock(key);

        while (mylock.isLocked()) {
            Thread.sleep(10);
        }

        mylock.lock(timeout, TimeUnit.SECONDS);
        logger.info("try to lock : " + key + " success...");
        return true;
    } catch (Exception e) {
        logger.warn("DistributedLock try lock :" + key + "error:" + e.getMessage());
        return false;
    }
}

public static void releaseLock(String key) {
    logger.info("try to release lock : " + key);
    RLock mylock = redisson.getLock(key);
    mylock.unlock();
}

}
test unit code:
public class RedissonLockTest {
public static void main(String[] args) {
final String key = "test_lock";
for(int i=1; i<=5; i++){
new Thread(new Runnable() {
public void run() {
DistributedLock.lock(key);
System.out.println("当前线程已获取锁:" + Thread.currentThread().getName());
try {
Thread.sleep(2000L);
} catch (InterruptedException e) {
e.printStackTrace();
}
DistributedLock.releaseLock(key);
System.out.println("当前线程已释放锁:" + Thread.currentThread().getName());
}
}).start();
}
}
}
redis lock key ttl info(loop range:20-30 why?):
127.0.0.1:6379> ttl test_lock
(integer) 23
127.0.0.1:6379> ttl test_lock
(integer) 21
127.0.0.1:6379> ttl test_lock
(integer) 20
127.0.0.1:6379> ttl test_lock
(integer) 30
127.0.0.1:6379> ttl test_lock
(integer) 29
127.0.0.1:6379> ttl test_lock
(integer) 28
127.0.0.1:6379> ttl test_lock
(integer) 28
127.0.0.1:6379> ttl test_lock
(integer) 27
127.0.0.1:6379> ttl test_lock
(integer) 26
127.0.0.1:6379> ttl test_lock
(integer) 26
127.0.0.1:6379> ttl test_lock
(integer) 25
127.0.0.1:6379> ttl test_lock
(integer) 24
127.0.0.1:6379> ttl test_lock
(integer) 24
127.0.0.1:6379> ttl test_lock
(integer) 23
127.0.0.1:6379> ttl test_lock
(integer) 22
127.0.0.1:6379> ttl test_lock
(integer) 21
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi @mrniko , we are checking the work with AWS elastiCache instead of Redis-labs, and wanted to check if the following parameters seems ok in that case:
`
elasticacheServersConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 1000
timeout: 600000
retryAttempts: 3
retryInterval: 600000
reconnectionTimeout: 3000
failedAttempts: 3
password: null
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveSubscriptionConnectionMinimumIdleSize: 1
slaveSubscriptionConnectionPoolSize: 25
slaveConnectionMinimumIdleSize: 10
slaveConnectionPoolSize: 3000
masterConnectionMinimumIdleSize: 10
masterConnectionPoolSize: 3000
readMode: "SLAVE"
nodeAddresses:
""
scanInterval: 1000
database: 0
threads: 0
codec: !<org.redisson.codec.KryoCodec> {}
codec: !<org.redisson.codec.JsonJacksonCodec> {}
useLinuxNativeEpoll: false
eventLoopGroup: null
`
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According timeout issue with blpop command redis/redis#874 one second should be added to response timeout handler.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unhandled exceptions in CommandDecoder during decoding leads to response timeout exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Same thing as for CommandDecoder: unhandled exceptions leads to response timeout exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If a timeout occurs while inserting a ginormous payload, the entire payload is logged in the error message.
Is it possible to limit the payload portion of the error log?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
command execution timeout should be = retryInterval * retryAttempts
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis PubSub Scalability issure:
redis/redis#2672
fixed code:
slact/redis@905dc01
after fixed it , redisson can't receive message becauseof following code:
MasterSlaveConnectionManager.java
    private void connect(final Codec codec, final String channelName, final RedisPubSubListener listener,
            final Promise<PubSubConnectionEntry> promise, final PubSubType type) {
        final int slot = 0; // <----------------
        // final int slot = CRC16.crc16(channelName.getBytes()) % MAX_SLOT;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
127.0.0.1:6379> lpush name li lee zhang si
(integer) 4
127.0.0.1:6379> lrange name 0 -1

"si"
"zhang"
"lee"
"li"
127.0.0.1:6379>

RedissonClient redisson = Redisson.create(config);
RList list = redisson.getList("name");
ListIterator iterator = list.listIterator();
while(iterator.hasNext()){
System.out.println(iterator.next());
}
Exception in thread "main" org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:305)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:150)
at org.redisson.RedissonObject.get(RedissonObject.java:55)
at org.redisson.RedissonList.getValue(RedissonList.java:301)
at org.redisson.RedissonList$1.hasNext(RedissonList.java:470)
at com.omniprimeinc.redis.RedisList.main(RedisList.java:18)
Caused by: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'si': was expecting ('true', 'false' or 'null')
at [Source: io.netty.buffer.ByteBufInputStream@3c130745; line: 1, column: 5]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1586)
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:521)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looks funny! Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello!
Will it be a big effort to support java.util.LinkedHashSet-like behavior in one of redisson data structures?
Basically what I need is a collection with element uniqueness and preserved insertion order.
Would be happy to contribute as well, but I would need some guidance or example where to start from.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis use  Sentinel when switch master slave  where cause it
2016-10-11 19:10:26.625 WARN  o.r.c.SentinelConnectionManager.onNodeDown:272 master: 10.116.192.13:7091 has down
2016-10-11 19:10:27.666 WARN  o.r.c.SentinelConnectionManager.slaveDown:286 slave: 10.116.192.13:7091 has down
2016-10-11 19:10:42.937 WARN  o.r.c.SentinelConnectionManager.slaveDown:286 slave: 10.116.192.13:7091 has down
2016-10-11 19:12:18.385 WARN  i.n.c.DefaultChannelPipeline.warn:151 An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
org.redisson.client.RedisConnectionException: MasterConnectionPool exhausted!  Disconnected hosts: [10.25.63.47/10.25.63.47:7091]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
First off, thank you for this awesome library! :)
I've noticed a potential bug with Live Objects IDs. It is caused by the calls to isGetter and isSetter in the intercept() method of the AccessorInterceptor class (lines 102-108):
if (isGetter(method, getREntityIdFieldName(me))) {
    return ((RLiveObject) me).getLiveObjectId();
}

if (isSetter(method, getREntityIdFieldName(me))) {
    ((RLiveObject) me).setLiveObjectId(args[0]);
    return null;
}

These helper methods only compare prefix and suffix of method name. For example, this means that an @RId field named Id is overwritten by a call to  setSomeOtherId.
As a workaround, I avoid naming things get...Id and set...Id for now :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
under heavy load we experience a NPE in the CommandDecoder sometimes [1]. Do you have a guess about what could be going wrong here?
Thanks.
Cheers,
Philipp
[1]
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) [74:io.netty.codec:4.1.1.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) [74:io.netty.codec:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:326) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:326) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1320) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:334) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:905) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:563) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:504) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:418) [79:io.netty.transport:4.1.1.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:390) [79:io.netty.transport:4.1.1.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:742) [76:io.netty.common:4.1.1.Final]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:145) [76:io.netty.common:4.1.1.Final]
at java.lang.Thread.run(Thread.java:745) [?:?]
Caused by: java.lang.NullPointerException
at org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:397) ~[275:redisson:2.2.24]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:269) ~[275:redisson:2.2.24]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110) ~[275:redisson:2.2.24]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[74:io.netty.codec:4.1.1.Final]
... 20 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is it safe to exclude the byte-buddy dependency, or is it required at runtime?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When restarting the Redis server all connection threads logged the following exception.
2016-10-18 12:45:59,686 ERROR [redisson-netty-1-1] (org.redisson.client.handler.CommandsQueue) Exception occured. Channel: [id: 0xa23d4302, L:0.0.0.0/0.0.0.0:42732 ! R:xxxxxxxxxxxxxx]
java.lang.NullPointerException: null
    at org.redisson.client.handler.ConnectionWatchdog.reconnect(ConnectionWatchdog.java:88) ~[redisson-2.5.0.jar:?]
    at org.redisson.client.handler.ConnectionWatchdog.channelInactive(ConnectionWatchdog.java:75) ~[redisson-2.5.0.jar:?]
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:251) [netty-transport-4.0.42.Final.jar:4.0.42.Final]
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:237) [netty-transport-4.0.42.Final.jar:4.0.42.Final]
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:230) [netty-transport-4.0.42.Final.jar:4.0.42.Final]
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1289) [netty-transport-4.0.42.Final.jar:4.0.42.Final]

After the connection "interruption" the application starts logging the following..
2016-10-18 13:10:34,676 ERROR [globalEventExecutor-2-1] (org.redisson.connection.ElasticacheConnectionManager) Command execution timeout for xxxxxxxxxxxx
org.redisson.client.RedisTimeoutException: Command execution timeout for xxxxxxxxxxx
    at org.redisson.client.RedisConnection.await(RedisConnection.java:126) ~[redisson-2.5.0.jar:?]
    at org.redisson.client.RedisConnection.sync(RedisConnection.java:158) ~[redisson-2.5.0.jar:?]
    at org.redisson.client.RedisConnection.sync(RedisConnection.java:144) ~[redisson-2.5.0.jar:?]
    at org.redisson.connection.ElasticacheConnectionManager$1.run(ElasticacheConnectionManager.java:134) [redisson-2.5.0.jar:?]
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_102]
    at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:126) [netty-common-4.0.42.Final.jar:4.0.42.Final]
    at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:237) [netty-common-4.0.42.Final.jar:4.0.42.Final]
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [netty-common-4.0.42.Final.jar:4.0.42.Final]
    at java.lang.Thread.run(Thread.java:745) [?:1.8.0_102]

The host resolves to the same IP so that isn't a problem and I am able to telnet and issue the replication command without problems (immediate response)..
Escape character is '^]'.
INFO replication
$178
# Replication
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for an attempt, but such fix would be wrong. setMasterAddress, addSlaveAddress method should be called before init(this.config); line.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>2.4.0</version>
</dependency>

java:
Config config = new Config();
        config.useSentinelServers()
               .setMasterName("mymaster")
               .addSentinelAddress("192.168.109.5:26379");
        RedissonClient redisson = Redisson.create(config);

Exception in thread "main" org.redisson.client.RedisConnectionException: Can't init enough connections amount! Only 0 from 5 were initialized. Server: /127.0.0.1:6380
at org.redisson.connection.pool.ConnectionPool$2.operationComplete(ConnectionPool.java:120)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:129)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:75)
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:257)
at org.redisson.connection.pool.ConnectionPool.access$200(ConnectionPool.java:51)
at org.redisson.connection.pool.ConnectionPool$3.operationComplete(ConnectionPool.java:221)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:129)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:75)
at org.redisson.connection.ClientConnectionsEntry$1.operationComplete(ClientConnectionsEntry.java:149)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:129)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:75)
at org.redisson.client.RedisClient$2$2.run(RedisClient.java:159)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:408)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:140)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /127.0.0.1:6380
at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717)
at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:257)
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:291)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:552)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:466)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
... 3 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
see http://redis.io/commands/client-reply. probably most AWS users are still on 2.8 as 3.2 has just made available, so it might make sense to document this on the API.
ImmediateEventExecutor$ImmediatePromise@241ecb4(failure: org.redisson.client.RedisException: ERR Syntax error, try CLIENT (LIST | KILL ip:port | GETNAME | SETNAME connection-name). channel: [id: 0xb4ff98ef, L:/127.0.0.1:54955 - R:localhost/127.0.0.1:6379] command: CommandData [promise=org.redisson.misc.RedissonPromise@6e2742ee, command=(CLIENT REPLY), params=[ON], codec=null])
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I am using Redisson library version 2.2.4. I have the following settings configured for when I want to create a Redisson Client object for connecting to the datastore.
"elasticacheServersConfig": {
    "nodeAddresses": [
          "//XXX.001.cache.amazonaws.com:6379",
          "//XXX.002.cache.amazonaws.com:6379"
     ],
    "timeout": 3000
}

As you can see from the above settings I am setting the timeout explicitly to be 3 seconds. But I am seeing exceptions in the log which says mentions 1 second timeout. Here is the exception,
error: org.redisson.client.RedisTimeoutException: Redis server response timeout (1000 ms) occured for command: (GET) with params: [XXXXX] channel: [id: 0x002202e0, L:/172.17.0.160:43221 - R://XXX.002.cache.amazonaws.com/10.169.226.201:6379]
        at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:528)
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:588)
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:662)
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:385)
        at java.lang.Thread.run(Thread.java:745)

I am wondering how is this is possible? Also I think there is also auto-retry feature in Redisson, which defaults to 3 attempts. Then why would this happen?
Can I provide some more info to debug this issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey, I experienced two more NPE if I am using Redisson under load. Do you have an idea what might be the problem? Thx Philipp
2016-10-25T08:24:20,935 | WARN | LABS | i-5a270ba2 | 2016.0.0.426 | valid_b5099182-52b6-b069-65c6-65fd8b26d7a9 | XXX-Redis-Autobahn-1-2 | io.netty.channel.DefaultChannelPipeline | 2016-10-25T08:23:13,631_twoUserCollaborate_80c54f49-768d-2eee-bcd5-45d1337684b1 | An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. io.netty.handler.codec.DecoderException: java.lang.NullPointerException at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) [78:io.netty.codec:4.1.6.Final] at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) [78:io.netty.codec:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450) [83:io.netty.transport:4.1.6.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873) [80:io.netty.common:4.1.6.Final] at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [80:io.netty.common:4.1.6.Final] at java.lang.Thread.run(Thread.java:745) [?:?] Caused by: java.lang.NullPointerException at org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:414) ~[285:redisson:2.4.0] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:280) ~[285:redisson:2.4.0] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:118) ~[285:redisson:2.4.0] at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[78:io.netty.codec:4.1.6.Final] ... 20 more
and
2016-10-25T08:24:28,370 | WARN | LABS | i-af1e993c | 2016.0.0.426 | valid_0418a877-2e5f-ea68-18d6-76def289edbe | XXX-Redis-Autobahn-1-2 | io.netty.channel.DefaultChannelPipeline | 2016-10-25T08:23:13,631_twoUserCollaborate_1f6eab22-4072-5c98-9e8e-12accb75d2cf | An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. io.netty.handler.codec.DecoderException: java.lang.NullPointerException at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) [78:io.netty.codec:4.1.6.Final] at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) [78:io.netty.codec:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:651) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:574) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:488) [83:io.netty.transport:4.1.6.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:450) [83:io.netty.transport:4.1.6.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873) [80:io.netty.common:4.1.6.Final] at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [80:io.netty.common:4.1.6.Final] at java.lang.Thread.run(Thread.java:745) [?:?] Caused by: java.lang.NullPointerException at org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:414) ~[285:redisson:2.4.0] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:280) ~[285:redisson:2.4.0] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:118) ~[285:redisson:2.4.0] at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[78:io.netty.codec:4.1.6.Final] ... 20 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Connection pool should wait for free connection instead of throwing pool exhausted error. This improves command handling performance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Amazon has announced new version of ElastiCache with Redis Cluster support. Redisson should be checked for proper work with it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In our micro services system, we use RTopic process messages between services. In the onMessage method, I need to get data from redis, or set data. But in the test env, when it got or set data from/to redis, there ware always timeout errors (maybe one error for 2 tests). When I commented the code, no more errors.
So, is there any handling time limitation in onMessage method for RTopic? Or any limitation to interact with redis in onMessage method?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I add schedule job and cron quartz expression,but it' not exectue.
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson</artifactId>
	<version>2.4.0</version>
</dependency>

public class ParentTask implements Runnable {
    
    @RInject
    private RedissonClient redissonClient;

    @Override
    public void run() {
        System.out.println("execute parent task");
    }
    
    public static void main(String[] args) {
        Config config = new Config();
        config.useSingleServer().setPassword("redhat").setAddress("192.168.109.5:6379");
        RedissonClient redisson = Redisson.create(config);
        RScheduledExecutorService executorService = redisson.getExecutorService("parentTask");
        executorService.schedule(new ParentTask(), CronSchedule.of("0/5 * * * * ?"));
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fix message at https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java#L677
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a proposal for the issue. Tbh I don't know if this is overengineered and it might just be ok to check for byte[] and Strings and limit these in their size :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I haven't found an explanation about how to upload pure array of bytes. Redisson has a RBitSet but it manages an array of bits not bytes. How to store a byte array by using Redisson?
Here is my configuration:
Config config = new Config();

LoadBalancer loadBalancer = new RoundRobinLoadBalancer();

config.useClusterServers()
        .setScanInterval(5000) // cluster state scan interval in milliseconds
        .addNodeAddress("192.168.0.14:6379", "192.168.0.15:6379")
        .setReadMode(ReadMode.MASTER_SLAVE)
        .setLoadBalancer(loadBalancer)
        .setPassword("bTFBx1NYYWRMTUEyNHhsCg")
        .setSlaveConnectionPoolSize(10)
        .setMasterConnectionPoolSize(10);

RedissonClient redisson = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry, I don't see any changes
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have two schedule job parent and children,the children depend on parent job.when parent job done,then  the children job execute.but the children can not execute
public class ParentTask implements Runnable {
    
    @RInject
    private RedissonClient redissonClient;

    @Override
    public void run() {
        System.out.println("execute parent task");
        RTopic<String> topic = redissonClient.getTopic("topic");
        topic.publish("complete");
    }
    
}


public class SubTask implements Runnable {
    
    @RInject
    private RedissonClient redissonClient;
    
    @Override
    public void run() {
        RTopic<String> topic = redissonClient.getTopic("topic");
        topic.addListener(new MessageListener<String>() {
            @Override
            public void onMessage(String channel, String message) {
                System.out.println("receive message : " + message);
                System.out.println("execute sub task");
            }
        });
    }
}

 public static void main(String[] args) {
        // Redisson程序化配置代码
        Config config = new Config();
        config.useSingleServer().setPassword("redhat").setAddress("192.168.109.5:6379");
        RedissonClient redisson = Redisson.create(config);
        
       
        // Redisson Node 程序化配置方法
        RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
        Map<String, Integer> workers = new HashMap<String, Integer>();
        workers.put("parentjob", 1);
        workers.put("subjob", 1);
        nodeConfig.setExecutorServiceWorkers(workers);
        
        // 创建一个Redisson Node实例
        RedissonNode node = RedissonNode.create(nodeConfig);
//        
        node.start();
        RScheduledExecutorService executorParent = redisson.getExecutorService("parentjob");
        executorParent.schedule(new ParentTask(), CronSchedule.of("0/10 * * * * ?"));
   
        RScheduledExecutorService executorSub = redisson.getExecutorService("subjob");
        executorSub.schedule(new SubTask(), CronSchedule.of("0/2 * * * * ?"));
        
       // node.shutdown();
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have experienced some NullPointerExceptions in the CommandDecoder (besides the ones reported in #667.  In the handleResult method is a check if data is null so I guess there are situations where this can be null. In the bottom of the method where the NPE occurs the check is missing though. Should this be checked as well? I am using Redisson 3.0.0.
2016-11-04T00:01:09,935 | WARN | LABS | i-5dc2f5a5 | 1.0.0.0 | valid_0835907a-bf24-79f0-26e5-779d69317af6 | XXXX | io.netty.channel.DefaultChannelPipeline | 2016-11-03T09:59:13,694_twoUserCollaborate_b3a2aa58-bd2a-41de-c3d7-e41512e75e7a | An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:351)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:373)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:1018)
at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:402)
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:307)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:384)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:232)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:119)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
... 18 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please don't merge yet. The first upload is just a preview for now and I would like to add some annotations first since this is a lot of changed files =)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In case when queue consumers in different parts of network: some of them closer to redis and some farther.
"Farther" consumers will get lower amount of messages from queue due to network delays. In turn "closer" consumers will get higher amount and this could lead to client overloading.
Blocking queue with fair polling and guarantees access order for poll and take methods and allows to get uniformly distributed consumption by clients.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for pointed out!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Address like 192.168.234.129:7001@17001 should be converted to 192.168.234.129:7001
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the below code snippet , can the cache name use wildcard . for example '*'
Map<String, CacheConfig> _config = Maps.newHashMap();
 _config.put("cache*", new CacheConfig(1000 * 60 * 10, 0));
 return new RedissonSpringCacheManager(redissonClient, _config);
when i write '*' in the code, but donot effective
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could be attached to destination queue only. All elements are inserted with transfer delay to destination queue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
十一月 15, 2016 1:47:28 下午 io.netty.util.concurrent.DefaultPromise notifyListener0
警告: An exception was thrown by org.redisson.cluster.ClusterConnectionManager$4.operationComplete()
java.util.concurrent.RejectedExecutionException: event executor terminated
at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:805)
at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:345)
at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:338)
at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:748)
at io.netty.util.concurrent.AbstractScheduledEventExecutor.schedule(AbstractScheduledEventExecutor.java:190)
at io.netty.util.concurrent.AbstractScheduledEventExecutor.schedule(AbstractScheduledEventExecutor.java:134)
at org.redisson.client.RedisConnection.async(RedisConnection.java:179)
at org.redisson.client.RedisConnection.async(RedisConnection.java:170)
at org.redisson.client.RedisConnection.async(RedisConnection.java:162)
at org.redisson.cluster.ClusterConnectionManager.updateClusterState(ClusterConnectionManager.java:361)
at org.redisson.cluster.ClusterConnectionManager.access$900(ClusterConnectionManager.java:60)
at org.redisson.cluster.ClusterConnectionManager$4.operationComplete(ClusterConnectionManager.java:355)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:170)
at org.redisson.misc.RedissonPromise.addListener(RedissonPromise.java:85)
at org.redisson.misc.RedissonPromise.addListener(RedissonPromise.java:34)
at org.redisson.cluster.ClusterConnectionManager.checkClusterState(ClusterConnectionManager.java:345)
at org.redisson.cluster.ClusterConnectionManager.access$800(ClusterConnectionManager.java:60)
at org.redisson.cluster.ClusterConnectionManager$3.run(ClusterConnectionManager.java:331)
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:120)
at io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:237)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Unknown Source)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is there still any interest in the PR?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We started using redis hash for our logged in user session data, and I am having trouble getting a simple map of string key/vals.  I made a little test, where I create the same hash map in java/redisson and in PHP, and I am getting errors when I try to read the map that was created in our PHP application.
This is what they look like via rediscli:
127.0.0.1:6379> type test_string_map
hash
127.0.0.1:6379> type web:test_string_map
hash

127.0.0.1:6379> hgetall test_string_map
1) "\"key1\""
2) "\"stringval1\""
3) "\"key2\""
4) "\"50\""

127.0.0.1:6379> hgetall web:test_string_map
1) "key1"
2) "stringval1"
3) "key2"
4) "50"

Example that triggeres the warning:
# test RMap created in redisson (reads/writes fine)
RMap<String, String> testStringMap = redissonClient.getMap("test_string_map");
testStringMap.put("key1", "stringval1");
testStringMap.put("key2", "50");

# error trying to read hash map created in PHP
RMap<String, String> webStringMap = redissonClient.getMap("web:test_string_map");

# ExceptionCaught() event warning in log triggered when I call redissonClient.getMap()

10:19:12,542 11-18-2016 [WARN ] io.netty.channel.DefaultChannelPipeline::warn:151()
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.

io.netty.handler.codec.DecoderException: java.lang.NullPointerException
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) ~[rt.runnable.ej.build.30.jar:?]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) ~[rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:346) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:346) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1294) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:911) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:652) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:575) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:489) [rt.runnable.ej.build.30.jar:?]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:451) [rt.runnable.ej.build.30.jar:?]
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:140) [rt.runnable.ej.build.30.jar:?]
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [rt.runnable.ej.build.30.jar:?]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_101]
Caused by: java.lang.NullPointerException
	at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:384) ~[rt.runnable.ej.build.30.jar:?]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:284) ~[rt.runnable.ej.build.30.jar:?]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:119) ~[rt.runnable.ej.build.30.jar:?]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[rt.runnable.ej.build.30.jar:?]
	... 20 more

When I try to retrieve a redis hash with redisson that originated in our PHP application (via Predis), I get that exception and I am unable to read that hash map from PHP key: "web:test_string_map"
Is there a way to handle cases like these?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Introduce task objects instead of methods
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Not really an issue per say, more of a clarification really.  I'm about to launch a new feature that will be making use of the expires for individual entries in RMapCache and RSetCache, and I was wondering how that works regarding restarting the Java process that created/set it.  Will they be expired on shutdown, not touched at all and the expire is lost?
Just want to be sure of what is expected when I restart my Java service.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Poll method blocks infinitely if timeout specified during invocation less than 1 second
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I try RExecutorService ,found the task not execute
my example:

public class CallableTask implements Callable<Long> {

    @RInject
    private RedissonClient redissonClient;

    @Override
    public Long call() throws Exception {

         System.out.println("000000000")
         return 0;
    }

}

RExecutorService executorService = redisson.getExecutorService("myExecutor");
Future<Long> future = executorService.submit(new CallableTask());
Long result = future.get();

normal the console whill output : 000000000
but the console output nothing;
when i try this:
 ExecutorService executorService = Executors.newCachedThreadPool();
  executorService.execute(new RetryTask());

the console output:00000000
redission version:2.6.0
jdk:1.6
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I encountered an issue on using RedissonBaseIterator.
Inside of RedissonBaseIterator.hasNext(), it checked the end of iteration by lastValues.removeAll(firstValues) when scanned result is larger than default scan count 10.
It failed to return true on lastValues.removeAll(firstValues) when values are in custom object type since ArrayList.removeAll() uses Object.equals(). An object not implementing equals causing infinite loop while processing the iterator.
I'd rather check nextIterPos == 0 && nextIter != null && !nextIter.hasNext() at the start of hasNext() method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SPOP accepts an optional count argument since 3.2.0 version. It should be supported by RSet object
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Default connection pool could be reduced to 70 because #680 issue has been fixed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson 3.1.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sometimes there are few exceptions occur during Redisson shutdown process.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a rare possibility of race-condition during channel re-connection and RTopic subscription invoked first time.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using Redisson 3.2.0 and currently facing a problem reading for a cached collection. The following error is thrown
"2016-12-07 14:28:01,810 WARN  [redisson-netty-1-2] io.netty.channel.DefaultChannelPipeline   An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. "io.netty.handler.codec.DecoderException: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:346) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:346) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1294) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:367) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:353) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:911) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:652) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:575) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:489) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:451) at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:140) at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) at java.lang.Thread.run(Thread.java:745) Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(ArrayList.java:653) at java.util.ArrayList.get(ArrayList.java:429) at org.redisson.client.handler.CommandDecoder.messageDecoder(CommandDecoder.java:392) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:317) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:301) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:119) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ... 20 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm seeing a scenario in which RListMultimap.keySet() will return an empty set in spite of the fact that I have confirmed that data exists in the map.  The same goes for keySet().size() as well as simply calling size() on the map.
I captured the behavior .  Note that the in the expression editor the sizes are even though I had just immediately inserted the value into the map.  I also have confirmed that my local Redis instance actually contains the keys mentioned.
I tried to write a test case to demonstrate the issue, but it seems to work fine when running my test case.  However, I'm a bit perplexed to see it happening in my production code.
Could this be related to serialization or string encoding?  I dug pretty deep into Redisson's source code, but I had a hard time pinning down where in the client it actually issues the KEYS command to determine the keyset of the map.
I'd be happy to continue writing a test case, and a fix if necessary but I'm having difficulty reproducing the issue.  Any thoughts?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently we are running Redisson on hundreds of application servers to communicate with a redis cluster acting as cache. During a restart of the app servers there is a stampeding of the herd that can result in slower responses from the cluster. For our application we want to ensure that the cluster is available so we have a long connectTimeout. However we don't want to wait very long on key lookups (since we can bypass the cache if needed) so we have a short commandTimeout. In other words, we can tolerate occasional slow lookups, but we abort startup of our application if the redis cluster is not available.
As part of ClusterConnectionManager instantiation, ClusterNodeInfo is retrieved synchronously via RedisCommands.CLUSTER_NODES. It would be nice if this command respected the connectTimeout value rather than commandTimeout.
Example stacktrace of timeout leading to initialization failure:
2016-12-09 01:22:18,302 pGroup-4-6 WARN  o.r.c.h.CommandDecoder    - response has been skipped due to timeout! channel: [id: 0x324735bb, L:/10.0.x.x:59954 - R:10.0.x.x/10.0.x.x:6379], command: CommandData [promise=ImmediateEventExecutor$ImmediatePromise@37950b5e(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for /10.0.x.x:6379), command=(CLUSTER INFO), params=[], codec=null], result: {cluster_known_nodes=6, cluster_my_epoch=1, cluster_size=3, cluster_stats_messages_sent=6898613, cluster_slots_pfail=0, cluster_stats_messages_received=6898613, cluster_current_epoch=2, cluster_state=ok, cluster_slots_assigned=16384, cluster_slots_ok=16384, cluster_slots_fail=0}
2016-12-09 01:22:18,311 Group-4-12 ERROR .ClusterConnectionManager - Can't execute CLUSTER_INFO for /10.0.x.x:6379
org.redisson.client.RedisTimeoutException: Command execution timeout for /10.0.x.x:6379
        at org.redisson.client.RedisConnection$2.run(RedisConnection.java:183) ~[chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:120) [chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:408) [chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:309) [chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:140) [chanalyze-jar-with-dependencies.jar:Release94]
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) [chanalyze-jar-with-dependencies.jar:Release94]
        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_101]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would be quite useful to be able to add a MessageListener of any generic type, or at least supertypes. This would be extremely useful for topics that might contain multiple types of packets, especially when subscribing to a pattern. Thanks for considering it :)
        RTopic<CharSequence> topic = redisson.getTopic("test");
        topic.addListener(new MessageListener<String>() {
            @Override
            public void onMessage(String s, String string) {
                
            }
        });
        
        topic.addListener(new MessageListener<StringBuilder>() {
            @Override
            public void onMessage(String s, StringBuilder charSequence) {
                
            }
        });

Lambda Support:
   topic.<StringBuilder>addListener((s, builder) -> {

        });
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * <p>
     * Stores value mapped by key with specified time to live.
     * Entry expires after specified time to live.
     * <p>
     * If the map previously contained a mapping for
     * the key, the old value is replaced by the specified value.
     *
     * @param key - map key
     * @param value - map value
     * @param ttl - time to live for key\value entry.
     *              If <code>0</code> then stores infinitely.
     * @param ttlUnit - time unit
     * @return current associated value
     */
    V putIfAbsent(K key, V value, long ttl, TimeUnit ttlUnit);
Same for overloaded variant. The last paragraph seems incorrect.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Currently i am trying to plugin a Connection manager and config which can auto-discover nodes in AWS ElastiCache calling an AWS api, Current ReplicatedServersConfig is limited, where in it cannot add/remove newly added/removed slaves automatically and it needs me to configure individual node addresses instead of configuration endpoint.
But i see that ConfigSupport.createConnectionManager is static method. is there any way to plugin new connection manager?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This should fix #801
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
MyLiveObject myLiveObject = service.get(MyLiveObject.class, "1");
//distribution lock
lock(myLiveObject.GetPressKey()){
if(myLiveObject.GetPressKey()==“”){
do something...
myLiveObject.setPressKey("A");
}else{
System.out.println("you already press key");
}
}finally{
//releaseLock
releaseLock(myLiveObject.GetPressKey()))
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is my application-dev.yml file
`spring:
datasource:
url: jdbc:mysql://localhost:3306/smart?serverTimezone=UTC&useSSL=false
username: root
password: 123456
driver-class-name: com.mysql.cj.jdbc.Driver
redis:
singleServerConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
reconnectionTimeout: 3000
failedAttempts: 3
password: 12345678
subscriptionsPerConnection: 5
clientName: null
address: "redis://127.0.0.1:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 10
connectionPoolSize: 64
database: 0
dnsMonitoring: false
dnsMonitoringInterval: 5000
threads: 2
nettyThreads: 2
useLinuxNativeEpoll: true`
How can i config this in Application.java in Spring-boot?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So I am setting up redisson with spring per the doc https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#141-spring-framework. However the schema doesn't seem to be working. I'm getting 301 and is redirected to the homepage of redisson. Am I missing something?
Please check following links:
http://redisson.org/schema/redisson
http://redisson.org/schema/redisson/redisson.xsd
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
{"success":false,"message":"ERR Error running script (call to f_286dd696309f4ab2005d9df55e2410a1170fe3b3): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0xc42f8263, L:/10.28.11.46:57841 - R:/10.4.19.105:5002] command: CommandData [promise=org.redisson.misc.RedissonPromise@187b0930[Not completed], command=(EVAL), params=[local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 3, quickQueryCount, redisson__timeout__set__{quickQueryCount}, redisson__idle__set__{quickQueryCount}, 1489468477463, fa2512ba3ddae61295cff5528449149d], codec=org.redisson.codec.FstCodec@472b2094]"}
I have a issue,blew the exception it's what mean?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have configured redisson in my tomcat and ran an web application successfuly，after an ajax request，
the session data  has been stored in redis successfully，but when I restarted tomcat and called the ajax request again，an error occured and the request responsed with error code 500, then I called the ajax request again, a new session has bean created.
the stacktrace:
ava.lang.IllegalStateException: setAttribute: Session [2D3B8D8630A3EC8B89D10B63CB912382] has already been invalidated
org.apache.catalina.session.StandardSession.setAttribute(StandardSession.java:1463)
org.redisson.tomcat.RedissonSession.setAttribute(RedissonSession.java:130)
org.redisson.tomcat.RedissonSession.load(RedissonSession.java:182)
org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:121)
org.apache.catalina.connector.Request.doGetSession(Request.java:2922)
org.apache.catalina.connector.Request.getSessionInternal(Request.java:2575)
org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:431)
org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)
org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:620)
org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:509)
org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1104)
org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:684)
org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1524)
org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1480)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tried to update my project to redisson 3.3.1 (from 3.3.0) and I'm using redis sentinel configured via json file, and it is giving me a stack overflow (same config that works fine in 3.3.0).  Were there any changes in 3.3.1 that could break sentinel config via json?
Error is:
Exception in thread "main" java.lang.StackOverflowError
	at org.redisson.config.Config.fromJSON(Config.java:576)

My usage:
    private RedissonClient getSentinelClientJSON() throws IOException {
        String redisSentinelJsonConfig = // path to json file
        
        // this is the line that the stack overflow stems from and it says 
        Config config = Config.fromJSON(new File(redisSentinelJsonConfig));

        SentinelServersConfig sentinelConfig = config.useSentinelServers();
        sentinelConfig
            .setMasterName(SENTINEL_MASTER_NAME)
            .setPassword(SENTINEL_PW);

        return Redisson.create(config);
    }

Json file:
{
  "sentinelServersConfig":{
    "idleConnectionTimeout":10000,
    "pingTimeout":1000,
    "connectTimeout":5000,
    "timeout":5000,
    "retryAttempts":5,
    "retryInterval":1000,
    "reconnectionTimeout":2000,
    "failedAttempts":3,
    "password":null,
    "subscriptionsPerConnection":5,
    "clientName":null,
    "loadBalancer":{
      "class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
    },
    "slaveSubscriptionConnectionMinimumIdleSize":1,
    "slaveSubscriptionConnectionPoolSize":50,
    "slaveConnectionMinimumIdleSize":10,
    "slaveConnectionPoolSize":64,
    "masterConnectionMinimumIdleSize":10,
    "masterConnectionPoolSize":64,
    "readMode":"MASTER",
    "sentinelAddresses":[
      "redis://10.2.0.203:26379",
      "redis://10.2.0.204:26379",
      "redis://10.2.0.205:26379"
    ],
    "masterName":"redismaster",
    "database":0
  },
  "threads":0,
  "nettyThreads":0,
  "codec":null,
  "useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Something like.
firstObjectScore =   RScoredSortedSet.firstScore()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redisson for Spring Cache.
If I set sync=true for @Cacheable then this cache never expires (cache ttl is ignored).
Probably the reason of this issue is in code of function
RedissonCache#public <T> T get(Object key, Callable<T> valueLoader) 
Also no ZSET "redisson__idle__set__{...}" is created in Redis in this case.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Could I clarify if the example YAML at https://github.com/redisson/redisson/wiki/2.-Configuration#242-cluster-json-yaml-and-spring-xml-config-format for cluster configuration is sufficient, I am getting "server(s) address(es) not defined!" (IllegalStateException in ConfigSupport). I already have a working cluster, YAML config documentation seems incomplete to me. (Also a cluster restart seems necessary after this config has failed).
Please note that I have just spent two hours on this problem, I am asking a question about documentation, not asking for support, I've tried just about everything I can think of, including Config.useClusterServers() which seems to reset the config somehow.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redisson for Spring Session
In the source code,I can find the package "org.redisson.spring.support".
but in compiled jar from maven,The package "org.redisson.spring.support" is missing
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonLocalCachedMap should use encodeMapValue instead of encodeMapKey at here https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java#L342
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently RedissonSpringCacheManager creates new cache on each getCache call. But it should reuse existing caches if there are. Otherwise, Spring cache interceptor retrieves new cache at each time.
This behaviour can be implemented by just extending from  org.springframework.cache.support.AbstractCacheManager and overriding getMissingCache method as implemented in current getCache method.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are seeing an increase in the number of timeouts lately when we try to use SET or SETX commands lately with Elasticache. Here are some details about our setup.
We use a 4 node cache.m3.xlarge Elasticache Redis cluster.
Our Redisson initialization code:
`StringTokenizer nodes = new StringTokenizer(nodeList, DELIMITER);
            Config config = new Config();
            while(nodes.hasMoreTokens()) {
                config.useElasticacheServers()
                        .setConnectTimeout(connectTimeout)
                        .setTimeout(readTimeout)
                        .addNodeAddress(nodes.nextToken());
            }
            config.useElasticacheServers().setScanInterval(redisScanInterval);

            client = Redisson.create(config);`


nodeList is a comma separated list of all nodes (master and slaves)
readTimeout is 5000ms
connectTimeout is 5000ms
redisScanInterval is 1000ms

Exception thrown:
Error occurred in cache put org.redisson.client.RedisTimeoutException: Redis server response timeout (5000 ms) occured for command: (SET) with params: [Foo.bar.xxx.2, com.xxx.mobile.png.api.cbo.SenderApp@1224aee8] channel: [id: 0x192c6979, L:/10.81.229.161:47068 - R:png-prod-cache01-002.ni8ion.0001.usw2.cache.amazonaws.com/10.81.229.186:6379] at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:529) ~[redisson-2.2.27.jar:?] at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:588) ~[netty-common-4.0.39.Final.jar:4.0.39.Final] at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:662) ~[netty-common-4.0.39.Final.jar:4.0.39.Final] at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:385) ~[netty-common-4.0.39.Final.jar:4.0.39.Final] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_91]
We are using Redisson client version: 2.2.27
Is 5 second timeout too low for EC2? We are operating within a VPC. All EC2 instances and cache is running within the same VPC.
Any help/guidance will be very helpful...please do let me know if i can provide any additional info.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a non-serializable task to schedule. The executor is failing to submit this task with a NotSerializableException. The task is available to the worker node in its classpath. Is there a way I can execute these kind of tasks on the worker node.
public class NonSerializableTask implements Runnable {
    
    @RInject
    private RedissonClient redissonClient;

    // several members which are non-serializable

    @Override
    public void run() {
        
    }    
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to get ttl like jedis.ttl(key) in redisson?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use
Java 1.7.0_75
tomcat-8.0.23
redisson-tomcat-8-2.8.1.jar
redisson-all-2.8.1.jar
=============================================================
[[[[[ Spring Error ]]]]]
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:320)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:165)
at org.redisson.RedissonObject.get(RedissonObject.java:69)
at org.redisson.RedissonMap.fastPut(RedissonMap.java:436)
at org.redisson.tomcat.RedissonSession.setAttribute(RedissonSession.java:133)
at org.apache.catalina.session.StandardSession.setAttribute(StandardSession.java:1441)
at org.apache.catalina.session.StandardSessionFacade.setAttribute(StandardSessionFacade.java:142)
at org.springframework.web.context.request.ServletRequestAttributes.registerSessionDestructionCallback(ServletRequestAttributes.java:252)
at org.springframework.web.context.request.ServletRequestAttributes.registerDestructionCallback(ServletRequestAttributes.java:188)
at org.springframework.web.context.request.AbstractRequestAttributesScope.registerDestructionCallback(AbstractRequestAttributesScope.java:66)
at org.springframework.beans.factory.support.AbstractBeanFactory.registerDisposableBeanIfNecessary(AbstractBeanFactory.java:1572)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:580)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
at org.springframework.beans.factory.support.AbstractBeanFactory$2.getObject(AbstractBeanFactory.java:341)
at org.springframework.web.context.request.AbstractRequestAttributesScope.get(AbstractRequestAttributesScope.java:44)
at org.springframework.web.context.request.SessionScope.get(SessionScope.java:93)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:336)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1021)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:964)
at org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectFactory.getObject(DefaultListableBeanFactory.java:1203)
at org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyProvider.get(DefaultListableBeanFactory.java:1219)
at com.ets.aop.ControllerAop.etsCrpMngCheck(ControllerAop.java:129)
at com.ets.ctl.cs.HomeController.main_aroundBody4(HomeController.java:94)
at com.ets.ctl.cs.HomeController$AjcClosure5.run(HomeController.java:1)
at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:149)
at com.ets.aop.ControllerAop.apiErrorString(ControllerAop.java:103)
at com.ets.ctl.cs.HomeController.main(HomeController.java:90)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:747)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:676)
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:938)
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:870)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:622)
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:721)
at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:466)
at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:391)
at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:318)
at org.tuckey.web.filters.urlrewrite.NormalRewrittenUrl.doRewrite(NormalRewrittenUrl.java:195)
at org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:159)
at org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:141)
at org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:90)
at org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:417)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
at com.ets.filter.XssFilter.doFilter(XssFilter.java:37)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)
at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:518)
at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1091)
at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:668)
at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1517)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1474)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
at java.lang.Thread.run(Thread.java:745)
Caused by: com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError) (through reference chain: java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:706)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:690)
at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeWithType(BeanSerializerBase.java:581)
[[[[[Tomcat Error]]]]]
[redisson-netty-1-2] WARN io.netty.channel.AbstractChannelHandlerContext - Failed to mark a promise as failure because it has failed already: DefaultChannelPromise@4e341b8e(failure: io.netty.handler.codec.EncoderException: com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError) (through reference chain: java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["classloader"]->sun.misc.Launcher$AppClassLoader["defaultDomain"]->java.security.ProtectionDomain["
....
And
StackOverflowError
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
context:property-placeholder/
context:annotation-config/
<redisson:client name="redisson">
<redisson:single-server address="1xx.xx.xx:6379"/>
<redisson:list key="phone"></redisson:list>
</redisson:client>
redisson 3.2.4  netty 4.1.8  jackson 2.7.6  tomcat 7.0.73
jdk 1.7.0_80
Caused by: java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.ObjectMapper.addMixIn(Ljava/lang/Class;Ljava/lang/Class;)Lcom/fasterxml/jackson/databind/ObjectMapper;
at org.redisson.codec.JsonJacksonCodec.init(JsonJacksonCodec.java:148)
at org.redisson.codec.JsonJacksonCodec.(JsonJacksonCodec.java:95)
at org.redisson.codec.JsonJacksonCodec.(JsonJacksonCodec.java:80)
at org.redisson.codec.JsonJacksonCodec.(JsonJacksonCodec.java:55)
at org.redisson.config.Config.(Config.java:101)
at org.redisson.Redisson.(Redisson.java:113)
at org.redisson.Redisson.create(Redisson.java:154)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
... 37 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello , have peculiar situation where below works only first time around (reason for first API call is to establish "expire" on key as addAndGet does not allow one to specify expire)
so below works fine during first run, subsequent runs Redisson throws an exception (below at the end of this post)
thanks for any input on this
RMapCache<String, Object> mapCache = redisClient.getMapCache("test_put_if_absent");
Object  currValue = mapCache.putIfAbsent("4", 0L, 10000L, TimeUnit.SECONDS);
Object updatedValue = mapCache.addAndGet("4", 1L);
System.out.println("updatedValue: " + updatedValue);

org.redisson.client.RedisException: ERR Error running script (call to f_04ca52da6f32fea58a7378efe5e857fbdc376470): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0xfe4a958b, /127.0.0.1:45434 => /127.0.0.1:6379] command: CommandData [promise=org.redisson.misc.RedissonPromise@34c88748[Not completed], command=(EVAL), params=[if redis.call('hexists', KEYS[1], ARGV[4]) == 0 then if tonumber(ARGV[1]) > 0 then redis.call('zadd'..., 3, test_put_if_absent, redisson__timeout__set:{test_put_if_absent}, redisson__idle__set:{test_put_if_absent}, 1490911908793, 0, 0, 4, 0], codec=org.redisson.codec.JsonJacksonCodec@7bb8b36e]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:267)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:370)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:230)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:308)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:294)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:831)
at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:346)
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:254)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
jdk 1.7  redisson 2.8.2 kryo 3.03


          RList<String> ll=null;
	RLock re = redisson1.getLock("lock");
	for (int i = 0; i < l1.size(); i++) {
		re.tryLock();
		 ll = redisson1.getList("phone",new KryoCodec());

		if (!ll.contains(l1.get(i))) {
			ll.addAsync(l1.get(i));
		} 
		re.unlock();
            }
	System.out.println("cus:="+ll);





 com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: 32
at com.esotericsoftware.kryo.util.DefaultClassResolver.readClass(DefaultClassResolver.java:137)
at com.esotericsoftware.kryo.Kryo.readClass(Kryo.java:670)
at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:781)
at org.redisson.codec.KryoCodec$1.decode(KryoCodec.java:112)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:283)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at    io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)



please tell me  why  kryo with DefaultClassResolver.readClass  to error
i see #166     kryocodec     kryo.setReferences(false);   was change
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
this still fails for
RMapCache<String, Object> mapCache = redisClient.getMapCache("test_put_if_absent", StringCodec.INSTANCE);
Object currValue = mapCache.putIfAbsent("4", 0L, 10000L, TimeUnit.SECONDS);
Object updatedValue = mapCache.addAndGet("4", 1L);
System.out.println("updatedValue: " + updatedValue);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For example, i deploy my application on 3 servers
now,
the first request as req1 processed by server1
the secoind request as req2 processed by server2
the third request as req3 processed by server3
will RedissonFairLock works to make sure three requests be synchronized and the process order is
req1,req2,req3?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Team,
We are planning to use redisson in pivotal cloud foundry. Can you please help me to configure that.
if you guys can provide some example it will be nice.

We are using redis as a service.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in doc https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks,
the chart 14.1. Spring Framework，the that:
http://redisson.org/schema/redisson
http://redisson.org**_/schema/redisson/redisson.xsd_**
but it comes to error, the spring can not find "redisson.org/schema/redisson/redisson.xsd"
i unzip the redisson.jar，and find the in the file "spring.schemas" only that:
http://redisson.org**/schema/redisson.xsd**=org/redisson/spring/support/redisson-1.0.xsd
http://redisson.org/schema/redisson-1.0.xsd=org/redisson/spring/support/redisson-1.0.xsd
i use "redisson.org/schema/redisson.xsd", it comes ok
difference:
"http://redisson.org/schema/redisson.xsd"                                   in spring.schemas
"http://redisson.org/schema/redisson/redisson.xsd"                     in online doc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have configured a plain single server install of Redis. When I configure the Redisson client within my spring XML config with a simple single-server configuration. Spring gives the following error:

Bean property 'address' is not writable or has an invalid setter method.

I had a look at the file SingleServerConfig.java file and I noticed that it has both a public SingleServerConfig setAddress(String address) method as well as a void setAddress(URL address) method. I am not sure if this is what is causing the configuration error. I have created a gist with my XML config.
Spring Version: 3.1.3.RELEASE
Java Version: 1.7
Redisson Version: 2.8.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
                SingleServerConfig singleServerConfig = config.useSingleServer();
//                ReplicatedServersConfig singleServerConfig = config.useReplicatedServers();
                String address = redisResult.getHost().concat(":").concat(redisResult.getPort());
                singleServerConfig.setAddress(address);
                singleServerConfig.setSubscriptionConnectionMinimumIdleSize(Constant.SUBSCRIPTION_CONNECTION_MINIMUM_IDLE_SIZE);
                singleServerConfig.setSubscriptionConnectionPoolSize(Constant.SUBSCRIPTION_CONNECTION_POOL_SIZE);
                singleServerConfig.setConnectionMinimumIdleSize(Constant.CONNECTION_MINIMUM_IDLE_SIZE);
                singleServerConfig.setTimeout(Constant.TIME_OUT);
                singleServerConfig.setRetryAttempts(Constant.RETRY_ATTEMPTS);
                singleServerConfig.setRetryInterval(Constant.RETRY_INTERVAL);
//                singleServerConfig.setScanInterval(Constant.SCAN_INTERVAL);
                singleServerConfig.setReconnectionTimeout(Constant.RECONNECTION_TIME_OUT);
                singleServerConfig.setFailedAttempts(Constant.FAILED_ATTEMPT);
                singleServerConfig.setPassword(redisResult.getPassword());
                singleServerConfig.setSubscriptionsPerConnection(Constant.SUBSCRIPTIONS_PER_CONNECTION);
                redisson = Redisson.create(config);
Configure as above, but raise java.lang.IllegalStateException: java.lang.NoSuchFieldException: No field factory in class Ljava/net/URL; (declaration of 'java.net.URL' appears in /system/framework/core-libart.jar) Exception.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I got it, removed unnecessary lines by your comment.
Btw, I think there is some bug in [RedissonCacheMap.putIfAbsentAsync].
    @Override
    public RFuture<V> putIfAbsentAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit) {
        .......
        .......
        .......
        return commandExecutor.evalWriteAsync(getName(key), codec, EVAL_PUT_TTL,
                      "if redis.call('hexists', KEYS[1], ARGV[4]) == 0 then "
                        + "if tonumber(ARGV[1]) > 0 then "
                            + "redis.call('zadd', KEYS[2], ARGV[1], ARGV[4]); "
                        + "end; "
                        + "if tonumber(ARGV[2]) > 0 then "
                            + "redis.call('zadd', KEYS[3], ARGV[2], ARGV[4]); "
                        + "end; "
                        + "local value = struct.pack('dLc0', ARGV[3], string.len(ARGV[5]), ARGV[5]); "
                        + "redis.call('hset', KEYS[1], ARGV[4], value); "
                        + "return nil; "
                    + "else "
                        + "local value = redis.call('hget', KEYS[1], ARGV[4]); "
                        + "if value == false then "
                            + "return nil; "
                        + "end;"
                        + "local t, val = struct.unpack('dLc0', value); "
                        + "return val; "
                    + "end",
                Arrays.<Object>asList(getName(key), getTimeoutSetNameByKey(key), getIdleSetNameByKey(key)), ttlTimeout, maxIdleTimeout, maxIdleDelta, key, value);
    }

And I made this test code.
    @Test
    public void testPutIfAbsent() throws Exception {
        RMapCache<SimpleKey, SimpleValue> map = redisson.getMapCache("simple");
        SimpleKey key = new SimpleKey("1");
        SimpleValue value = new SimpleValue("2");
        map.put(key, value);
        Assert.assertEquals(value, map.putIfAbsent(key, new SimpleValue("3"), 1, TimeUnit.SECONDS));
        Assert.assertEquals(value, map.get(key));

        map.putIfAbsent(new SimpleKey("4"), new SimpleValue("4"), 1, TimeUnit.SECONDS);
        Assert.assertEquals(new SimpleValue("4"), map.get(new SimpleKey("4")));

        Thread.sleep(1000);

        Assert.assertNull(map.get(new SimpleKey("4")));
        
        //
        // this should be passed, but fail
        map.putIfAbsent(new SimpleKey("4"), new SimpleValue("4"), 1, TimeUnit.SECONDS);
        Assert.assertEquals(new SimpleValue("4"), map.get(new SimpleKey("4")));
        //
        // 

        SimpleKey key1 = new SimpleKey("2");
        SimpleValue value1 = new SimpleValue("4");
        Assert.assertNull(map.putIfAbsent(key1, value1, 2, TimeUnit.SECONDS));
        Assert.assertEquals(value1, map.get(key1));
    }

This test should be passed, but failed.
As you can see, there is no code for checking ttl or idle time in [putIfAbsentAsync] method,
not like [getAsync] or [fastPutIfAbsent] I have added.
If you're good, I'll fix it up.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello!
I would like connect to Azure Redis Cache service with redisson, but I didn't find how to connect over ssl. I searched here in the redisson wiki, looked up more forums, but I didn't find anything. Can you show me a descriptoin or code sample!
Thank you!
Tamas
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@iamdobi  Please add unit test
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hey,gays.
i want use redisson with spring
here(https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks#141-spring-framework),
just say set it in spring xml,like this:
<redisson:client id="redisson">
<redisson:single-server address="127.0.0.1:6379"/>
</redisson:client>
after it, i want get it's instance ,just like under pseudocode
@service
public class RedissonUtils {
@Autowired
private RedissonClient redissonClient;
{
    System.out.println(redissonClient.toString());
}

}
how to do?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson 2.8.0
2017/04/19 04:30:42:306  WARN logging.Slf4JLogger:141 - Failed to mark a promise as failure because it has failed already: DefaultChannelPromise@1e3a7e78(failure: io.netty.handler.codec.EncoderException: java.lang.StackOverflowError), unnotified cause: io.netty.handler.codec.EncoderException: java.lang.StackOverflowError
at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:125)
at org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:63)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:817)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:724)
at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:817)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:724)
at io.netty.channel.ChannelOutboundHandlerAdapter.write(ChannelOutboundHandlerAdapter.java:104)
at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:76)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802)
at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:815)
at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:795)
at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1027)
at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:301)
at org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:102)
at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:79)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731)
at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1090)
at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1137)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1079)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:662)
Caused by: java.lang.StackOverflowError
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
at org.redisson.misc.URLBuilder$1.createURLStreamHandler(URLBuilder.java:78)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RMap<String, byte[]> map = redisson.getMap("anyMap");
    for (int i = 0; i < 10; i++) {
        map.put(String.valueOf(i), String.valueOf(i).getBytes());
    }
    byte[] o = map.get("2"); //java.lang.ClassCastException: java.lang.String cannot be cast to [B

Is it wrong way  to use RMap?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson is so slow!
code bellow will output :
81215
799
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>2.8.2</version>
    </dependency>
    <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
        <version>2.9.0</version>
    </dependency>


<redisson:client id="redissonClient" name="redissonClient" >
    <redisson:single-server address="***.****.***.**:6379" database="3"></redisson:single-server>
</redisson:client>


   StopWatch stopWatch = new StopWatch();
    stopWatch.reset();
    stopWatch.start();

    RMap<String, String> map = redisson.getMap("anyMap");
    for (int i = 0; i < 1000; i++) {
        map.put(String.valueOf(i), String.valueOf(i));
    }

    System.out.println(map.get(String.valueOf(2)));

    stopWatch.reset();
    stopWatch.start();

    JedisPool pool = new JedisPool(new JedisPoolConfig(), "***.***.***.***");
    Jedis jedis = pool.getResource();
    jedis.select(3);
    Map<byte[], byte[]> map2 = new JedisByteHashMap();
    for (int i = 0; i < 1000; i++) {
        map2.put(String.valueOf(i).getBytes(), String.valueOf(i).getBytes());
    }
    jedis.hmset("23".getBytes(), map2);
    jedis.close();
    pool.destroy();

    System.out.println(stopWatch.getTime());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org/redisson/spring/support/redisson-1.0.xsd
line 780:    <xsd:attribute name="database" type="xsd:int">
It will  be wrong like this:
<redisson:single-server address="${redisson.address}" database="${redisson.dbid}"></redisson:single-server>
Is it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I think there is some bug in [RedissonCacheMap.putIfAbsentAsync].
    @Override
    public RFuture<V> putIfAbsentAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit) {
        .......
        .......
        .......
        return commandExecutor.evalWriteAsync(getName(key), codec, EVAL_PUT_TTL,
                      "if redis.call('hexists', KEYS[1], ARGV[4]) == 0 then "
                        + "if tonumber(ARGV[1]) > 0 then "
                            + "redis.call('zadd', KEYS[2], ARGV[1], ARGV[4]); "
                        + "end; "
                        + "if tonumber(ARGV[2]) > 0 then "
                            + "redis.call('zadd', KEYS[3], ARGV[2], ARGV[4]); "
                        + "end; "
                        + "local value = struct.pack('dLc0', ARGV[3], string.len(ARGV[5]), ARGV[5]); "
                        + "redis.call('hset', KEYS[1], ARGV[4], value); "
                        + "return nil; "
                    + "else "
                        + "local value = redis.call('hget', KEYS[1], ARGV[4]); "
                        + "if value == false then "
                            + "return nil; "
                        + "end;"
                        + "local t, val = struct.unpack('dLc0', value); "
                        + "return val; "
                    + "end",
                Arrays.<Object>asList(getName(key), getTimeoutSetNameByKey(key), getIdleSetNameByKey(key)), ttlTimeout, maxIdleTimeout, maxIdleDelta, key, value);
    }

And I made this test code.
    @Test
    public void testPutIfAbsent() throws Exception {
        RMapCache<SimpleKey, SimpleValue> map = redisson.getMapCache("simple");
        SimpleKey key = new SimpleKey("1");
        SimpleValue value = new SimpleValue("2");
        map.put(key, value);
        Assert.assertEquals(value, map.putIfAbsent(key, new SimpleValue("3"), 1, TimeUnit.SECONDS));
        Assert.assertEquals(value, map.get(key));

        map.putIfAbsent(new SimpleKey("4"), new SimpleValue("4"), 1, TimeUnit.SECONDS);
        Assert.assertEquals(new SimpleValue("4"), map.get(new SimpleKey("4")));

        Thread.sleep(1000);

        Assert.assertNull(map.get(new SimpleKey("4")));
        
        //
        // this should be passed, but fail
        map.putIfAbsent(new SimpleKey("4"), new SimpleValue("4"), 1, TimeUnit.SECONDS);
        Assert.assertEquals(new SimpleValue("4"), map.get(new SimpleKey("4")));
        //
        // 

        SimpleKey key1 = new SimpleKey("2");
        SimpleValue value1 = new SimpleValue("4");
        Assert.assertNull(map.putIfAbsent(key1, value1, 2, TimeUnit.SECONDS));
        Assert.assertEquals(value1, map.get(key1));
    }

This test should be passed, but failed.
As you can see, there is no code for checking ttl or idle time in [putIfAbsentAsync] method,
not like [getAsync] or [fastPutIfAbsent] I have added.
If it's alright, I'm ready to PR to fix it.
Please verify whethrer my found is right.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The redisson JSR107 org.redisson.jcache.JCache implementation throws exception like org.redisson.client.RedisException. According to the JSR107 specification this exception should be wrapped into javax.cache.CacheException . This way when interchanging cache implementation one can expect same error handling.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I did not see previously that master branch also has the same issue and same fix needs to be applied there
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actuator is an optional feature in Spring Boot, there are a lot of projects that do not use actuator due to additional dependencies and complexity.
Redisson 3.3.1 worked fine without actuator but 3.3.2 fails to start with ClassNotFoundException for org.springframework.boot.actuate.cache.CacheStatisticsProvider.
Suggested change registers Redisson AutoConfiguration only if actuator is in the classpath
Pull request #851
That pull request is only for 3.0.0 but change changes apply for the master branch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With GEORADIUS | GEORADIUSBYMEMBER ... STORE key, Redis stores the result to the specified key, and returns the result size.
https://redis.io/commands/georadius
I see two ways to implement this into the Redisson API:

Add new radiusStore...() methods to RGeo and RGeoAsync, with a fromKey parameter. Search the Geo specified by fromKey, and store the result in this RGeo. This mirrors the API for intersecting and unioning sorted sets.

GEORADIUS fromKey ... STORE getName()


Add new radiusStore...() methods to RGeo and RGeoAsync, with a storeKey parameter. Search this Geo, and store the results in the Geo specified by storeKey. This is more straightforward to implement.

GEORADIUS getName() ... STORE storeKey

Which is preferred? Are there alternate suggestions? I vote for # 1.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Forgot to mention:

the commit aaf3166 also fixed a bug where slots were incorrectly allocated to slave nodes instead of only for masters.
SpringNamespaceTest.java is modified to demonstrate the capability of running a redis cluster with multiple masters with multiple slaves and as well as having multiple slave nodes connected to a slave.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Do Redisson  version 2.8.2 compatibly to jdk 1.6  ???
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2017/04/21 23:28:43 12283  INFO redisson.Version:41 - Redisson 2.8.1
2017/04/21 23:28:43 12530  INFO pool.ConnectionPool$2$1:137 - 5 connections initialized for /192.168.0.121:7001
2017/04/21 23:28:43 12532 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12535 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12531  INFO pool.ConnectionPool$2$1:137 - 5 connections initialized for /192.168.0.121:7003
2017/04/21 23:28:43 12539 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12545 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12551 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12555 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12558 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12561 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12565 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12568 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12569  INFO cluster.ClusterConnectionManager$2$1$1:294 - master: redis://192.168.0.121:7001 added for slot ranges: [[5461-10922]]
2017/04/21 23:28:43 12572 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12575 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12577  INFO cluster.ClusterConnectionManager$2$1$1:294 - master: redis://192.168.0.121:7003 added for slot ranges: [[0-5460]]
2017/04/21 23:28:43 12579 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12583 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12586 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12589 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12593 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12597 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
2017/04/21 23:28:43 12600 ERROR logging.Slf4JLogger:181 - Failed to submit a listener notification task. Event loop shut down?
java.lang.StackOverflowError
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2944)
at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1208)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1688)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1569)
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2944)
at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1208)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1688)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1569)
at org.apache.log4j.spi.ThrowableInformation.getThrowableStrRep(ThrowableInformation.java:87)
at org.apache.log4j.spi.LoggingEvent.getThrowableStrRep(LoggingEvent.java:413)
at org.apache.log4j.WriterAppender.subAppend(WriterAppender.java:313)
at org.apache.log4j.WriterAppender.append(WriterAppender.java:162)
at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:251)
at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:66)
at org.apache.log4j.Category.callAppenders(Category.java:206)
at org.apache.log4j.Category.forcedLog(Category.java:391)
at org.apache.log4j.Category.log(Category.java:856)
at org.slf4j.impl.Log4jLoggerAdapter.error(Log4jLoggerAdapter.java:571)
at io.netty.util.internal.logging.Slf4JLogger.error(Slf4JLogger.java:181)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:673)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
at io.netty.util.concurrent.DefaultPromise.execute(DefaultPromise.java:671)
at io.netty.util.concurrent.DefaultPromise.access$400(DefaultPromise.java:32)
at io.netty.util.concurrent.DefaultPromise$LateListeners.run(DefaultPromise.java:850)
at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:87)
......
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I used redisson to keep my tomcat session, and deserializing session error when the tomcat was restart.
The error info is 'the class missing default constructor or creator, or perhaps need to add/enable type information'.
So I add jackson annotation JsonDeserialize to my class, but it does not worked.
Can you help me solve this problem?
I have try deserializing the class with Jackson, and it can working
The code:
@JsonDeserialize(using = UsernamePasswordAuthenticationTokenSerializer.class)
public class UsernamePasswordAuthenticationTokenExt extends UsernamePasswordAuthenticationToken {
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using redisson JSR107 implementation and after upgrading from version 3.3.1 to 3.3.2 I start to get following exception immediately:
Caused by: java.lang.NoClassDefFoundError: net/openhft/hashing/LongHashFunction 
	at org.redisson.misc.Hash.hashToBase64(Hash.java:43) 
	at org.redisson.jcache.JCache.getLockName(JCache.java:560) 
	at org.redisson.jcache.JCache.getLockedLock(JCache.java:744) 
	at org.redisson.jcache.JCache.put(JCache.java:809)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have this message quite often in my logs. There is a StackOverflowException happening right before that (though I am not sure whether these two correlate). Do you have an idea what is happening? Is the message too long to be processed? (Just for the context we have a pub/sub on expired keys.)
2017-04-26T15:51:45,881 | WARN | io.netty.channel.DefaultChannelPipeline | 2017-04-26T11:55:49,825_load_twoUserCollaborate_d4bd6e09-1bab-d0ff-b03f-823eb4c9442d | An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.lang.IllegalStateException: Can't decode replay: *4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_501134d3-f81b-4ad8-dfb9-bc63bbe830a8.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_350da5f7-3827-b630-7744-e9c7ecbf62db.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$46
pack_350da5f7-3827-b630-7744-e9c7ecbf62db.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$85
fc_gzip_b028edc1-2a3a-8d08-5c13-fe25bd1de7de_b2106b913601c201e1687aa7da9f2938b6fc2d03
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_91fd49c4-4bd0-5f78-d0e1-f3f278ba6880.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$46
pack_30c173d4-9f54-5532-24f4-6cca218ca8f2.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$46
pack_f1476d2d-d46f-506a-8f76-4e6e1a34aedd.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$85
fc_gzip_dcd6dbfa-e6b5-3798-64ff-08331278ab61_b68a1cdb9552248089bb739e119929d56e1033d4
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$46
pack_01fb66ff-6c32-07ef-5f15-ae7e009a1e9b.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_660999bc-d87b-73a1-3700-ee494e4e629a.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$46
pack_8cb9d5f8-bf22-e20a-fc22-6c43c6c2209f.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_7f32f80d-ef10-d9fa-0cbc-bc6907b41403.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$46
pack_d3c04450-7a2c-76d6-4694-d1a809373736.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_edfcb536-287a-7f63-7b42-909b5f6b815c.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$46
pack_60cc8f0a-98de-d61c-f6bd-8a90114d41bb.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$45
pack_d1e992c7-ee8a-6b7a-360f-eb340e69d696.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_d1e992c7-ee8a-6b7a-360f-eb340e69d696.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_7e134dc6-9748-521c-5340-e97a1c790ed3.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_ce902045-ea2c-055d-87e2-ded21f156227.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_deba09f5-e7e0-879a-305b-fa0aaef2b12f.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$48
pack_775d43a6-c38e-51ff-72b8-a045871140d6.bitmap
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$45
pack_436b03f5-2a47-c03a-36b5-c65df9fb830d.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$48
pack_0ceea1c5-d2b3-3a28-0246-8116a1588dd8.bitmap
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_e931dc2d-de9a-696e-2c89-35ea0bd926f4.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$48
pack_96ebc9ff-32d9-f910-925d-911a6ac8b53a.bitmap
*4
$8
pmessage
$16
__keyevent@*__:*
$22
__keyevent@0__:expired
$46
pack_c52dee39-468b-4c5f-c9e1-337f2a8ca1be.pack
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_461227e4-88fd-9689-4c9c-f6453c3a4eca.idx
*4
$8
pmessage
$16
__keyevent@*__:*
$21
__keyevent@0__:expire
$45
pack_1a4904bc-3db3-c88b-9560-ea62d0a839c5.idx
*4
$8
pmessage
$16
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One of our use case requires that if there is a failover, we reconnect automatically to another node. This is available in single server config as DnsMonitoring but not in Master Slave mode. Is there a specific reason for this? Can there be a support added? @mrniko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
04-27 09:56:07.361 3495-3495/com.medzone.redisson E/AndroidRuntime: FATAL EXCEPTION: main
                                                                    Process: com.medzone.redisson, PID: 3495
                                                                    java.lang.NoClassDefFoundError: Failed resolution of: Lcom/fasterxml/jackson/dataformat/avro/PackageVersion;
                                                                        at org.redisson.codec.DefenceModule.<init>(DefenceModule.java:72)
                                                                        at org.redisson.codec.JsonJacksonCodec.init(JsonJacksonCodec.java:146)
                                                                        at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:102)
                                                                        at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:87)
                                                                        at org.redisson.codec.JsonJacksonCodec.<clinit>(JsonJacksonCodec.java:62)
                                                                        at org.redisson.config.Config.<init>(Config.java:101)
                                                                        at org.redisson.Redisson.<init>(Redisson.java:113)
                                                                        at org.redisson.Redisson.create(Redisson.java:154)
                                                                        at com.medzone.redisson.redis.RedisActivity$2.call(RedisActivity.java:84)
                                                                        at com.medzone.redisson.redis.RedisActivity$2.call(RedisActivity.java:65)
                                                                        at rx.internal.util.ActionSubscriber.onNext(ActionSubscriber.java:39)
                                                                        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134)
                                                                        at com.jakewharton.rxbinding.view.ViewClickOnSubscribe$1.onClick(ViewClickOnSubscribe.java:23)
                                                                        at android.view.View.performClick(View.java:5697)
                                                                        at android.widget.TextView.performClick(TextView.java:10815)
                                                                        at android.view.View$PerformClick.run(View.java:22526)
                                                                        at android.os.Handler.handleCallback(Handler.java:739)
                                                                        at android.os.Handler.dispatchMessage(Handler.java:95)
                                                                        at android.os.Looper.loop(Looper.java:158)
                                                                        at android.app.ActivityThread.main(ActivityThread.java:7237)
                                                                        at java.lang.reflect.Method.invoke(Native Method)
                                                                        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)
                                                                        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)
                                                                     Caused by: java.lang.ClassNotFoundException: Didn't find class "com.fasterxml.jackson.dataformat.avro.PackageVersion" on path: DexPathList[[zip file "/data/app/com.medzone.redisson-2/base.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_dependencies_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_0_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_1_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_2_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_3_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_4_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_5_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_6_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_7_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_8_apk.apk", zip file "/data/app/com.medzone.redisson-2/split_lib_slice_9_apk.apk"],nativeLibraryDirectories=[/data/app/com.medzone.redisson-2/lib/arm64, /vendor/lib64, /system/lib64]]
                                                                        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)
                                                                        at java.lang.ClassLoader.loadClass(ClassLoader.java:511)
                                                                        at java.lang.ClassLoader.loadClass(ClassLoader.java:469)
                                                                        at org.redisson.codec.DefenceModule.<init>(DefenceModule.java:72) 
                                                                        at org.redisson.codec.JsonJacksonCodec.init(JsonJacksonCodec.java:146) 
                                                                        at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:102) 
                                                                        at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:87) 
                                                                        at org.redisson.codec.JsonJacksonCodec.<clinit>(JsonJacksonCodec.java:62) 
                                                                        at org.redisson.config.Config.<init>(Config.java:101) 
                                                                        at org.redisson.Redisson.<init>(Redisson.java:113) 
                                                                        at org.redisson.Redisson.create(Redisson.java:154) 
                                                                        at com.medzone.redisson.redis.RedisActivity$2.call(RedisActivity.java:84) 
                                                                        at com.medzone.redisson.redis.RedisActivity$2.call(RedisActivity.java:65) 
                                                                        at rx.internal.util.ActionSubscriber.onNext(ActionSubscriber.java:39) 
                                                                        at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:134) 
                                                                        at com.jakewharton.rxbinding.view.ViewClickOnSubscribe$1.onClick(ViewClickOnSubscribe.java:23) 
                                                                        at android.view.View.performClick(View.java:5697) 
                                                                        at android.widget.TextView.performClick(TextView.java:10815) 
                                                                        at android.view.View$PerformClick.run(View.java:22526) 
                                                                        at android.os.Handler.handleCallback(Handler.java:739) 
                                                                        at android.os.Handler.dispatchMessage(Handler.java:95) 
                                                                        at android.os.Looper.loop(Looper.java:158) 
                                                                        at android.app.ActivityThread.main(ActivityThread.java:7237) 
                                                                        at java.lang.reflect.Method.invoke(Native Method) 
                                                                        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230) 
                                                                        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120) 
                                                                    	Suppressed: java.lang.ClassNotFoundException: com.fasterxml.jackson.dataformat.avro.PackageVersion
                                                                        at java.lang.Class.classForName(Native Method)
                                                                        at java.lang.BootClassLoader.findClass(ClassLoader.java:781)
                                                                        at java.lang.BootClassLoader.loadClass(ClassLoader.java:841)
                                                                        at java.lang.ClassLoader.loadClass(ClassLoader.java:504)
                                                                        		... 24 more
                                                                     Caused by: java.lang.NoClassDefFoundError: Class not found using the boot class loader; no stack trace available
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello friend
For blow code with stress test redisson client, but test_redisson_set method add loop items, have Exception message
`public class RedisClientTestUnit extends BaseTest{
public static final int invocations = 1000;

public static final int threads = 1;

public static final int duration = 6000;

@Rule
public ContiPerfRule rule = new ContiPerfRule();

@Autowired
private RedissonTemplete<String, Object> redissonTemplete;

@Before
public void check_bean_is_not_null(){
	Assert.assertNotNull(redissonTemplete);
}

@Test
@PerfTest(invocations = invocations, threads = threads, duration = duration)
public void test_redisson_set(){
	for(long i=1; i<=100000; i++){
		System.out.println(redissonTemplete.hashCode());
		long start = System.currentTimeMillis();
		Order order = new Order(); 
		order.setOrderId(i);
		order.setOrderSn(UUIDUtil.randomString(10));
		redissonTemplete.set(String.valueOf(i), order);
		System.out.println("i:" + (System.currentTimeMillis()-start));
	}
}

@Test
@PerfTest(invocations = invocations, threads = threads, duration = duration)
public void test_redisson_get(){
	for(int i=1; i<=1000; i++){
		long start = System.currentTimeMillis();
		List<Order> orders = (List<Order>) redissonTemplete.get(String.valueOf(i));
		System.out.println(orders.get(0).getOrderSn());
		System.out.println("i:" + (System.currentTimeMillis()-start));
	}
}

}`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Great work! But there is some remarks. If you have a look at org.redisson.api.RSortable interface you may notice that it uses storeTo names. With key destination name and not from destination. Please rework your patch according this naming convention.
For example:
radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit);
could be renamed to
radiusStoreToAsync(String destinationKey, V member, double radius, GeoUnit geoUnit);
the method itself applied against geo source and the destination
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My RedissonClient codec is Config config = new Config().setCodec(new KryoCodec());
use this codec. Get RMap via RedissonClient, and then call RMAP's addAndGet method. Can be successful, but I then throw out the RMap when the exception thrown: Throws an exception: Unable to evaluate the expression Method threw 'org.redisson.client.RedisException' exception.
p.s:If the codec from KryoCodec into StringCodec or default codec(Jackson JSON) will not be an error.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Add metric for each command execution.
Add metrics for succeed and failed commands.
Add metrics for connections utilization
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Running redisson 2.9.1, jasckon dataformat 2.7.2.
I'm attempting to use AvroJacksonCodec with redisson client. This stack trace occurs when attempting to serialize and deserialize avro data from redis.
Failed to mark a promise as failure because it has failed already: DefaultChannelPromise@60a37695(failure: io.netty.handler.codec.EncoderException: com.fasterxml.jackson.databind.JsonMappingException: Incompatible types: declared root type ([simple type, class com.sumologic.app.api.ProtocolContinuousQueryRecordList]) vs java.lang.String), unnotified cause: io.netty.handler.codec.EncoderException: com.fasterxml.jackson.databind.JsonMappingException: Incompatible types: declared root type ([simple type, class com.sumologic.app.api.ProtocolContinuousQueryRecordList]) vs java.lang.String at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:125) at org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:63) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:817) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:724) at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:817) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:724) at io.netty.channel.ChannelOutboundHandlerAdapter.write(ChannelOutboundHandlerAdapter.java:104) at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:76) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739) at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:802) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:815) at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:795) at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1027) at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:301) at org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:102) at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:79) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:739) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:731) at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38) at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1090) at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1137) at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1079) at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:445) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) at java.lang.Thread.run(Thread.java:745) Caused by: com.fasterxml.jackson.databind.JsonMappingException: Incompatible types: declared root type ([simple type, class com.sumologic.app.api.ProtocolContinuousQueryRecordList]) vs java.lang.String at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:262) at com.fasterxml.jackson.databind.SerializerProvider._reportIncompatibleRootType(SerializerProvider.java:1115) at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:225) at com.fasterxml.jackson.databind.ObjectWriter$Prefetch.serialize(ObjectWriter.java:1425) at com.fasterxml.jackson.databind.ObjectWriter._configAndWriteValue(ObjectWriter.java:1129) at com.fasterxml.jackson.databind.ObjectWriter.writeValueAsBytes(ObjectWriter.java:1025) at org.redisson.codec.AvroJacksonCodec$AvroExtendedMapper.writeValueAsBytes(AvroJacksonCodec.java:52) at org.redisson.codec.JsonJacksonCodec$1.encode(JsonJacksonCodec.java:75) at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:103) at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:45) at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107) ... 32 more 
This is how the codec is being created (note, the environment is scala).
  private val codec = new AvroJacksonCodec( classOf[ProtocolContinuousQueryRecordList], new AvroSchema(ProtocolContinuousQueryRecordList.SCHEMA$))
It works when I use JsonJacksonCodec, but not with AvroJacksonCodec. Am I doing something incorrectly which would be causing this issue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello mrniko:
Config = ...
RedissonClient redisson = Redisson.create(config);
RAtomicLong  atomicLong = redisson.getAtomicLong(key);
Long result = atomicLong.addAndGet(10L);
//execute successful
RBucket bucket = redisson.getBucket(key)
But (bucket.get()) return Integer result? why?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With present radisson is it possible to search more than one item by id or  other properties ?
for example :
 RLiveObjectService liveObjectService = redisson.getLiveObjectService();
List ids = new ArrayList<>();
ids.add(12);
ids.add(13);
ids.add(14);
 List customers = liveObjectService.get(Customer.class, ids );


if not this way. are there any other ways to do this ?
Question 2:
Is it possible to search objects by property name?
for eg: searching customer by product id.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what about delay to  connect to redis  , by the first function call ?
rather than connect to redis immediately  when  application startup .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm investigating moving from Hazelcast to Redisson and one question popped up that I can't seem to work out the answer for. Perhaps I'm trying to incorrectly compare functionality between the two?
Anyway, in our code that uses Hazelcast, we create a distributed IMap and add listeners so that each process (Hazelcast client) can listen for changes to that map. I can't seem to work out how to get the same functionality using the RMap. Is this possible or is this functionality only available using the LiveObject? Or do I have to mimic this functionality using a topic perhaps?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a requirement where I need to read and write from only master, so that our application gets consistent data from Redis. At the same time, we need HA and automatic failover.
To satisfy above requirements, I am using Redis master-slave setup, with sentinel, and with read mode as MASTER. The issue I am facing is, Redisson tries to write to a read-only slave and Redis throws exception.
To reproduce the issue, perform following steps:

Start Master_1 with Sentinel_1, and Slave_1 with Sentinel_2 (Redission performs all reads & writes against Master_1)
Shutdown Master_1 (Slave_1 becomes master now, and Redission performs all reads & writes against Slave_1)
Start Master_1 (Master_1 becomes read-only slave, but Redisson tries to insert data into Master_1)

Configuration and other details are as follows:
Maven dependency:
<dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.4.3</version>
</dependency>

Spring Redisson bean definition:
@Bean(destroyMethod = "shutdown")
	public RedissonClient redisson() throws IOException {
		Config config = new Config();
		config.useSentinelServers()
				.setMasterName("redis-cluster")
				.addSentinelAddress("redis://127.0.0.1:26179")
				.addSentinelAddress("redis://127.0.0.1:26381")
				.setReadMode(ReadMode.MASTER);

		RedissonClient redisson = Redisson.create(config);
		return redisson;
}

A test spring scheduled job that reads and writes dummy data:
@Component
public class OrderProcessorJob implements Job {

	@Autowired
	private OrderProcessorService se;

	@Autowired
	private RedissonClient rc;

	@Override
	public void execute(JobExecutionContext jc) throws JobExecutionException {
		// se.process();

		RMapCache<String, String> map = rc.getMapCache("123");
		try {
			map.fastPut("1", "2");
			String s = map.get("1");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Spring log snippet:
2017-06-29 09:43:26.658  INFO 64974 --- [           main] org.redisson.Version                     : Redisson 3.4.3
2017-06-29 09:43:26.900  INFO 64974 --- [           main] o.r.c.SentinelConnectionManager          : master: redis://127.0.0.1:6381 added
2017-06-29 09:43:26.904  INFO 64974 --- [           main] o.r.c.SentinelConnectionManager          : slave: redis://127.0.0.1:6379 added
2017-06-29 09:43:26.923  INFO 64974 --- [isson-netty-1-7] o.r.c.pool.MasterConnectionPool          : 10 connections initialized for /127.0.0.1:6381
2017-06-29 09:43:26.931  INFO 64974 --- [sson-netty-1-11] o.r.c.SentinelConnectionManager          : sentinel: 127.0.0.1:26179 added
2017-06-29 09:43:26.931  INFO 64974 --- [sson-netty-1-10] o.r.c.SentinelConnectionManager          : sentinel: 127.0.0.1:26381 added
2017-06-29 09:43:26.993  INFO 64974 --- [           main] o.s.s.quartz.SchedulerFactoryBean        : Loading Quartz config from [class path resource [quartz.properties]]
2017-06-29 09:43:27.003  INFO 64974 --- [           main] org.quartz.impl.StdSchedulerFactory      : Using default implementation for ThreadExecutor
2017-06-29 09:43:27.008  INFO 64974 --- [           main] org.quartz.core.SchedulerSignalerImpl    : Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl
2017-06-29 09:43:27.008  INFO 64974 --- [           main] org.quartz.core.QuartzScheduler          : Quartz Scheduler v.2.3.0 created.
2017-06-29 09:43:27.009  INFO 64974 --- [           main] org.quartz.simpl.RAMJobStore             : RAMJobStore initialized.
2017-06-29 09:43:27.009  INFO 64974 --- [           main] org.quartz.core.QuartzScheduler          : Scheduler meta-data: Quartz Scheduler (v2.3.0) 'scheduler' with instanceId 'NON_CLUSTERED'
  Scheduler class: 'org.quartz.core.QuartzScheduler' - running locally.
  NOT STARTED.
  Currently in standby mode.
  Number of jobs executed: 0
  Using thread pool 'org.quartz.simpl.SimpleThreadPool' - with 1 threads.
  Using job-store 'org.quartz.simpl.RAMJobStore' - which does not support persistence. and is not clustered.

2017-06-29 09:43:27.009  INFO 64974 --- [           main] org.quartz.impl.StdSchedulerFactory      : Quartz scheduler 'scheduler' initialized from an externally provided properties instance.
2017-06-29 09:43:27.009  INFO 64974 --- [           main] org.quartz.impl.StdSchedulerFactory      : Quartz scheduler version: 2.3.0
2017-06-29 09:43:27.009  INFO 64974 --- [           main] org.quartz.core.QuartzScheduler          : JobFactory set to: de.chandre.quartz.spring.AutowiringSpringBeanJobFactory@40298285
2017-06-29 09:43:27.217  INFO 64974 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@61009542: startup date [Thu Jun 29 09:43:25 CDT 2017]; root of context hierarchy
2017-06-29 09:43:27.260  INFO 64974 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2017-06-29 09:43:27.261  INFO 64974 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2017-06-29 09:43:27.281  INFO 64974 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-06-29 09:43:27.281  INFO 64974 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-06-29 09:43:27.306  INFO 64974 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-06-29 09:43:27.573  INFO 64974 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2017-06-29 09:43:27.579  INFO 64974 --- [           main] o.s.c.support.DefaultLifecycleProcessor  : Starting beans in phase 2147483647
2017-06-29 09:43:27.579  INFO 64974 --- [           main] o.s.s.quartz.SchedulerFactoryBean        : Starting Quartz Scheduler now
2017-06-29 09:43:27.579  INFO 64974 --- [           main] org.quartz.core.QuartzScheduler          : Scheduler scheduler_$_NON_CLUSTERED started.
2017-06-29 09:43:27.587  INFO 64974 --- [           main] o.e.j.s.h.ContextHandler.application     : Initializing Spring FrameworkServlet 'dispatcherServlet'
2017-06-29 09:43:27.587  INFO 64974 --- [           main] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2017-06-29 09:43:27.599  INFO 64974 --- [           main] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 12 ms
2017-06-29 09:43:27.615  INFO 64974 --- [           main] o.e.jetty.server.AbstractConnector       : Started ServerConnector@54e81b21{HTTP/1.1,[http/1.1]}{0.0.0.0:8090}
2017-06-29 09:43:27.617  INFO 64974 --- [           main] .s.b.c.e.j.JettyEmbeddedServletContainer : Jetty started on port(s) 8090 (http/1.1)
2017-06-29 09:43:27.621  INFO 64974 --- [           main] c.k.s.p.OrderProcessorApplication        : Started OrderProcessorApplication in 2.902 seconds (JVM running for 3.259)
org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (EVAL) with params: [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 5, 123, redisson__timeout__set:{123}, redisson__idle__set:{123}, redisson_map_cache_created:{123}, redisson_map_cache_updated:{123}, 1498747454972, [34, 49, 34], [34, 50, 34]] channel: [id: 0x041d1a59, L:/127.0.0.1:62642 - R:/127.0.0.1:6381]
	at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:646)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
	at java.lang.Thread.run(Thread.java:745)
2017-06-29 09:44:20.430  INFO 64974 --- [  redisson-3-14] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has up
2017-06-29 09:44:20.431  INFO 64974 --- [  redisson-3-16] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has up
2017-06-29 09:44:20.438  INFO 64974 --- [isson-netty-1-4] o.r.c.pool.MasterConnectionPool          : 10 connections initialized for /127.0.0.1:6379
2017-06-29 09:44:20.438  INFO 64974 --- [  redisson-3-13] o.r.c.SentinelConnectionManager          : master redis://127.0.0.1:6381 changed to redis://127.0.0.1:6379
org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (EVAL) with params: [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 5, 123, redisson__timeout__set:{123}, redisson__idle__set:{123}, redisson_map_cache_created:{123}, redisson_map_cache_updated:{123}, 1498747458005, [34, 49, 34], [34, 50, 34]] channel: [id: 0x641bdb90, L:/127.0.0.1:62644 - R:/127.0.0.1:6381]
	at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:646)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
	at java.lang.Thread.run(Thread.java:745)
2017-06-29 09:44:25.451  WARN 64974 --- [   redisson-3-4] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has down
2017-06-29 09:44:25.456  WARN 64974 --- [   redisson-3-3] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has down
2017-06-29 09:45:11.415  INFO 64974 --- [   redisson-3-2] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has up
2017-06-29 09:45:11.605  INFO 64974 --- [   redisson-3-1] o.r.c.SentinelConnectionManager          : slave: 127.0.0.1:6381 has up
org.redisson.client.RedisException: ERR Error running script (call to f_251ec2dd5ace5005169a1407c376c269a9838a5c): @user_script:1: @user_script: 1: -READONLY You can't write against a read only slave.   . channel: [id: 0xc6bb6b64, L:/127.0.0.1:63323 - R:/127.0.0.1:6381] command: CommandData [promise=org.redisson.misc.RedissonPromise@3c893d51[Not completed], command=(EVAL), params=[local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 5, 123, redisson__timeout__set:{123}, redisson__idle__set:{123}, redisson_map_cache_created:{123}, redisson_map_cache_updated:{123}, 1498747532973, [34, 49, 34], [34, 50, 34]], codec=org.redisson.codec.JsonJacksonCodec@6f240f43]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:267)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	at java.lang.Thread.run(Thread.java:745)

As you can from see in above above logs, node 127.0.0.1:6381 joined as slave (but was master in the beginning). But Redisson tries to insert data into it.
Please let me know if I am doing anything wrong in my configuration, or this is a bug with Redisson.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi. Debugging my swarm cluster and down my network, then I see:
Message: org.redisson.client.RedisTimeoutException: Redis server response timeout (500 ms) occured for command: (INCRBY) with params: [..., 0] channel: [id: 0x315e345a, L:/172.18.0.8:54874 - R:/192.168.167.182:6379].
Only restart help me. Why can you reconnect?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Who controls the count of connection to the remote server? You or I?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have a requirement where I need to use take() from RPriorityQueue, But I can't found any RPriorityBlockingQueue, can you implement Priority Blocking Queue?
PriorityBlockingQueue oracle doc
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
errorInfo:
org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 26 in XML document from class path resource [application-service.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 26; columnNumber: 42; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'redisson:client' 的声明。
The config header is copy from this project https://github.com/redisson/redisson/wiki/14.-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88
my config as bellow:


<context:component-scan base-package="com.rqb.*.service" />

<redisson:client id="redissonClient">
<redisson:single-server address="192.168.0.32::6380"/>
</redisson:client>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: ERR Error running script (call to f_44835d092e21a738755f49f8c3e9f6f442b617a1): @user_script:1: user_script:1: too many results to unpack . channel: [id: 0xd1cbb036, L:/172.24.142.185:52278 - R:/10.144.17.21:8100] command: CommandData [promise=org.redisson.misc.RedissonPromise@376618da[Not completed], command=(EVAL), params=[for i, value in ipairs(ARGV) do if i % 2 == 0 then local val = struct.pack('dLc0', 0, string.len(...], codec=org.redisson.codec.JsonJacksonCodec@5bafb1ee]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:267)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
at java.lang.Thread.run(Thread.java:745)
23:30:13.003 [main] INFO  o.s.b.a.l.AutoConfigurationReportLoggingInitializer 101 -
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I can't find the example how can i use redisson with spring-session as a spring-xml config
this is my spring-xml
<bean class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" >
	<constructor-arg name="poolConfig" ref="jedisPoolConfig"></constructor-arg>
	<property name="hostName" value="10.33.25.13"></property>
	<property name="port" value="6379"></property>
 </bean>
 
<bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration" />

<redisson:client>
	<redisson:single-server address="redis://10.33.25.13:6379"/>
</redisson:client> 

Now I config redis-server twice  and  i must  add spring-data-redis and jedis for the spring-session. the redisson's wiki show the code  we can config with java code to use this 2, but i don't know how can i use thsi 2 with  spring-xml config
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After updating to 3.4.3 I got a parse URI exception by setting my Redis address, which is in the form: redis-instance.something.else.0001.euc3.cache.amazonaws.com. Switching back to 3.4.2 everything works fine. The error relies in org.redisson.misc.URLBuilder.create which has been changed in 3.4.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since netty keeps being a source of headaches sometimes, specially when using this library in combination with Play Framerwork or AsyncHttpClient or gRPC, as all of them use Netty, and netty seems to not play very nice with differences even on minor and hotfix versions.
Now i am testing with the newly release play 2.6 which has netty 4.0.x but since this version they shaded it, but i am still having issues when trying to use the nativeEpoll and including the dependency to redisson, I am still trying to figure out the cause, since the dependency is there but i still get
java.lang.NoSuchMethodError: Method io.netty.channel.epoll.Native.recvFd0(I)I not found
I will be testing a few more things soon, but if anyone has observed anything like that using play 2.6, feel free to mention.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello! Could you please explain what's going on?
Using Redisson 3.4.3 in Java EE with Wildfly 10.1.0.Final on Linux in production.
JRE 1.8.
This is how I configure it (may be not the excelent solution, but anyway...):
@Singleton
@Startup
public class RedisClientBean{

private static RedissonClient client;

public RedissonClient getClient(){
    return client;
}

@PostConstruct
public void init(){
    Config config = new Config();
    try{
      config.useSentinelServers()
                .setMasterConnectionPoolSize(200)
                .setSlaveConnectionPoolSize(200)
                .setConnectTimeout(15000)
                .setReconnectionTimeout(3000)
                .setRetryAttempts(20)
                .setFailedAttempts(20)
                .setRetryInterval(3000)
                .setClientName("MyRedissonClient")
                .setMasterName("mymaster")
                .addSentinelAddress(.........);
      client = Redisson.create(config); 
    } catch (Exception e){
         throw new RuntimeException("Unable to init Redis connection : "+e.toString(), e);
    }
}

@PreDestroy
public void kill(){
    if(client != null){
        client.shutdown();
    }
}

}

And all the Stateless beans use this static RedissonClient instance to use API's business.
After some time (about several hours) I started to face to this stack trace (even if no invocations of Redisson API were done) :
23:04:32,009 ERROR [stderr] (redisson-3-257) Exception in thread "redisson-3-257" java.lang.IllegalStateException: failed to create a child event loop
23:04:32,009 ERROR [stderr] (redisson-3-257) Exception in thread "redisson-3-268" 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:88)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:58)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.MultithreadEventLoopGroup.<init>(MultithreadEventLoopGroup.java:52)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:87)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:82)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:63)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:51)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:43)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.client.RedisClientConfig.<init>(RedisClientConfig.java:42)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.connection.MasterSlaveConnectionManager.createRedisConfig(MasterSlaveConnectionManager.java:363)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:358)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.connection.SentinelConnectionManager.registerSentinel(SentinelConnectionManager.java:158)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.connection.SentinelConnectionManager.onSentinelAdded(SentinelConnectionManager.java:220)
23:04:32,009 ERROR [stderr] (redisson-3-257) 	at org.redisson.connection.SentinelConnectionManager$1$1.onMessage(SentinelConnectionManager.java:179)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:81)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at org.redisson.client.handler.CommandDecoder$1.run(CommandDecoder.java:366)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at java.lang.Thread.run(Thread.java:745)
23:04:32,010 ERROR [stderr] (redisson-3-257) Caused by: io.netty.channel.ChannelException: failed to open a new selector
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:175)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoop.<init>(NioEventLoop.java:149)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:127)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:36)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:84)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	... 19 more
23:04:32,010** ERROR [stderr] (redisson-3-257) Caused by: java.io.IOException: Too many open files
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at sun.nio.ch.IOUtil.makePipe(Native Method)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at sun.nio.ch.EPollSelectorImpl.<init>(EPollSelectorImpl.java:65)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at sun.nio.ch.EPollSelectorProvider.openSelector(EPollSelectorProvider.java:36)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	at io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:173)
23:04:32,010 ERROR [stderr] (redisson-3-257) 	... 23 more
23:04:32,010 ERROR [stderr] (redisson-3-268) java.lang.IllegalStateException: failed to create a child event loop
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:88)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:58)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.MultithreadEventLoopGroup.<init>(MultithreadEventLoopGroup.java:52)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:87)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:82)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:63)
23:04:32,010 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:51)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.<init>(NioEventLoopGroup.java:43)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.client.RedisClientConfig.<init>(RedisClientConfig.java:42)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.connection.MasterSlaveConnectionManager.createRedisConfig(MasterSlaveConnectionManager.java:363)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:358)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.connection.SentinelConnectionManager.registerSentinel(SentinelConnectionManager.java:158)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.connection.SentinelConnectionManager.onSentinelAdded(SentinelConnectionManager.java:220)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.connection.SentinelConnectionManager$1$1.onMessage(SentinelConnectionManager.java:179)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:81)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at org.redisson.client.handler.CommandDecoder$1.run(CommandDecoder.java:366)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at java.lang.Thread.run(Thread.java:745)
23:04:32,011 ERROR [stderr] (redisson-3-268) Caused by: io.netty.channel.ChannelException: failed to open a new selector
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at 

io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:175)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoop.<init>(NioEventLoop.java:149)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:127)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:36)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at io.netty.util.concurrent.MultithreadEventExecutorGroup.<init>(MultithreadEventExecutorGroup.java:84)
23:04:32,011 ERROR [stderr] (redisson-3-268) 	... 19 more
23:04:32,011 ERROR [stderr] (redisson-3-268) Caused by: java.io.IOException: Too many open files
23:04:32,011 ERROR [stderr] (redisson-3-268) 	at sun.nio.ch.IOUtil.makePipe(Native Method)
23:04:32,012 ERROR [stderr] (redisson-3-268) 	at sun.nio.ch.EPollSelectorImpl.<init>(EPollSelectorImpl.java:65)
23:04:32,012 ERROR [stderr] (redisson-3-268) 	at sun.nio.ch.EPollSelectorProvider.openSelector(EPollSelectorProvider.java:36)
23:04:32,012 ERROR [stderr] (redisson-3-268) 	at io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:173)
23:04:32,012 ERROR [stderr] (redisson-3-268) 	... 23 more

FDs examination with lsof -p WILDFLY_PID | wc -l  shows that count of opened FDs increases each minute.
Using lsof -p WILDFLY_PID we can see lots of rows like these :
java    11317 wildfly  427r     FIFO               0,10      0t0 1658137609 pipe
java    11317 wildfly  428w     FIFO               0,10      0t0 1658137609 pipe
java    11317 wildfly  429u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  430r     FIFO               0,10      0t0 1658126709 pipe
java    11317 wildfly  431w     FIFO               0,10      0t0 1658126709 pipe
java    11317 wildfly  432u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  433r     FIFO               0,10      0t0 1658126710 pipe
java    11317 wildfly  434w     FIFO               0,10      0t0 1658126710 pipe
java    11317 wildfly  435u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  436r     FIFO               0,10      0t0 1658126711 pipe
java    11317 wildfly  437w     FIFO               0,10      0t0 1658126711 pipe
java    11317 wildfly  438u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  439r     FIFO               0,10      0t0 1658126712 pipe
java    11317 wildfly  440w     FIFO               0,10      0t0 1658126712 pipe
java    11317 wildfly  441u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  442r     FIFO               0,10      0t0 1658126713 pipe
java    11317 wildfly  443w     FIFO               0,10      0t0 1658126713 pipe
java    11317 wildfly  444u  a_inode               0,11        0       8156 [eventpoll]
java    11317 wildfly  445r     FIFO               0,10      0t0 1658126714 pipe

ulimit -a gives me nofiles = 64000 soft and hard, and it is said to be good for production environment.
How to deal with it?
(Fortunatelly the problem had some not excellent solution : I switched to single server configuration, and that worked for me, but how about API's sentinel configuration?)
By the way since Redisson uses netty, how to (or should I at all) correctly deal with EventLoopGroup, mentioned in this theme with almost the same issue ? : https://github.com/netty/netty/issues/639
As far as I understood from that article, EventLoopGroup should be shared between clients.
But EventLoopGroup is not mentioned in Redisson documentation at all (Am I wrong?)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reactor is about to be released. It would be great have Redisson compatible with the latest version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use spring session with redisson, I got some error when call session method
<bean class="org.springframework.session.web.http.HeaderHttpSessionStrategy" />

<bean
		class="org.springframework.security.web.session.HttpSessionEventPublisher" />

	<bean class="org.redisson.spring.session.config.RedissonHttpSessionConfiguration">
		<property name="maxInactiveIntervalInSeconds" value="10"></property>
		<property name="keyPrefix" value="api" />
	</bean>

    <redisson:client>
        <redisson:single-server address="redis://${redis.server}:${redis.port}" password="${redis.password}" database="${redis.db}" connection-minimum-idle-size="${redis.minconection}" connection-pool-size="${redis.poolsize}" />
    </redisson:client>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I'm new to redisson. And I'm learning using priority queue with customized comparator. My code works well for the first time, but fails the second. Seems it cannot load the comparator class.
Here's my code.
	public static void test() { Config config = new Config(); config.setUseLinuxNativeEpoll(false); config.useSingleServer().setAddress("redis://0.0.0.0:6379"); RedissonClient redisson = Redisson.create(config); RPriorityQueue<Integer> queue = redisson.getPriorityQueue("Queue2"); queue.trySetComparator(new MyComparator()); queue.add(1); queue.add(2); } 
`
class MyComparator implements Comparator {
	@Override
	public int compare(Integer o1, Integer o2) {
		// TODO Auto-generated method stub
		return o1 - o2;
	}

}`
The exception:
Exception in thread "main" java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.redisson.RedissonPriorityQueue can not access a member of class MyComparator with modifiers "" at org.redisson.RedissonPriorityQueue.loadComparator(RedissonPriorityQueue.java:134) at org.redisson.RedissonPriorityQueue.<init>(RedissonPriorityQueue.java:102) at org.redisson.Redisson.getPriorityQueue(Redisson.java:617) Caused by: java.lang.IllegalAccessException: Class org.redisson.RedissonPriorityQueue can not access a member of class MyComparator with modifiers "" at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102) at java.lang.Class.newInstance(Class.java:436) at org.redisson.RedissonPriorityQueue.loadComparator(RedissonPriorityQueue.java:129) 
So anybody can tell me how to write customized comparator for priority queue.
Thanks so much !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version:2.9.3
错误日志:
Caused by: org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace [http://redisson.org/schema/redisson]
3.4.3版本的jar里面是有spring.scheme和org.redisson.spring.support.RedissonNamespaceHandlerSupport这两个文件的
然而在2.9.3的jar包里面并没有xsd文件和spring.scheme相关文件
导致spring配置
http://redisson.org/schema/redisson http://redisson.org/schema/redisson/redisson.xsd会报错
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi. Why this code does not work?
ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE);
        objectMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);
        objectMapper.setConfig(objectMapper.getSerializationConfig().withView(MobileView.MainFeed.class));

        Config config = new Config();
        config
            .setCodec(new JsonJacksonCodec(objectMapper))
            .useSingleServer()
            .setAddress("redis://" + "localhost" + ":" + 6379)
            .setFailedAttempts(10_000)
            .setReconnectionTimeout(300)
            .setRetryAttempts(3)
            .setRetryInterval(100);
        RedissonClient redissonClient = Redisson.create(config);

        LocalCachedMapOptions options = LocalCachedMapOptions.defaults()
            .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.LFU)
            .cacheSize(1000)
            .invalidationPolicy(LocalCachedMapOptions.InvalidationPolicy.ON_CHANGE);

        RLocalCachedMap<String, List<FeedPost>> map = redissonClient.getLocalCachedMap("test1", options);

        map.put("1", Collections.singletonList(FeedPost.builder().buttonLink("tt").build()));
        map.put("1", Collections.singletonList(FeedPost.builder().buttonLink("tt").build()));
I see on second put:
Exception in thread "redisson-3-2" java.lang.NullPointerException
	at org.redisson.RedissonLocalCachedMap$2.onMessage(RedissonLocalCachedMap.java:307)
	at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:76)
	at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:81)
	at org.redisson.client.handler.CommandDecoder$1.run(CommandDecoder.java:366)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in class CommandAsyncService 498-503 line
final RFuture connectionFuture;
if (readOnlyMode) {
connectionFuture = connectionManager.connectionReadOp(source, command);
} else {
connectionFuture = connectionManager.connectionWriteOp(source, command);
}
In my opinion, after the bootstrap(RedissonClient redisson = Redisson.create(config)),we have
Created serveral long connections  from the client to redis server.
Can we poll the connection from che ClientConnectionsEntry.freeSubscribeConnections  directly
without using the connectionFuture. I think using che connectionFuture is nonecessary。
Who can answer the question？Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi team,
        Config config = new Config();
        config.useClusterServers().addNodeAddress("redis://10.16.179.14:6379", "redis://10.16.179.30:6379", "redis://10.16.179.31:6379",
                "redis://10.16.179.24:6379", "redis://10.16.179.16:6379", "redis://10.16.179.15:6379");
        RedissonClient redisson = Redisson.create(config);
        redisson.shutdown();

Redisson 3.4.4
Windows 7 64bit
Oracle jdk 1.8.0_111
It throw an error, but it works fine @3.4.2 without prefix (redis://)
Exception in thread "main" org.redisson.client.RedisConnectionException: Can't connect to servers!
	at org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:139)
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)
	at org.redisson.Redisson.<init>(Redisson.java:116)
	at org.redisson.Redisson.create(Redisson.java:155)
	at redis.main(redis.java:11)
Caused by: org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.client.RedisConnection.await(RedisConnection.java:159)
	at org.redisson.client.RedisConnection.sync(RedisConnection.java:183)
	at org.redisson.client.RedisConnection.sync(RedisConnection.java:169)
	at org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:93)
	... 4 more
Caused by: java.lang.IllegalArgumentException: Illegal character in scheme name at index 0: []r[]e[]d[]i[]s[]:[]/[]/[]:[]0[]
	at java.net.URI.create(URI.java:852)
	at org.redisson.misc.URIBuilder.create(URIBuilder.java:37)
	at org.redisson.cluster.ClusterNodeInfo.setAddress(ClusterNodeInfo.java:56)
	at org.redisson.client.protocol.decoder.ClusterNodesDecoder.decode(ClusterNodesDecoder.java:50)
	at org.redisson.client.protocol.decoder.ClusterNodesDecoder.decode(ClusterNodesDecoder.java:35)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:259)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:103)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.net.URISyntaxException: Illegal character in scheme name at index 0: []r[]e[]d[]i[]s[]:[]/[]/[]:[]0[]
	at java.net.URI$Parser.fail(URI.java:2848)
	at java.net.URI$Parser.checkChars(URI.java:3021)
	at java.net.URI$Parser.checkChar(URI.java:3031)
	at java.net.URI$Parser.parse(URI.java:3047)
	at java.net.URI.<init>(URI.java:588)
	at java.net.URI.create(URI.java:850)
	... 32 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it's related to #952 and maybe  #959
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When i use redisson 2.9.4 , i find this error in logs
java.lang.UnsupportedClassVersionError: reactor/fn/Supplier : Unsupported major.minor version 51.0 (unable to load class reactor.fn.Supplier)
	at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2948)
	at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1208)
	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1688)
	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1569)
	at org.redisson.RedissonBatch.<init>(RedissonBatch.java:68)
	at org.redisson.Redisson.createBatch(Redisson.java:571)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you! Could you please cover it with a test?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I'm using Redisson with two Tomcat, each one in a virtual instance behind a Load Balancer on Azure, using Azure Redis PaaS as centralized database.
Everything works great, both Tomcat can create and store session on Redis (I can easily see keys/values serialized on Redis) and both can retrieve the stored session correctly.
My issue/question is: should Tomcat be able to delete keys automatically from Redis when the session expires? The sessionDestroyed() method on the SessionListener in correctly invoked, so I'm sure that Tomcat is destroying the session internally, but keys keep staying on Redis. I was assuming that Tomcat, through Redisson, whould be able to delete keys from Redis as well.
Thanks.
IP
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If I have a list or set to save data,How can l get data by pagination?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm trying to setup a Tomcat 8 cluster with 2 nodes without sticky session.
Issues:
1.java.lang.IllegalStateException: setAttribute: Session [F766FB4EAE8FE29451215A67300EF46A] has already been invalidated
2. ```
Caused by: java.io.IOException: java.lang.ClassNotFoundException: xxx.dto.PermissionDTO
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:53)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:259)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:289)
at org.redisson.client.handler.CommandDecoder.decodeFromCheckpoint(CommandDecoder.java:154)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)


3. From RedissonSessionManager and RedissonSession i can't understand how this solution replicates in real time( no sticky sessions) the same session from one node to another.I was expecting that method getAttribute should use the map also. If someone can explain this.

And a feature if it is possible:
can we filter some session attributes from going into RMap?

Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use redisson with springboot，throw the following Exception when starting:
Exception in thread "redisson-netty-17-12" java.lang.NoClassDefFoundError: ch/qos/logback/classic/spi/ThrowableProxy
at ch.qos.logback.classic.spi.LoggingEvent.(LoggingEvent.java:119)
at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:419)
at ch.qos.logback.classic.Logger.filterAndLog_0_Or3Plus(Logger.java:383)
at ch.qos.logback.classic.Logger.warn(Logger.java:692)
at io.netty.util.internal.logging.Slf4JLogger.warn(Slf4JLogger.java:151)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:861)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Redis has the feature HSCAN to retrieve the hash keys that matches the given pattern.
I will retrieve the values one by one through get after filtering the keys because some of the keys will contain objects that do not exists for the certain environment.
Is there a way to do this without modifying your code?
Thanks =)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
项目非常强大,可是引入的包实在太多了,maven引入居然多了13个包, all包差不多10M大.
本来项目引入过多的包,实在难管理,体积也是各种大.
如果我只是单纯要一个redis客户端,不需要其他复杂功能,应该怎么缩减??
json包能否用其他的替换,因为项目其他包也有json依赖,结果我的项目里就有3,4种不同的json架包了. 推荐做成SPI方式的,比如fastjson,jackson都有实现jax-rs @Provider.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi team:
redisson throw an error when I put a "null value" into cache with fst codec, but works fine when I use kryo codec.
Redisson: 3.4.2
FST: 2.51
Win7 64bit
Oracle jdk 1.8.0_111
Spring cache: 4.3.9
15:06:35.728 [redisson-netty-1-3] WARN  io.netty.channel.AbstractChannelHandlerContext - Failed to mark a promise as failure because it has failed already: DefaultChannelPromise@169f8a31(failure: io.netty.handler.codec.EncoderException: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable), unnotified cause: io.netty.handler.codec.EncoderException: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:125)
	at org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:63)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)
	at io.netty.channel.ChannelOutboundHandlerAdapter.write(ChannelOutboundHandlerAdapter.java:104)
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:76)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:801)
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814)
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794)
	at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1027)
	at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:301)
	at org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:102)
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:79)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
	at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38)
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1089)
	at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1136)
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1078)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable
	at org.nustaq.serialization.FSTClazzInfo.<init>(FSTClazzInfo.java:142)
	at org.nustaq.serialization.FSTClazzInfoRegistry.getCLInfo(FSTClazzInfoRegistry.java:130)
	at org.nustaq.serialization.FSTObjectOutput.getFstClazzInfo(FSTObjectOutput.java:523)
	at org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:416)
	at org.nustaq.serialization.FSTObjectOutput.writeObjectInternal(FSTObjectOutput.java:327)
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:294)
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:204)
	at org.redisson.codec.FstCodec$2.encode(FstCodec.java:84)
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:103)
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:45)
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107)
	... 32 more

io.netty.handler.codec.EncoderException: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:125) ~[netty-codec-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:63) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120) ~[netty-codec-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.ChannelOutboundHandlerAdapter.write(ChannelOutboundHandlerAdapter.java:104) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:76) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:801) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1027) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:301) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:102) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:79) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1089) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1136) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1078) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_111]
Caused by: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable
	at org.nustaq.serialization.FSTClazzInfo.<init>(FSTClazzInfo.java:142) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTClazzInfoRegistry.getCLInfo(FSTClazzInfoRegistry.java:130) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.getFstClazzInfo(FSTObjectOutput.java:523) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:416) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObjectInternal(FSTObjectOutput.java:327) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:294) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:204) ~[fst-2.51.jar:?]
	at org.redisson.codec.FstCodec$2.encode(FstCodec.java:84) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:103) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:45) ~[redisson-3.4.2.jar:?]
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107) ~[netty-codec-4.1.10.Final.jar:4.1.10.Final]
	... 32 more
15:06:35.728 [qtp1225358173-57] ERROR controller.handler.ControllerExceptionHandler - handle exception! { dbId: 4a8b361cdcd6e1b057c9d9a65901bd9dc6bb5d19e619108dfad4343d239c6d0a, userId: 7a5afbdf44604531957f2969e877de09 }
org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:322) ~[redisson-3.4.2.jar:?]
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:165) ~[redisson-3.4.2.jar:?]
	at org.redisson.RedissonObject.get(RedissonObject.java:69) ~[redisson-3.4.2.jar:?]
	at org.redisson.RedissonMapCache.fastPut(RedissonMapCache.java:477) ~[redisson-3.4.2.jar:?]
	at org.redisson.spring.cache.RedissonCache.put(RedissonCache.java:97) ~[redisson-3.4.2.jar:?]
	at com.neweggtech.server.commons.spring.BufferedSpringCache.put(BufferedSpringCache.java:56) ~[neweggdbs-commons-1.0.146.0.jar:?]
	at org.springframework.cache.interceptor.AbstractCacheInvoker.doPut(AbstractCacheInvoker.java:85) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.cache.interceptor.CacheAspectSupport$CachePutRequest.apply(CacheAspectSupport.java:784) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:417) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:327) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:61) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at cache.impl.DistributedCacheImpl$$EnhancerBySpringCGLIB$$2ad062b6.getCachedGlobalItemStyle(<generated>) ~[bin/:?]
	at service.impl.FileServiceImpl.getFile(FileServiceImpl.java:239) ~[bin/:?]
	at service.impl.FileServiceImpl$$FastClassBySpringCGLIB$$e163a904.invoke(<generated>) ~[bin/:?]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) ~[spring-core-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:669) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at service.impl.FileServiceImpl$$EnhancerBySpringCGLIB$$928ee3ca.getFile(<generated>) ~[bin/:?]
	at controller.impl.FileControllerImpl.getFile(FileControllerImpl.java:84) ~[bin/:?]
	at controller.impl.FileControllerImpl$$FastClassBySpringCGLIB$$9e52f6d4.invoke(<generated>) ~[bin/:?]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) ~[spring-core-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:85) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at aop.impl.ControllerAspect.executeLocalRequest(ControllerAspect.java:161) ~[bin/:?]
	at aop.impl.ControllerAspect.processRequest(ControllerAspect.java:143) ~[bin/:?]
	at aop.impl.ControllerAspect.processRequest(ControllerAspect.java:125) ~[bin/:?]
	at aop.impl.ControllerAspect.controllerAround(ControllerAspect.java:77) ~[bin/:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_111]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_111]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_111]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_111]
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) ~[spring-aop-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at controller.impl.FileControllerImpl$$EnhancerBySpringCGLIB$$5a019369.getFile(<generated>) ~[bin/:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_111]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_111]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_111]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_111]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) ~[spring-web-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:755) ~[javax.servlet.jar:?]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:848) ~[javax.servlet.jar:?]
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:684) ~[?:?]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1496) ~[?:?]
	at com.neweggtech.server.commons.web.filter.impl.LoggingFilter.doFilter(LoggingFilter.java:56) ~[neweggdbs-commons-web-1.0.146.0.jar:?]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1467) ~[?:?]
	at com.neweggtech.server.commons.web.filter.impl.CorsFilter.doFilter(CorsFilter.java:56) ~[neweggdbs-commons-web-1.0.146.0.jar:?]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1467) ~[?:?]
	at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:230) ~[javamelody-core-1.67.0.jar:1.67.0]
	at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:202) ~[javamelody-core-1.67.0.jar:1.67.0]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1467) ~[?:?]
	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:499) ~[?:?]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:137) ~[?:?]
	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:557) ~[?:?]
	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:231) ~[?:?]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1086) ~[?:?]
	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:428) ~[?:?]
	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:193) ~[?:?]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1020) ~[?:?]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135) ~[?:?]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116) ~[?:?]
	at org.eclipse.jetty.server.Server.handle(Server.java:370) ~[?:?]
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:494) ~[?:?]
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:982) ~[?:?]
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1043) ~[?:?]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:865) ~[?:?]
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240) ~[?:?]
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82) ~[?:?]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:667) ~[?:?]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52) ~[?:?]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608) ~[?:?]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543) ~[?:?]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_111]
Caused by: java.lang.RuntimeException: Class org.redisson.spring.cache.NullValue does not implement Serializable or externalizable
	at org.nustaq.serialization.FSTClazzInfo.<init>(FSTClazzInfo.java:142) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTClazzInfoRegistry.getCLInfo(FSTClazzInfoRegistry.java:130) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.getFstClazzInfo(FSTObjectOutput.java:523) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObjectWithContext(FSTObjectOutput.java:416) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObjectInternal(FSTObjectOutput.java:327) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:294) ~[fst-2.51.jar:?]
	at org.nustaq.serialization.FSTObjectOutput.writeObject(FSTObjectOutput.java:204) ~[fst-2.51.jar:?]
	at org.redisson.codec.FstCodec$2.encode(FstCodec.java:84) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:103) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:45) ~[redisson-3.4.2.jar:?]
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107) ~[netty-codec-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandEncoder.write(CommandEncoder.java:63) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:120) ~[netty-codec-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:816) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.ChannelOutboundHandlerAdapter.write(ChannelOutboundHandlerAdapter.java:104) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:76) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:801) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:814) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:794) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1027) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:301) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at org.redisson.client.handler.CommandsQueue.sendData(CommandsQueue.java:102) ~[redisson-3.4.2.jar:?]
	at org.redisson.client.handler.CommandsQueue.write(CommandsQueue.java:79) ~[redisson-3.4.2.jar:?]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1089) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1136) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1078) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462) ~[netty-transport-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144) ~[netty-common-4.1.10.Final.jar:4.1.10.Final]
	... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I got some error when I try to undeploy or reloading my webapp in tomcat manager.
spring config
  <!-- redisson redis config -->
    <redisson:client>
        <redisson:single-server address="redis://${redis.server}:${redis.port}" password="${redis.password}" database="${redis.db}" connection-minimum-idle-size="${redis.minconection}" connection-pool-size="${redis.poolsize}" />
    </redisson:client>

I also tried @PreDestroy on app destroy event as following code, but same error.
        redissonClient.shutdown();
        FastThreadLocal.removeAll();
        FastThreadLocal.destroy();
        InternalThreadLocalMap.remove();
        InternalThreadLocalMap.destroy();
        try {
            GlobalEventExecutor.INSTANCE.shutdownGracefully().get();
        } catch (final InterruptedException | ExecutionException e) {
            logger.error(" shut down  GlobalEvent error! ",e);
        }

Environment
tomcat 8.5.16
redisson 3.4.4
jdk 1.8

tomcat log
21-Jul-2017 17:14:06.592 INFO [http-nio-8080-exec-7] org.apache.catalina.core.StandardContext.reload Reloading Context with name [/fm] has started
21-Jul-2017 17:14:11.439 WARNING [http-nio-8080-exec-7] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [fm] appears to have started a thread named [Abandoned connection cleanup thread] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.lang.Object.wait(Native Method)
 java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
 com.mysql.cj.jdbc.AbandonedConnectionCleanupThread.run(AbandonedConnectionCleanupThread.java:43)
21-Jul-2017 17:14:11.440 WARNING [http-nio-8080-exec-7] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [fm] appears to have started a thread named [threadDeathWatcher-7-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 java.lang.Thread.sleep(Native Method)
 io.netty.util.ThreadDeathWatcher$Watcher.run(ThreadDeathWatcher.java:152)
 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
 java.lang.Thread.run(Thread.java:745)
21-Jul-2017 17:14:11.442 WARNING [http-nio-8080-exec-7] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [fm] appears to have started a thread named [globalEventExecutor-2-5] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 sun.misc.Unsafe.park(Native Method)
 java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
 java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
 java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
 io.netty.util.concurrent.GlobalEventExecutor.takeTask(GlobalEventExecutor.java:90)
 io.netty.util.concurrent.GlobalEventExecutor$TaskRunner.run(GlobalEventExecutor.java:230)
 io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
 java.lang.Thread.run(Thread.java:745)
21-Jul-2017 17:14:11.444 SEVERE [http-nio-8080-exec-7] org.apache.catalina.loader.WebappClassLoaderBase.checkThreadLocalMapForLeaks The web application [fm] created a ThreadLocal with key of type [java.lang.ThreadLocal] (value [java.lang.ThreadLocal@1d87dd4]) and a value of type [io.netty.util.internal.InternalThreadLocalMap] (value [io.netty.util.internal.InternalThreadLocalMap@15a166d]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.

any idea?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public Cache getCache(String name) {
        Cache cache = instanceMap.get(name);
        if (cache != null) {
            return cache;
        }
        if (!dynamic) {
            return cache;
        }
        CacheConfig config = configMap.get(name);
        if (config == null) {
            config = createDefaultConfig();
            configMap.put(name, config);
            return createMap(name, config);    //createMap method don`t use config,so can use createMapCache() replace
        }
        if (config.getMaxIdleTime() == 0 && config.getTTL() == 0) {
            return createMap(name, config);
        }
        return createMapCache(name, config);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis集群规模：20个节点，10主、10从；
17:21:00 [pool-57-thread-1] ERROR o.s.s.s.TaskUtils$LoggingErrorHandler - Unexpected error occurred in scheduled
task.
org.redisson.client.RedisTimeoutException: Redis server response timeout (60000 ms) occured for command: (EVAL)
with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('
pe..., 1, com.baidu.baixiao.dict.cache.CacheHandlerImpl, 30000, 296bce1e-7062-4778-88d0-6ac3c4819163:133] channe
l: [id: 0x42335488, L:/10.0.3.2:37336 - R:/10.150.177.11:8379]
at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:646)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
at java.lang.Thread.run(Thread.java:745)
17:21:01 [http-nio-8080-exec-17] INFO  c.b.g.s.i.AbsSecurityInterceptor - Intercept RateLimitInterceptor begin c
heck request /search.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I wanted to sure the connection still alive while putting objects to Redis and so tried to add connection listener. But the methods won't get triggered.
The redis version I'm working on:

➜  ~ redis-server --version
Redis server v=3.2.9 sha=00000000:0 malloc=libc bits=64 build=d97708fd9e007be7

	private static boolean connected = false;
	private static boolean running = true;

	public static void main(String[] args) {
		Config config = new Config();
		config.useSingleServer().setAddress("127.0.0.1:6379");

		RedissonClient redissonClient = Redisson.create(config);
		redissonClient.getNodesGroup().addConnectionListener(new ConnectionListener() {
			@Override
			public void onConnect(InetSocketAddress inetSocketAddress) {
				connected = true;
				System.out.println("Redis server connected");
			}

			@Override
			public void onDisconnect(InetSocketAddress inetSocketAddress) {
				connected = false;
				System.out.println("Redis server disconnected");
			}
		});

		while (running) {

			System.out.println("Redis status: " + connected);

			try {
				Thread.sleep(1000);
			}
			catch (InterruptedException e) {
				running = false;
			}
		}
	}
The output:

[main] INFO org.redisson.Version - Redisson 3.3.2
[redisson-netty-1-4] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for /127.0.0.1:6379
[redisson-netty-1-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /127.0.0.1:6379
Redis status: false
Redis status: false
Redis status: false
Redis status: false
Redis status: false
Redis status: false
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Greetings.
I have an application consisting of two applications in one ear. And we have separated them in two .war.
These applications share the session in redis database whit Spring Session Fst coded. The point is that there are classes that an application does not have in another and deserializacion fails. Is there any way to add a list of in each app to omit deserialization by class name so that each application gets the object it wants to share. There apps in Jsf and various session manage bean each .war.
Thanks sorry for My English.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
支持与spring boot整合么
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am not able to connect to redis cluster on my local machine using redisson but single redis server is working in redisson - kindly check the issue and let me know if there is something wrong on my end or some actually with 3.4.3 version of redisson.
2017-07-26 17:42:53,092 - [info]  o.r.Version - Redisson 3.4.3
If I am using: config.useSingleServer().setAddress("redis://127.0.0.1:6379") then redisson singleton client instance is getting created with the below mentioned pool details:
2017-07-26 17:43:52,237 - [info]  o.r.c.p.MasterPubSubConnectionPool - 1 connections initialized for /127.0.0.1:6379
2017-07-26 17:43:52,236 - [info]  o.r.c.p.MasterConnectionPool - 10 connections initialized for /127.0.0.1:6379
But, when I am specifying:
config.useClusterServers()
.addNodeAddress("redis://127.0.0.1:6380","redis://127.0.0.1:6381","redis://127.0.0.1:6382" ,"redis://127.0.0.1:6383" ,"redis://127.0.0.1:6384" ,"redis://127.0.0.1:6385","redis://127.0.0.1:6386", "redis://127.0.0.1:6387" , "redis://127.0.0.1:6388")
.setClientName("AppName")
.setConnectTimeout(10000)))
.setTimeout(Integer.parseInt(1000)))
.setReadMode(ReadMode.MASTER_SLAVE)
.setRetryAttempts(0)));
Application Logs:
2017-07-26 19:25:51,984 - [info]  o.r.Version - Redisson 3.4.3
2017-07-26 19:25:52,108 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6380
2017-07-26 19:25:52,111 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6381
2017-07-26 19:25:52,114 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6382
2017-07-26 19:25:52,117 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6383
2017-07-26 19:25:52,121 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6384
2017-07-26 19:25:52,123 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6385
2017-07-26 19:25:52,126 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6386
2017-07-26 19:25:52,129 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6387
2017-07-26 19:25:52,132 - [warn]  o.r.c.ClusterConnectionManager - Command execution timeout for /127.0.0.1:6388
Error Message: Can't connect to servers!
akshaymani@mac:$  redis-cli -p 6380
127.0.0.1:6380>
akshaymani@mac:$ date
Wed Jul 26 19:28:57 IST 2017
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using cache to generate some events on key expiry. As version 3.4.4 has support to add listeners directly using cache.getCollection.addListener. We are getting following exceptions and unable to find out the reason.
java.lang.NoSuchMethodError: io.netty.bootstrap.Bootstrap.config()Lio/netty/bootstrap/BootstrapConfig;
at org.redisson.client.RedisClient$2$1.operationComplete(RedisClient.java:260)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:567)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:406)
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:78)
at org.redisson.client.handler.BaseConnectionHandler.channelActive(BaseConnectionHandler.java:85)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(AbstractChannelHandlerContext.java:212)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelActive(AbstractChannelHandlerContext.java:198)
at io.netty.channel.DefaultChannelPipeline.fireChannelActive(DefaultChannelPipeline.java:818)
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:252)
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:282)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:528)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
at java.lang.Thread.run(Thread.java:748)
I checked the code of netty.jar we are using and Bootstrap.config is present.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It will be nice to have a functionality to connect via redisson to redis using a DNS as hostname instead of specifying host:port of all the nodes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While building for Android I get following error
// Gradle
compile 'org.redisson:redisson:2.9.4'
compileOptions {
sourceCompatibility JavaVersion.VERSION_1_7
targetCompatibility JavaVersion.VERSION_1_7
}
// Error
Error:Execution failed for task ':app:transformClassesWithNewClassShrinkerForFikDebug'. com.android.build.gradle.shrinker.ClassLookupException: Invalid class reference: org/springframework/beans/support/ArgumentConvertingMethodInvoker
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
代码如下：
RLock lock = redis.getLock("test");
lock.lock(3,TimeUnit.SECONDS);
偶尔会报下面的错误：
org.redisson.client.RedisTimeoutException: Subscribe timeout: (9500ms)
at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:125)
at org.redisson.RedissonLock.lockInterruptibly(RedissonLock.java:121)
at org.redisson.RedissonLock.lock(RedissonLock.java:99)
配置文件如下：
"sentinelServersConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":5000,
"retryAttempts":3,
"retryInterval":1500,
"reconnectionTimeout":3000,
"failedAttempts":3,
jdk为1.8，Redisson版本为3.4.4，redis版本为3.0.6
是我配置的超时时间有问题吗？
应该配置多少合适呢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I define a live object like this:
@REntity
public class ExampleLiveObject {
    @RId(generator = LongGenerator.class)
    private Long id;
    @RCascade(RCascadeType.ALL)
    private Map<Integer, Integer> map;
}

Then try to expire a live object:
RLiveObjectSerivce service;
ExampleLiveObject liveObject;

service.asRExpirable(liveObject).expire(1, TimeUnit.SECONDS);

The live object will be removed after one second, but the map in the object won't. Is this behavior expected?
My current workaround is to expire each distributed object field in a live object explicitly.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
    RedissonClient client = Redisson.create(config);

    System.out.println("has keys: " + client.getKeys().count() );
    Iterator rkey =client.getKeys().getKeys().iterator();
    int count = 0;
    while (rkey.hasNext() ){
        count++;
        rkey.next();
    }
    System.out.println("count: "+ count);

The counts of keys are 3000 for example, but the iterator seem never stops counting. Why?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is it possible to store Redisson Live Object in RSetCache such that when the live object expires, it is evicted from RSetCache as well?
Also can we access the Live Objects from RSetCache?  While iterating over the live objects in RSetCache, I tried to assign the object to an instance of Live Object Class but I got an error stating that I cannot typecast object of type RedissonReference to object of type Class X.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have configured redisson with the following configuration
"replicatedServersConfig": { "timeout":1000, "nodeAddresses": ["redis://redis-cache-1.redis.ppe:6379","redis://redis-cache-0.redis.ppe:6379","redis://redis-cache-2.redis.ppe:6379"] }
I am initalising reddison client at the start of my application like this
try { Config config = Config.fromJSON(redisConfiguration.toString()); RedissonReactiveClient client = Redisson.createReactive(config); cache = client.getMapCache("cache"); } catch (IOException e) { throw new IllegalArgumentException(e); }
I wanted to test the scenario of how redisson behaves when master  goes down
I brought the master node down and  it was back up within a minute
I see this in redisson logs
`
13:46:56.482 [] [redisson-netty-3-3] INFO  o.r.c.ReplicatedConnectionManager:195 - Master has changed from redis://redis-cache-2.redis.ppe:6379 to redis://redis-cache-0.redis.ppe:6379
 
So redisson aware of the new master
However I am getting this exception from the logs
org.redisson.client.RedisTimeoutException: Command execution timeout for redis-cache-2.redis.ppe/100.96.5.7:6379
at org.redisson.client.RedisConnection$2.run(RedisConnection.java:212) ~[productlist.jar:na]
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [productlist.jar:na]
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:120) [productlist.jar:na]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [productlist.jar:na]
This is trying to connect to the old master node when I am doing status check by redisson.getNodesGroup().pingAll();
Also getting this exception from ReplicatedConnectionManager
14:36:33.463 [] [redisson-netty-3-5] ERROR o.r.c.ReplicatedConnectionManager:183 - Command execution timeout for redis-cache-2.redis.ppe/100.96.5.7:6379
 My redis cluster is very simple. It is using kubernetes helm chart https://github.com/kubernetes/charts/tree/master/incubator/redis-cache to use redis as an in memory cache
Could you please advice if anything is wrong with the configuration or is it a bug?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I do a RemoteService invoke test,it report a warn,then the remote client wait timeout.what wrong is it?
2017-08-11 15:43:40,699 [redisson-3-2] WARN  [io.netty.util.concurrent.DefaultPromise] - An exception was thrown by org.redisson.command.CommandAsyncService$13.operationComplete()
java.lang.NullPointerException: null
	at org.redisson.command.CommandAsyncService$13.operationComplete(CommandAsyncService.java:707) ~[redisson-3.5.0.jar:?]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:507) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:500) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:479) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:420) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at io.netty.util.concurrent.DefaultPromise.cancel(DefaultPromise.java:315) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at org.redisson.misc.RedissonPromise.cancel(RedissonPromise.java:228) [redisson-3.5.0.jar:?]
	at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:287) [redisson-3.5.0.jar:?]
	at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:59) [redisson-3.5.0.jar:?]
	at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:239) [redisson-3.5.0.jar:?]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_144]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_144]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_144]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_144]
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) [netty-common-4.1.14.Final.jar:4.1.14.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_144]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.RedissonLock#lockInterruptibly(long, java.util.concurrent.TimeUnit)

try {
        while (true) {
            ttl = tryAcquire(leaseTime, unit, threadId);
            // lock acquired
            if (ttl == null) {
                break;
            }
            // waiting for message
             if (ttl >= 0) {
                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
            }else {
                getEntry(threadId).getLatch().acquire();
            }
        }
    } finally {
        unsubscribe(future, threadId);
    }



<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
    internalLockLeaseTime = unit.toMillis(leaseTime);

    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
              "if (redis.call('exists', KEYS[1]) == 0) then " +
                  "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                  "return nil; " +
              "end; " +
              "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                  "return nil; " +
              "end; " +
              "return redis.call('pttl', KEYS[1]);",
                Collections.<Object>singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
}


attention to this code:

           if (ttl >= 0) {
                getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
            }else {
                getEntry(threadId).getLatch().acquire();
            }


I wanna know when to execute the 'else' block?
because tryLockInnerAsync just return null or pttl.
PTTL :https://redis.io/commands/pttl
The command returns -2 if the key does not exist.
The command returns -1 if the key exists but has no associated expire
firstly, if the key exists, it must have a ttl time, so return -1 will not happen.
secondly, if the key not exists, the lua script will return nil before execute pttl.
conclusion: 'else' block will not be executed.
or is there really happen in lua script:

              "if (redis.call('exists', KEYS[1]) == 0) then " +  


// (1)false, key exists. but the key almost be expired.

                  "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                  "return nil; " +
              "end; " +
              "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " 


// (2) false, this thread dose not have the lock.

                  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                  "return nil; " +
              "end; " +


// (3) key has been expired, so pttl return -2

              "return redis.call('pttl', KEYS[1]);",
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using an REntity object that I'd like to store in the redis store. And I'd also like to set the expiry time as 30 miutes for the same. But whenever I use the RExpirable function I get the ClassCastException.
The REntity class that I'm using
@REntity
public class Session {
    @RId
    private String id;
    private String api_key;
    private String userid;
    private String ip;
    private Long expirytime;
    private Long sessionexpirytime;

    public Session() {
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getApi_key() {
        return api_key;
    }

    public void setApi_key(String api_key) {
        this.api_key = api_key;
    }

    public String getUserid() {
        return userid;
    }

    public void setUserid(String userid) {
        this.userid = userid;
    }

    public String getIp() {
        return ip;
    }

    public void setIp(String ip) {
        this.ip = ip;
    }

    public Long getExpirytime() {
        return expirytime;
    }

    public void setExpirytime(Long expirytime) {
        this.expirytime = expirytime;
    }

    public Long getSessionexpirytime() {
        return sessionexpirytime;
    }

    public void setSessionexpirytime(Long sessionexpirytime) {
        this.sessionexpirytime = sessionexpirytime;
    }

    private final static String key="Bar12345Bar12345";
    private static final String initVector = "RandomInitVector";
    public static String encrypt(String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            return java.util.Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public  static String decrypt(String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] original = cipher.doFinal(java.util.Base64.getDecoder().decode(encrypted));

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }
    /*@Override
    public boolean equals(Object obj) {
        return (obj instanceof Session && UUID.fromString(decrypt(((Session) obj).id)).hashCode() == UUID.fromString(decrypt(this.id)).hashCode());

    }
    @Override
    public int hashCode() {
        return UUID.fromString(decrypt(id)).hashCode();
    }*/

}



The function persisting and setting it as RExpirable
RLiveObjectService service = client.getLiveObjectService();
Session session = new Session();
session.setId(encrypt("1345434"));
session.setExpirytime(Utils.getUnixTimeWithAddedMinutes(10));
session.setIp("127.0.0.2");
session.setSessionexpirytime(Utils.getUnixTimeWithAddedMinutes(30));
session.setUserid(encrypt("301237"));
session.setApi_key(encrypt("tSpP"));
service.persist(session);
service.asRExpirable(session).expire(30, TimeUnit.MINUTES);



The persist function works as I'm able to retreive the data back. So the redis config is fine. But the following exception is being thrown.
Caused by: java.lang.ClassCastException: models.Session cannot be cast to org.redisson.api.RExpirable
	at org.redisson.RedissonLiveObjectService.asRExpirable(RedissonLiveObjectService.java:493) ~[redisson-3.5.0.jar:na]


Any help is appreciated. Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We have a trouble with Redisson RMapCache in a redis cluster.
Map Initialization
RMapCache<String, BaseMessage> mapCache = redissonClient.getMapCache("callbackFailedMessages");
mapCache.addListener((EntryExpiredListener<String, BaseMessage>) entryEvent -> { [listener_code]}

Map Update
RMapCache<String, BaseMessage> mapCache = redissonClient.getMapCache("callbackFailedMessages");
mapCache.put(localMsgId, drMessage, intervalTime, TimeUnit.SECONDS);

With our app configured with one redis, we have no trouble, the listener is called once
But we experienced troubles with a redis cluster with 3 nodes, the listener is called 3 times.
It seems that every node send an expiry event...
Did you have any similar troubles?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We want to use JCache API for hibernate second level cache. We have successfully done a POC for basic scenarios of Caching using hibernate-jcache 5.2.9 with Redisson 3.4.4.
How do we provide configurations such as expiry time (time-to-live) for individual Cache(s)?
(Couldn't find much info in the documentation for JCache API.)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
哨兵模式：
当某个节点down调或者新增节点时，客户端如何感知，用以下代码进行测试，获取哨兵监控的redis节点，休眠10s后，停掉某一个redis节点发现和前一次获取的redis节点一样。
Redisson rd=(Redisson) context.getBean("dbbasicRedisson");
Collection nodes=rd.getNodesGroup().getNodes();
		for (Node node : nodes) {
			System.out.println(node.getAddr()+"\t"+node.getType());
		}
		
		Thread.sleep(10000);
		
		System.out.println("休眠10s================================");
		
		Collection<Node> nodes1=rd.getNodesGroup().getNodes();
		
		for (Node node : nodes1) {
			System.out.println(node.getAddr()+"\t"+node.getType());
		}

Collection nodes=rd.getNodesGroup().getNodes();
		for (Node node : nodes) {
			System.out.println(node.getAddr()+"\t"+node.getType());
		}
		
		Thread.sleep(10000);
		
		System.out.println("休眠10s================================");
		
		Collection<Node> nodes1=rd.getNodesGroup().getNodes();
		
		for (Node node : nodes1) {
			System.out.println(node.getAddr()+"\t"+node.getType());
		}

/192.168.10.109:6439	SLAVE
/192.168.10.109:6429	MASTER
/192.168.10.109:6449	SLAVE
/192.168.10.109:6459	SLAVE
/192.168.10.109:6429	SLAVE
休眠10s================================
/192.168.10.109:6439	SLAVE
/192.168.10.109:6429	MASTER
/192.168.10.109:6449	SLAVE
/192.168.10.109:6459	SLAVE
/192.168.10.109:6429	SLAVE
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi. Is it possible to traverse all the objects in RLiveObject Service?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have a question regarding the DNS monitoring. Looks like the 'dnsMonitoring' can only be set when using single server config, but not in ReplicatedServersConfig. We are currently using AWS elasticache and we found in the AWS document, it highlights that "It is important that client applications are configured to frequently resolve DNS names of cache nodes when they attempt to connect to a cache node endpoint." So does redisson have the ability to detect potential ip changes on endpoints when using Elasticache?
Based on my test, when I 'restored' an endpoint with the same host url but a different ip address, redisson kept using the last known ip address to try connect to that endpoint, but never detected the new one. I tried to change the ttl in java.security and it didn't help.
Please let know if you have any ideas on this one. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
During our tests of redisson, we noticed that if the redis server is down, the latency is around 100ms, no matter what.
This is problematic for our use case because it slows down too much and we would prefer a fast response/error.
After carefully reading configuration options and experimenting with many tests, we could not find a solution.
Do you have an idea of what could provoke this latency ?
Below is a simplified code allowing to reproduce it (no need to launch a redis instance):
package test;

import org.redisson.Redisson;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.redisson.client.codec.StringCodec;
import org.redisson.config.Config;
import org.redisson.config.SingleServerConfig;

public class RedisDownTest {

    public static void main(String[] args) {
        Config config = new Config();
        config.setCodec(StringCodec.INSTANCE);
        SingleServerConfig singleServerConfig = config.useSingleServer();
        singleServerConfig.setAddress("redis://localhost:6378"); // 6378 is on purpose, there is no redis listening on it
        singleServerConfig.setConnectionMinimumIdleSize(0); // this was set to 0 just to be able to build the client without error
        singleServerConfig.setSubscriptionConnectionMinimumIdleSize(0);
        singleServerConfig.setSubscriptionConnectionPoolSize(0);
        singleServerConfig.setConnectTimeout(50);
        singleServerConfig.setTimeout(50);
        singleServerConfig.setRetryInterval(0);
        singleServerConfig.setRetryAttempts(0);
        singleServerConfig.setReconnectionTimeout(0);
        singleServerConfig.setPingTimeout(0);
        config.setRedissonReferenceEnabled(false);
        RedissonClient redissonClient = Redisson.create(config);

        for (int i = 0 ; i < 20 ; i++) {
            long start = System.currentTimeMillis();
            try {
                RBucket<String> bucket = redissonClient.getBucket("someKey");
                String content = bucket.get();
            } catch (Exception e) {
            } finally {
                long end = System.currentTimeMillis();
                System.out.println("Took: " + (end - start) + "ms");
            }
        }
    }
}
Here are the logs for the last 10 iterations:
Took: 100ms
Took: 98ms
Took: 102ms
Took: 97ms
Took: 100ms
Took: 101ms
Took: 101ms
Took: 98ms
Took: 102ms
Took: 97ms
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//RLO对象:
MyLiveObject myLiveObject = service.get(MyLiveObject.class, "1");
MyOtherObject other = new MyOtherObject();
other.setOtherName("ABC");
myLiveObject.setValue(other);
System.out.println(myLiveObject.getValue().getOtherName());
//输出是ABC
//普通Java对象:
MyLiveObject myLiveObject = service.get(MyLiveObject.class, "1");
MyOtherObject other = new MyOtherObject();
other.setOtherName("ABC");
myLiveObject.setValue(other);
System.out.println(myLiveObject.getValue().getOtherName());
//输出是ABC
普通java对象应该是
MyLiveObject myLiveObject  = new MyLiveObject();
the document write here
//Standard Java Object behaviour:
MyLiveObject myLiveObject = service.get(MyLiveObject.class, "1");
the Standard Java Object behaviour,should be:
MyLiveObject myLiveObject  = new MyLiveObject();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
1）使用RBatch进行key-value的读写；
2）redis master节点挂掉后，重新启动，ops(instantaneous_ops_per_sec)集群飙升至20万,cpu使用率600%；
请查看下，是不是在pipeline模式下，缺少了对master-slave的检测，导致写请求无限制打到旧的master节点上；
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi，please check whether this situation is a bug：
1）I use RBatch to read and write bucket data，so that I'can use the redis pipeline mechanism；
2）redis is in cluster mode，the version is 3.2.9; redisson version is 3.5.0；
3）when I killed the redis master instance，until failover，and restart it；now the old master become slave；
4）use info command to observe the old master's cpu ratio and instantaneous_ops_per_sec indicator，I find it's very high；cpu ratio is 400%，and ops is nearly 200,000；
5）I killed the redisson process，and the old master instance become normal；
here is my configuration:

and my code below，I implement codec interface using proto buf as the codec：
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
我用RScoredSortedSet rScoredSortedSet=redissonClient.getScoredSortedSet("ConsumingTime");获取到RScoredSortedSet，然后调用rScoredSortedSet.getScore(100);方法。
当我的redis中没有100对应的值时会报NullPointerException。
这个似乎不太合理，如果没有值可以返回0。但是直接报NullPointerException，我需要自己处理rScoredSortedSet.getScore(100);一层一层抛出来的异常。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is my set in the spring.xml:
redisson:client
<redisson:single-server address="redis//10.211.55.7:6379"  />
</redisson:client>
but:
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.redisson.config.Config#0$created#0': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'address' of bean class [org.redisson.config.SingleServerConfig]: Bean property 'address' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1396)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1118)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:605)
at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:925)
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:472)
at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:383)
at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:283)
at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:111)
at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4853)
at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5314)
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1408)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1398)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
Please help me,Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the redisson version is 3.5.0,
follow is the StackTrace
java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.ObjectMapper.setFilterProvider(Lcom/fasterxml/jackson/databind/ser/FilterProvider;)Lcom/fasterxml/jackson/databind/ObjectMapper;
at org.redisson.config.ConfigSupport.createMapper(ConfigSupport.java:281)
at org.redisson.config.ConfigSupport.(ConfigSupport.java:124)
at org.redisson.config.Config.fromJSON(Config.java:639)
at org.redisson.config.Config.fromJSON(Config.java:651)
at steed.util.redis.RedissonUtil.(RedissonUtil.java:18)
at steed.test.redis.TestRedisson.testDataCacheUtil(TestRedisson.java:14)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
my config code is this:
 Config.fromJSON(new File(PathUtil.praseRelativePath("properties/redisson.json")));

the follow is a part of maven downed redisson source code
  mapper.addMixIn(MasterSlaveServersConfig.class, MasterSlaveServersConfigMixIn.class);
  FilterProvider filterProvider = new SimpleFilterProvider().addFilter("classFilter", SimpleBeanPropertyFilter.filterOutAllExcept());
  mapper.setFilterProvider(filterProvider);//this line throw the exception

then i copy this code to eclipse ,and eclipse report an Compile error like follow:
 The method setFilterProvider(FilterProvider) is undefined for the type ObjectMapper
so I think there is some problem in the jar of 3.5.0 version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I'm trying to use redisson 3.5.0 with the same settings where I previously used 3.4.1. However, the steps below don't work anymore.
SentinelServersConfig sentinelConfig = config.useSentinelServers();
sentinelConfig.addSentinelAddress("10.10.10.0:16380");
This code results in the following error messages:
Caused by: java.lang.IllegalArgumentException: Illegal character in scheme name at index 0: 10.10.10.0:16380
at java.net.URI.create(URI.java:852)
at org.redisson.misc.URIBuilder.create(URIBuilder.java:27)
at org.redisson.config.SentinelServersConfig.addSentinelAddress(SentinelServersConfig.java:71)
Caused by: java.net.URISyntaxException: Illegal character in scheme name at index 0: 10.10.10.0:16380
at java.net.URI$Parser.fail(URI.java:2848)
at java.net.URI$Parser.checkChars(URI.java:3021)
at java.net.URI$Parser.checkChar(URI.java:3031)
at java.net.URI$Parser.parse(URI.java:3047)
at java.net.URI.(URI.java:588)
at java.net.URI.create(URI.java:850)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
config.class :
Config config = new Config();
config.setCodec(new StringCodec());
ClusterServersConfig clusterServersConfig = config.useClusterServers();
clusterServersConfig.setConnectTimeout(timeout);
clusterServersConfig.setTimeout(timeout);
clusterServersConfig.setReconnectionTimeout(4000);
clusterServersConfig.setScanInterval(2000);
clusterServersConfig.addNodeAddress("redis://10.0.3.252:7001",
"redis://10.0.3.252:7002",
"redis://10.0.3.252:7003",
"redis://10.0.3.252:7004",
"redis://10.0.3.252:7005",
"redis://10.0.3.252:7006");
JDK:1.8   redisson:3.5.0  redisServer:3.0.3
my project can't start. i debug ClusterConnectionManager.class file. connectionFuture is not completed

redisson:3.3.1 is OK.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
这个方法会报错的原因应该是redis没有提供DECRBYFLOAT命令。
但是执行getAndDecrement()方法是不会报错的。
我看了一下这两个方法的实现差异
decrementAndGet()方法使用的是DECR命令
getAndDecrement()方法则使用的是INCRBYFLOAT -1.0的方式
想问一下这里的实现方式为什么是不一致的，这算不算是一个bug呢？
源码传送门：https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/RedissonAtomicDouble.java
decrementAndGet() 71-79行
getAndDecrement() 137-145行
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In sentinel mode timeout for sentinel response is configured as retryInterval*retryAttempts. This make it impossible to set retryAttempts =0 in sentinel mode.
Also RBatch retryAttempts cannot be set to zero.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using singleServer mode without slave.
        Config config = new Config();
        config.useSingleServer().setAddress(redisServer1);
        client = Redisson.create(config);
        ....
        RBucket<Object> bucket = client.getBucket("TestKey");
        bucket.get();

now, when the Redis server is down, an exception will be throw:
org.redisson.client.RedisConnectionException: MasterConnectionPool no available Redis entries
	at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:196)
	at org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:31)
	at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:419)
	at org.redisson.connection.SingleEntry.connectionReadOp(SingleEntry.java:45)
	at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:752)
	at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:504)
	at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:585)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
	at java.lang.Thread.run(Thread.java:745)

I'd like to handle this in our app, but it looks like the getBucket() or get() is an async call, so the function doesnt throw the exception, I look through the docs, and found nothing to configure Redission to work in synchronized mode. Is  synchronous mode supported by Redission or is there a different way to handle this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
`org.redisson.client.RedisTimeoutException: Redis server response timeout (10000 ms) occured for command: (EVAL) with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, 123, 30000, cb52c4c0-bcf8-49e2-9b27-a68401b43123:147] channel: [id: 0x500b5be9, L:/192.168.1.165:36618

R:/192.168.1.46:6379
]
at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:696)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
at java.lang.Thread.run(Thread.java:745)`

redis server 信息
1，redis 版本 3.0.6，
2，单节点
3，server配置

redisson信息
1，版本2.10.4
2，配置如下
SingleServerConfig singleSerververConfig = config.useSingleServer(); singleSerververConfig.setConnectionPoolSize(300);		singleSerververConfig.setConnectionMinimumIdleSize(10); singleSerververConfig.setConnectTimeout(10000); singleSerververConfig.setTimeout(10000); singleSerververConfig.setRetryAttempts(3); singleSerververConfig.setRetryInterval(1000);	singleSerververConfig.setSubscriptionConnectionMinimumIdleSize(1); singleSerververConfig.setSubscriptionConnectionPoolSize(25);
出现RedisTimeoutException是并发量很少的时候，高峰期并没有这样的错误，请帮忙看看是哪里有问题
谢谢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I make sure that if a certain nodes takes a scheduled task but crashes, someone else would try and recover it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
这个问题之前提过：#1106
redisson版本：3.5.4
看了下源码，从节点恢复时，会走MasterSlaveEntry.slaveUp方法，但是在判断当前恢复节点不是主节点后，会从slaveBalancer中下线主节点，但是代码却下线了从节点（刚恢复的节点），代码行数：349
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi. I am using redisson 3.5.4.
I am using redisson for task service management. However, I am seeing a bunch of redis errors - not for every call, but for enough calls to where I am concerned. Here is a sample:
 RedisTimeoutException occurred when processing request: [GET] /tasks/74618b07-dbce-4c06-93e9-8720b59d56f9
Redis server response timeout (3000 ms) occured for command: (EVAL) with params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 3, ns:redisson-task:results, redisson__timeout__set:{ns:redisson-task:results}, redisson__idle__set:{ns:redisson-task:results}, 1509457132711, 74618b07-dbce-4c06-93e9-8720b59d56f9] channel: [id: 0xa8085706, L:/10.10.41.230:57794 - R:non-prod-cache-dev.dkmn9o.0001.use1.cache.amazonaws.com/10.10.41.103:6379]. Stacktrace follows:
org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (EVAL) with params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 3, ns:redisson-task:results, redisson__timeout__set:{ns:redisson-task:results}, redisson__idle__set:{ns:redisson-task:results}, 1509457132711, 74618b07-dbce-4c06-93e9-8720b59d56f9] channel: [id: 0xa8085706, L:/10.10.41.230:57794 - R:non-prod-cache-dev.dkmn9o.0001.use1.cache.amazonaws.com/10.10.41.103:6379]
        at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:647)
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:661)
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:736)
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:464)
        at java.lang.Thread.run(Thread.java:748)

and a different error:
RedisConnectionException occurred when processing request: [GET] /tasks/3b28ac7f-8ca2-45ab-b3c7-a422798ed7b7
RedisConnection@1674996143 [redisClient=[addr=non-prod-cache-dev.dkmn9o.0001.use1.cache.amazonaws.com/10.10.41.103:6379], channel=[id: 0x0248d945, L:0.0.0.0/0.0.0.0:57512]] is not active!. Stacktrace follows:
org.redisson.client.RedisConnectionException: RedisConnection@1674996143 [redisClient=[addr=non-prod-cache-dev.dkmn9o.0001.use1.cache.amazonaws.com/10.10.41.103:6379], channel=[id: 0x0248d945, L:0.0.0.0/0.0.0.0:57512]] is not active!
        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:314)
        at org.redisson.connection.pool.ConnectionPool.connectTo(ConnectionPool.java:251)
        at org.redisson.connection.pool.ConnectionPool.access$300(ConnectionPool.java:53)
        at org.redisson.connection.pool.ConnectionPool$3.run(ConnectionPool.java:216)
        at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:76)
        at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:114)
        at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:154)
        at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:226)
        at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:168)
        at org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:31)
        at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:409)
        at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:677)
        at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:503)
        at org.redisson.command.CommandAsyncService$7.run(CommandAsyncService.java:552)
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:661)
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:736)
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:464)
        at java.lang.Thread.run(Thread.java:748)

I am also seeing some RemoteServiceAckTimeException: No ACK response after 5000ms for request: RemoteServiceRequest.
Here is my configuration:
redisson {
    config {
        singleServerConfig {
            idleConnectionTimeout = 10000
            pingTimeout = 1000
            connectTimeout = 10000
            timeout = 3000
            retryAttempts = 3
            retryInterval = 1500
            reconnectionTimeout = 3000
            failedAttempts = 3
            password = null
            subscriptionsPerConnection = 5
            clientName = null
            address = 'redis://127.0.0.1:6379'
            subscriptionConnectionMinimumIdleSize = 1
            subscriptionConnectionPoolSize = 50
            connectionMinimumIdleSize = 10
            connectionPoolSize = 64
            database = 0
            dnsMonitoring = false
            dnsMonitoringInterval = 5000
        }
        threads = 0
        nettyThreads = 0
        codec = null
        useLinuxNativeEpoll = false
    }
}

Is there any config setting I could change to help with this? Am I doing something wrong?
thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redis with elastic cache in my spring application where i am using spring annotations for accessing cache.
I need to reset cache idle time and ttl on read so that i can keep my user active until user goes idle beyond timeout.
But read is not resetting the timeout and cache is evicted as per idle time and ttl set in configuration. Using below annotation in both the cases for creating and reading cache, the issue is same in both single and multiple server configuration.
@Cacheable(value = TEST_CACHE, key = CACHE_KEY)
config
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"reconnectionTimeout":3000,
"failedAttempts":3,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"address": ["redis://127.0.0.1:6379"],
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":10,
"connectionPoolSize":64,
"database":0,
"dnsMonitoring":false,
"dnsMonitoringInterval":5000
},
"threads":0,
"nettyThreads":0,
"codec":null,
"useLinuxNativeEpoll":false
What is the configuration needed to reset idle time and ttl on read? please advise.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We're are struggling with basic persist function.
When have written a piece of code to persist a simple Customer object that is annotated as @REntity with its guid field marked as @RId.
package org.redisson.example.objects;

import org.redisson.api.annotation.REntity;
import org.redisson.api.annotation.RId;

@REntity
public class Customer {
	
	@RId
	private String guid;
	private int age;
	private String fname;
	private String lname;
	
        public Customer() {}
	
	public Customer(String guid) {
		super();
		this.guid = guid;
	}
	public String getGuid() {
		return guid;
	}
	public void setGuid(String guid) {
		this.guid = guid;
	}
       // other setter getters here...

}


The piece of code used to persist is as follows:
    Config config = new Config();
    config.useSingleServer().setAddress("127.0.0.1:9000");
    redissonClient = Redisson.create(config);

   RLiveObjectService service = redissonClient.getLiveObjectService();
   Customer customer1 = new Customer("1", 20, "A", "A", new Address(40001));
   service.persist(customer1);

Customer object is getting stored in Redis server with the key:
'redisson_live_object:{223122}:org.redisson.example.objects.Customer:guid:java.lang.String'
and value:
127.0.0.1:9000> HGETALL redisson_live_object:{223122}:org.redisson.example.objects.Customer:guid:java.lang.String
1) "\"redisson_live_object\""
2) "\"1\""
3) "\"age\""
4) "20"
5) "\"fname\""
6) "\"A\""
7) "\"lname\""
8) "\"A\""


We expected it to be saved using its field guid as the key. Nevertheless, now when we try to get this object back, it returns a object (which we believe is a proxy object) with all null values.
service.get(Customer.class, "1")
returns
Customer [guid=null, age=0, adress=null, fname=null, lname=null]
Can you please point us in the right direction for using redisson api? Further, we want objects to be searched not just by the @Rid field but also a combination of fields, say, Age and Name etc.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Parent -child is still not working for me. I am getting no such field exception when the RId is a part of the parent class. Can you please guide? What am I missing?
Redis loading failed.java.lang.NoSuchFieldException: No such field: guid
java.lang.IllegalArgumentException: java.lang.NoSuchFieldException: No such field: guid
at org.redisson.liveobject.misc.ClassUtils.getField(ClassUtils.java:105)
at org.redisson.RedissonLiveObjectService.persist(RedissonLiveObjectService.java:163)
at org.redisson.RedissonLiveObjectService.merge(RedissonLiveObjectService.java:152)
Use Case:
Here is my base class:
@rentity
public abstract class AbstractDo implements Serializable {
private static final long serialVersionUID = 7680440665187761533L;
private @Rid String guid;
public String getGuid() {
return guid;
}
public void setGuid(String guid) {
this.guid = guid;
}
@OverRide
public int hashCode() {
...
}
@OverRide
public boolean equals(Object obj) {
...
}
My Derived Class:
@rentity
public class UserProfile extends AbstractDo {
private static final long serialVersionUID = -7817007972557889495L;
private String enterpriseGuid;
@Auditable
private String defaultStoreGuid;
private @indexed Set roleGuids = new LinkedHashSet();
public static final String LOGIN_ID = "loginId";
private @indexed String  loginId;
// private String loginId;
public static final String USER_ASSIGNMENTS = "assignments";
@Auditable
private Set assignments = new LinkedHashSet();
public UserProfile(Set assignments) {
setAssignments(assignments);

}
public UserProfile() {
assignments.add(new UserProfileAssignment());

}
public String getEnterpriseGuid() {
return enterpriseGuid;
}
public void setEnterpriseGuid(String enterpriseGuid) {
this.enterpriseGuid = enterpriseGuid;
}
public String getDefaultStoreGuid() {
return defaultStoreGuid;
}
...
...
}
And this is how I invoke it:
public class UserProfileRedisRadisson {
@Autowired
private RedissonClient redissonClient;
public void loadData(Collection allRows) {
RLiveObjectService liveObjectService = redissonClient.getLiveObjectService();
System.out.println("START");
for(UserProfile ur:allRows) {
	if(liveObjectService.get(UserProfile.class, ur.getGuid()).getGuid() == null) {
		liveObjectService.persist(liveObjectService.attach(ur));
	} else {
		liveObjectService.merge(liveObjectService.attach(ur));
	}
}
System.out.println("END");

}
}
Thanks,
Salil
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a Spring Boot application and a Bean that implements org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer, i.e. there is a method that takes a javax.cache.CacheManager, and then follows the instructions provided here. Specifically, I have implemented a mixture of the code snippets for:

"Using config file with custom location"
"Using Redisson's config object:"

Essentially, I have the following that does create caches as I would expect on my local Redis instance:
@Override
public void customize(javax.cache.CacheManager manager) {
    MutableConfiguration<String, String> jcacheConfig = new MutableConfiguration<>();
    Config redissonCfg = getClass().getResource(expectedRedissonCacheConfigLocation);
    Configuration<String, String> config = RedissonConfiguration.fromConfig(redissonCfg, jcacheConfig);
    Cache<String, String> cache = manager.createCache("namedCache", config);
}

However, when I run tests or start/stop the Spring boot application, I always receive the following Log message and the Redis caches are not cleared.  Note that the caches are reset if multiple tests are run in sequence but the data cached in the last test is still present in the Redis instance after the test has been run.
WARN 10556 --- [           main] o.s.b.f.support.DisposableBeanAdapter    : Invocation of destroy method 'close' failed on bean with name 'jCacheCacheManager': java.lang.NullPointerException
After debugging, it seems that there is no org.redisson.Redisson object created. This appears to be caused by the checks for either a redisson-jcache.json and redisson-jcache.yaml being on the classpath in org.redisson.jcache.JCachingProvider#loadConfig(URI uri). If these files are not found, the config returned is null which means that org.redisson.jcache.JCachingProvider#getCacheManager(URI uri, ClassLoader classLoader, Properties properties) does not invoke the code inside the if conditional below:
Redisson redisson = null;
if (config != null) {
    redisson = (Redisson) Redisson.create(config);
}
manager = new JCacheManager(redisson, classLoader, this, properties, uri);

I do not have either a redisson-jcache.json and redisson-jcache.yaml file on the classpath since my team are trying to develop a way of loading different Redisson configuration files based upon the Spring Boot profile that is used to launch a Spring Boot application.  Configuration files are instead searched for in a specified location with a specified file name (the name of a Spring Boot profile).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a Customer object as below
            @REntity
            public class Customer {
               @RId
               private String guid;
               private String name;
 
               //Required getter-setter and constructors here...
          }

I store this object in Redis using the persist method as below:
                Config config = new Config();
		config.useSingleServer().setAddress("redis://127.0.0.1:9000");
		redissonClient = Redisson.create(config);
		RLiveObjectService service = redissonClient.getLiveObjectService();
                service.persist(new Customer("1", "Tom");

I can use the service.get(Customer.class, "1")  method to retrieve this object based on the guid we pass to it. However, I have following requirements:

retrieving Customer objects based on the name field, which is not @Rid
retrieving Customer objects based on combination of guid and name field.

Can you point me to the right api for such requirement?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I was testing the behavior of Redis/Redisson when a network failure happens (say for few minutes) and then recovers. I observed the following unexpected behavior and wondering if there is a way to avoid this scenario.
Observation:

SADD command was issued at 14:46 PM and failed due to RedisTimeoutException. This seems to have happened just about when network failure just started.
At 14:50 (A full 4 minutes later), it looks like Redisson heard back from Redis master node but due to client side timeout set, just skipped the response.

Here are the logs:
03 Nov 2017 14:46:39,438 [WARN] ...... org.redisson.client.RedisTimeoutException: Redis server response timeout (25 ms) occured for command: (SADD) with params: [AKC-590000000707, 78af13d0-d00b-4898-9da3-8410236dcfb9] channel: [id: 0x845c3d76, L:/10.0.19.60:39336 - R:/10.1.48.182:6379]

03 Nov 2017 14:50:08,771 [WARN]  (redisson-netty-5-15) org.redisson.client.handler.CommandDecoder: response has been skipped due to timeout! channel: [id: 0x845c3d76, L:/10.0.19.60:39336 - R:/10.1.48.182:6379], command: CommandData [promise=org.redisson.misc.RedissonPromise@3742b67c[Completed exceptionally], command=(SADD), params=[AKC-590000000707, 78af13d0-d00b-4898-9da3-8410236dcfb9], codec=org.redisson.codec.JsonJacksonCodec@438dd2b6], result: true

Redis Version:
Redisson Version: 3.4.1
Client configuration: (For ElastiCache cluster)
    Config config = new Config();
    config.useClusterServers()
        .addNodeAddress(endpoint.getAddress() + ":" + endpoint.getPort())
        .setConnectTimeout(1000)
        .setTimeout(25)
        .setRetryAttempts(1) // client creation fails when set to 0
        .setRetryInterval(25);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tried following config
initially copied from the document at https://github.com/redisson/redisson/wiki/2.-Configuration#27-sentinel-mode before changing readMode from "SLAVE" to "MASTER_SLAVE"

{
"sentinelServersConfig":{
... ,
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"readMode":"MASTER_SLAVE",
"sentinelAddresses":[
"redis://192.168.1.101:26379",
"redis://192.168.1.101:26379",
"redis://192.168.1.102:26379"
],
...
}
}

I wish both master and 2 slaves could be read (33% chance on RoundRobin algo). But I see the master never got read.
Tried different Balancer and dug into the source, seems that the LB seems only be applied to slaves. The master server is setFreezed(true) and it won't get read unless both slaves get disconnected.
Looks like ReadMode of "MASTER_SLAVE" is actually same as ReadMode of "SLAVE".
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it used to accept "localhost:6379", but now the address seems have to be: "redis://127.0.0.1:6379"
this is because the change in org.redisson.misc.URIBuilder.java.
Should it more developer friendly?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, i'm using redisson with a Replicated Mode configuration (1 master and 2 slaves).
When attempting to debug an issue, i found that apparently the timeout configuration parameter is not being used in the implementation as documented.
I was receiving a fair amount of unexpected RedisTimeoutException: Command execution timeout messages.
Changing the retryAttempts and retryInterval allowed to circumvent the issue - but not changing timeout - which seemed odd to me, so i decided to dig further.
In ReplicatedConnectionManager#L123,
the parameter passed for connectionTimeout is cfg.getRetryInterval() * cfg.getRetryAttempts() (and not timeout).

    RedisClient client = createClient(
        NodeType.MASTER, addr,
         cfg.getConnectTimeout(), 
          cfg.getRetryInterval() * cfg.getRetryAttempts()  // shouldn't it be cfg.getTimeout() (?)
    );


A value of 0 for retryAttempts, or even a higher number matched with a relatively low retryInterval always causes the RedissonClient instantiation to fail (due toCommand execution timeout).
Raising these values can bypass the error on the initial connection and allow the instantiation.
Still, the same applies to subsequent calls: they also won't also use the timeout provided in the configuration.
Am i observing this correctly or is there something i'm missing here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One of our teams has been running some load tests that involve calling deleting keys from a redis cluster among other things. And when they run a profiler they observed that top hot spot was actually related to collection management (ConcurrentHashMap and HashSet) on redisson when getting connection info and copying it for every operation.
As seen on the following hotspot analysis

This was tested with redisson 3.4.3, haven't tried with the latest one yet
Is there anything that could be changed from config or improved on the code in future versions?
I believe the same scenario might show up on other operations besides delete
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I was trying to use your library with AWS Clustered mode and figured out it does not work with SSL.
I figured out the problem and fixed it in my fork  but it's a hack what I did.
Basically everywhere you create an address like "redis://" -- you need a way to know if it's SSL and put "rediss://" instead. Since those places have no access to config, unfortunately I changed all to force SSL everywhere.
Do you have in plan a fix for this, or I can do it if you point me to the right way. I am trying to understand your logic and how can I be least invasive to pass a config. The simplest way would be to put a static public flag somewhere -- but that's also a hack I guess, and will only allow one type at one time, or pass a jvm property ...what do you suggest?
Thanks in advance,
Florin Moisa
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We have a usecase where we store Java objects in cache and search them by multiple fields. Is there a way to achieve it in Redisson liveObjects? Spring-data-redis provides such functionality but does not support redisson.
Thanks,
Salil Gandhi
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am Using Java 1.6 and the Redisson 2.10.1
and i am using the RedissonReactiveClient  as shown in the blow sample code
Config config = Config.fromJSON(new File("src/main/resources/WEB-INF/SentinelServersConfig.json")
RedissonReactiveClient redisson = Redisson.createReactive(config);
RMapCacheReactive<String, String> mapCachemain = redisson.getMapCache("sessionloopmain");
mapCachemain.putIfAbsent("1234" , "manoj", 30 , TimeUnit.SECONDS);
when i run the code  I am getting the below Error
java.lang.UnsupportedClassVersionError: reactor/fn/Supplier : Unsupported major.minor version 51.0
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClassCond(ClassLoader.java:637)
at java.lang.ClassLoader.defineClass(ClassLoader.java:621)
at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at org.redisson.RedissonReactive.(RedissonReactive.java:106)
at org.redisson.Redisson.createReactive(Redisson.java:182)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Redis 4.0.0 and 3.2.10 introduced read-only GEORADIUS variants(GEORADIUS_RO and GEORADIUSBYMEMBER_RO), as the docs state. Are there any plans to add this command to redisson?
Thanks in advance!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a redisson configuration with a single worker executors for various schedules - 1min, 5min, 1hour, ... 24hours. When each of these ticker-tasks are invoked I have a set of devices on which I need to run diagnostics. Each device will have a task that will be slotted in various schedules and these tasks for all the devices that belong to a schedule need to be invoked at that particular time.
The device tasks are put in a 'now' executor. So on every schedule invocation, there are a lot of tasks that are submitted on the now-executor.
I am using Redisson version 3.3.1 and my key settings are:
timeout - 180000 ms (3 mins)
retryInterval - 60000 ms (1 min)
connectionPoolSize - 1100
Maximum workers in now-executor - 1000.

I am observing sporadic RedisTimeoutException when submitting tasks to the now executor:
org.redisson.client.RedisTimeoutException: Command execution timeout for command: (EVAL) with params: [if redis.call('exists', KEYS[2]) == 0 then redis.call('rpush', KEYS[3], ARGV[1]); redis.call('incr',..., 3, {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_now:org.redisson.executor.Rem..., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_now:org.redisson.executor.Rem..., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_now:org.redisson.executor.Rem..., [123, 34, 64, 99, 108, 97, 115, 115, 34, 58, ...]] at org.redisson.command.CommandAsyncService$7.run(CommandAsyncService.java:538) ~[redisson-3.3.1.jar!/:na] at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:625) ~[netty-common-4.1.8.Final.jar!/:4.1.8.Final] at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:700) ~[netty-common-4.1.8.Final.jar!/:4.1.8.Final] at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:428) ~[netty-common-4.1.8.Final.jar!/:4.1.8.Final] at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_102] 



I am also getting sporadic timeouts on the ticker tasks - 1min, 3min etc.
2017-11-09 10:10:00,437 [pool-1-thread-1] ERROR [o.r.QueueTransferTask] - Command execution timeout for command: (EVAL) with params: [local expiredTaskIds = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #ex..., 3, {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., 1510221960038, 100] org.redisson.client.RedisTimeoutException: Command execution timeout for command: (EVAL) with params: [local expiredTaskIds = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #ex..., 3, {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., {f4242397-122e-410a-ba32-f455ef71bbdf_device.manager.task.schedule.sys_every_3_minutes:org.redisson...., 1510221960038, 100] at org.redisson.command.CommandAsyncService$7.run(CommandAsyncService.java:538) ~[redisson-3.3.1.jar!/:na] at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:625) [netty-common-4.1.8.Final.jar!/:4.1.8.Final] at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:700) [netty-common-4.1.8.Final.jar!/:4.1.8.Final] at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:428) [netty-common-4.1.8.Final.jar!/:4.1.8.Final] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_102]

I have two instances running that feed off the Redis cache. These errors are sporadic in  nature. Appreciate any help in understanding the root cause of these timeouts.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In my local redis database, I have a node.js app that sets redis keys and values. Can I use redisson to retrieve using the key name? Or can redisson only retrieve keys that were created by redisson?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I've been fighting for the past week with some weird timeout issue on one of our apps.
The use case is an RBatch operation that execute a bit of getBucket(..).getAsync()
Run scenarios with 1 get or N gets as part of the batch and happens on any.
The issue is basically that after a few minutes after starting the app, some instances of my app start displaying timeouts on that cache operation and thus becoming slow, then i restart that particular node of the app, and maybe it's fine forever, then I restart another instance and maybe now that one starts exhibiting the same problem. Sometimes it add a constant base of 50ms delay (due to timeout and retries) and sometimes it's 150ms or similar.
We tried with redisson 3.2.0 and 3.5.5 and we can observe the problem on both, we though it might some hardware/network problem on those servers where such apps are running, but after restarting and re-running it works fine (or not) and viceversa on other servers.
The errors we get on the failing app are always like this
org.redisson.client.RedisException: Unexpected exception while processing command at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:308) at org.redisson.command.CommandBatchService.checkConnectionFuture(CommandBatchService.java:379) at org.redisson.command.CommandBatchService.access$200(CommandBatchService.java:58) at org.redisson.command.CommandBatchService$4.operationComplete(CommandBatchService.java:296) at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514) at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488) at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427) at io.netty.util.concurrent.DefaultPromise.cancel(DefaultPromise.java:322) at org.redisson.misc.RedissonPromise.cancel(RedissonPromise.java:225) at org.redisson.command.CommandBatchService$3.run(CommandBatchService.java:258) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:588) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:662) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:385) at java.lang.Thread.run(Thread.java:748)
And this what we observe many times
1 app failing out of 10

1 failing out 3

3 failing out of 5

Our settings are like the following
    "clusterServersConfig": { "connectTimeout" : 100, "timeout" : 100, "retryInterval" : 30, "masterConnectionMinimumIdleSize" : 64, "masterConnectionPoolSize": 64, "slaveConnectionMinimumIdleSize" : 64, "slaveConnectionPoolSize": 64, "retryAttempts": 2, "readMode": "MASTER_SLAVE", "nodeAddresses": [ "redis://redis001.prod.hnd1.bdd.local:6329", "redis://redis001.prod.hnd1.bdd.local:6339", "redis://redis001.prod.hnd1.bdd.local:6349", "redis://redis002.prod.hnd1.bdd.local:6329", "redis://redis002.prod.hnd1.bdd.local:6339", "redis://redis002.prod.hnd1.bdd.local:6349", "redis://redis003.prod.hnd1.bdd.local:6329", "redis://redis003.prod.hnd1.bdd.local:6339", "redis://redis003.prod.hnd1.bdd.local:6349", "redis://redis004.prod.hnd1.bdd.local:6329", "redis://redis004.prod.hnd1.bdd.local:6339", "redis://redis004.prod.hnd1.bdd.local:6349", "redis://redis005.prod.hnd1.bdd.local:6329", "redis://redis005.prod.hnd1.bdd.local:6339", "redis://redis005.prod.hnd1.bdd.local:6349", "redis://redis006.prod.hnd1.bdd.local:6329", "redis://redis006.prod.hnd1.bdd.local:6339", "redis://redis006.prod.hnd1.bdd.local:6349" ] }, "useLinuxNativeEpoll": true }
This is being used on a very high traffic app, but we can reproduce it with low traffic as well.
Do you have any suggestion or insight on any thing we can try changing on our config and re-run our load test so we can sort out this issue. And we really need the data to be read from redis because the alternative when our cache fails is a much worse system that cannot handle the load or our SLA
We have been trying changes on the servers, running on different hardware, etc but nothing changed yet. Could it be some dead connection or bottleneck on the batch or connection manager that is causing this? Also as you can see on the avg time graph on top, it doesn't happen for every request, but for many of them, but constantly ONLY on that running app of all the total
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
你好，我发现redisson的jdk1.7的兼容版本（2.10.5）中已经使用了netty的4.1.16版本，该版本在netty官方已经是jdk1.8编译的的版本了。请问用jdk1.7使用这个版本会出现问题吗？
另外，由于代码冲突的原因，我们需要把netty降版到4.0.25，请问哪个redisson的版本是兼容这个netty版本的呢。我直接把最新的redisson中的netty降到该版本会不会有问题？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Summary
Up to and including Redisson version 2.10.1 and 3.5.1, Redisson used the Xerial implementation of Snappy (https://github.com/xerial/snappy-java) for its SnappyCodec.
In versions 2.10.2 and 3.5.2, Redisson was changed to use the internal implementation of Snappy from Netty instead. However, this implementation seems to be designed only for Netty's use cases and cannot encode moderately-sized payloads. In this case, moderately-sized means that payloads of more than 50,000 bytes are very likely to fail.
This results in an error during the encoding step, e.g.
Exception in thread "main" java.lang.IndexOutOfBoundsException: index: -32765, length: 4 (expected: range(0, 8388608))
	at io.netty.buffer.AbstractByteBuf.checkIndex0(AbstractByteBuf.java:1358)
	at io.netty.buffer.AbstractByteBuf.checkIndex(AbstractByteBuf.java:1353)
	at io.netty.buffer.AbstractByteBuf.getInt(AbstractByteBuf.java:417)
	at io.netty.handler.codec.compression.Snappy.encode(Snappy.java:127)
	at org.redisson.codec.SnappyCodec$4.encode(SnappyCodec.java:89)
Steps to Reproduce
I have created a repository that shows how and when this bug occurs. I take the last known good versions (2.10.1 and 3.5.1) and compare them with the most recent versions at the time of writing (2.10.5 and 3.5.4).
See the repository here: https://github.com/nebel/netty-snappy-redisson-demo
To run the examples, either run the main method for each module in your IDE, or run each module via the command line with mvn package exec:java.
The redisson-*-snappy-demo modules show the behavior in the indicated Redisson version. As you can see, the last known good versions (using the Xerial implementation of Snappy) can encode this payload without any problems, whereas the new versions (using the Netty implementation of Snappy) will fail.
The netty-xerial-snappy-demo module shows how increasing the size of the encoded payload will soon cause Netty's implementation to reach a breaking point after which all attempts at encoding will fail. When creating the sample data with a random seed of 0, Netty will succeed on a payload of 44,895 bytes and fail on a payload of 44,896 bytes. Changing the seed will change this number, but it will generally fail somewhere between 40,000 to 50,000 bytes.
The Xerial implementation, on the other hand, does not fail at any size I tested (up to 100 million bytes).
Fix
While it's nice to avoid an additional dependency, I believe the Snappy implementation from Netty should probably be considered an internal implementation since this size limitation makes it unsuitable as a general compression algorithm.
The Xerial implementation seems to be more widely used by more high-profile projects (e.g. Cassanda) and is probably a safer choice.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are testing the distributed services feature of redisson. We are noticing that at scale (i.e. 1000 tasks in a minute), redisson is throwing NullPointerExceptions and the tasks do not complete.
Redisson Version: 3.5.5
Number of Workers: 20
Here is the stack trace:
2017-11-15 15:06:01,844 [redisson-netty-1-12] WARN  concurrent.DefaultPromise  - An exception was thrown by org.redisson.BaseRemoteService$1$2$1.operationComplete()
Message: null
   Line | Method
->> 282 | operationComplete  in org.redisson.BaseRemoteService$1$2$1
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
|   507 | notifyListener0    in io.netty.util.concurrent.DefaultPromise
|   481 | notifyListenersNow in     ''
|   420 | notifyListeners    in     ''
|   104 | trySuccess . . . . in     ''
|    74 | trySuccess         in org.redisson.misc.RedissonPromise
|   402 | run . . . . . . .  in org.redisson.BaseRemoteService$4
|    38 | call               in io.netty.util.concurrent.PromiseTask$RunnableAdapter
|   120 | run . . . . . . .  in io.netty.util.concurrent.ScheduledFutureTask
|   163 | safeExecute        in io.netty.util.concurrent.AbstractEventExecutor
|   403 | runAllTasks . . .  in io.netty.util.concurrent.SingleThreadEventExecutor
|   463 | run                in io.netty.channel.nio.NioEventLoop
|   858 | run . . . . . . .  in io.netty.util.concurrent.SingleThreadEventExecutor$5
|   138 | run                in io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator
^   745 | run . . . . . . .  in java.lang.Thread

Let me know what other information would be helpful to try and track this down.
thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have a setup of 3 redis nodes with 3 sentinel nodes.
I am using latest redisson with master_slave read mode.
I see that almost all connections go to the master redis and slaves are not in use.
Also when connecting to redis i see only db0 is being in use.
What am i doing wrong in my redisson config?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there any current plans, third party plugins, or a recommended best practice approach to use Open Tracing with Redisson?
In particular the remote service invocations seem like they could benefit from the tracing span context propagating across the service boundaries.
I have done some quick googling and didn't find any libraries, documentation, or anything else on the subject.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.lang.NullPointerException
at org.redisson.tomcat.RedissonSession.save(RedissonSession.java:174)
at org.redisson.tomcat.RedissonSessionManager.createSession(RedissonSessionManager.java:116)
at org.apache.catalina.connector.Request.doGetSession(Request.java:2312)
at org.apache.catalina.connector.Request.getSession(Request.java:2075)
at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:833)
at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:844)
at org.apache.jasper.runtime.PageContextImpl._initialize(PageContextImpl.java:146)
at org.apache.jasper.runtime.PageContextImpl.initialize(PageContextImpl.java:124)
at org.apache.jasper.runtime.JspFactoryImpl.internalGetPageContext(JspFactoryImpl.java:107)
at org.apache.jasper.runtime.JspFactoryImpl.getPageContext(JspFactoryImpl.java:63)
at org.apache.jsp.testRedis_jsp._jspService(testRedis_jsp.java:45)
at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342)
at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:286)
at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:845)
at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)
at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447)
at java.lang.Thread.run(Thread.java:662)
redis搭建了集群 3主3从,然后项目使用的是jdk1.6 tomcat6 完全按照教程的配置文件使用Tomcat Redis Session Manager管理session 启动tomcat信息:
2017-11-18 21:35:11 org.apache.catalina.core.AprLifecycleListener init
信息: The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: /home/jdk1.6.0_45/jre/lib/i386/server:/home/jdk1.6.0_45/jre/lib/i386:/home/jdk1.6.0_45/jre/../lib/i386:/usr/java/packages/lib/i386:/lib:/usr/lib
2017-11-18 21:35:12 org.apache.coyote.http11.Http11Protocol init
信息: Initializing Coyote HTTP/1.1 on http-8080
2017-11-18 21:35:12 org.apache.catalina.startup.Catalina load
信息: Initialization processed in 523 ms
2017-11-18 21:35:12 org.apache.catalina.core.StandardService start
信息: Starting service tomcat1
2017-11-18 21:35:12 org.apache.catalina.core.StandardEngine start
信息: Starting Servlet Engine: Apache Tomcat/6.0.18
2017-11-18 21:35:12 com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector 
警告: Unable to load JDK7 annotation types; will have to skip
WARNING: could not load Java7 Path class
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012111118 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012111619 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012112120 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[redisson-netty-1-3] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-1-2] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-1-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-1-1] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-1-1] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-1-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-1-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-1-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-1-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-1-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-1-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-1-2] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-1-4] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-1-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-1-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012113625 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012111619 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012112120 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[redisson-netty-5-2] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-5-3] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-5-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-5-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-5-2] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-5-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-5-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-5-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-5-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-5-2] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-5-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-5-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-5-2] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-5-1] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-5-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012113625 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012114127 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012114127 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[redisson-netty-7-2] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-7-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-7-3] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-7-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-7-4] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-7-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-7-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-7-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-7-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-7-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-7-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-7-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-7-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-7-2] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-7-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012113625 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012114127 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012114127 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[redisson-netty-9-2] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-9-2] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-9-3] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-9-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-9-2] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-9-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-9-4] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-9-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-9-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-9-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-9-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-9-3] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-9-3] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-9-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-9-3] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012113625 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012114127 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012114127 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[main] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-11-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-11-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-11-2] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-11-1] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-11-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-11-1] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-11-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-11-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-11-2] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-11-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-11-1] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-11-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-11-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-11-1] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
[main] INFO org.redisson.cluster.ClusterConnectionManager - Redis cluster nodes configuration got from /192.168.1.104:7000:
9ede82afe626e38487b46edddbc3427bb6f05eac 192.168.1.104:7002 master - 0 1511012113124 3 connected 10923-16383
a58ca3c53d37fc1a909a8c5402da23b02d62b048 192.168.1.104:7005 slave 9ede82afe626e38487b46edddbc3427bb6f05eac 0 1511012113625 6 connected
82fec9e38ec4e6ee633009cf5366408368ce497b 192.168.1.104:7003 slave 58360c20acaad16bfa651800390b9ec676db265f 0 1511012114127 4 connected
ea942df7f35c28e96154948f08ad214c522a2d32 192.168.1.104:7004 slave 6d4190de16cce92b47e6d38129ecf5723a7b07f3 0 1511012113124 5 connected
6d4190de16cce92b47e6d38129ecf5723a7b07f3 192.168.1.104:7001 master - 0 1511012114127 2 connected 5461-10922
58360c20acaad16bfa651800390b9ec676db265f 192.168.1.104:7000 myself,master - 0 0 1 connected 0-5460
[redisson-netty-13-4] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7004
[redisson-netty-13-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7004] added for slot ranges: [[5461-10922]]
[redisson-netty-13-2] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7003] added for slot ranges: [[0-5460]]
[redisson-netty-13-4] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7003
[redisson-netty-13-1] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7001
[redisson-netty-13-1] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7001 added for slot ranges: [[5461-10922]]
[redisson-netty-13-4] INFO org.redisson.cluster.ClusterConnectionManager - slaves: [redis://192.168.1.104:7005] added for slot ranges: [[10923-16383]]
[redisson-netty-13-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7004
[redisson-netty-13-3] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for /192.168.1.104:7005
[redisson-netty-13-4] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7000
[redisson-netty-13-4] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7000 added for slot ranges: [[0-5460]]
[redisson-netty-13-1] INFO org.redisson.connection.pool.MasterConnectionPool - 10 connections initialized for /192.168.1.104:7002
[redisson-netty-13-1] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.104:7002 added for slot ranges: [[10923-16383]]
[redisson-netty-13-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7003
[redisson-netty-13-4] INFO org.redisson.connection.pool.SlaveConnectionPool - 10 connections initialized for /192.168.1.104:7005
2017-11-18 21:35:14 org.apache.coyote.http11.Http11Protocol start
信息: Starting Coyote HTTP/1.1 on http-8080
2017-11-18 21:35:14 org.apache.jk.common.ChannelSocket init
信息: JK: ajp13 listening on /0.0.0.0:8009
2017-11-18 21:35:14 org.apache.jk.server.JkMain start
信息: Jk running ID=0 time=0/21  config=null
2017-11-18 21:35:14 org.apache.catalina.startup.Catalina start
信息: Server startup in 2944 ms
但访问项目中的jsp就报异常了,请问谁知道为什么,在线等,急~~~~~~
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We are seeing Out Of Memory Exception when using RScheduledExecutorService.
We are using redisson 3.5.5
These are our settings:
scanInterval = 5000;
idleConnectionTimeout = 30000;
masterIdleConnectionPool = 50;
masterConnectionPoolSize = 250;
slaveIdleConnectionPool = 50;
slaveConnectionPoolSize = 250;
connectionTimeout = 30000;
readTimeout = 30000;
executorWorkerThreads = 10;
This is how we produced it:
`    public static void main(String args[]){
    int duration = 120;
    int totalThreads = 150;
    int delayInMillis = 30000;
    System.out.println("params are: "+duration+" "+totalThreads+" "+delayInMillis);
    init();

    long currentTime = System.currentTimeMillis();
    Calendar time = Calendar.getInstance();
    time.add(Calendar.MINUTE,duration);

    try {
        ExecutorService service = Executors.newFixedThreadPool(totalThreads);
        while(currentTime < time.getTimeInMillis()){
            try{

                for(int i = 0;i<totalThreads; i++){
                    service.submit(new MessageSender(redissonExecutorService, delayInMillis));
                }
                currentTime=System.currentTimeMillis();
                Thread.sleep(1000);
            }catch(Exception ex){
                ex.printStackTrace();
            }

        }

        service.shutdown();
        System.out.print("================Done Scheduling..............");

    } catch (Exception e) {
        e.printStackTrace();
    }


}`

`    public static void init() {
    Config config = new Config();

    if (nodeList != null) {
        StringTokenizer nodes = new StringTokenizer(nodeList, DELIMITER);
        while (nodes.hasMoreTokens()) {
            config.useReplicatedServers()
                    .addNodeAddress(nodes.nextToken());
        }
        config.useReplicatedServers().setScanInterval(5000);
        config.useReplicatedServers().setIdleConnectionTimeout(30000);
        config.useReplicatedServers().setMasterConnectionMinimumIdleSize(50);
        config.useReplicatedServers().setMasterConnectionPoolSize(250);
        config.useReplicatedServers().setSlaveConnectionMinimumIdleSize(50);
        config.useReplicatedServers().setSlaveConnectionPoolSize(250);
        config.useReplicatedServers().setConnectTimeout(30000);
        config.useReplicatedServers().setTimeout(30000);

        RedissonNodeConfig nodeCnfig = new RedissonNodeConfig(config);
        nodeCnfig.setExecutorServiceWorkers(Collections.singletonMap("EXECUTORSERVICENAME", 10));
        RedissonNode processingNode  =  RedissonNode.create(nodeCnfig);
        processingNode.start();
        redissonClient = Redisson.create(config);
        redissonExecutorService = redissonClient.getExecutorService("EXECUTORSERVICENAME");

    } else {
        System.out.println("Redis initialization failed due to missing node list");
    }
}`

`public class MessageSender implements Callable {
private RScheduledExecutorService redissonExecutorService;
private int delayInMillis;

public MessageSender(RScheduledExecutorService service,int delayInMillis){

    this.redissonExecutorService = service;
    this.delayInMillis = delayInMillis;
}
public String call(){

    System.out.println("Scheduling...");
    RScheduledFuture<?> future  = this.redissonExecutorService.scheduleAsync(new RedisRunner("Hello World"), delayInMillis, TimeUnit.MILLISECONDS);
    System.out.print(future.getTaskId());


    return null;
}

}`
`public class RedisRunner implements Runnable {
private String message;


public RedisRunner(){
}

public RedisRunner(String message){
    this.message = message;
}

public String getMessage() {
    return message;
}

public void setMessage(String message) {
    this.message = message;
}

@Override
public void run(){

    System.out.println("Processed: "+message);

}

}`
It would be great if you could help provide some guidance here and help figure out the issue.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am Using the RMapCache<K,V> and using the Method  putIfAbsent(K key, V value, long ttl, TimeUnit ttlunit) .
I want to use the Eviction functionality i.e provided so I am giving ttl as 45 Sec.
After 45 Sec when i check the Entry in the MapCache From the ReddisonClient at runtime i didnt found the entry
But when i check the same in the Redis-cli using HGETALL i can still able to found this Entry that was Deleted through Eviction Process by Redisson
SomeTimes even after 5 min i can able to see the Entry in the Redis-cli even Though it can't be able to find from the Redissonclient after 45 Secs
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using spring and redisson cache manager. Below is the issue I am running into. The thing is that if I manually cleared cache from redis-cli, the issue is gone.
org.redisson.client.RedisException: ERR Error running script (call to f_f3b214e49c28f69ed888c0b1a1c0308d2676972d): @user_script:1: user_script:1: bad argument #1 to 'len' (string expected, got boolean) .  command: (EVAL), params: [local insertable = false; local value = redis.call('hget', KEYS[1], ARGV[5]); local t, val;if value ..., 8, EntityDataCache, redisson__timeout__set:{EntityDataCache}, redisson__idle__set:{EntityDataCache}, redisson_map_cache_created:{EntityDataCache}, redisson_map_cache_updated:{EntityDataCache}, redisson__map_cache__last_access__set:{EntityDataCache}, redisson_map_cache_removed:{EntityDataCache}, {EntityDataCache}:redisson_options, ...]
org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:243)
org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:103)
io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1336)
io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1127)
io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1162)
io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
Can you please tell me the difference between AvroJacksonCodec in Redisson vs creating my own codec using Avro's BinaryEncoder directly? Does the Jackson codec covert the object to JSON first and then to binary? E.g. is it wrapping my objects in { } and also writing the field names? Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redssion 配置
redisson:client
<redisson:master-slave-servers master-address="redis://127.0.0.1:16379" password="123">
<redisson:slave-address value="redis://127.0.0.1:16380"/>
<redisson:slave-address value="redis://127.0.0.1:16381"/>
</redisson:master-slave-servers>
</redisson:client>
项目启动后一直报
十一月 21, 2017 10:39:40 上午 org.redisson.client.handler.CommandsQueue exceptionCaught
严重: Exception occured. Channel: [id: 0x36a1b44e, L:/127.0.0.1:6539 - R:/127.0.0.1:16380]
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:366)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:118)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:745)
不知道是怎么回事。希望能处理下。 万分感谢！！！
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I used high version(org.redisson:redisson:3.5.3)，The error is as follows.
But, when I used low version(org.redisson:redisson:2.2.17), my project is started normal with tomcat 8.0.14.
My project is used gradle 4.0, I want to use the high version, please tell me how to do?
2017-11-21 16:57:57.807||WARN -[Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.xxx.common.utils.SpringUtils#0' defined in ServletContext resource [/WEB-INF/classes/spring/spring-servlet.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalCacheAdvisor': Cannot resolve reference to bean 'org.springframework.cache.annotation.AnnotationCacheOperationSource#0' while setting bean property 'cacheOperationSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.annotation.AnnotationCacheOperationSource#0': BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalJCacheAdvisor': Cannot resolve reference to bean 'org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#0' while setting bean property 'cacheOperationSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#0': Cannot resolve reference to bean 'cacheManager' while setting bean property 'cacheManager'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cacheManager' defined in ServletContext resource [/WEB-INF/classes/spring/spring-servlet.xml]: Invocation of init method failed; nested exception is java.lang.NullPointerException]-[o.s.w.c.s.XmlWebApplicationContext]-[localhost-startStop-1]
2017-11-21 16:57:57.822||ERROR-[Context initialization failed]-[o.s.web.servlet.DispatcherServlet]-[localhost-startStop-1]
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'com.xxx.common.utils.SpringUtils#0' defined in ServletContext resource [/WEB-INF/classes/spring/spring-servlet.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalCacheAdvisor': Cannot resolve reference to bean 'org.springframework.cache.annotation.AnnotationCacheOperationSource#0' while setting bean property 'cacheOperationSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.annotation.AnnotationCacheOperationSource#0': BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.config.internalJCacheAdvisor': Cannot resolve reference to bean 'org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#0' while setting bean property 'cacheOperationSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource#0': Cannot resolve reference to bean 'cacheManager' while setting bean property 'cacheManager'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cacheManager' defined in ServletContext resource [/WEB-INF/classes/spring/spring-servlet.xml]: Invocation of init method failed; nested exception is java.lang.NullPointerException
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:479) ~[AbstractAutowireCapableBeanFactory.class:4.3.6.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[AbstractBeanFactory$1.class:4.3.6.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[DefaultSingletonBeanRegistry.class:4.3.6.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[AbstractBeanFactory.class:4.3.6.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) ~[AbstractBeanFactory.class:4.3.6.RELEASE]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to use the Namespace of IRedisClient. Where is the Namespace of Redisson?
@Test
public void testMap() throws InterruptedException {
	RMap<String, String> map = redisson.getMap("anyMap");
	String prevObject = map.put("111", "AAA");
	String currentObject = map.putIfAbsent("222", "BBB");
	String obj = map.remove("111");
}

public abstract interface IRedisClient
{
	public abstract boolean set(RedisNamespace paramRedisNamespace, String paramString1, 	String paramString2);
  
	public abstract boolean set(RedisNamespace paramRedisNamespace, String paramString1, String paramString2, long paramLong);
  
	public abstract boolean set(RedisNamespace paramRedisNamespace, String paramString1, String paramString2, boolean paramBoolean);
  
	public abstract boolean exists(RedisNamespace paramRedisNamespace, String paramString);

	public abstract String get(RedisNamespace paramRedisNamespace, String paramString);
 ...
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We are seeing out of memory when trying to use RedissonExecutorService.
Please find attached the file you can use to reproduce the issue.
Usage:
nohup java -Xmx512m -XX:MaxMetaspaceSize=80m -cp testredisscheduler-1.0-SNAPSHOT-jar-with-dependencies.jar com.test.redis.scheduler.TestRedisScheduler 120 10 10 > output.log &
Running it for about 20-30 min produces the issue.
final.zip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What is the application scenario of the RedissonRedLock?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of org.springframework.security.authentication.UsernamePasswordAuthenticationToken: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)
 at [Source: io.netty.buffer.ByteBufInputStream@360d676b; line: 1, column: 184] (through reference chain: org.springframework.security.core.context.SecurityContextImpl["authentication"])


I've read somewhere that you need to add a serializationcodec but didn't manage to get it to work.. any tips?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson runs base on redis-cluster mode, and every thing looks cool.  When redis cluster nodes all down, the redisson is unable to work and throws connection exception. Howerer, when the redis cluster recovered, the redisson is still unable to work and throws null pointer exception!!!!!!!
I did this test base on redisson 3.3.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey guys,
currently trying redis + redisson (v3.5.5), so this might be an easy question for some of you. Anyways as soon as I create my Redisson Client (config seems right), the client hangs in the create statement indefinitely without any exception or timeout, etc (waited for over an hour to hopefully see some error, sadly none).
To the setup: Win10 + Ubuntu subsystem running redis on standard port (6379), single server setup. In its config the redis server is binding to 127.0.0.1 (also tried disabling protected mode). RedisDesktop Manager and Jedis connect just fine without any issues.
Code (Kotlin):
val config = Config()
    config.useSingleServer()
            .setAddress("redis://localhost:6379") // redis://127.0.0.1 does not work either
            .setDatabase(0)
            .setSslEnableEndpointIdentification(false)
            .setConnectTimeout(10)

    val redisson = Redisson.create(config)

Hope someone can help, as I couldn't find anything related to this anywhere online.
Stacktrace :
"main" #1 prio=5 os_prio=0 tid=0x0000000004f46000 nid=0x37450 waiting on condition [0x0000000004f3e000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x000000076b9ae160> (a java.util.concurrent.CompletableFuture$Signaller)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1693)
        at java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323)
        at java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1729)
        at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1934)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:168)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:39)
        at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:277)
        at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:165)
        at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:32)
        at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:231)
        at org.redisson.Redisson.<init>(Redisson.java:117)
        at org.redisson.Redisson.create(Redisson.java:156)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: java.lang.IndexOutOfBoundsException: fromIndex: 0 toIndex: 2 size: 0
at org.redisson.RedissonList.subList(RedissonList.java:572)
at com.westone.message.processor.RedissionImp.deleteMessage(RedissionImp.java:210)
at com.westone.message.processor.MessageProcessor.deleteMessage(MessageProcessor.java:484)
The source code is
RList userInboxRList = redisson.getList(rListKey);
int confirmedIndex = userInboxRList.indexOf(confirmedMessageId);
List messageIds = userInboxRList.subList(0, confirmedIndex + 1);
the error occurs when get a sub list from Rlist object, use 'indexOf' to get index number of specified string, it returns 1, it shows that there should be some elements in specified region, but reported no data
found, did somebody meet same issue? how did it happen?
BTW, the redission version is 3.4.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
观察了下代码redisson-tomcat6 的
protected RedissonClient buildClient() throws LifecycleException {
Config config = null;
try {
config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
} catch (IOException e) {
// trying next format
try {
config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
} catch (IOException e1) {
log.error("Can't parse json config " + configPath, e);
throw new LifecycleException("Can't parse yaml config " + configPath, e1);
}
}
    try {
        return Redisson.create(config);
    } catch (Exception e) {
        throw new LifecycleException(e);
    }
}

和
redisson-tomcat-7
protected RedissonClient buildClient() throws LifecycleException {
Config config = null;
try {
config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
} catch (IOException e) {
// trying next format
try {
config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
} catch (IOException e1) {
log.error("Can't parse json config " + configPath, e);
throw new LifecycleException("Can't parse yaml config " + configPath, e1);
}
}
    try {
        try {
            Config c = new Config(config);
            Codec codec = c.getCodec().getClass().getConstructor(ClassLoader.class)
                            .newInstance(Thread.currentThread().getContextClassLoader());
            config.setCodec(codec);
        } catch (Exception e) {
            throw new IllegalStateException("Unable to initialize codec with ClassLoader parameter", e);
        }
        
        return Redisson.create(config);
    } catch (Exception e) {
        throw new LifecycleException(e);
    }
}

不同
问一下,这个是为什么?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redission.getSet("key").removeRandom(10);
it seems to use the command "SPOP key 10"
but in fact redis Set doesn't support that uses, SPOP  only pop out one value at a time. So this will cause an Exception "wrong number of arguments for 'spop' command"
i am using redission version 3.5.5;
and i hope redission wilol support the SRANDMEMBER command in the future
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Environment:
redis_4.0.2(1 master 5 slave)
apache-tomcat-8.0.41
Redisson 3.5.5
nginx-1.12.0
Configuration all set and session can store in redis and get from redis.
But when I login, I have to login 2 times (First time fail and auto refresh page, second time can success).. After logined, when I click the page, it will show "Uncaught TypeError: Cannot read property 'click' of undefined" (Google Chrome) or "TypeError: tableDom is null"(FireFox). Then I refresh the page and click it agian, it will be normal.
Can you help me slove this problem? thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It looks like the second time you try to get a key that was null through a map loader, the loader will simply hang.
I was able to reproduce this in RedissonMapCacheTest.java with the following code
@Test
public void testMapLoaderGetMulipleNulls() {
    Map<String, String> cache = new HashMap<String, String>();
    cache.put("1", "11");
    cache.put("2", "22");
    cache.put("3", "33");
    
    RMap<String, String> map = getLoaderTestMap("test", cache);
    assertThat(map.get("0")).isNull();
    assertThat(map.get("1")).isEqualTo("11");
    assertThat(map.get("0")).isNull(); // This line will never return anything and the test will hang
}

// This code will work fine, because the keys without values are different.
@Test
public void testMapLoaderGetMulipleNullsDifferentKeys() {
    Map<String, String> cache = new HashMap<String, String>();
    cache.put("1", "11");
    cache.put("2", "22");
    cache.put("3", "33");
    
    RMap<String, String> map = getLoaderTestMap("test", cache);
    assertThat(map.get("0")).isNull();
    assertThat(map.get("1")).isEqualTo("11");
    assertThat(map.get("-1")).isNull(); 
}

I'm running Windows 10 with Redis Version 3.2.100 64 bit version.  This is happening on Redisson 3.5.5 and the current master branch.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: Unexpected exception while processing command
Caused by: com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of org.springframework.security.authentication.UsernamePasswordAuthenticationToke
n: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)
at [Source: io.netty.buffer.ByteBufInputStream@3a0db884; line: 1, column: 184] (through reference chain: org.springframework.security.core.context.SecurityContextImpl["aut
hentication"])
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version: 3.5.5, code:
c.getScript().eval(RScript.Mode.READ_WRITE,
                new JsonJacksonCodec(),
                "return redis.call('SET', KEYS[1], ARGV[1]);",
                RScript.ReturnType.BOOLEAN,
                ImmutableList.of("test"), "x");

Command executed:
"EVAL" "return redis.call('SET', KEYS[1], ARGV[1]);" "1" "test" "x"

Expected result: values and/or keys encoded with json codec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version:3.5.4
@Test
    public void cacheLongTest() {
        RAtomicLong rAtomicLong = redissonClient.getAtomicLong("testKey");
        System.out.println(rAtomicLong.isExists());
    }

At first,I delete the key,confirm the key not exist.
run this test and debug with no breakpoint the result is : false
secend,  debug + breakpoint at
RAtomicLong rAtomicLong = redissonClient.getAtomicLong("testKey");

system out the result is : true
why?
我是不是应该用中文。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Just wanted to report this warning I'm seeing now since I am giving Java 9 a go (for native alpn/ssl stuff that's not directly related to Redisson).
This warning is shown on stdout when I start up my runnable/uber jar:
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.redisson.config.ConfigSupport (file:/opt/rt_deploy/ej_test/target/rt-push-server.jar) to method java.net.URI.lowMask(java.lang.String)
WARNING: Please consider reporting this to the maintainers of org.redisson.config.ConfigSupport
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release

So far it appears everything is working fine, but figured it might be worth reporting, since it says it will eventually be denied in a future Java 9 release.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
你好，
在使用RedissonRedLock发现了一个疑似bug的问题。
首先，redlock的算法中提到：

当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。

但是RedissonRedLock实际使用中的行为与上面不一致。
将RedissonRedLockTest中的测试用例testLockSuccess修改为如下：
    RLock lock1 = client1.getLock("lock1");
    RLock lock2 = client1.getLock("lock2");
    RLock lock3 = client2.getLock("lock3");
    
    Thread t1 = new Thread() {
        public void run() {
            lock1.lock();
        }
    };
    t1.start();
    t1.join();

    RedissonMultiLock lock = new RedissonRedLock(lock1, lock2, lock3);
    assertThat(lock.tryLock(500, 5000, TimeUnit.MILLISECONDS)).isTrue();
    lock.unlock();

    lock1.delete();

上面代码中的assert只在lock3被锁住的时候能通过，lock1或者lock2被锁住时都assert失败。
这个问题在调用public boolean tryLock()方法时则不会出现。
查看了源码以后发现，出现上述现象的原因是，在获取已经被锁住的lock1或者lock2时，waitTime与RedLock的waitTime是一样的（代码在RedissonMultiLock）。所以只要lock1或者lock2获取超时，RedLock就获取超时返回false了。
而redlock的算法中提到：

如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。

请帮忙看下这个问题该如何解决。谢谢。
参考资料：Redlock算法
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2017-12-04 17:59:01.118  WARN 2872 --- [nio-9090-exec-1] o.s.b.a.health.RedisHealthIndicator      : Health check failed
org.springframework.data.redis.RedisConnectionFailureException: Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool
at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:204)
at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.getConnection(JedisConnectionFactory.java:348)
at org.springframework.data.redis.core.RedisConnectionUtils.doGetConnection(RedisConnectionUtils.java:129)
at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:92)
at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:79)
Caused by: redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool
at redis.clients.util.Pool.getResource(Pool.java:53)
at redis.clients.jedis.JedisPool.getResource(JedisPool.java:226)
at redis.clients.jedis.JedisPool.getResource(JedisPool.java:16)
at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:194)
... 119 common frames omitted
Caused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.ConnectException: Connection refused: connect
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I was hoping to see support for RxJava2, I love having Redis on the stack when I make apps, but it's a real pain when almost every other library has standardized. Thanks for considering :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are currently using Redisson 3.5.0 to connect to our Redis labs enterprise cluster(RLEC). The driver is configured to connect using single server mode (as recommended for RLEC). When the active node ip switches/changes, Redisson is not able to reconnect with the new active node. It keeps retrying to communicate with the last known active node ip from the endpoint. This behavior is consistent with either "dns monitoring" being set to true / false.  If we manually set the same active node ip back, it immediately reconnects, which proves the point that its unaware of the ip address changes, unless the last known ip is elected again as active.
How do we enable Redisson to detect potential ip changes of active node, while using endpoint of RLEC in single server mode?
Please let me know if you have any ideas on this one. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I asked a question on stackoverflow about how to well configure redisson to make eviction scheduler working on set in redis, but no answer yet :(. Could you help us by answering on this post or by improving the wiki about this point ?
Many thanks !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am creating a set through Medis, a Redis client or FastoRedis. When I try to read the same using redissonClient.getSet(key), I see an exception being thrown saying "Unable to evaluate the expression Method threw 'org.redisson.client.RedisException' exception." while debugging the set in IntelliJ. Why can't redisson is reading the value for the key? I noticed one thing when the redisson sets the value, it has quotes. But when you set a string from external clients, it doesn't have any quotes and redisson can't seems to be recognizing it.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello.
I'm interested in this project. I am creating a sample project(https://github.com/bleujin/CrakenRedis) using this,
And I do not think readswriteLock is working properly.
The error pattern is a bit different, but the example org.redission.example.ReadWriteLockExamples.java is not working properly. Version 2.10.5 does not work either.
I do not know much about redis
I hope this project can be maintained.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
你好，
我将redis cluster的参数cluster-require-full-coverage设置为了no，以让集群在挂掉部分节点的时候仍然可以提供服务。但是一旦16384个slot没有全部被覆盖，redisson在初始化的时候会报如下错误，请问如何解决：
org.redisson.client.RedisConnectionException: Not all slots are covered! Only 10923 slots are avaliable. Failed masters according to cluster status: [/127.0.0.1:8800]
at org.redisson.cluster.ClusterConnectionManager.(ClusterConnectionManager.java:146)
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)
at org.redisson.Redisson.(Redisson.java:117)
at org.redisson.Redisson.create(Redisson.java:156)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:601)
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
... 42 more
Caused by: com.eif.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /127.0.0.1:8800
at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:692)
at com.eif.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:347)
at com.eif.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:340)
at com.eif.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:630)
at com.eif.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:565)
at com.eif.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:479)
at com.eif.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441)
at com.eif.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at com.eif.io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
at java.lang.Thread.run(Thread.java:722)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You can't find a class using the Lambda creation task
java.lang.NullPointerException
at java.io.FilterInputStream.available(FilterInputStream.java:168)
at org.redisson.RedissonExecutorService.getClassBody(RedissonExecutorService.java:326)
at org.redisson.RedissonExecutorService.scheduleAsync(RedissonExecutorService.java:734)
at org.redisson.RedissonExecutorService.schedule(RedissonExecutorService.java:726)
at org.redisson.RedissonExecutorService.schedule(RedissonExecutorService.java:87)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FstCodec deserialization problem when adding new properties to session object.
Is there any way to handle that? If its possible to either ignore or invalidate session if new properties are added.
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:319) ~[redisson-2.10.0.jar:na]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:164) ~[redisson-2.10.0.jar:na]
at org.redisson.RedissonObject.get(RedissonObject.java:70) ~[redisson-2.10.0.jar:na]
at org.redisson.RedissonMap.readAllEntrySet(RedissonMap.java:359) ~[redisson-2.10.0.jar:na]
at org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:95) ~[redisson-2.10.0.jar:na]
at org.redisson.spring.session.RedissonSessionRepository.getSession(RedissonSessionRepository.java:300) ~[redisson-2.10.0.jar:na]
at org.redisson.spring.session.RedissonSessionRepository.getSession(RedissonSessionRepository.java:51) ~[redisson-2.10.0.jar:na]
at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:327) ~[spring-session-1.3.1.RELEASE.jar:na]
at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:344) ~[spring-session-1.3.1.RELEASE.jar:na]
at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:217) ~[spring-session-1.3.1.RELEASE.jar:na]
at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:231) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.security.web.context.HttpSessionSecurityContextRepository.loadContext(HttpSessionSecurityContextRepository.java:110) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:100) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) ~[spring-security-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]
at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:167) ~[spring-session-1.3.1.RELEASE.jar:na]
at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:80) ~[spring-session-1.3.1.RELEASE.jar:na]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106) ~[spring-boot-actuator-1.5.6.RELEASE.jar:1.5.6.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) ~[tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar:8.5.16]
at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar:8.5.16]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar:8.5.16]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME: loader:sun.misc.Launcher$AppClassLoader@18b4aac2
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:243) ~[fst-2.47.jar:na]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:69) ~[redisson-2.10.0.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:259) ~[redisson-2.10.0.jar:na]
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:289) ~[redisson-2.10.0.jar:na]
at org.redisson.client.handler.CommandDecoder.decodeFromCheckpoint(CommandDecoder.java:154) ~[redisson-2.10.0.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101) ~[redisson-2.10.0.jar:na]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.13.Final.jar:4.1.13.Final]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[netty-codec-4.1.13.Final.jar:4.1.13.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458) ~[netty-transport-4.1.13.Final.jar:4.1.13.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.13.Final.jar:4.1.13.Final]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) ~[netty-common-4.1.13.Final.jar:4.1.13.Final]
... 1 common frames omitted
Caused by: java.lang.RuntimeException: class not found CLASSNAME: loader:sun.misc.Launcher$AppClassLoader@18b4aac2
at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:235) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173) ~[fst-2.47.jar:na]
at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:472) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:933) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:343) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:708) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:562) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:708) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:562) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:708) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:562) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:327) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:307) ~[fst-2.47.jar:na]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:241) ~[fst-2.47.jar:na]
... 31 common frames omitted
Caused by: java.lang.ClassNotFoundException:
at java.lang.Class.forName0(Native Method) ~[na:1.8.0_131]
at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_131]
at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:197) ~[fst-2.47.jar:na]
... 48 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
executeSchedule methods return void method instead of ScheduledFuture this allow to avoid memory consumption by each schedule.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Rename codecProvider and redissonReferenceEnabled Config properties to referenceCodecProvider and referenceEnabled
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 3.5.6 fails on bootstrap when using custom event loop.
    private RedissonClient createRedissonClient(int database) {
        Config config = new Config();
        if (redisNodes.indexOf(',') > -1) {
            ReplicatedServersConfig clusterConfig = config.useReplicatedServers();
            clusterConfig.setScanInterval(3000);
            clusterConfig.setDatabase(database);
            clusterConfig.setTcpNoDelay(true);
            clusterConfig.setKeepAlive(true);
            for (String addr : StringUtils.tokenizeToStringArray(redisNodes, ",", true, true)) {
                clusterConfig.addNodeAddress(addSchema(addr));
            }
            clusterConfig.setTimeout(8000);
            if (database == redisGameDatabase) {
                clusterConfig.setReadMode(ReadMode.MASTER); // consistency is crucial
            } else {
                clusterConfig.setReadMode(ReadMode.MASTER_SLAVE); // consider setting SLAVE when we have multiple slaves
            }
        } else {
            SingleServerConfig singleServerConfig = config.useSingleServer();
            singleServerConfig.setDatabase(database);
            singleServerConfig.setTimeout(8000);
            singleServerConfig.setTcpNoDelay(true);
            singleServerConfig.setKeepAlive(true);
            singleServerConfig.setAddress(addSchema(redisNodes));
        }
        config.setCodec(new SnappyCodec());
        config.setThreads(redisEventLoop.getThreadPoolSize());
        config.setEventLoopGroup(redisEventLoop.getWorkerGroup());
        config.setUseLinuxNativeEpoll(redisEventLoop.isNativeEpoll());

        return Redisson.create(config);
    }
Caused by: java.lang.IllegalStateException: channel not registered to an event loop
	at io.netty.channel.AbstractChannel.eventLoop(AbstractChannel.java:162) ~[netty-transport-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.channel.nio.AbstractNioChannel.eventLoop(AbstractNioChannel.java:119) ~[netty-transport-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.channel.nio.AbstractNioChannel.eventLoop(AbstractNioChannel.java:49) ~[netty-transport-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.query(DnsNameResolverContext.java:316) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.query(DnsNameResolverContext.java:295) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.query(DnsNameResolverContext.java:791) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.internalResolve(DnsNameResolverContext.java:200) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.doSearchDomainQuery(DnsNameResolverContext.java:189) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolverContext.resolve(DnsNameResolverContext.java:136) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolver.doResolveUncached(DnsNameResolver.java:657) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolver.doResolve(DnsNameResolver.java:594) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.DnsNameResolver.doResolve(DnsNameResolver.java:527) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.SimpleNameResolver.resolve(SimpleNameResolver.java:63) ~[netty-resolver-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:100) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:66) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.dns.InflightNameResolver.resolve(InflightNameResolver.java:51) ~[netty-resolver-dns-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.InetSocketAddressResolver.doResolve(InetSocketAddressResolver.java:57) ~[netty-resolver-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.InetSocketAddressResolver.doResolve(InetSocketAddressResolver.java:32) ~[netty-resolver-4.1.18.Final.jar:4.1.18.Final]
	at io.netty.resolver.AbstractAddressResolver.resolve(AbstractAddressResolver.java:108) ~[netty-resolver-4.1.18.Final.jar:4.1.18.Final]
	at org.redisson.connection.DNSMonitor.<init>(DNSMonitor.java:65) ~[redisson-3.5.6.jar:?]
	at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:288) ~[redisson-3.5.6.jar:?]
	at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:165) ~[redisson-3.5.6.jar:?]
	at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:32) ~[redisson-3.5.6.jar:?]
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:231) ~[redisson-3.5.6.jar:?]
	at org.redisson.Redisson.<init>(Redisson.java:117) ~[redisson-3.5.6.jar:?]
	at org.redisson.Redisson.create(Redisson.java:156) ~[redisson-3.5.6.jar:?]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2017-12-12 14:42:32.691 DEBUG 2092 --- [isson-netty-4-6] o.redisson.command.CommandAsyncService   : acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return 0;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys1 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys1)); redis.call('zrem', KEYS[3], unpack(expiredKeys1)); redis.call('zrem', KEYS[2], unpack(expiredKeys1)); redis.call('hdel', KEYS[1], unpack(expiredKeys1)); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys2 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys2)); redis.call('zrem', KEYS[3], unpack(expiredKeys2)); redis.call('zrem', KEYS[2], unpack(expiredKeys2)); redis.call('hdel', KEYS[1], unpack(expiredKeys2)); end; return #expiredKeys1 + #expiredKeys2;, 6, myMap, redisson__timeout__set:{myMap}, redisson__idle__set:{myMap}, redisson_map_cache_expired:{myMap}, redisson__map_cache__last_access__set:{myMap}, redisson__execute_task_once_latch:{myMap}, 1513089752691, 100, 5, 1] from slot NodeSource [slot=null, addr=null, redirect=null] using node memcache-0-slots/192.168.10.48:6379... RedisConnection@1478021281 [redisClient=[addr=memcache-0-slots/192.168.10.48:6379], channel=[id: 0x34bb60ae, L:/192.168.10.198:50957 - R:memcache-0-slots/192.168.10.48:6379]]
2017-12-12 14:42:32.693 TRACE 2092 --- [isson-netty-4-6] o.r.client.handler.CommandEncoder        : channel: [id: 0x34bb60ae, L:/192.168.10.198:50957 - R:memcache-0-slots/192.168.10.48:6379] message: *13
$4
EVAL
$1435
if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return 0;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys1 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys1)); redis.call('zrem', KEYS[3], unpack(expiredKeys1)); redis.call('zrem', KEYS[2], unpack(expiredKeys1)); redis.call('hdel', KEYS[1], unpack(expiredKeys1)); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys2 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys2)); redis.call('zrem', KEYS[3], unpack(expiredKeys2)); redis.call('zrem', KEYS[2], unpack(expiredKeys2)); redis.call('hdel', KEYS[1], unpack(expiredKeys2)); end; return #expiredKeys1 + #expiredKeys2;
$1
6
$5
myMap
$30
redisson__timeout__set:{myMap}
$27
redisson__idle__set:{myMap}
$34
redisson_map_cache_expired:{myMap}
$45
redisson__map_cache__last_access__set:{myMap}
$41
redisson__execute_task_once_latch:{myMap}
$13
1513089752691
$3
100
$1
5
$1
1
2017-12-12 14:42:32.695 TRACE 2092 --- [isson-netty-4-6] o.r.client.handler.CommandDecoder        : channel: [id: 0x34bb60ae, L:/192.168.10.198:50957 - R:memcache-0-slots/192.168.10.48:6379] message: :1
2017-12-12 14:42:32.695 TRACE 2092 --- [isson-netty-4-7] o.r.client.handler.CommandPubSubDecoder  : channel: [id: 0xcc31d152, L:/192.168.10.198:50953 - R:memcache-0-slots/192.168.10.48:6379] message: *3
$7
message
$34
redisson_map_cache_expired:{myMap}
$28
�       "key1"�       "val1"
2017-12-12 14:42:32.696 DEBUG 2092 --- [isson-netty-4-6] o.redisson.command.CommandAsyncService   : connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return 0;end;redis.call('expire', KEYS[6], ARGV[3]); local expiredKeys1 = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys1) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys1 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys1)); redis.call('zrem', KEYS[3], unpack(expiredKeys1)); redis.call('zrem', KEYS[2], unpack(expiredKeys1)); redis.call('hdel', KEYS[1], unpack(expiredKeys1)); end; local expiredKeys2 = redis.call('zrangebyscore', KEYS[3], 0, ARGV[1], 'limit', 0, ARGV[2]); for i, key in ipairs(expiredKeys2) do local v = redis.call('hget', KEYS[1], key); if v ~= false then local t, val = struct.unpack('dLc0', v); local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(val), val); local listeners = redis.call('publish', KEYS[4], msg); if (listeners == 0) then break;end; end;end;if #expiredKeys2 > 0 then redis.call('zrem', KEYS[4], unpack(expiredKeys2)); redis.call('zrem', KEYS[3], unpack(expiredKeys2)); redis.call('zrem', KEYS[2], unpack(expiredKeys2)); redis.call('hdel', KEYS[1], unpack(expiredKeys2)); end; return #expiredKeys1 + #expiredKeys2;, 6, myMap, redisson__timeout__set:{myMap}, redisson__idle__set:{myMap}, redisson_map_cache_expired:{myMap}, redisson__map_cache__last_access__set:{myMap}, redisson__execute_task_once_latch:{myMap}, 1513089752691, 100, 5, 1] from slot NodeSource [slot=null, addr=null, redirect=null] using connection RedisConnection@1478021281 [redisClient=[addr=memcache-0-slots/192.168.10.48:6379], channel=[id: 0x34bb60ae, L:/192.168.10.198:50957 - R:memcache-0-slots/192.168.10.48:6379]]
2017-12-12 14:42:32.699  WARN 2092 --- [isson-netty-4-7] io.netty.channel.DefaultChannelPipeline  : An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 0)): only regular white space (\r, \n, \t) is allowed between tokens
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422) ~[netty-codec-4.1.17.Final.jar:4.1.17.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:138) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459) [netty-transport-4.1.17.Final.jar:4.1.17.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) [netty-common-4.1.17.Final.jar:4.1.17.Final]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) [netty-common-4.1.17.Final.jar:4.1.17.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_144]
Caused by: com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 0)): only regular white space (\r, \n, \t) is allowed between tokens
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1798) ~[jackson-core-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:663) ~[jackson-core-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.core.base.ParserMinimalBase._throwInvalidSpace(ParserMinimalBase.java:614) ~[jackson-core-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.core.json.ReaderBasedJsonParser._skipWSOrEnd(ReaderBasedJsonParser.java:2350) ~[jackson-core-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:646) ~[jackson-core-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4129) ~[jackson-databind-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3988) ~[jackson-databind-2.9.3.jar:2.9.3]
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3058) ~[jackson-databind-2.9.3.jar:2.9.3]
at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:87) ~[redisson-3.5.6.jar:na]
at org.redisson.codec.MapCacheEventCodec.decode(MapCacheEventCodec.java:102) ~[redisson-3.5.6.jar:na]
at org.redisson.codec.MapCacheEventCodec.access$100(MapCacheEventCodec.java:35) ~[redisson-3.5.6.jar:na]
at org.redisson.codec.MapCacheEventCodec$1.decode(MapCacheEventCodec.java:44) ~[redisson-3.5.6.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:257) ~[redisson-3.5.6.jar:na]
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:287) ~[redisson-3.5.6.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:276) ~[redisson-3.5.6.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:93) ~[redisson-3.5.6.jar:na]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.17.Final.jar:4.1.17.Final]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[netty-codec-4.1.17.Final.jar:4.1.17.Final]
... 28 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
To reproduce this, on 3.5.6, I updated BaseTest.java and ran the tests against a clustered Redis server running  Windows 10 with Redis Version 3.2.100 64 bit version.
Completion appears to work fine.  It's just the ack that is throwing an error.  If I set the options to noAck, I can get a result.
Ack does appear to work correctly if Redis is not in cluster mode.
BaseTest Modification:
public static Config createConfig() {

//        String redisAddress = System.getProperty("redisAddress");
//        if (redisAddress == null) {
//            redisAddress = "127.0.0.1:6379";
//        }
Config config = new Config();
//        config.setCodec(new MsgPackJacksonCodec());
//        config.useSentinelServers().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26379", "127.0.0.1:26389");
config.useClusterServers().addNodeAddress("redis://127.0.0.1:7001"); // uncommented this line
//        config.useSingleServer()
//                .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort()); // commented this line
//        .setPassword("mypass1");
//        config.useMasterSlaveConnection()
//        .setMasterAddress("127.0.0.1:6379")
//        .addSlaveAddress("127.0.0.1:6399")
//        .addSlaveAddress("127.0.0.1:6389");
return config;
}
When I ran the RedissonRemoteServiceTest.java against the clustered server, I received many of these errors.
[redisson-netty-9-5] ERROR org.redisson.RedissonRemoteService - Can't send ack for request: RemoteServiceRequest [requestId=eed729180d9ccae3c040bb76553410c1, methodName=voidMethod, signatures=[[java.lang.String, java.lang.Long]], args=[noResult, 100], options=RemoteInvocationOptions[ackTimeoutInMillis=1000, executionTimeoutInMillis=null], date=1513171997453]
org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0x22df13ac, L:/127.0.0.1:55263 - R:/127.0.0.1:7002] command: (EVAL), params: [if redis.call('setnx', KEYS[1], 1) == 1 then redis.call('pexpire', KEYS[1], ARGV[2]);redis.call('rpu..., 2, {redisson_rs:remote}:eed729180d9ccae3c040bb76553410c1:ack, {remote_response}:44c56d88-e906-48ca-9462-6de13664ef75, PooledUnsafeDirectByteBuf(ridx: 0, widx: 89, cap: 256), 1000]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:241)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I would like to minimize the data storage in Redis. When putting an Object in a list, I found that the object is serialized and stored in JSON. However, for every field in the json string, it has a class name info "java.lang.String" next a field for example.
Looking at the source code, https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java#L140, realized that this is added by default. Passing my object mapper to initialize won't work either.
Is this necessary? Is there a way to disable this?
Alternatively, I serialized myself an object into a string and put the string into RList. However, then it seems the library serialize one extra time as follow:
from "\{\"stepId\":1}\" (application serialize) to "\"{\\\"stepId\\\":1}\"" (how it looks in Redis)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I've a java application where I'm using Rmap to store and retrieve objects to/from Redis. The response time of map.put(...) is reasonable but map.get(...) is averaging 4000000.0 ns.  I'm using FstCodec for serialization/deserialization. The application has many classes that do not provide no arg constructor and hence certain codecs can't be used.
I would like to know how to improve the map.get(...) response. When same object to go LinkedHashMap, the response time is in the range of 446.0 ns and I'm looking for a response time in that range.
Find attached my sample java application and config file.
RedissonIPWCTaskTester.java.txt
RedisConfig.json.txt
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have got CertificateException when Redisson try to connect.
Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 12.34.567.89 found
at sun.security.util.HostnameChecker.matchIP(HostnameChecker.java:167)
at sun.security.util.HostnameChecker.match(HostnameChecker.java:93)
at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:455)
at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:436)
at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:252)
at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:136)
at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1501)
... 28 more
When i disabled the setSslEnableEndpointIdentification the connection was successfully established.
The scenario is when I'm using useClusterServers config
the Redisson client sends cluster nodes command to Azure Redis,
the server responses with a list of IP and port of cluster nodes, then Redisson client try to connect to newly discovered masters, but now the target is IP and Azure doesn't sign the certificate.
Important note:
all the discovered IPs are the same IP resolved by endpoint URL (which provided by Azure).
I saw that other redis clients separate the endpointIdentification for the base connection and cluster node connection.
If we are able to do node cluster endpointIdentification with the base connection verification it will solve the issue.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It clears all local cache across all RLocalCachedMap instances.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Any reason RBatch does have a getSortedSet() method?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After the fix of #1280 which improved greatly the resilience of Sentinel setup, it would be great to have dnsMonitoring  feature as well because in failover scenarios of sentinels instances, the box can get a different IP and the current implementation caches the dns resolution forever.  It means it never reconnects to new sentinels in the cluster.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to create a singleton bean of RScheduledExecutorService in Spring 4. I have not yet autowired this bean anywhere. I am always ending up with error. I am working with Redisson 2.11.
Unable to find any kind of solution or any instances of problem with anyone else here. Is this a bug ?
Since it is a JsonMappingException I also tried using different codes but nothing helped.
SEVERE: StandardWrapper.Throwable java.lang.IllegalArgumentException: com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: org.springframework.scheduling.concurrent.ReschedulingRunnable["cancelled"]) at org.redisson.RedissonExecutorService.encode(RedissonExecutorService.java:317) at org.redisson.RedissonExecutorService.scheduleAsync(RedissonExecutorService.java:741) at org.redisson.RedissonExecutorService.schedule(RedissonExecutorService.java:700) at org.redisson.RedissonExecutorService.schedule(RedissonExecutorService.java:92) at org.springframework.scheduling.concurrent.ReschedulingRunnable.schedule(ReschedulingRunnable.java:73) at org.springframework.scheduling.concurrent.ConcurrentTaskScheduler.schedule(ConcurrentTaskScheduler.java:170) at org.springframework.scheduling.config.ScheduledTaskRegistrar.scheduleTasks(ScheduledTaskRegistrar.java:306) at org.springframework.scheduling.config.ScheduledTaskRegistrar.afterPropertiesSet(ScheduledTaskRegistrar.java:284) at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.finishRegistration(ScheduledAnnotationBeanPostProcessor.java:208) at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:162) at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:85) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:151) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:128) at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:331) at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:773) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:483) at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:664) at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:536) at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:490) at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:136) at javax.servlet.GenericServlet.init(GenericServlet.java:158)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found that in master-slave mode, the redis connections on slave servers may not get closed properly.
Caused by: org.redisson.client.RedisException: ERR max number of clients reached
After reading the source code, I found that the reason is that RedisClient does not override hashcode and equals.
Consider the following situation：

One hostname slave-hostname maps to two ip-addresses: ip1, ip2
Firstly, slave-hostname  maps to ip1, client2Entry will cache new RedisClient and ClientConnectionsEntry instances: RedisClient-ip1 and ClientConnectionsEntry-ip1

public RFuture<Void> add(final ClientConnectionsEntry entry) {
        RPromise<Void> result = new RedissonPromise<Void>();
        
        CountableListener<Void> listener = new CountableListener<Void>(result, null) {
            public void operationComplete(io.netty.util.concurrent.Future<Object> future) throws Exception {
                super.operationComplete(future);
                if (this.result.isSuccess()) {
                    client2Entry.put(entry.getClient(), entry);
                }
            };
        };

        RFuture<Void> slaveFuture = slaveConnectionPool.add(entry);
        listener.incCounter();
        slaveFuture.addListener(listener);
        
        RFuture<Void> pubSubFuture = pubSubConnectionPool.add(entry);
        listener.incCounter();
        pubSubFuture.addListener(listener);
        return result;
    }


DNS  changes from ip1 to ip2, all the connections of ClientConnectionsEntry-ip1 were closed properly.
DNS  changes from ip2 to ip1, client2Entry will cache another RedisClient and ClientConnectionsEntry instances: RedisClient-ip1-1 and ClientConnectionsEntry-ip1-1. RedisClient-ip1-1 was different from RedisClient-ip1 as they were not the same instance.
DNS  changes from ip1 to ip2 again,
All the connections of ClientConnectionsEntry-ip1-1 should get closed properly.  When san client2Entry values, it is possible to find ClientConnectionsEntry-ip1 or ClientConnectionsEntry-ip1-1

    protected ClientConnectionsEntry getEntry(InetSocketAddress address) {
        for (ClientConnectionsEntry entry : client2Entry.values()) {
            InetSocketAddress addr = entry.getClient().getAddr();
            if (addr.getAddress().equals(address.getAddress()) && addr.getPort() == address.getPort()) {
                return entry;
            }
        }
        return null;
    }

The connections of ClientConnectionsEntry-ip1-1 may not get closed properly.

Our master-slave model

one master server
two slave servers, with one slave hostname, DNS changes every twenty seconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Problem
If I initialize a bloom filter like this
RBloomFilter<String> filter = redissonClient.getBloomFilter("test");
filter.tryInit(10000, 0.01);
filter.expire(1l, TimeUnit.MINUTES);

The String test is the only thing that gets deleted from Redis after expiration time. The config hash {test}:config remains even after expiration.
Env details
Mac OS X 10.13.2
Java version: 1.8.0_151
Redis server v=4.0.7
Redisson Version : 3.6.0
Redis used in Single Server mode
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I transfer redis cluster server from local host to virtual host recently, then some interesting things happened.
The cluster worked fine itself, but as soon as I used redisson as client, it went wrong.
They can registry by using remote address.However,they cant recognize each other with remote external address, but with local internal address. I dont know how to deal with it, can anyone help me, thanks a lot.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is very likely a bug.
in https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/client/RedisPubSubConnection.java#L118
Set up:
Redis: Sentinel Mode
Redisson: version 2.9.1   read from slave
Steps to Recreate:

shut down all redis-sentinels
shut down all redis-servers
wait for some time (redisson client initiates enough "GET" command, and connection_pool reset cause maximum failed attempts reached)
restart all redis-server
restart all redis-sentinel

in step3: slaveDown happens when maximum attempts reached, but it was unable to send "Unsubscribe"
but in https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/client/RedisPubSubConnection.java#L118, when "UNSUBSCRIBE" failure happens, it removes the channel and remove all the listeners.
my thoughts is when "UNSUBSCRIBE" failure, we should readd the channel, and not executing onMessage()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Today I had a lot of work to bind embedded Redisson Node with Spring Boot. Here are the final thoughts and conclusions. In short I believe creating own codec in TasksRunnerService using TasksRunnerService class loader is a bug. Please review the article for more details.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
I'm using Redisson 3.6.0 with redisson-tomcat 3.5.6 with:

Elasticache Redis Cluster
Spring App deployed on two instances EC2 Tomcat (instance 1 and instance 2)
Load Balance with non-sticky session

My session timeout is configured to 30min.
The steps to reproduce the issue:
a. User logged in on instance 1 (a new session is created with timeout of 30 min);
b. After 15 min, an ajax request was made by the application which was managed by 'instance 2' refreshing the session to more 30min;
c. After more 20min the user reload the page, and the load  balance send some requests to 'instance1' and to 'instance 2', but the instance 1 has been idle  for 35minutes and because of that, delete the session that was renewed 20 min ago!
This issue is only reproducible using at least two instances behind a load balance with non-sticky session because the action to delete the session ignores if the session was renewed by other instances.
Is there anything I can do to prevent this behavior?
I think this is related with #972
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry to open so many issues for the same problem, feel free to close it if you think this is not appropriate.
#1284
#1309
We are trying to have the best availability of our service when redis servers in Sentinel mode run into disaster situations (like all redis-server, redis-sentinel are down)
Currently, what we are trying is when Redisson client last received ping is too old, it will try to re-subscribe to the same channel. However, this introduced new problems, when the QPS is high, we added multiple listeners for the same client to the same channel, which is not optimal.
In following two places, there is no duplicate check (if the listener already in the PubsubConnection, don't add the listener)
https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/connection/PubSubConnectionEntry.java#L91
https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/client/RedisPubSubConnection.java#L61
Is it possible to add a duplicate check that only when the listener is not there, we add the listener to the connection ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I try to upgrade redisson from 3.5.7 to 3.6.1 but I get this exception :
java.lang.AbstractMethodError: org.redisson.spring.session.RedissonSessionRepository.getSession(Ljava/lang/String;)Lorg/springframework/session/Session;
	at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:327)
	at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:344)
	at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:217)
	at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:270)
	at org.springframework.security.web.context.HttpSessionSecurityContextRepository.loadContext(HttpSessionSecurityContextRepository.java:110)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:100)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:157)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegatatingFilterProxy.java:347)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)
	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:167)
	at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:80)
	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
	at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)
	at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
	at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:64)
	at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
	at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:131)
	at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handlt(ServletAuthenticationCallHandler.java:57)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
	at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
	at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
	at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)
	at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
	at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:119)
	at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)
	at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)
	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)
	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)
	at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
	at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
	at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)
	at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)
	at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)
	at io.undertow.server.Connectors.executeRoor(Connectors.java:332)
	at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

I'm using theses dependencies :
compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-redis', version: '1.5.9.RELEASE'
compile group: 'org.springframework.session', name: 'spring-session', version: '1.3.2.RELEASE'
compile group: 'org.redisson', name: 'redisson', version: '3.6.1'
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using Jackson 2.9.2 and 2.9.4 (tried both), trying to upgrade from Redisson 3.3.2 to 3.6.1 I get this:
Caused by: java.lang.IllegalStateException: Failed copy(): org.msgpack.jackson.dataformat.MessagePackFactory (version: 2.9.2) does not override copy(); it has to
        at com.fasterxml.jackson.core.JsonFactory._checkInvalidCopy(JsonFactory.java:333)
        at com.fasterxml.jackson.core.JsonFactory.copy(JsonFactory.java:320)
        at com.fasterxml.jackson.databind.ObjectMapper.<init>(ObjectMapper.java:499)
        at com.fasterxml.jackson.databind.ObjectMapper.copy(ObjectMapper.java:617)
        at org.redisson.codec.JsonJacksonCodec.<init>(JsonJacksonCodec.java:107)

Redisson 3.5.7 does not have this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We're having trouble spinning up redisson (3.6.1) when the minimum number of connections is high.
Steps to reproduce:

Run a local redis server. We used the official docker image:

docker container run -d --name redis -p 6379:6379 redis

Try to create a redisson client with a high number of idle connections, short retry interval and some client name:

public static void main(String[] args) {
    Config config = new Config();
    config.useSingleServer()
            .setAddress("redis://127.0.0.1:6379")
            .setClientName("client")
            .setConnectionMinimumIdleSize(1000)
            .setConnectionPoolSize(2000)
            .setRetryInterval(100);
    RedissonClient client = Redisson.create(config);
    System.out.println("Done!");
}

More often than not, we're getting the following exception after a few seconds, with a varying number if successful connections:
Exception in thread "main" org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 440 from 1000 were initialized. Redis server: /127.0.0.1:6379
	at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:138)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:512)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:425)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:122)
	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
	at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:307)
	at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:54)
	at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:277)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:512)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:505)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:484)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:425)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:122)
	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
	at org.redisson.client.RedisClient$2$1$1$1.run(RedisClient.java:215)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: org.redisson.client.RedisTimeoutException: Command execution timeout for /127.0.0.1:6379
	at org.redisson.client.RedisConnection$2.run(RedisConnection.java:212)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
	... 6 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@Bean
public CacheManager cacheManager(RedissonClient redissonClient) throws IOException {
    Map<String, CacheConfig> config = new HashMap<String, CacheConfig>();
    config.put(CacheNames.XinLianService_getAllAgentData, new CacheConfig(60 * 1000, 60 * 1000));
    config.put(CacheNames.XinlianRoleService_getById, new CacheConfig(2 * 60 * 1000, 60 * 1000));
    return new RedissonSpringCacheManager(redissonClient, config);
}

I hava set the ttl and idleTime for cache, the cache can be remove when the app is running, however when I restart app the EvictionScheduler may not work for cache, the cache can not be clear when ttl approach. Does it problem have any solution?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I'm re-opening the issue #1272 for me it's not fixed in 3.6.1, I get lot of errors long time after a fail-over.

My setup :

Spring boot 1.5.9 with Spring session 2.0.1 and redisson 3.6.1 like in this sample repo : https://github.com/DevWantJustHaveFun/spring-boot-session-redisson

The logs :
[2018-02-27 08:06:19,646] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:19,832] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:19,834] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:20,031] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:20,035] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:20,133] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:20,232] [WARN] [i.n.u.i.l.Slf4JLogger] [Null|127.0.0.1|Null|Null] - An exception was thrown by org.redisson.command.CommandAsyncService$15.operationComplete()
java.lang.NullPointerException: null
[2018-02-27 08:06:20,308] [WARN] [o.r.c.SentinelConnectionManager] [Null|127.0.0.1|Null|Null] - Skipped slave up 57.190.12.71:6399 for master redis://?:0 differs from current redis://57.190.12.72:6399

[2018-02-27 08:06:14,360] [ERROR] [i.u.s.a.LoggingExceptionHandler] [651d4b3e-6b90-4ab5-909e-46120aa1bcf8|10.4.0.2|Null|UAE10] - UT005023: Exception handling request to /connect
java.lang.IllegalArgumentException: session cannot be null
        at org.springframework.session.web.http.HttpSessionAdapter.<init>(HttpSessionAdapter.java:51)
        at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper$HttpSessionWrapper.<init>(SessionRepositoryFilter.java:372)
        at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:308)
        at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:196)
        at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:270)
        at org.springframework.security.web.context.HttpSessionSecurityContextRepository.loadContext(HttpSessionSecurityContextRepository.java:110)
        at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:100)
        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
        at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
        at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:157)
        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
        at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214)
        at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177)
        at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347)
        at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:146)
        at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:81)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
        at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
        at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
        at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)
        at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
        at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:64)
        at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
        at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:131)
        at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
        at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
        at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
        at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)
        at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
        at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81)
at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138)
        at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135)
        at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
        at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
        at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272)
        at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81)
        at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104)
        at io.undertow.server.Connectors.executeRootHandler(Connectors.java:332)
        at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:748)```
  

[2018-02-27 08:06:57,834] [ERROR] [i.u.s.a.LoggingExceptionHandler] [24b62c4f-f833-4463-bdab-ada972beeb49|10.4.0.2|Null|UAE9] - UT005023: Exception handling request to /connect/login
org.redisson.client.RedisTimeoutException: Unable to send command: (HGETALL) with params: [redisson_spring_session:cb50538c-5244-4cb2-953d-77b733fe5814] after 3 retry attempts
        at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:562)
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
        at java.lang.Thread.run(Thread.java:748)

[2018-02-27 08:07:02,365] [ERROR] [o.r.c.SentinelConnectionManager$8] [Null|127.0.0.1|Null|Null] - Can't add slave: redis://57.190.12.71:6399
org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 31 from 32 were initialized. Redis server: /57.190.12.71:6399
        at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:138)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:512)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:425)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:122)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:307)
        at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:54)
        at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:277)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:512)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:505)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:484)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:425)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:122)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.client.RedisClient$2$1$2.run(RedisClient.java:225)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.channel.ConnectTimeoutException: connection timed out: /57.190.12.71:6399
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267)
        at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
        at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
        ... 6 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
018-02-28 19:56:31,534:io.netty.util.ResourceLeakDetector.reportTracedLeak(ResourceLeakDetector.java:311).LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This issue is to implement RBloomFilter with the RBatch batch commands. I do not see a getBloomFilter() option with the batch commands, it would be incredibly helpful to have.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonSessionManager uses "redisson_tomcat_session:"  as key prefix, so if multiple tomcat instances are using same "redis" server for storing session data. So need a mechanism to configure default key prefix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi! Thank you for your contribution. Could you change keySpace to keyPrefix?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While reading the Redisson tutorial and examples, I am under the impression that I need to always call redisson.getMap() in order to get the latest data from the cache . Right ?
I have a storm bolt which calls getmap(key) for millions of incoming records
Looks like millions of instances of RedisonMap being created , leading to pressure on GC
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After upgrading from 3.5.7 to 3.6.1 I can see a lot of warnings every 3 seconds:
2018-03-05 13:12:44.197  WARN 5 --- [isson-netty-1-2] o.r.c.SentinelConnectionManager          : Skipped slave up 10.2.42.12:6379 for master redis://?:0 differs from current redis://10.2.96.31:6379
I use SentinelServersConfig.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks a lot!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using RLock and seeing memory leak via org.redisson.client.handler.CommandPubSubDecoder

Retained objects delta between heap dumps taken apart

Around 10MB leak per day
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We configured a Redisson cached based on Jcr-107. Most operations are working fine but the getAndRemove implementation is throwing a null pointer exception. When removing the key with cache.remove("key"); instead, it works fine. We could do it in two operations but it will lose the free Atomicity.
Unfortunately, I'm not fluent in the LUA scripting used in order to propose a solution at the moment
javax.cache.CacheException: org.redisson.client.RedisException: Unexpected exception while processing command

	at org.redisson.jcache.JCache.evalWrite(JCache.java:342)
	at org.redisson.jcache.JCache.getAndRemoveValue(JCache.java:1445)
	at org.redisson.jcache.JCache.getAndRemove(JCache.java:1521)
	at com.jive.jci.cache.redisson.RedissonDefaultResourceIT.getAndRemoveTest(RedissonDefaultResourceIT.java:207)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.testcontainers.containers.FailureDetectingExternalResource$1.evaluate(FailureDetectingExternalResource.java:30)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:338)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:169)
	at org.redisson.RedissonObject.get(RedissonObject.java:74)
	at org.redisson.jcache.JCache.evalWrite(JCache.java:340)
	... 27 more
Caused by: java.lang.NullPointerException
	at org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:401)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:302)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:345)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:329)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1414)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:945)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Code that show the issue:
    String host = REDIS.getContainerIpAddress();
    int port = REDIS.getMappedPort(6379);
    MutableConfiguration<String, String> jcacheConfig = new MutableConfiguration<>();

    Config redissonConfig = new Config();
    redissonConfig.setCodec(new JsonJacksonCodec());

    redissonConfig.useSingleServer()
        .setAddress("redis://" + host + ":" + port);

    Configuration<String, String> jConfig = RedissonConfiguration.fromConfig(
        redissonConfig, jcacheConfig);


    CacheManager manager = Caching.getCachingProvider("org.redisson.jcache.JCachingProvider")
        .getCacheManager();

    try (Cache<String, String> cache = manager.createCache("strings", jConfig);)
    {
      cache.put("key", "value");
      String result = cache.getAndRemove("key");

      Assert.assertEquals("value", result);
      Assert.assertNull(cache.get("key"));

      cache.put("key", "value");
      cache.remove("key");
      Assert.assertNull(cache.get("key"));
    }
Dependencies:
Redisson: 3.6.1
Redis: Vanilla docker image version 4.0.8
JDK: 1.8.0_151
[INFO] +- org.ehcache:ehcache:jar:3.4.0:compile
[INFO] +- org.cache2k:cache2k-all:jar:1.0.1.Final:compile
[INFO] +- org.cache2k:cache2k-api:jar:1.0.1.Final:provided
[INFO] +- org.redisson:redisson:jar:3.6.1:provided
[INFO] |  +- io.netty:netty-common:jar:4.1.21.Final:provided
[INFO] |  +- io.netty:netty-codec:jar:4.1.21.Final:provided
[INFO] |  +- io.netty:netty-buffer:jar:4.1.21.Final:provided
[INFO] |  +- io.netty:netty-transport:jar:4.1.21.Final:provided
[INFO] |  |  \- io.netty:netty-resolver:jar:4.1.21.Final:provided
[INFO] |  +- io.netty:netty-resolver-dns:jar:4.1.21.Final:provided
[INFO] |  |  \- io.netty:netty-codec-dns:jar:4.1.21.Final:provided
[INFO] |  +- io.netty:netty-handler:jar:4.1.21.Final:provided
[INFO] |  +- io.projectreactor:reactor-core:jar:3.1.1.RELEASE:provided
[INFO] |  |  \- org.reactivestreams:reactive-streams:jar:1.0.1:provided
[INFO] |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.9.1:provided
[INFO] |  |  \- org.yaml:snakeyaml:jar:1.18:provided
[INFO] |  +- com.fasterxml.jackson.core:jackson-core:jar:2.9.1:compile
[INFO] |  +- net.bytebuddy:byte-buddy:jar:1.7.10:provided
[INFO] |  \- org.jodd:jodd-bean:jar:3.7.1:provided
[INFO] |     \- org.jodd:jodd-core:jar:3.7.1:provided
[INFO] +- javax.cache:cache-api:jar:1.0.0:compile
[INFO] +- org.projectlombok:lombok:jar:1.16.18:provided
[INFO] +- org.slf4j:slf4j-api:jar:1.7.25:compile
[INFO] +- org.slf4j:jcl-over-slf4j:jar:1.7.25:runtime
[INFO] +- org.slf4j:jul-to-slf4j:jar:1.7.25:runtime
[INFO] \- org.slf4j:log4j-over-slf4j:jar:1.7.25:runtime```
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
我希望redisson能提供一些连接效率和查询效率的统计功能，
并且把这些统计导出到jmx上面，
alibaba开源的druid连接池也有这个功能。
很多开发不清楚他们应该配什么参数，比如connectionPoolSize，
因为各家环境不同，没有1个统一的配置能包打天下
我想，如果提供这个功能，应该能够帮助开发 优化redisson参数配置、诊断线上问题。
@jackygurui
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Keeps redirecting me to this page.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When trying to implement a healthcheck for a Redis Cluster I'm using code similar to the below to get the list of nodes and ping them to see if they're up.
NodesGroup nodesGroup = redisson.getNodesGroup();
Collection<Node> allNodes = nodesGroup.getNodes();
for (Node n : allNodes) {
    n.ping();
}

If I redeploy a node and it gets a new IP, the new node is returned by redisson.getNodesGroup(); but the old one remains and we get an error:
Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://OLD.IP.ADD.RESS:6379], redirect=null, entry=null], connection: [id: 0x511b46ea, L:0.0.0.0/0.0.0.0:39616], command: (PING), params: []
If I failover a slave node then the slave node will be returned by redisson.getNodesGroup(); as a master (which is correct) but the original master will appear twice as both a master and a slave. If I then failover back to the original master, that node will be returned as a master twice and still as a slave.
When digging into the code it looks like this list/map lives in MasterSlaveConnectionManager as clientEntries which only gets cleared or removed from during a shutdown.
What I'd expect is for old or stale nodes to be cleared up from this list/map.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using lib version: 3.6.2
When trying to connect AWS Elastic cache(i.e rediss://clustercfg.xxx-test-sample.ttt.usw2.cache.amazonaws.com:6379) over ssl in cluster mode getting below exception:
io.netty.handler.codec.DecoderException: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
                at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
                at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
                at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
                at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
                at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
                at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1414)
                at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
                at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
                at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:945)
                at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:146)
                at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
                at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
                at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
                at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
                at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
                at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
                at java.lang.Thread.run(Thread.java:748)
Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
                at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1529)
                at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535)
                at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:813)
                at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
                at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
                at io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:292)
                at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1257)
                at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1159)
                at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1203)
                at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
                at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
                ... 16 common frames omitted
Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem
                at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
                at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1728)
                at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:330)
                at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:322)
                at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1614)
                at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
                at sun.security.ssl.Handshaker.processLoop(Handshaker.java:1052)
                at sun.security.ssl.Handshaker$1.run(Handshaker.java:992)
                at sun.security.ssl.Handshaker$1.run(Handshaker.java:989)
                at java.security.AccessController.doPrivileged(Native Method)
                at sun.security.ssl.Handshaker$DelegatedTask.run(Handshaker.java:1467)
                at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1417)
                at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1325)
                ... 20 common frames omitted
Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 10.82.141.245 found
                at sun.security.util.HostnameChecker.matchIP(HostnameChecker.java:168)
                at sun.security.util.HostnameChecker.match(HostnameChecker.java:94)
                at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:455)
                at sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:436)
                at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:252)
                at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:136)
                at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1601)

Not sure whats going wrong here, as per documents AWS manages the SSL certs so ideally this exception shouldn't have arrises.
I see this was closed as part of the issue #1135 . How ever single server mode with SSL is working fine. Could you please help me on this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using org.redisson.codec.SerializationCodec and   redisson 3.6.0
I have a child Rmap inside a parent Rmap.
Facing an Exception while fetching the stored Rmap

java.io.NotSerializableException: org.redisson.RedissonReference

Is Rmap serializable ?
How can I use a codec for fetching (get) and storing (put) Rmap from inside a parent Rmap ?
/////////////////
// onetime-initialization
RMap<String,Map<String,Long> parentMap = redisson.getMap("parentMap");
/////////////
if(parentMap.containsKey("child") == null) {
parentMap.put("child",redisson.getMapCache("childMapCache"));
}
RMap childCache = parentMap.get("child");
childCache.put("test1", 1000));
///////////////////////////////////
as long as I don't restart the application , it works fine
upon subsequent restart, it fails in the step -> parentMap.get("child");
[ERROR] Exception : Unexpected exception while processing command
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:322) ~[stormjar.jar:?]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:165) ~[stormjar.jar:?]
at org.redisson.RedissonObject.get(RedissonObject.java:69) ~[stormjar.jar:?]
at org.redisson.RedissonMap.put(RedissonMap.java:191) ~[stormjar.jar:?]
////////
Caused by: java.io.NotSerializableException: org.redisson.RedissonReference
at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) ~[?:1.8.0_72]
at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) ~[?:1.8.0_72]
at org.redisson.codec.SerializationCodec$2.encode(SerializationCodec.java:64) ~[stormjar.jar:?]
at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:103) ~[stormjar.jar:?]
at org.redisson.client.handler.CommandEncoder.encode(CommandEncoder.java:45) ~[stormjar.jar:?]
at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107) ~[stormjar.jar:?]
////////////
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
master-slave有bug
触发条件


redisson 版本选3.6.2


采用redisson推荐的默认配置，其中retryInterval=1500，负载均衡策略为RoundRobinLoadBalancer


readMode 设置为 SLAVE


slaveAddresses配至少1个，masterAddress也配上


JDK 版本为1.8x


bug表现
有时候get操作非常缓慢，需要1500毫秒以上（等1个retryInterval周期）才能完成
bug发生的原因


debug发现slaveConnectionPool会持有写连接池，它持有的写连接池为冻结状态


所以，在这段代码中，一旦负载均衡到写连接池，就会进入抛异常重试逻辑


重试获取连接至少要1500毫秒


//代码位置为org.redisson.connection.pool.ConnectionPool#get(org.redisson.client.protocol.RedisCommand<?>)

    public RFuture<T> get(RedisCommand<?> command) {
        for (int j = entries.size() - 1; j >= 0; j--) {
            final ClientConnectionsEntry entry = getEntry();
            if ((!entry.isFreezed() || 
                    (entry.getFreezeReason() == FreezeReason.SYSTEM && config.getReadMode() == ReadMode.MASTER_SLAVE)) && 
        		    tryAcquireConnection(entry)) {
                return acquireConnection(command, entry);
            }
        }
        
        List<InetSocketAddress> failedAttempts = new LinkedList<InetSocketAddress>();
        List<InetSocketAddress> freezed = new LinkedList<InetSocketAddress>();
        for (ClientConnectionsEntry entry : entries) {
            if (entry.isFreezed()) {
                freezed.add(entry.getClient().getAddr());
            } else {
                failedAttempts.add(entry.getClient().getAddr());
            }
        }

        StringBuilder errorMsg = new StringBuilder(getClass().getSimpleName() + " no available Redis entries. ");
        if (!freezed.isEmpty()) {
            errorMsg.append(" Disconnected hosts: " + freezed);
        }
        if (!failedAttempts.isEmpty()) {
            errorMsg.append(" Hosts disconnected due to `failedAttempts` limit reached: " + failedAttempts);
        }

        RedisConnectionException exception = new RedisConnectionException(errorMsg.toString());
        return RedissonPromise.newFailedFuture(exception);
    }
@jackygurui
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RListMultimapCache<String, RuleHit> test = redissonClient.getListMultimapCache("test");
test.put("key1",new RuleHit("value1","title1","info1"));
test.put("key1",new RuleHit("value2","title2","info2"));

System.out.println(test.getAll("key1").size());

test.removeAll("key1");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Getting error when calling readAllKeySet() operation.
org.redisson.client.RedisException: ERR Error running script (call to f_8770695dc269722cd5368a1e08ca936b4ccbb0b7): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0x0f03b43a, L:/192.168.1.66:57481 - R:/192.168.1.159:6379] command: (EVAL), params: [local s = redis.call('hgetall', KEYS[1]); local maxSize = tonumber(redis.call('hget', KEYS[5], 'max-..., 5, userDataCache, redisson__timeout__set:{userDataCache}, redisson__idle__set:{userDataCache}, redisson__map_cache__last_access__set:{userDataCache}, {userDataCache}:redisson_options, 1521112711284]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:241)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:138)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Apologize, if it's not the right forum to post my concern, kindly let me know so i will remove my post or you could redirect me right direction.
we have one doubt regarding how redisson internally storing data on redis cluster (here we are using AWS elastiCache), because the actual number of items is not the same as we have stored using our cache application.
as per logging it's showing proper Set and Get (the data from/to cache server) but the problem is with the actual item count (number of keys) on AWS, it's too lower tan expected,(e.g   even if we are storing 3K data the count is still showing ~20-30).
we are using spring @cachable annotation on top of redisson to achive the caching , also for cluster redis environment we are using AWS elastiCache . here are more details,
Spring redisson config:
<redisson:client name="redissonClient"> <redisson:cluster-servers idle-connection-timeout="1000"  ping-timeout="1000"  connect-timeout="10000" timeout="3000"  retry-attempts="3"  retry-interval="1500" reconnection-timeout="3000"  failed-attempts="3" subscriptions-per-connection="5" client-name="none" subscription-connection-minimum-idle-size="1" subscription-connection-pool-size="50" slave-connection-minimum-idle-size="10"  slave-connection-pool-size="64" master-connection-minimum-idle-size="10"  master-connection-pool-size="64" read-mode="SLAVE"  subscription-mode="SLAVE"  scan-interval="1000"> <redisson:node-address value="server_ip:port" /> <redisson:node-address value="server_ip:port" /> </redisson:cluster-servers> </redisson:client>
Java Code:
`@Cacheable(value="CustCacheName", keyGenerator="CustCacheKeyGen")
public Object custMethod(String param1, Object obj) {
...
}
cache mnager:
org.redisson.spring.cache.RedissonSpringCacheManager
`
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is it possible to execute the "Type" command and determine which datastructure should be used?
If not could this be Implemented?
Ref: https://redis.io/commands/type
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a sorted set of longs and try to check if a value is contained.
I use the LongCodec and get the following error:
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long
at java.lang.Long.compareTo(Long.java:54)
at org.redisson.RedissonSortedSet$NaturalComparator.compare(RedissonSortedSet.java:63)
at org.redisson.RedissonSortedSet.binarySearch(RedissonSortedSet.java:432)
at org.redisson.RedissonSortedSet.contains(RedissonSortedSet.java:197)
I debugged it and also saw that a RedissonList is created in the constructor, but the Codec is not supplied to it. May has something to do with it...
The Values in the list are typed as Integer, which they shouldn't be
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi @mrniko
 redisson use sentinel configure for pub/sub successful，but RTopic publish method return 0；current use version:2.7.0，I have try use last stable version for 2.11.3，this problem still reappearing.
 spring.xml:
 `<bean id="redissonConfig" class="com.cloudyoung.common.tools.redis.RedissonConfig" init-method="init">
    <constructor-arg index="0" name="model" value="sentinel" type="java.lang.String"/>
    <constructor-arg index="1" name="dataBase" value="${wx.redis.database.index}" type="int"/>
    <constructor-arg index="2" name="masterName" value="${redis.sentinel.masterName}" type="java.lang.String"/>
    <constructor-arg index="3" name="password" value="${redis.password}" type="java.lang.String"/>
    <constructor-arg index="4" name="nodes" type="java.util.Set">
        <set>
            <value>${redis.sentinel1}</value>
            <value>${redis.sentinel2}</value>
            <value>${redis.sentinel3}</value>
        </set>
    </constructor-arg>
 </bean>
  
 <bean id="redissonTemplete" class="com.cloudyoung.common.tools.redis.RedissonTemplete">
    <property name="redissonConfig" ref="redissonConfig" />  
 </bean>`

   RedissonConfig.Java code:
   `public class RedissonConfig {

private final Config config = new Config();
private RedissonClient redisson;

//common configure
private String model;
private int dataBase = 0;
private String password;
private int idleConnectionTimeout = 10000;//连接空闲超时，单位：毫秒
private int connectTimeout = 10000;//连接超时，单位：毫秒

//single special configure
private String singleNodes;//single地址
private int connectionPoolSize = 64;//连接池大小

//sentinel special configure
private String masterName;//masterName
private Set<String> nodes;//sentinel地址集

//master-slave special configure
private String masterNodes;//主节点地址
private Set<String> slaveNodes;//从节点地址集

//cluster special configure
private int scanInterval;//集群状态扫描间隔时间，单位是毫秒
private Set<String> clusterNodes;//集群节点地址集

//sentinel、 master-slave、 cluster common configure
private int slaveConnectionMinimumIdleSize = 10;//从节点最小空闲连接数
private int slaveConnectionPoolSize = 64;//从节点连接池大小
private int masterConnectionMinimumIdleSize = 10;//主节点最小空闲连接数
private int masterConnectionPoolSize = 64;//主节点连接池大小

/**
 * single model construct
 * @param model
 * @param dataBase
 * @param password
 * @param singleNodes
 */
public RedissonConfig(String model, int dataBase, String password, String singleNodes) {
    super();
    this.model = model;
    this.dataBase = dataBase;
    this.password = password;
    this.singleNodes = singleNodes;
}

/**
 * sentinel model construct
 * @param model
 * @param dataBase
 * @param masterName
 * @param password
 * @param nodes
 */
public RedissonConfig(String model, int dataBase, String masterName, String password, Set<String> nodes) {
    super();
    this.model = model;
    this.dataBase = dataBase;
    this.masterName = masterName;
    this.password = password;
    this.nodes = nodes;
}

/**
 * sentinel model construct, include pool and timeout properties
 * @param model
 * @param dataBase
 * @param masterName
 * @param password
 * @param nodes
 * @param slaveConnectionMinimumIdleSize
 * @param slaveConnectionPoolSize
 * @param masterConnectionMinimumIdleSize
 * @param masterConnectionPoolSize
 * @param idleConnectionTimeout
 * @param connectTimeout
 */
public RedissonConfig(String model, int dataBase, String masterName, String password, Set<String> nodes, 
        int slaveConnectionMinimumIdleSize, int slaveConnectionPoolSize, 
        int masterConnectionMinimumIdleSize, int masterConnectionPoolSize, int idleConnectionTimeout, int connectTimeout) {
    super();
    this.model = model;
    this.dataBase = dataBase;
    this.masterName = masterName;
    this.password = password;
    this.nodes = nodes;
    this.slaveConnectionMinimumIdleSize = slaveConnectionMinimumIdleSize;
    this.slaveConnectionPoolSize = slaveConnectionPoolSize;
    this.masterConnectionMinimumIdleSize = masterConnectionMinimumIdleSize;
    this.masterConnectionPoolSize = masterConnectionPoolSize;
    this.idleConnectionTimeout = idleConnectionTimeout;
    this.connectTimeout = connectTimeout;
}

/**
 * master-slave construct
 * @param model
 * @param dataBase
 * @param password
 * @param slaveNodes
 * @param masterNodes
 */
public RedissonConfig(String model, int dataBase, String password, Set<String> slaveNodes, String masterNodes) {
    super();
    this.model = model;
    this.dataBase = dataBase;
    this.password = password;
    this.masterNodes = masterNodes;
    this.slaveNodes = slaveNodes;
}

/**
 * cluster construct
 * @param model
 * @param password
 * @param scanInterval
 * @param clusterNodes
 */
public RedissonConfig(String model, String password, int scanInterval, Set<String> clusterNodes) {
    super();
    this.model = model;
    this.password = password;
    this.scanInterval = scanInterval;
    this.clusterNodes = clusterNodes;
}

public void init(){
    if(StringUtils.isBlank(model)){
        throw new IllegalArgumentException("RedissonConfig init method params with:[model] can not be empty......!");
    }
    if(RedisArchModelEnum.SINGLE.getModel().equals(model)){
        this.initSingleRedissonClient();
    }else if(RedisArchModelEnum.MASTERSLAVE.getModel().equals(model)){
        this.initMasterSlaveRedissonClient();
    }else if(RedisArchModelEnum.SENTINEL.getModel().equals(model)){
        this.initSentinelRedissonClient();
    }else if(RedisArchModelEnum.CLUSTER.getModel().equals(model)){
        this.initClusterRedissonClient();
    }else{
        throw new IllegalArgumentException("RedissonConfig init method params with:[model] invalid......");
    }
}

/**
 * Description: init single redisson client
 * @Version1.0 2017年8月24日 上午10:32:39 by 代鹏（daipeng.456@gmail.com）创建
 */
private void initSingleRedissonClient(){
    if(StringUtils.isBlank(singleNodes)){
        throw new IllegalArgumentException("redis install mode choice single, must be set singleNodes params......!");
    }
    config.useSingleServer()
    .setPassword(StringUtils.isNotBlank(password)?password:null)
    .setAddress(singleNodes)
    .setDatabase(dataBase)
    .setIdleConnectionTimeout(idleConnectionTimeout)
    .setConnectTimeout(connectTimeout)
    .setConnectionPoolSize(connectionPoolSize);
    redisson = Redisson.create(config);
}

/**
 * Description: init master slave redisson client
 * @Version1.0 2017年8月24日 上午10:33:02 by 代鹏（daipeng.456@gmail.com）创建
 */
private void initMasterSlaveRedissonClient(){
    if(StringUtils.isBlank(masterNodes)){
        throw new IllegalArgumentException("redis install mode choice master-slave, must be set masterNodes params......!");
    }
    if(null == slaveNodes || slaveNodes.isEmpty()){
        throw new IllegalArgumentException("redis install mode choice master-slave, must be set slaveNodes params......!");
    }
    config.useMasterSlaveServers()
    .setPassword(StringUtils.isNotBlank(password)?password:null)
    .setDatabase(dataBase)
    .setMasterAddress(masterNodes)
    .addSlaveAddress(slaveNodes.toArray(new String[]{}))
    .setIdleConnectionTimeout(idleConnectionTimeout)
    .setConnectTimeout(connectTimeout)
    .setMasterConnectionPoolSize(masterConnectionPoolSize)
    .setSlaveConnectionPoolSize(slaveConnectionPoolSize)
    .setMasterConnectionMinimumIdleSize(masterConnectionMinimumIdleSize)
    .setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize);
    redisson = Redisson.create(config);
}

/**
 * Description: init sentinel redisson client
 * @Version1.0 2017年8月24日 上午10:33:15 by 代鹏（daipeng.456@gmail.com）创建
 */
private void initSentinelRedissonClient(){
    if(null == nodes || nodes.isEmpty()){
        throw new IllegalArgumentException("redis install mode choice sentinel, must be set sentinelAddress params......!");
    }
    if(StringUtils.isBlank(masterName)){
        throw new IllegalArgumentException("redis install mode choice sentinel, must be set masterName params......!");
    }
    
    config.useSentinelServers()
    .setMasterName(masterName)
    .setPassword(StringUtils.isNotBlank(password)?password:null)
    .setDatabase(dataBase)
    .setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize)
    .setSlaveConnectionPoolSize(slaveConnectionPoolSize)
    .setMasterConnectionMinimumIdleSize(masterConnectionMinimumIdleSize)
    .setMasterConnectionPoolSize(masterConnectionPoolSize)
    .setIdleConnectionTimeout(idleConnectionTimeout)
    .setConnectTimeout(connectTimeout)
    .addSentinelAddress(nodes.toArray(new String[]{}));
    redisson = Redisson.create(config);
}

/**
 * Description: init cluster redisson client
 * @Version1.0 2017年8月24日 上午10:33:30 by 代鹏（daipeng.456@gmail.com）创建
 */
private void initClusterRedissonClient(){
    if(null == clusterNodes || clusterNodes.isEmpty()){
        throw new IllegalArgumentException("redis install mode choice cluster, must be set clusterNodes params......!");
    }
    config.useClusterServers()
    .setScanInterval(scanInterval)
    .addNodeAddress(clusterNodes.toArray(new String[]{}))
    .setPassword(password)
    .setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize)
    .setSlaveConnectionPoolSize(slaveConnectionPoolSize)
    .setMasterConnectionMinimumIdleSize(masterConnectionMinimumIdleSize)
    .setMasterConnectionPoolSize(masterConnectionPoolSize)
    .setIdleConnectionTimeout(idleConnectionTimeout)
    .setConnectTimeout(connectTimeout);
    redisson = Redisson.create(config);
}

public RedissonClient getRedissonInstance(){
    return redisson;
}

 }`

     RedissonTemplete.java code:
    `public class RedissonTemplete<V> {

private RedissonConfig redissonConfig;

private RedissonClient redisson;

public RedissonTemplete<V> setRedissonConfig(RedissonConfig config) {
    this.redissonConfig = config;
    this.redisson = redissonConfig.getRedissonInstance();
    return this;
}

/**
 * Description: 获取RTopic
 * @Version1.0 2018年3月8日 下午5:28:37 by 代鹏（daipeng.456@gmail.com）创建
 * @param objectName
 * @return
 */
private <M> RTopic<M> getRTopic(String objectName) {
    return redisson.getTopic(objectName);
}

// -------------------------Pub/Sub Start-----------------------//
public <M> int subscribe (String objectName, MessageListener<M> msgListener) {
    RTopic<M> rTopic = this.getRTopic(objectName);
    return rTopic.addListener(msgListener);
}

public <M> void unSubscribe (String objectName, int listenerId) {
    RTopic<M> rTopic = this.getRTopic(objectName);
    rTopic.removeListener(listenerId);
}

public <M> long publish(String objectName, M msg) {
    RTopic<M> rTopic = this.getRTopic(objectName);
    return rTopic.publish(msg);
}
// -------------------------Pub/Sub End-------------------------//    
 }`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@Configuration
public class RedissonConfig {

    @Value("${spring.redis.cluster.nodes}")
    String nodes;

    @Bean(destroyMethod = "shutdown")
    RedissonClient init() {
        Config config = new Config();
        config.setCodec(StringCodec.INSTANCE);
        ClusterServersConfig clusterConfig = config.useClusterServers();
        for (String node : nodes.split(",")) {
            clusterConfig.addNodeAddress("redis://" + node);
        }
        return Redisson.create(config);
    }

}

RMapCache<String, String> map = redissonClient.getMapCache("testttl");
map.fastPut("k", "值", 1, TimeUnit.MINUTES);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I have seen my redis password in the TRACE log.
Example:
[2018-03-20 12:58:13,996] [TRACE] [o.r.c.h.CommandEncoder] - channel: [id: 0xec5fae85, L:/1.2.3.4:46592 - R:1.2.3.4/1.2.3.4:6399] message: *2
$4
AUTH
$16
MyPassword

In general this is one of security requirements for a development: do not print any passwords in the logs.
See OWASP Error Handling and Logging Best Practice 119
I suggest to obfuscate the logged body of the redis command "AUTH" in the class CommandEncoder
Thanks,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey!
When I send a batch with multiple .publish(msg)  commands to redis,
does redis send these messages as a "batch/pipeline" back to the subscribers
in ONE network connection so that redisson handles them all at once?
Regards, RoboFlax
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixed in 6521683
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<!-- https://mvnrepository.com/artifact/org.redisson/redisson -->
	<dependency>
	    <groupId>org.redisson</groupId>
	    <artifactId>redisson</artifactId>
	    <version>3.6.3</version>
	</dependency>

redisson-jcache.json
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"reconnectionTimeout":3000,
"failedAttempts":3,
"password":"secret",
"subscriptionsPerConnection":5,
"clientName":null,
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":32,
"connectionPoolSize":64,
"database":0,
"dnsMonitoring":false,
"dnsMonitoringInterval":5000
},
"threads":0,
"nettyThreads":0,
"codec":{
"class":"org.redisson.codec.JsonJacksonCodec"
},
"transportMode":"NIO"
}
I have also tried this with multiple serialization codecs and the result is always the same. We are attempting to convert our EHCache JCache implementation to Redis. Calling JCache.get with a key works but JCache.getAll with a set of keys fails every time. This is essential to a smooth transition for us as we don't want to redesign our application at the same time we are switching technologies. We would like to avoid using native libraries if at all possible.
io.netty.util.IllegalReferenceCountException: refCnt: 0
at io.netty.buffer.AbstractByteBuf.ensureAccessible(AbstractByteBuf.java:1408)
at io.netty.buffer.AbstractByteBuf.checkIndex(AbstractByteBuf.java:1347)
at io.netty.buffer.AbstractByteBuf.getInt(AbstractByteBuf.java:415)
at io.netty.buffer.ByteBufUtil.hashCode(ByteBufUtil.java:162)
at io.netty.buffer.AbstractByteBuf.hashCode(AbstractByteBuf.java:1306)
at java.util.HashMap.hash(HashMap.java:339)
at java.util.HashMap.put(HashMap.java:612)
at org.redisson.jcache.JCache.getAll(JCache.java:642)
Thank you, any help would be appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422)
at io.netty.handler.codec.ReplayingDecoder.channelInputClosed(ReplayingDecoder.java:329)
at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:359)
at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:342)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
at io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)
at org.redisson.client.handler.CommandsQueue.channelInactive(CommandsQueue.java:83)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
at org.redisson.client.handler.ConnectionWatchdog.channelInactive(ConnectionWatchdog.java:83)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
at io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1409)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:927)
at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:822)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:204)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:119)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson throw follow exception, while start app everytime.
redisson version:  3.6.3
redis version:4.0.8
18:56:00.262 [nioEventLoopGroup-2-1] DEBUG org.redisson.connection.ClientConnectionsEntry - new connection created: RedisConnection@752529858 [redisClient=[addr=redis://172.16.4.115:6379], channel=[id: 0x8e14d761, L:/172.16.4.109:61553 - R:/172.16.4.115:6379]]
18:56:00.262 [nioEventLoopGroup-2-1] INFO org.redisson.connection.pool.MasterConnectionPool - 32 connections initialized for /172.16.4.115:6379
18:56:05.779 [nioEventLoopGroup-2-1] ERROR org.redisson.connection.SentinelConnectionManager - Can't execute SENTINEL commands on /172.16.4.115:26379
org.redisson.client.RedisTimeoutException: Command execution timeout for /172.16.4.115:26379
at org.redisson.client.RedisConnection$2.run(RedisConnection.java:212)
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found out that when using skipResult() + execute() in combination it throws a RedisException.
RBatch batch = redisson.createBatch();
        RTopicAsync<Object> topic = batch.getTopic( "topic" );
        topic.publishAsync( "an object" );
        batch.skipResult().execute(); // here
I tried it without skipResult() and everything was fine.
So all except .execute() (or the depricated .executeSkipResult() ) are working with .skipResult():
batch.skipResult().executeAsync();
batch.skipResult().atomic();
batch.executeSkipResultAsync(); // depricated

Exception:
org.redisson.client.RedisException: ERR Syntax error, try CLIENT (LIST | KILL ip:port | GETNAME | SETNAME connection-name). channel: [id: 0xdfb7c3aa, L:/***PRIVATE***:21173 - R:/***PRIVATE***:6383] command: (CLIENT REPLY), params: [ON]

	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:293)
	at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:199)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:119)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1414)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:945)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:146)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
项目使用redisson的单机模式，现在要升级为集群模式，搭建好redis服务后启动项目出现如下错误：
2018-03-23 15:22:25,978 [main] INFO  org.nutz.log.Log$info.call(?:?)
 --- Redis Server:192.168.28.60:6379,192.168.28.60:6380,192.168.28.60:6381
2018-03-23 15:22:25,979 [main] INFO  org.nutz.log.Log$info.call(?:?)
 --- Redis Server:192.168.28.60:6379
2018-03-23 15:22:25,992 [main] INFO  org.nutz.log.Log$info.call(?:?)
 --- Redis Server:192.168.28.60:6380
2018-03-23 15:22:25,993 [main] INFO  org.nutz.log.Log$info.call(?:?)
 --- Redis Server:192.168.28.60:6381
2018-03-23 15:24:49,894 [main] WARN  org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:94)
 --- port out of range:-1
2018-03-23 15:26:10,913 [main] WARN  org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:94)
 --- port out of range:-1
2018-03-23 15:26:19,812 [main] ERROR org.nutz.log.Log$error$0.call(?:?)
 --- Can't connect to servers!
org.redisson.client.RedisConnectionException: Can't connect to servers!
	at org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:100)
	at org.redisson.Redisson.<init>(Redisson.java:108)
	at org.redisson.Redisson.create(Redisson.java:158)
	at com.asiainfo.mm.biz.util.RedissonUtil.create(RedissonUtil.groovy:17)
	at com.asiainfo.mm.biz.util.RedissonUtil$create.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at com.asiainfo.mm.MvcSetup.init(MvcSetup.groovy:61)
	at org.nutz.mvc.impl.NutLoading.evalSetup(NutLoading.java:256)
	at org.nutz.mvc.impl.NutLoading.load(NutLoading.java:115)
	at org.nutz.mvc.ActionHandler.<init>(ActionHandler.java:19)
	at org.nutz.mvc.NutFilter.init(NutFilter.java:78)
	at org.eclipse.jetty.servlet.FilterHolder.initialize(FilterHolder.java:137)
	at org.eclipse.jetty.servlet.ServletHandler.initialize(ServletHandler.java:831)
	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:300)
	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1341)
	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1334)
	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:744)
	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:497)
	at org.eclipse.jetty.maven.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:281)
	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114)
	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:60)
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:154)
	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114)
	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:60)
	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132)
	at org.eclipse.jetty.server.Server.start(Server.java:357)
	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114)
	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:60)
	at org.eclipse.jetty.server.Server.doStart(Server.java:324)
	at org.eclipse.jetty.maven.plugin.JettyServer.doStart(JettyServer.java:68)
	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)
	at org.eclipse.jetty.maven.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:564)
	at org.eclipse.jetty.maven.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:360)
	at org.eclipse.jetty.maven.plugin.JettyRunMojo.execute(JettyRunMojo.java:168)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)
	at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:47)


程序代码为如下：
log.info("初始化Redis Client")

                Config redisConfig = new Config()
                def serverConfig = redisConfig.useClusterServers()

                String hosts = DictItemUtil.REDIS_CONFIG.value()

                log.info("Redis Server:" + hosts)
                for (String host : hosts.split(",")) {
                    log.info("Redis Server:" + host)
                    serverConfig.addNodeAddress(host)
                }
//                def serverConfig = redisConfig.useSingleServer()
//
//                String hosts = DictItemUtil.REDIS_CONFIG.value()

//                serverConfig.setAddress("192.168.28.60:6379")

                RedissonUtil.create(redisConfig)

单机模式使用192.168.28.60:6379可以成功，现在使用 集群addNodeAddress增加三台实例（192.168.28.60:6379  192.168.28.60:6380  192.168.28.60:6381）时就出现如上错误，字面理解是端口有问题，但是6379 这样的端口应该没问题吧，请大神赐教
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
请问redisson-3.4.4开始到最新的版本
putAll方法里面调用的putAllOperationAsync方法，里面会对传入的map的value值进行非空检查，
以致于在==null的时候抛出map value can't be null
我的测试代码
RMap<String, Object> rMap = redissonClient.getMap("test-365-hash");
Map<String, Object> map = new HashMap();
map.put("aaa-1", "AAA 1");
map.put("aaa-2", null);
rMap.putAll(map);
使用在redisson-3.4.4 + 将会抛出异常
如果使用redisson-3.2.0这样的包里面没有对 value进行非空检测
那么测试代码是可以正常执行的
请教一下各位前辈，如果我想用新的版本，也想正常执行上面的测试代码，该如何做？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
哪个codec支持LocalDateTime/LocalDate？
有如何自定义Codec的文档吗？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
i'm using embedded elasticsearch in my application with EHCache and it all works fine. Now I want to configure redisson and I get this exception during startup:
Caused by: java.lang.IllegalStateException: availableProcessors is already set to [8], rejecting [8]
	at io.netty.util.NettyRuntime$AvailableProcessorsHolder.setAvailableProcessors(NettyRuntime.java:51)
	at io.netty.util.NettyRuntime.setAvailableProcessors(NettyRuntime.java:87)
	at org.elasticsearch.transport.netty4.Netty4Utils.setAvailableProcessors(Netty4Utils.java:85)
	at org.elasticsearch.http.netty4.Netty4HttpServerTransport.<init>(Netty4HttpServerTransport.java:219)
	at org.elasticsearch.transport.Netty4Plugin.lambda$getHttpTransports$1(Netty4Plugin.java:105)
	at org.elasticsearch.node.Node.<init>(Node.java:438)
	at com.nemesis.platform.module.search.elasticsearch.config.ElasticsearchAutoConfiguration$1.<init>(ElasticsearchAutoConfiguration.java:129)

Looks like redisson has already initialized a netty runtime and elasticsearch is trying to do the same so it blows with this error.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I have my app working perfectly fine with EHCache. Now I want to migrate my app to use redisson, however I get the following exception:
Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `org.javamoney.moneta.internal.JDKCurrencyAdapter` (no Creators, like default construct, exist): cannot deserialize from Object value (no delegate- or property-based Creator)
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 93] (through reference chain: java.util.ArrayList[0])
	at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)
	at com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1451)
	at com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1027)
	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1290)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:326)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:194)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:161)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:130)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:97)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:193)
	at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712)
	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:288)
	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)
	at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)
	at com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer.deserialize(StdDelegatingDeserializer.java:169)
	at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:116)
	at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:53)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:191)
	at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712)
	at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4001)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3058)
	at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:75)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:283)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1414)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:945)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:146)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
We are using the redisson-tomcat-8 in a Webserver containing more than a 100 apps. In the tomcat start up we get the following errors in some apps:
ERROR io.netty.util.HashedWheelTimer - You are creating too many HashedWheelTimer instances. HashedWheelTimer is a shared resource that must be reused across the JVM,so that only a few 

How can we reuse the HashedWheelTimer in order to avoid this error (Many customers have lost their session while browsing, but we are not sure if that is the cause of the problem).
We are using Redisson 3.6.2 with redisson-tomcat-8.
This is the tomcat context.xml:
<!-- The contents of this file will be loaded for each web application -->
<Context>

    <!-- Default set of monitored resources. If one of these changes, the    -->
    <!-- web application will be reloaded.                                   -->
    <WatchedResource>WEB-INF/web.xml</WatchedResource>
    <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>

    <!-- Uncomment this to disable session persistence across Tomcat restarts -->
    <!-- <Manager pathname="" /> -->
    <Manager className="org.redisson.tomcat.RedissonSessionManager"
          configPath="${catalina.base}/conf/redisson.json" readMode="REDIS" updateMode="DEFAULT"/>

    <!-- Uncomment this to enable Comet connection tacking (provides events
         on session expiration as well as webapp lifecycle) -->
    <!--
    <Valve className="org.apache.catalina.valves.CometConnectionManagerValve" />
    -->
</Context>
And the redisson.json:
{
   "singleServerConfig":{
      "idleConnectionTimeout":10000,
      "pingTimeout":1000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "reconnectionTimeout":3000,
      "failedAttempts":3,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "address": "redis://redis-endpoint.com:6379",
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "connectionMinimumIdleSize":10,
      "connectionPoolSize":64,
      "database":0,
      "dnsMonitoring":false,
      "dnsMonitoringInterval":5000
   },
   "threads":0,
   "nettyThreads":0,
   "codec":null,
   "useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are trying to upgrade our redisson client to latest version by using "After_request" property. However, there is an DecoderException was thrown during tomcat failover testing.
Do you have any recent codec code change may link to this error? Currently we are using "SerializationCodec".
[redisson-netty-1-4] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.io.InvalidClassException: com.sb.cribbage.model.CribbageUser; local class incompatible: stream classdesc serialVersionUID = -8168868324796443460, local class serialVersionUID = -586601342026738621
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:422)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1414)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:945)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:146)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.io.InvalidClassException: com.sb.cribbage.model.CribbageUser; local class incompatible: stream classdesc serialVersionUID = -8168868324796443460, local class serialVersionUID = -586601342026738621
at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:621)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1623)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1518)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1623)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1518)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1774)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:50)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:309)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:351)
at org.redisson.client.handler.CommandDecoder.decodeFromCheckpoint(CommandDecoder.java:176)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367)
... 28 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonRemoteService.java
protected RFuture removeAsync(String requestQueueName, RequestId taskId) {
return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
"redis.call('lrem', KEYS[1], 1, ARGV[1]); "
+ "redis.call('hset', KEYS[2], ARGV[1]);"   --may be "hdel"
+ "return 1;",
Arrays.asList(requestQueueName, requestQueueName + ":tasks"),
taskId.toString());
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RMap<String, SomeObject> map = redisson.getMap("anyMap");
SomeObject prevObject = map.put("123", new SomeObject());
prevObject is null!!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[ERROR] MSG - o.r.c.SentinelConnectionManager Can't update cluster state
Hi,
I've RedissonClient connected to Redis Sentinels(Redis 4). Redis commands work fine, but throws the above error. Couldn't figure out the cause of the issue
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Java 10 looks currently not supported because highMask and lowMask private methods are removed from URI class what is referenced here.
Caused by: java.io.IOException: java.lang.NoSuchMethodException: java.net.URI.lowMask(java.lang.String)
	at org.redisson.config.ConfigSupport.patchUriField(ConfigSupport.java:147)
	at org.redisson.config.ConfigSupport.patchUriObject(ConfigSupport.java:127)
	at org.redisson.config.ConfigSupport.toJSON(ConfigSupport.java:183)
	at org.redisson.config.Config.toJSON(Config.java:659)
	at org.hibernate.cache.redis.client.RedisClient.<init>(RedisClient.java:62)
	at org.hibernate.cache.redis.client.RedisClient.<init>(RedisClient.java:57)
	at io.luna.lib.postgres.LunaRedisRegionFactory.createRedisClient(LunaRedisRegionFactory.java:49)
	at org.hibernate.cache.redis.hibernate52.SingletonRedisRegionFactory.start(SingletonRedisRegionFactory.java:55)
	... 40 common frames omitted
Caused by: java.lang.NoSuchMethodException: java.net.URI.lowMask(java.lang.String)
	at java.base/java.lang.Class.getDeclaredMethod(Class.java:2434)
	at org.redisson.config.ConfigSupport.patchUriField(ConfigSupport.java:134)
	... 47 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2018-04-02 14:55:17,694 ERROR [org.redisson.RedissonRemoteService] - Can't process the remote service request.
org.redisson.client.RedisTimeoutException: Unable to send command: (BLPOP) with params: [{redisson_rs:com.juno.java.iot.standard.service.account.EventChargeService}, 0] after 3 retry attempts
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:562)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466)
I run redisson by spring,and it works well,But when I register remote service,it does not work.Redis connection is ok.I do not know why.
redisson version is 2.11.1
I find that it will happened when worksAmout is a big number or you register a large amount of services
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How is "contains" method (remove, etc) is implemented? I overrided in my object methods "equals" and "hashcode", simplified, they look like this:
class Test 
private String id;
private String value;

boolean equals(Object o) { return this.id = o.id}
int hashcode = Objects.hash(super.hashCode(), id);

the point is two classes are equal when their id is equal.
But classes with different values (and same id) are not considered to be equal, when I use methods "contains" or "remove" in RScoredSet.
Is it the desired behavior?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I run redisson,there are some error logs:
2018-04-03 17:23:09,495 [redisson-netty-4-8] ERROR [io.netty.util.ResourceLeakDetector] - LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html
for more information.
Recent access records:
redisson version is 2.11.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson版本：3.6.4
JDK版本：1.8
RedissonClient redisson = Redisson.create();

RAtomicLong atomicLong = redisson.getAtomicLong("myLong");
atomicLong.set(3);
System.out.println(atomicLong.get());
atomicLong.expireAt(Date.from(ZonedDateTime.now().plusSeconds(10).toInstant()));
System.out.println(atomicLong.get());
for (int i = 0; i < 3; i++) {
        System.out.println(atomicLong.decrementAndGet());
}

redisson.shutdown();
上面这段代码执行的结果是：
3
0
-1
-2
-3

可以看出expireAt之后缓存的值变成了0
另外测试过atomicLong.expire(10, TimeUnit.SECONDS);是正常的。。
大佬求解决。。(:зゝ∠)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Implement Transaction API for Bucket, Set, SetCache, Map, MapCache, LocalCachedMap objects with commit/rollback methods and READ_COMMITTED isolation level.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RSets returned by get() cannot be used to populate RSetMultimap. Multimap key and size information is not managed properly despite get() returning populated sets. See this example:
    RedissonClient redisson = Redisson.create();

    // multimap populated via put() works
    RSetMultimap<String, Integer> multimap0 = redisson.getSetMultimap("myMultimap0");
    multimap0.put("1", 1);
    multimap0.put("1", 2);
    multimap0.put("1", 3);
    multimap0.put("2", 5);
    multimap0.put("2", 6);
    multimap0.put("4", 7);

    logger.error(">>>>>>>>>>>>>> multimap0 - keyset: "+multimap0.keySet());
    logger.error(">>>>>>>>>>>>>> multimap0 - keysize: "+multimap0.keySize());
    logger.error(">>>>>>>>>>>>>> multimap0 - 1: "+multimap0.get("1"));
    logger.error(">>>>>>>>>>>>>> multimap0 - 2: "+multimap0.get("2"));
    logger.error(">>>>>>>>>>>>>> multimap0 - 4: "+multimap0.get("4"));

    // multimap populated via get() does not work
    RSetMultimap<String, Integer> multimap1 = redisson.getSetMultimap("myMultimap1");
    Set<Integer> one = multimap1.get("1");
    Set<Integer> two = multimap1.get("2");
    Set<Integer> four = multimap1.get("4");
    one.add(1);
    one.add(2);
    one.add(3);
    two.add(5);
    two.add(6);
    four.add(7);

    logger.error(">>>>>>>>>>>>>> multimap1 - keyset: "+multimap1.keySet());
    logger.error(">>>>>>>>>>>>>> multimap1 - keysize: "+multimap1.keySize());
    logger.error(">>>>>>>>>>>>>> multimap1 - 1: "+multimap1.get("1"));
    logger.error(">>>>>>>>>>>>>> multimap1 - 2: "+multimap1.get("2"));
    logger.error(">>>>>>>>>>>>>> multimap1 - 4: "+multimap1.get("4"));

    multimap0.delete();
    multimap1.delete();

    redisson.shutdown();

This generates the following output:
    [main] ERROR - >>>>>>>>>>>>>> multimap0 - keyset: [1, 2, 4]
    [main] ERROR - >>>>>>>>>>>>>> multimap0 - keysize: 3
    [main] ERROR - >>>>>>>>>>>>>> multimap0 - 1: [1, 2, 3]
    [main] ERROR - >>>>>>>>>>>>>> multimap0 - 2: [5, 6]
    [main] ERROR - >>>>>>>>>>>>>> multimap0 - 4: [7]
    [main] ERROR - >>>>>>>>>>>>>> multimap1 - keyset: []
    [main] ERROR - >>>>>>>>>>>>>> multimap1 - keysize: 0
    [main] ERROR - >>>>>>>>>>>>>> multimap1 - 1: [1, 2, 3]
    [main] ERROR - >>>>>>>>>>>>>> multimap1 - 2: [5, 6]
    [main] ERROR - >>>>>>>>>>>>>> multimap1 - 4: [7]

Here, multimap1 keyset and keysize are not initialized. Javadoc for the get() method claims:
"Changes to the returned collection will update the underlying multimap, and vice versa."
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
No exceptions
Actual behavior
Subscribe timeout: (41000ms)org.redisson.client.RedisTimeoutException: Subscribe timeout: (41000ms)
	at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:130)
	at org.redisson.RedissonLock.lockInterruptibly(RedissonLock.java:122)
	at org.redisson.RedissonLock.lock(RedissonLock.java:100)
	at com.zeppelinen.carsharing.dataprocessor.registry.manager.locker.RegistryLocker.lock(RegistryLocker.java:39)
	at com.zeppelinen.carsharing.dataprocessor.registry.manager.lifecycle.LifeCycleManager.getRentIdAttachedToCar(LifeCycleManager.java:195)
	at com.zeppelinen.carsharing.dataprocessor.workunit.core.carserver.service.impl.TrackMessageProcessorImpl.processTrackMessage(TrackMessageProcessorImpl.java:60)
	at com.zeppelinen.carsharing.dataprocessor.workunit.periphery.io.carserver.listener.TrackMessageListener.receiveTrackData(TrackMessageListener.java:55)
	at sun.reflect.GeneratedMethodAccessor61.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:181)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:114)
	at org.springframework.amqp.rabbit.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:51)
	at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:182)
	at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.onMessage(MessagingMessageListenerAdapter.java:120)
	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:1414)
	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.actualInvokeListener(AbstractMessageListenerContainer.java:1337)
	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:1324)
	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:1303)
	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:785)
	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:769)
	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$700(SimpleMessageListenerContainer.java:77)
	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1010)
	at java.lang.Thread.run(Thread.java:748)

Steps to reproduce or test case
Redis version
4.0.6
Redis Replication
role:slave
master_host:10.233.80.95
master_port:6379
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:4327166295
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:610cea4395c4ccb2f4d42620e5b40be23f42a28f
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:4327166295
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:4326117720
repl_backlog_histlen:1048576
Redisson version
3.7.0
Redisson configuration
Sentinel configuration.
setRetryAttempts  (7)
setRetryInterval (3000 ms)
setSubscriptionConnectionPoolSize (200)
setSubscriptionConnectionMinimumIdleSize (10)
setSlaveConnectionPoolSize(200)
setMasterConnectionPoolSize(200)
other: default
Why is I keep getting these subscribe timeouts? After restarting service it works allright for, like, 24 hours, then I get a lot of subscribe errors. I have a pretty big connection pool, so I don't see why I keep getting it.
I mostly receive this error with RLock, which I use to synchronize. Should I tune my configuration somehow?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonLocalCachedMap can not init with NullPointerException when ReconnectionStrategy is ReconnectionStrategy.LOAD
I think the LocalCacheListener is null ;The line 160 in source code org.redisson.RedissonLocalCachedMap.java ,listener is null because it create in line 164;
Redis version 4.0
Redisson version 3.7.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class Main {

    private final static int NO_OF_JOBS = 5;

    public static void main(String[] args) {

        Config config = new Config();
        config.useClusterServers()
                .addNodeAddress("http://127.0.0.1:7000", "http://127.0.0.1:7001", "http://127.0.0.1:7002");
        RedissonClient redisson = Redisson.create(config);
        RExecutorService e =  redisson.getExecutorService("w1");//redisson.getExecutorService("w1");
        
        for (int j = 0; j < NO_OF_JOBS; j++) {
            Calendar calendar = Calendar.getInstance();
            int hour = calendar.get(Calendar.HOUR_OF_DAY);
            int minute = calendar.get(Calendar.MINUTE) + 1;
            //System.out.println("hour, minute" + hour + ", " + minute);
            ((RScheduledExecutorService) e).schedule(new RunnableTask(j + 1), CronSchedule.dailyAtHourAndMinute(hour, minute));
        }
    }
}
//new  job
public class RunnableTask implements Runnable {
    private int job_no;
    RunnableTask(int job_no) {
        this.job_no = job_no;
    }
    public void run() {
        try {
            Thread.sleep(10);
            System.out.println("This is task no " + job_no);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
//old Job
public class RunnableTask implements Runnable {
    private static volatile int i = 0;
    private long anyParam;
    public RunnableTask() {
    }
    RunnableTask(long anyParam) {
        this.anyParam = anyParam;
    }
    public void run() {
        try {
            Thread.sleep(10);
            i++;
            System.out.println(i);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

I previously scheduled 5 jobs (old jobs) they executed successfully. After that I scheduled another 5 jobs(new job) but this time the previous 5 jobs got executed on the schedule I gave for new job. Can anyone explain me this behaviour of redisson and point where I am making the mistake.
For this experiment I runned 4 redissonnodes in standalone mode with configuration as described below.
{
   "clusterServersConfig":{
      "nodeAddresses":[
         "redis://127.0.0.1:7001",
         "redis://127.0.0.1:7002",
         "redis://127.0.0.1:7003"
      ],
   },
   "threads":10,
   "executorServiceWorkers": {"w1":10},

}	

Redis version
4.0.9
Redisson version
3.7.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson API to get the number of subscribers subscribed to a particular channel.
PUBSUB numsub test

"test"
(integer) 1

How can we get the number of subscribers subscribed to a particular topic in redis as it was possible using the above command.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I scheduled some jobs first then I run one RedissonNode in standalone mode. and I got this error.
I have used the below code for scheduling the jobs.
public class Main {

    private final static int NO_OF_JOBS = 50;
    static int i = 1;

    public static void main(String[] args) {
        AtomicInteger a = new AtomicInteger(0);
        Config config = new Config();
        config.useClusterServers()
                .addNodeAddress("http://127.0.0.1:7000", "http://127.0.0.1:7001", "http://127.0.0.1:7002");
        RedissonClient redisson = Redisson.create(config);
        RExecutorService e = redisson.getExecutorService("d1");//redisson.getExecutorService("w1");
        for (int j = 0; j < NO_OF_JOBS; j++) {
            Calendar calendar = Calendar.getInstance();
            int hour = calendar.get(Calendar.HOUR_OF_DAY);
            int minute = calendar.get(Calendar.MINUTE) + 1;
            //System.out.println("hour, minute" + hour + ", " + minute);
            ((RScheduledExecutorService) e).schedule(new RunnableTask(j + 1), CronSchedule.dailyAtHourAndMinute(hour, minute));
        }
    }
}
public class RunnableTask implements Runnable {

    private int job_no;
    
    RunnableTask(int job_no) {
        this.job_no = job_no;
    }

    public void run() {
        try {
            Thread.sleep(10);
            System.out.println("This is task no " + job_no);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
Previously it was working fine but I have suddenly started getting this issue.
I am running 3 node redis cluster, with one replica
redis version 4.0.9
redisson version 3.7.0
[redisson-3-20] ERROR org.redisson.RedissonRemoteService - Can't execute: RemoteServiceRequest [requestId=52033463679a97be9bc4248e13a5c090, methodName=schedule, signatures=[[java.lang.String, [B, [B, long, java.lang.String, java.lang.String, java.lang.String]], args=[com.webengage.RunnableTask, [B@b02600d, [B@6703129b, 1528125840000, 0 54 20 ? * *, b00d5604-0e02-4a1a-8ea2-82ece6424caf, 52033463679a97be9bc4248e13a5c090], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1528125782651] java.lang.reflect.InvocationTargetException at sun.reflect.GeneratedMethodAccessor3.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:340) at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:66) at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:305) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) at java.lang.Thread.run(Thread.java:748) Caused by: org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0xada13228, L:/127.0.0.1:59757 - R:localhost/127.0.0.1:7003] command: (EVAL), params: [if redis.call('zrem', KEYS[2], ARGV[1]) > 0 then redis.call('hdel', KEYS[6], ARGV[1]); if redis.call..., 6, {{d1:org.redisson.executor.RemoteExecutorService}:org.redisson.executor.RemoteExecutorService}, {d1:org.redisson.executor.RemoteExecutorService}:scheduler, {d1:org.redisson.executor.RemoteExecutorService}:counter, {d1:org.redisson.executor.RemoteExecutorService}:status, {d1:org.redisson.executor.RemoteExecutorService}:termination-topic, {d1:org.redisson.executor.RemoteExecutorService}:tasks, 52033463679a97be9bc4248e13a5c090, 1, ...]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As requested in #1470 by @Himanshu4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am seeing below error while using RedissonSessionManager with tomcat. I have followed the default configuration that was provided at https://github.com/redisson/redisson/tree/master/redisson-tomcat.
Configuration is working fine in multi node environment with session replication at redis, but for every request I am seeing this error. Can you one please help on this.
Context.xml
Manager className="org.redisson.tomcat.RedissonSessionManager" configPath="${catalina.base}/lib/redisson.json"
JSON file:
{
"singleServerConfig":{
"password":null,
"address": "redis://localhost:6379",
"database":0
},
"codec":{
"class":"org.redisson.codec.SerializationCodec"
},
"transportMode": "EPOLL"
}
My redissona-all jar version is 3.7.1
redisson-tomcat-8:3.7.1
Tomcat version: 8.5.23
java.io.IOException: java.lang.ClassNotFoundException: org.springframework.webflow.conversation.impl.ConversationContainer
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:54)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:372)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:111)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808)
at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:408)
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:308)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.ClassNotFoundException: org.springframework.webflow.conversation.impl.ConversationContainer
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:348)
at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:677)
at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:43)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1826)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1713)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2000)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2245)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2169)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2027)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:50)
... 32 more
[redisson-netty-4-3] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.io.IOException: java.lang.ClassNotFoundException: org.springframework.webflow.conversation.impl.ConversationContainer
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808)
at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:408)
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:308)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: java.lang.ClassNotFoundException: org.springframework.webflow.conversation.impl.ConversationContainer
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:54)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:372)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:111)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
... 26 more
Caused by: java.lang.ClassNotFoundException: org.springframework.webflow.conversation.impl.ConversationContainer
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:348)
at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:677)
at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:43)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1826)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1713)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2000)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2245)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2169)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2027)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:50)
... 32 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Score/element order has been changed around in RC2. See: redis/redis@0a698e4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TestBean is
@Data
@EqualsAndHashCode(of = "id") //use lombok  .This annotation means use **id**  for hashing
public class TestBean {
    long id;
    String name;
}

        RSet<TestBean> set = mRedisClient.getSet("testSet");
        TestBean t1=new TestBean();
        t1.setId(1);
        t1.setName("1");

        TestBean t2=new TestBean();
        t2.setId(1);
        t2.setName("2");

        set.add(t1);
        set.add(t2);
﻿###  Expected behavior
set's size is 1
Actual behavior
set's size is 2, contains {"@Class":"com.meta.po.TestBean","id":1,"name":"2"} and
{"@Class":"com.meta.po.TestBean","id":1,"name":"1"}
Redis version
3.2.100
Redisson version
2.12.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
setPingConnectionInterval should ping redis Pub/Sub channel periodically and re-subscribe if pong is not received during specified interval. No exceptions should be thrown or logged by sending PING or receiving PONG messages.
Actual behavior
There is NullPointerException thrown and logged as error when pong is received.
Not sure if connection check and recovery would even work in this case.
This is copy/paste from our error log:
2018-06-08 14:39:53,778 ERROR [redisson-netty-1-3] o.r.c.handler.CommandPubSubDecoder  - Unable to decode data. channel: [id: 0x23e24825, L:/10.116.40.44:46628 - R:10.116.172.14/10.116.172.14:6379] message: *2 $4 pong $0 java.lang.NullPointerException: null 2018-06-08 14:39:53,779 WARN  [redisson-netty-1-3] i.n.channel.DefaultChannelPipeline  - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. io.netty.handler.codec.DecoderException: java.lang.NullPointerException at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: null
This is also logged as WARN by redisson, related to the same event:
2018-06-08 15:04:50,296 WARN  [redisson-netty-1-2] i.n.channel.DefaultChannelPipeline  - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. io.netty.handler.codec.DecoderException: java.lang.NullPointerException at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: null at org.redisson.client.handler.CommandPubSubDecoder.messageDecoder(CommandPubSubDecoder.java:179) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:378) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:111) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ... 32 common frames omitted
Steps to reproduce or test case
Application uses SerializationCodec for all channels, currently using 2 channels for pub/sub. Enable setPingConnectionInterval, in my case set to 5000 ms. After this NPE will be logged in error log.
Redis version
Server
redis_version:4.0.6
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:f1060815dd32471a
redis_mode:standalone
os:Linux 3.10.0-514.26.1.el7.x86_64 x86_64

Sentinels

Server
redis_version:4.0.6
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:f1060815dd32471a
redis_mode:sentinel
os:Linux 3.10.0-693.21.1.el7.x86_64 x86_64
Using 2 redis servers with master/slave + 3 sentinels of the same version
Redisson version
3.7.0, 3.7.1
Redisson configuration

sentinel mode
setConnectTimeout(10000)
setPingConnectionInterval(5000)
setSubscriptionMode(SubscriptionMode.MASTER)
setFailedSlaveReconnectionInterval(15000)
redis.connection.pool.size(10)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
The codec specified in the constructor should be used only for values, not for scores.
Redis commands : RedisCommands.ZSCORE and RedisCommands.ZSCORE_CONTAINS
Actual behavior
Codec for scores sometimes uses LongCodec sometimes uses "codec". For backward data compatibility should always use LongCodec when accessing scores.
Steps to reproduce or test case
Create a ScoredSortedSet with non default codec and use getScoreAsync / containsAsync methods
Redis version
4.0.6
Redisson version
3.7.1
Used to work fine with Redisson Version 3.5.7, when upgraded to 3.7.1 ScoredSortedSet stopped working. Codec
Works fine with this change:
 @Override
        public @Nullable RFuture<Double> getScoreAsync(final @Nullable V o) {
            return commandExecutor.readAsync(getName(), LongCodec.INSTANCE, RedisCommands.ZSCORE, getName(), encode(o));
        }
@Override
        public @Nullable RFuture<Boolean> containsAsync(final @Nullable Object o) {
            return commandExecutor.readAsync(getName(), LongCodec.INSTANCE, RedisCommands.ZSCORE_CONTAINS, getName(), encode(o));
        }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I get control over already scheduled jobs in redisson and do operation such as delete/modify on them.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current implementation of RBatch object accumulates all method invocations in memory on Redisson side before send them to Redis. This approach may lead to OOM exception if accumulated batch is too big.
Introduce executionMode setting to allow accumulation of all method invocations on Redis side.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Call Redis INFO on a given node in a cluster and it should return a blob of info for that given node.
Actual behavior
When the redisson client is preparing to send the redis INFO call, client2key returns null for the given redisClient which only happened to me during INFO calls, not any writes or reads. This is the commit that I believe caused this behavior. fe98d0a#diff-bb90b8f5c06abce59014861b02cecd93
06/04/2018 16:18:59 PDT DEBUG redisson-netty-1-4 ClusterConnectionManager:391 - cluster nodes state from 10.73.128.146/10.73.128.146:6379:
03de98146f0038a9a04587dd6ef102f48c54aeab 10.73.128.76:6379 slave 0cba7b1e954e4235a9ac86e0306608e97e04e404 0 1528154338964 98 connected
0cba7b1e954e4235a9ac86e0306608e97e04e404 10.73.128.146:6379 myself,master - 0 0 98 connected 10922-16383
117b100e765b5af972dd7d3f96b9541d7c7aba24 10.73.128.138:6379 slave a3e0502ebb14d9b6c4eb0d600e05e15d30adb387 0 1528154337463 79 connected
d78a886e8fb890bb98ed740f8908b222874a164a 10.73.129.85:6379 slave 178153b9fdc7b8314ef3a26f269395d4ec6597ca 0 1528154338464 93 connected
987c581e9b11b72d9e17c4e58d8c66abce653dd6 10.73.128.93:6379 slave 0cba7b1e954e4235a9ac86e0306608e97e04e404 0 1528154337963 98 connected
178153b9fdc7b8314ef3a26f269395d4ec6597ca 10.73.128.68:6379 master - 0 1528154336962 93 connected 5461-10921
a3e0502ebb14d9b6c4eb0d600e05e15d30adb387 10.73.128.91:6379 master - 0 1528154337463 79 connected 0-5460


org.redisson.client.RedisConnectionException: Can't find entry for [addr=redis://10.73.128.68:6379]
    at org.redisson.connection.balancer.LoadBalancerManager.getConnection(LoadBalancerManager.java:241)
    at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:507)
    at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:583)
    at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:497)
    at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:589)
    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668)
    at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743)
    at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471)
    at java.lang.Thread.run(Thread.java:745)
Can't find entry for [addr=redis://10.73.128.68:6379]

It seems the issue is the hashcodes are different only when making the INFO call (That i know of) because the channels value changes.

So when doing the get for client2key, it gets nothing. For Writes and reads that i tried, the hashcodes for the clients are the same
Steps to reproduce or test case
Spin up any redis cluster and simply call .info() on a node in the .getNodesGroup()
Redis version
3.2.11
Redisson version
3.7.1
Redisson configuration
default redis cluster config with 7 nodes in the cluster. 3 Master and 4 Slave
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SingleServerConfig serverConfig = config.useSingleServer()
.setAddress("redis://" + redissonProperties.getHost() + ":" + redissonProperties.getPort())
.setTimeout(redissonProperties.getTimeout())
.setConnectionPoolSize(redissonProperties.getConnectionPoolSize()).setDatabase(0);
config.setLockWatchdogTimeout(redissonProperties.getLockWatchdogTimeout());配置
lock.lock(“ceshifangfa”）
TODO
lock.unlock
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The performance benefit of using RedissonLocalCachedMap over RedissonMap is negligible when getting all data from the map via readAllKeySet*(), readAllValues*(), readAllEntrySet*() and values(). The readAll*() methods still gets data from server, values() method is not overriden in RedissonLocalCachedMap.
Would it be possible to read data only from the local cache in these cases?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the code blow:
config:
@bean
public RRateLimiter rRateLimiter(RedissonClient redissonClient){
RRateLimiter rateLimiter = redissonClient.getRateLimiter("myRateLimiter");
System.err.println("初始化流速10设置:"+rateLimiter.trySetRate(RateType.OVERALL, 10, 1,  RateIntervalUnit.SECONDS));
return rateLimiter;
}
call function:
@Autowired
private RRateLimiter rateLimiter;
@ApiOperation(value = "列表",notes = "进入列表页", httpMethod = "GET")
@RequestMapping(value = "init",method = RequestMethod.GET)
public String init(){
if(rateLimiter.tryAcquire(1,0, TimeUnit.SECONDS)){//获取令牌成功，尝试一次，直接返回
try {
System.err.println("获取令牌成功，确定执行时刻:" + new SimpleDateFormat("yyyy-MM-dd hh:mm:ss S").format(new Date()));
// 模拟执行耗时5秒
TimeUnit.SECONDS.sleep(5);
} catch (InterruptedException e) {
e.printStackTrace();
}
}else{
System.err.println("获取令牌失败，拒绝执行时刻:"+new SimpleDateFormat("yyyy-MM-dd hh:mm:ss S").format(new Date()));
}
return "solr/selectSolr";
}
the RedissonClient init success with cluster model,the console always print
1.初始化流速10设置:false,
this function "rateLimiter.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS)",return false  why?
need code demo for RateLimiter,thanks !
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
项目能够顺利启动。
Actual behavior
偶尔会抛出Search domain query failed.异常信息导致项目启动不了
Steps to reproduce or test case
项目采用的spring boot1.5.3。
Redis version
redis 4.0.2
Redisson version
Redisson 3.6.5
Redisson configuration
application.yml
redisson:
  address: redis://www.chasel.com:6279
  timeout: 3000
  connectionPoolSize: 64
  connectionMinimumIdleSize: 10
  reconnectionTimeout: 3000
  threads: 10
  codec: org.redisson.codec.JsonJacksonCodec
  nettyThreads: 10
  transportMode: NIO
  idleConnectionTimeout: 10000
  pingTimeout: 1000
  connectTimeout: 10000
  database: 0
Java Code
public class RedissonConfig {

	private String address;
	private int connectionMinimumIdleSize;
	private int idleConnectionTimeout;
	private int pingTimeout;
	private int connectTimeout;
	private int timeout;
	private int reconnectionTimeout;
	private int connectionPoolSize;
	private int database;
	private int threads; // 当前处理核数量 * 2
	private int nettyThreads;
	private String codec;
	@ConditionalOnProperty(name = "redisson.address")
	@Bean(destroyMethod = "shutdown")
	RedissonClient redisson() throws Exception {
		Config config = new Config();
		config.useSingleServer().setAddress(address)
				.setConnectionMinimumIdleSize(connectionMinimumIdleSize).setIdleConnectionTimeout(idleConnectionTimeout)
				.setPingTimeout(pingTimeout).setConnectTimeout(connectTimeout).setTimeout(timeout)
				.setConnectionPoolSize(connectionPoolSize).setDatabase(database)
				;
		config.setThreads(threads);
		config.setTransportMode(TransportMode.NIO);
		config.setNettyThreads(nettyThreads);
		// SingleServerConfig singleServerConfig =
		// config.useSingleServer().setAddress();
		// Config config = Config.fromJSON(new
		// ClassPathResource(RedisContants.RedissonConstants.REDISSON_JSON_CONFIG_FILE_NAME).getFile());
		return Redisson.create(config);
	}

	@ConditionalOnProperty(name = "redisson.address")
	@Bean
	RedissonReactiveClient RedissonReactive() throws IOException {
		Config config = new Config();
		config.useSingleServer().setAddress(address)
				.setConnectionMinimumIdleSize(connectionMinimumIdleSize).setIdleConnectionTimeout(idleConnectionTimeout)
				.setPingTimeout(pingTimeout).setConnectTimeout(connectTimeout).setTimeout(timeout)
				.setConnectionPoolSize(connectionPoolSize).setDatabase(database)
				;
		config.setThreads(threads);
		config.setTransportMode(TransportMode.NIO);
		config.setNettyThreads(nettyThreads);
		return Redisson.createReactive(config);
	}

Excpetion:
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redissonUtil': Unsatisfied dependency expressed through method 'setRedissonReactiveClient' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'RedissonReactive' defined in class path resource [com/sst/common/config/RedissonConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonReactiveClient]: Factory method 'RedissonReactive' threw exception; nested exception is io.netty.resolver.dns.DnsNameResolverContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'www.chasel.com' failed to resolve 'www.chasel.com' after 2 queries 
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:667)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)
	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:314)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151)
	at com.sst.AdminApiApplication.main(AdminApiApplication.java:13)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'RedissonReactive' defined in class path resource [com/sst/common/config/RedissonConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonReactiveClient]: Factory method 'RedissonReactive' threw exception; nested exception is io.netty.resolver.dns.DnsNameResolverContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'www.chasel.com' failed to resolve 'www.chasel.com' after 2 queries 
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1138)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:659)
	... 19 common frames omitted
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonReactiveClient]: Factory method 'RedissonReactive' threw exception; nested exception is io.netty.resolver.dns.DnsNameResolverContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'www.chasel.com' failed to resolve 'www.chasel.com' after 2 queries 
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)
	... 31 common frames omitted
Caused by: io.netty.resolver.dns.DnsNameResolverContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'www.chasel.com' failed to resolve 'www.chasel.com' after 2 queries 
	at io.netty.resolver.dns.DnsNameResolverContext.finishResolve(DnsNameResolverContext.java:728)
	at io.netty.resolver.dns.DnsNameResolverContext.tryToFinishResolve(DnsNameResolverContext.java:670)
	at io.netty.resolver.dns.DnsNameResolverContext.query(DnsNameResolverContext.java:306)
	at io.netty.resolver.dns.DnsNameResolverContext.query(DnsNameResolverContext.java:295)
	at io.netty.resolver.dns.DnsNameResolverContext.access$700(DnsNameResolverContext.java:60)
	at io.netty.resolver.dns.DnsNameResolverContext$3.operationComplete(DnsNameResolverContext.java:346)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
	at io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:223)
	at io.netty.resolver.dns.DnsQueryContext.access$300(DnsQueryContext.java:42)
	at io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:162)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/10.3.0.28:53] query timed out after 5000 milliseconds (no stack trace available)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
question
java project springboot+redission only, RedisCluster scanInterval 1000ms，jvm create too many HashMap.Node, cause YGC quickly, I see ClusterConnectionManager.java source
private void scheduleClusterChangeCheck(...){
}
private void checkSlotsChange(cfg, newPartitions) {
Collection newPartitionsSlots = slots(newPartitions);
...
}
private Collection<Integer> slots(Collection<ClusterPartition> partitions) {
   // **** create 16384 capacity HashMap.Node ***//
    Set<Integer> result = new HashSet<Integer>(MAX_SLOT);
    for (ClusterPartition clusterPartition : partitions) {
        result.addAll(clusterPartition.getSlots());
    }
    return result;
}


$ sudo /usr/local/java/jdk/bin/jstat -gc 6623
﻿ S0C    S1C    S0U    S1U      EC	EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
17920.0 19456.0 15506.0  0.0   772608.0 189177.1  165888.0   42155.6   52352.0 51221.4 6528.0 6239.4     14    0.102   2      0.081    0.183
Expected behavior
null
Actual behavior
num     instances         bytes  class name
1:       4719787	 151033184  java.util.HashMap$Node
2:         23692	 118076728  [Ljava.util.HashMap$Node;
3:        571827	  99347520  [C
4:        165795	  89233304  [I
5:       1192658	  19082528  java.lang.Integer
6:         16348	  16425592  [B
7:        357968        8591232  java.lang.String
8:         37014        5820136  [Ljava.lang.Object;
9:         43160        3798080  java.lang.reflect.Method
10:         80343        2570976  java.util.concurrent.ConcurrentHashMap$Node
11:         34579        2213056  java.net.URL
Steps to reproduce or test case
watch -n1 "sudo /usr/local/java/jdk/bin/jmap -histo pid"
Redis version
4.0.0+
Redisson version
3.7.1
Redisson configuration
// redis-cluster,3M-3S
Config config = new Config();
config.useClusterServers()
.setScanInterval(1000)
.addNodeAddress("redis://127.0.0.1:7001", "redis://127.0.0.1:7002")
.addNodeAddress("redis://127.0.0.1:7003", "redis://127.0.0.1:7004")
.addNodeAddress("redis://127.0.0.1:7005", "redis://127.0.0.1:7006")；
RedissonClient redisson = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I provide timezone in scheduled tasks according to which tasks should be executed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I imported Redission in spring boot using distributedLock,but the log always show this WARN
Actual behavior
collection-web 2018-06-13 20:50:24.428 WARN  --- [Thread-7] org.springframework.beans.factory.support.DisposableBeanAdapter Line:371 - Invocation of destroy method 'close' failed on bean with name 'jCacheCacheManager'
java.lang.NullPointerException: null
at org.redisson.jcache.JCacheManager.close(JCacheManager.java:368)
at org.redisson.jcache.JCachingProvider.close(JCachingProvider.java:183)
at org.redisson.jcache.JCacheManager.close(JCacheManager.java:360)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:364)
at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:287)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:578)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:554)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:961)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:523)
at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.destroySingletons(FactoryBeanRegistrySupport.java:230)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:968)
at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1030)
at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1006)
at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:958)
at org.springframework.boot.actuate.endpoint.ShutdownEndpoint$1.run(ShutdownEndpoint.java:74)
at java.lang.Thread.run(Thread.java:745)
Steps to reproduce or test case
Redis version
Redisson version
3.7.0
Redisson configuration
this is my configuration class:
/**
*
* @return
*/
@bean
RedissonClient redissonClient() {
List nodeList = redisClusterConfigProperties.getNodes();
Config config = new Config();
ClusterServersConfig clusterServersConfig = config.useClusterServers();
for (String node : nodeList) {
clusterServersConfig = config.useClusterServers().addNodeAddress("redis://" + node);
}
clusterServersConfig.setScanInterval(2000);
return Redisson.create(config);
}
@Bean
CacheManager cacheManager(RedissonClient redissonClient) {
    Map<String, CacheConfig> config = new HashMap<>();
    config.put("testMap", new CacheConfig(24*60*1000, 12*60*1000));
    return new RedissonSpringCacheManager(redissonClient, config);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
New feature of upcoming Redis 5.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have one RunnableTask which makes a HTTP request and hence needs a dependency of HTTP client. This job looks like this.
import com.mashape.unirest.http.Unirest;
import com.mashape.unirest.http.exceptions.UnirestException;

public class RunnableTask implements Runnable {
    private int job_no;
    RunnableTask(int job_no) {
        this.job_no = job_no;
    }
    public RunnableTask() {}
    public void run() {
        try {
            System.out.println(Unirest.get("http://192.168.1.108:3000").asString().getBody() + " " + job_no);
        } catch (UnirestException e) {
            e.printStackTrace();
        }
    }
}
Now I am scheduling some jobs using this code.
public class Main {
    private final static int NO_OF_JOBS = 10;
    static int i = 1;
    public static void main(String[] args) {
        //initUnirest();
        Config config = new Config();
        config.useClusterServers()
                .addNodeAddress("http://127.0.0.1:7000", "http://127.0.0.1:7001", "http://127.0.0.1:7002");
        RedissonClient redisson = Redisson.create(config);

//Block-1
       /* RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
        nodeConfig.setThreads(100);
        nodeConfig.setExecutorServiceWorkers(Collections.singletonMap("d1", 1));
        RedissonNode.create(nodeConfig).start();
*/
        RExecutorService e = redisson.getExecutorService("d1");
        //redisson.getExecutorService("d1").registerWorkers(10, Executors.newFixedThreadPool(10));
        for (int j = 0; j < NO_OF_JOBS; j++) {
            Calendar calendar = Calendar.getInstance();
            int hour = calendar.get(Calendar.HOUR_OF_DAY);
            int minute = calendar.get(Calendar.MINUTE) + 1;
            //System.out.println("hour, minute" + hour + ", " + minute);
            RExecutorFuture r = (RExecutorFuture) ((RScheduledExecutorService) e).schedule(new RunnableTask(j + 1), CronSchedule.dailyAtHourAndMinute(hour, minute));
            //System.out.println(r.getTaskId());
        }
    }
}
After this I launched a RedissonNode in standalone mode. Now when the time for the execution of this jobs come, I am getting following error.
[redisson-3-30] ERROR org.redisson.RedissonRemoteService - Can't execute: RemoteServiceRequest [requestId=01ff7d044609fe82f2a85d5eb665839f45, methodName=schedule, signatures=[[java.lang.String, [B, [B, long, java.lang.String, java.lang.String, java.lang.String]], args=[com.webengage.MRunnableTask, [B@3f8166bd, [B@7a83ef29, 1529334600000, 0 40 20 ? * *, cf987ea1-4e2b-4335-93f1-02baaccfca19, 01ff7d044609fe82f2a85d5eb665839f45], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1529334573532]
java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:347)
	at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:66)
	at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:312)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NoClassDefFoundError: com/mashape/unirest/http/exceptions/UnirestException
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:348)
	at com.fasterxml.jackson.databind.type.TypeFactory.classForName(TypeFactory.java:278)
	at com.fasterxml.jackson.databind.type.TypeFactory.findClass(TypeFactory.java:258)
	at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver._typeFromId(ClassNameIdResolver.java:68)
	at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver.typeFromId(ClassNameIdResolver.java:51)
	at com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._findDeserializer(TypeDeserializerBase.java:158)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:106)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:91)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:163)
	at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:554)
	at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:63)
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3807)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2867)
	at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:92)
	at org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:246)
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:268)
	at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:126)
	... 12 more
Caused by: java.lang.ClassNotFoundException: com.mashape.unirest.http.exceptions.UnirestException
	at java.lang.ClassLoader.findClass(ClassLoader.java:530)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 30 more

But when I uncomment the part of code described below, i.e., I launch the RedissonNodes from the same process and not in standalone mode, jobs get executed successfully.
RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
        nodeConfig.setThreads(100);
        nodeConfig.setExecutorServiceWorkers(Collections.singletonMap("d1", 1));
        RedissonNode.create(nodeConfig).start();
@mrniko @jackygurui
Anyone please explain why this is happening and resolution for this issue.
Redis version
4.0.9
Redisson version
3.7.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using the Redis Cell module for keeping track of rate limits on certain keys. Unfortunately with Redisson this means I have to use the low level client for now but it would be nice to include a method for the CL.THROTTLE command used in Redis Cell module with the high level client.
This is not related to RRateLimiter which to my understanding is for throttling calls to Redis itself.
Redis Cell
https://github.com/brandur/redis-cell
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Issue since Redisson 3.7.1
Line 125 of RedissonRateLimiter.java throws a null pointer exception when the time unit  parameter is null. When you call the acquire methods it passes a null for that parameter. Basic unit tests for the acquire method would have caught this.
 @Override public RFuture<Boolean> tryAcquireAsync(long permits, long timeout, TimeUnit unit) { RPromise<Boolean> promise = new RedissonPromise<Boolean>(); tryAcquireAsync(permits, promise, unit.toMillis(timeout)); return promise;  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class Main {

    private final static int NO_OF_JOBS = 10;
    static int i = 1;

    public static void main(String[] args) {
        Config config = new Config();
        config.useClusterServers()
                .addNodeAddress("http://127.0.0.1:7000", "http://127.0.0.1:7001", "http://127.0.0.1:7002");
        RedissonClient redisson = Redisson.create(config);
        RExecutorService e = redisson.getExecutorService("d1");
        for (int j = 0; j < NO_OF_JOBS; j++) {
            Calendar calendar = Calendar.getInstance();
            int hour = calendar.get(Calendar.HOUR_OF_DAY);
            int minute = calendar.get(Calendar.MINUTE) + 1;
            RExecutorFuture r = (RExecutorFuture) ((RScheduledExecutorService) e).schedule(new MRunnableTask(j + 1), CronSchedule.dailyAtHourAndMinute(hour, minute));//line-1
            //RExecutorFuture r = (RExecutorFuture) ((RScheduledExecutorService) e).schedule(new MRunnableTask(j + 1), CronSchedule.of("0 44 12 19 JUN ? 2018"));//line-2
        }
    }
}
I have used two methods to schedule the jobs. In method-1 I have used line-1 to schedule the job and in method-2 I have used line-2 to schedule the job. The problem I am facing is that method-1 is working fine but when I comment the line-1 and use method-2 instead the jobs doesn't get executed and I get the error as described below.
[redisson-3-52] ERROR org.redisson.RedissonRemoteService - Can't execute: RemoteServiceRequest [requestId=010c22ce1141604daa2fbe2c7d8254f5b0, methodName=schedule, signatures=[[java.lang.String, [B, [B, long, java.lang.String, java.lang.String, java.lang.String]], args=[com.webengage.MRunnableTask, [B@746aebd, [B@9815025, 1529393160000, 0 56 12 19 JUN ? 2018, 5ede66a4-83f0-4a19-b742-f126e7173a4d, 010c22ce1141604daa2fbe2c7d8254f5b0], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1529393122775]
java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:347)
	at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:66)
	at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:312)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NullPointerException
	at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:124)
	... 12 more

@jackygurui @mrniko kindly look into this.
I am using redisson 3.7.2 in standalone mode and redis 4.0.9.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I am sure that I will be definitely having a class already loaded in memory, is there any way to avoid serialization and deserialization of whole class.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As per my understanding, Redisson serializes the class at the time of scheduling the job and deserializes it at the time of execution of the job. If the class is already in memory at the time of execution of the job  then what does redisson do.
Kindly explain me this in details and also correct me if my understanding is not correct.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
setPingConnectionInterval should send periodic ping messages and keep channels alive, but this must not affect any other type of messages on channels.
Actual behavior
When using setPingConnectionInterval some messages will not be delivered to listeners after being published. I have a test code which can reliably reproduce this issue:
import org.redisson.Redisson;
import org.redisson.api.RTopic;
import org.redisson.api.RedissonClient;
import org.redisson.codec.SerializationCodec;
import org.redisson.config.Config;
import org.redisson.config.SubscriptionMode;

import java.util.UUID;
import java.util.concurrent.ConcurrentSkipListSet;

public class PlainPubSubTest {

    public static void main(String[] args) throws InterruptedException {
        ConcurrentSkipListSet<String> sentItems = new ConcurrentSkipListSet<>();
        ConcurrentSkipListSet<String> receivedItems = new ConcurrentSkipListSet<>();

        System.out.println("Staring test");

        RedissonClient redissonClient = redissonClient(configSentinel());

        RTopic<String> eventsTopic = redissonClient.getTopic("eventsTopic");
        eventsTopic.addListener((channel, msg) -> receivedItems.add(msg));

        System.out.println("Starting sending loop");
        for(int i = 0; i<1000; i++){
            final String message = UUID.randomUUID().toString();
            eventsTopic.publish(message);
            sentItems.add(message);
            Thread.sleep(10);
        }

        System.out.println("Sent: " + sentItems.size() + ", got: " + receivedItems.size());
        Thread.sleep(1000);
        System.out.println("Sent: " + sentItems.size() + ", got: " + receivedItems.size());
    }

    private static RedissonClient redissonClient(Config config){
        return Redisson.create(config);
    }

    private static Config configSentinel(){
        Config config = new Config();
        config.setCodec(new SerializationCodec());
        String password = "*****************";
        String masterName = "my-master-name";
        String[] sentinelAddresses = new String[]{"redis://localhost:26001", "redis://localhost:26002", "redis://localhost:26003"};
        Integer connectionTimeout = 10000;
        int pingTimeout = 5000;
        int reconnectionTimeout = 5000;
        int connectionPoolSize = 10;
        int connectionPoolMinSize = 10;
        int connectionPingInterval = 50; //Changing to 0 eliminates issue
        config.useSentinelServers()
                .setPassword(password)
                .setMasterName(masterName)
                .addSentinelAddress(sentinelAddresses)
                .setConnectTimeout(connectionTimeout)
                .setPingTimeout(pingTimeout)
                .setPingConnectionInterval(connectionPingInterval)
                .setSubscriptionMode(SubscriptionMode.MASTER)
                .setFailedSlaveReconnectionInterval(reconnectionTimeout)
                .setMasterConnectionMinimumIdleSize(connectionPoolMinSize)
                .setMasterConnectionPoolSize(connectionPoolSize);
        return config;
    }
}

Output of this code will produce varying results each time, but it will never get all sent messages, like this:
Staring test
Starting sending loop
Sent: 1000, got: 640
Sent: 1000, got: 640

However if connectionPingInterval is set to 0 (disabled) issue is completely eliminated, like this:
Staring test
Starting sending loop
Sent: 1000, got: 1000
Sent: 1000, got: 1000

Redis version
redis_version:4.0.6
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:f1060815dd32471a
redis_mode:standalone
os:Linux 3.10.0-514.26.1.el7.x86_64 x86_64

Redisson version
3.7.2
Redisson configuration
Visible in test case
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Code
//过滤第二个finishCall事件
RSet<String> finishedCallSet = cacheService.getFinishedCallSet();
RLock callIdLock = finishedCallSet.getLock(callId);
callIdLock.lock();
try {
    if (finishedCallSet.contains(callId)) {
        log.info("receive finishCall second time, callId is: {}", callId);
        return;
    }
    log.info("receive finishCall first time, callId is: {}", callId);
    finishedCallSet.add(callId);
} finally {
    callIdLock.unlock();
}﻿
Expected behavior
finishedCallSet.add(callId);只被调用一次
Actual behavior
finishedCallSet.add(callId);被调用了两次
原因猜想
redis slave是readonly的，lock可能也起作用了，但是在slave和master之间同步数据时调用了contains方法，而这时slave还没有同步完数据，返回了false，finishedCallSet.add(callId)被调用了两次。
Redis version
3.2.11
Redisson version
3.6.4
Redisson configuration
@Bean(destroyMethod = "shutdown")
public RedissonClient prodRedisson() {
    String[] sentinelAddress = sentinelServers.values().stream()
            .map(sentinelServer -> "redis://" + sentinelServer.getHost() + ":" + sentinelServer.getPort())
            .collect(Collectors.toList())
            .toArray(new String[0]);
    Config config = new Config();
    config.useSentinelServers()
            .setDatabase(database)
            .setClientName(clientName)
            .setMasterName(masterName)
            .setPassword(password)
            .setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize)
            .setSlaveConnectionPoolSize(slaveConnectionPoolSize)
            .setMasterConnectionMinimumIdleSize(masterConnectionMinimumIdleSize)
            .setMasterConnectionPoolSize(masterConnectionPoolSize)
            .setIdleConnectionTimeout(idleConnectionTimeout)
            .setTimeout(timeout)
            .setRetryAttempts(retryAttempts)
            .setRetryInterval(retryInterval)
            .addSentinelAddress(sentinelAddress);
    return Redisson.create(config);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko @jackygurui
If I want to schedule a job with certain cron expression, how do I specify that job should only run between some start and end time, whenever its execution according to the cron occurs. Like it is provided in quartz.
@mrniko
I also feel there should be support for cron expression with delay as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I perform some task after execution of some job?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since I get taskId after scheduling the task, how can I provide taskId to the RunnableTask, so that I can have taskId during execution of task.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How to schedule a task that would run at particular time, currently I tried to do this with cron expression but it is giving error as described here.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why would you even schedule a job thats never going to be executed?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using redisson MapCache expiration I would like a replace to refresh the idleTimeout, so that a field does not expire as long as it is replaced within the idleTimeout period.  Note that replace returns the old value, so strictly speaking the value is accessed.
Actual behavior
Fields are expired after idleTimeout regardless of whether their values are replaced or not.
Steps to reproduce or test case
a test added to RedissonMapCacheTest, I would like it to pass:
@Test
public void testReplaceValueTTLIdleUpdate() throws InterruptedException {
    RMapCache<SimpleKey, SimpleValue> map = null;
	SimpleValue val1;
	try {
		map = redisson.getMapCache("simple");
		map.put(new SimpleKey("1"), new SimpleValue("2"), 1, TimeUnit.SECONDS, 500, TimeUnit.MILLISECONDS);

		Thread.sleep(300);
	
		// update value, would like idle timeout to be refreshed
		SimpleValue res = map.replace(new SimpleKey("1"), new SimpleValue("3"));
		assertThat(res).isNotNull();

		Thread.sleep(300);

		// if idle timeout has been updated val1 will be not be null, else it will be null
		val1 = map.get(new SimpleKey("1"));
		assertThat(val1).isNotNull(); // this throws an assertion error

		Thread.sleep(300);
		
		// val1 will have expired due to TTL
		val1 = map.get(new SimpleKey("1"));
		assertThat(val1).isNull();

	} catch (Exception e) {
		e.printStackTrace();
	} finally {
        map.remove(new SimpleKey("1"));
	}
}

Redis version
4.0.10
Redisson version
3.7.0, master
Redisson configuration
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":3000,
"connectTimeout":10000,
"timeout":10000,
"retryAttempts":20,
"retryInterval":1500,
"password":null,
"subscriptionsPerConnection":15,
"clientName":null,
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":32,
"connectionPoolSize":64,
"database":3,
"address": "redis://xxx:6379"
},
"threads":40,
"nettyThreads": 40,
"codec":null,
"useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson 3.7.0 shouldn't leak file handles.
Actual behavior
After upgrading from Redisson 3.5.5 to Redisson 3.7.0 With Elasticache cluster I noticed file handles are left open and within an hour all the handles are exhausted causing AWS ECS to terminate the service instance. The issue goes away once I revert back to 3.5.5
Steps to reproduce or test case
Use Redisson 3.7.0 with AWS ElasticCache Cluster.
Redis version
Elasticache 4.x
Redisson version
3.7.0
Redisson configuration
ElasticCache cluster. Following is the Spring code to configure redisson with cluster:
I've configured pool size at 20 and minimum pool size at 5. Scan interval is set at 2000 milliseconds.
	ClusterServersConfig clusterServersConfig = config.useClusterServers();
	clusterServersConfig.setScanInterval(<scan-interval>);
	for(String host: redisHostArr){
		clusterServersConfig.addNodeAddress("redis://"+host);
	}
	clusterServersConfig.setMasterConnectionPoolSize(<pool-size>);
	clusterServersConfig.setMasterConnectionMinimumIdleSize(<min-pool-size>);
	clusterServersConfig.setSlaveConnectionPoolSize(<pool-size>);
	clusterServersConfig.setSlaveConnectionMinimumIdleSize(<min-pool-size>);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is it any difference between this checks? I use getNodesGroup().pingAll() for pinging nodes with cluster config as well. Is it correct way or should I change check on getClusterNodesGroup().pingAll()?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
package src;
import org.redisson.api.RedissonClient;
import src.UserProfileStatus;
public class PresenceStore {
private static ConcurrentMap<String, ConcurrentHashMap<String, UserProfileStatus>> resourceStore = new ConcurrentHashMap<>();
public static RedissonClient redisson = Redisson.create();
private static RMap<String, RMap> resourcemap=  redisson.getMap("Anyone");
public  RLiveObjectService liveObjectService = redisson.getLiveObjectService();


public void AddResourceStore(String resourceId, ClientProfile clientProfile, String status) {

    UserProfile userProfile = clientProfile.getUserProfile();
    DeviceProfile deviceProfile = clientProfile.getDeviceProfile();
    userProfile = liveObjectService.merge(clientProfile.getUserProfile());
    deviceProfile = liveObjectService.merge(clientProfile.getDeviceProfile());
    // check userprofile and device profile class registered
    System.out.println(liveObjectService.isClassRegistered(UserProfile.class));
    System.out.println(liveObjectService.isClassRegistered(DeviceProfile.class));


   clientProfile = liveObjectService.merge(clientProfile);
    System.out.println("Client Profile Resistration State = " + liveObjectService.isClassRegistered(ClientProfile.class));

    RMap<String,UserProfileStatus> hmap= redisson.getMap(resourceId);
    UserProfileStatus userProfileStatus = new UserProfileStatus(clientProfile, status);
    // UserProfileStatus object is becoming "live" object
    userProfileStatus = liveObjectService.merge(userProfileStatus);
    System.out.println("UserProfile Registration Status = " + liveObjectService.isClassRegistered(UserProfileStatus.class));
    String key = clientProfile.getClientId();
    hmap.put(key, userProfileStatus);
    resourcemap.put(resourceId, hmap);
}

public  void GetResource(String resourceId){
    RMap<String,UserProfileStatus> hmap= resourcemap.get(resourceId);
    Set<Map.Entry<String,UserProfileStatus>>s= hmap.entrySet();
    Iterator i=s.iterator();

    hmap.forEach((K, V) -> {
        UserProfileStatus pstatus = V;
       (error line)---> System.out.println("Key: "+ K + "\nvalue : " + pstatus.getClientProfile());
    });

}

}



import org.redisson.api.annotation.REntity;
import org.redisson.api.annotation.RId;
import org.redisson.liveobject.resolver.LongGenerator;
import src.ClientProfile;
import src.DeviceProfile;
import src.UserProfile;
import java.util.Map;
@rentity
public class UserProfileStatus {
@RId(generator = LongGenerator.class)

private String status;
private ClientProfile clientProfile;

public UserProfileStatus(){System.out.println("my userprofilestatus");}

public UserProfileStatus(ClientProfile clientProfile, String status){
    System.out.println("in user profile status");
    this.setClientProfile(clientProfile);
    this.status=status;
}

public ClientProfile getClientProfile() {
    return clientProfile;
}

public void setClientProfile(ClientProfile clientProfile) {
    if (clientProfile == null) {
        throw new NullPointerException("clientProfile cannot be null");
    }
    this.clientProfile = clientProfile;
}

public String getStatus() {
    return status;
}

public void setStatus(String status) {
    this.status = status;
}

public void serializeToMap(Map<String, String> userData) {
    if(null == userData){

        return;
    }
    UserProfile userProfile = this.clientProfile.getUserProfile();
    userData.put("userId", userProfile.getUserId());
    userData.put("name", userProfile.getName());
    userData.put("displayName", userProfile.getDisplayName());
    userData.put("firstName", userProfile.getFirstName());
    userData.put("lastName", userProfile.getLastName());
    userData.put("emailId", userProfile.getEmailId());

    DeviceProfile deviceProfile = this.clientProfile.getDeviceProfile();
    userData.put("deviceId", deviceProfile.getDeviceId());
    userData.put("deviceDescription", deviceProfile.getDeviceDescription());

    userData.put("state", status);
}

}



package src;
import org.redisson.api.annotation.REntity;
import org.redisson.api.annotation.RId;
import org.redisson.liveobject.resolver.LongGenerator;
import org.redisson.liveobject.resolver.UUIDGenerator;
@rentity
public class ClientProfile {
@Rid
private String clientId;
private UserProfile userProfile;
private DeviceProfile deviceProfile;
public ClientProfile(UserProfile userProfile, DeviceProfile deviceProfile) {
    this.setUserProfile(userProfile);
    this.setDeviceProfile(deviceProfile);
    this.clientId = userProfile.getKey()+ "_" + deviceProfile.getKey();
}

public ClientProfile(){System.out.println("my client call");}

public ClientProfile(ClientProfile otherProfile){
    this.clientId = otherProfile.clientId;
    this.userProfile = otherProfile.userProfile;
    this.deviceProfile = otherProfile.deviceProfile;
}

public UserProfile getUserProfile() {
    return userProfile;
}

public void setUserProfile(UserProfile userProfile) {
    if (userProfile == null) {
        throw new NullPointerException("userProfile cannot be null");
    }
    this.userProfile = userProfile;
}

public DeviceProfile getDeviceProfile() {
    System.out.println("getdeviceprofile");return deviceProfile;
}

public void setDeviceProfile(DeviceProfile deviceProfile) {
    if (deviceProfile == null) {
        throw new NullPointerException("deviceProfile cannot be null");
    }
    this.deviceProfile = deviceProfile;
}

public String getClientId(){
    System.out.println("getting key");
    return this.clientId;
}

public static String getKey(String userId, String deviceId) {
    return userId + "_" + deviceId;
}

}
I am getting "java.lang.ClassCastException: org.redisson.RedissonMap cannot be cast to src.ClientProfile" error. can someone tell me why?(client profile also have 2 classes inside it).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/1514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exception in thread "main" java.lang.NoSuchMethodError: io.netty.util.internal.StringUtil.indexOfNonWhiteSpace(Ljava/lang/CharSequence;I)I at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parse(UnixResolverDnsServerAddressStreamProvider.java:171) at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.<init>(UnixResolverDnsServerAddressStreamProvider.java:90) at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.<init>(UnixResolverDnsServerAddressStreamProvider.java:124) at io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parseSilently(UnixResolverDnsServerAddressStreamProvider.java:66) at io.netty.resolver.dns.DnsServerAddressStreamProviders.<clinit>(DnsServerAddressStreamProviders.java:32) at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:195) at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:158) at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:34) at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:192) at org.redisson.Redisson.<init>(Redisson.java:121) at org.redisson.Redisson.create(Redisson.java:158) at com.vanwardsmart.tools.RedisTool.init(RedisTool.java:53) at com.vanwardsmart.cloud.SmartServer.main(SmartServer.java:49)
设置了断点调试，发觉redission会读取/etc/resolv.conf文件，大概就说格式错误吧
可是这些地址格式是系统自动生成的，怎么回事
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While building the redisson locally, I am getting the following error:
[ERROR] /Users/mehul/projects/redisson/redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java:[57,5] error: cannot find symbol
[ERROR]   symbol:   class REntity
[ERROR]   location: class RedissonLiveObjectServiceTest
[ERROR] 
[ERROR] -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.7.0:testCompile (default-testCompile) on project redisson: Compilation failure
/Users/mehul/projects/redisson/redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java:[57,5] error: cannot find symbol
  symbol:   class REntity
  location: class RedissonLiveObjectServiceTest

    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:213)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)
    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)
    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)
    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)
    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)
    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)
    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)
    at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)
    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke (Method.java:498)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)
Caused by: org.apache.maven.plugin.compiler.CompilationFailureException: Compilation failure
/Users/mehul/projects/redisson/redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java:[57,5] error: cannot find symbol
  symbol:   class REntity
  location: class RedissonLiveObjectServiceTest

    at org.apache.maven.plugin.compiler.AbstractCompilerMojo.execute (AbstractCompilerMojo.java:1161)
    at org.apache.maven.plugin.compiler.TestCompilerMojo.execute (TestCompilerMojo.java:176)
    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:208)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:154)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:146)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)
    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)
    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)
    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)
    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)
    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)
    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:290)
    at org.apache.maven.cli.MavenCli.main (MavenCli.java:194)
    at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke (Method.java:498)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:289)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:229)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:415)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:356)
[ERROR] 
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException

In stable release version I can see 2.12.2 and 3.7.2, I am using 3.7.2 what is the purpose of other release 2.12.2, what is the difference between both.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When we use addAndGetAsync the value of key is incremented or decremented.
Actual behavior
RMap.readAllValues() should return values as 0-> 1, 1- >2 but instead returns values in the form og
0->"0", 1->"2" where the Number class is a string value.
Iterating through this collection causes a class cast exception.
Redis version
4.0.10
Redisson version
3.7.2
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently when we schedule the job with scheduleWithFixedDelay() method, it takes only initial delay and delay. But if I do this then this will keep running the job forever. I think there should be version of scheduleWithFixedDelay() method which supports endTime as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Classloader passed into CustomObjectInputStream is not used to load proxied classes.
In my case redisson cant deserialize org.springframework.security.oauth2.client.token.AccessTokenRequest class
Actual behavior
Following exception is thrown during class loading:
Caused by: java.lang.ClassNotFoundException: org.springframework.security.oauth2.client.token.AccessTokenRequest
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:348)
at java.io.ObjectInputStream.resolveProxyClass(ObjectInputStream.java:698)
at java.io.ObjectInputStream.readProxyDesc(ObjectInputStream.java:1559)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1515)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1774)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)
Steps to reproduce or test case
Redis version
4.x
Redisson version
3.6.5
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
这个我的配置
@bean
public RedissonClient singleRedissonLock () throws URISyntaxException {
Config config = new Config();
config.useSingleServer()
.setAddress("redis://" + ip + ":" + port)
.setConnectTimeout(500)
.setPassword(StringUtils.defaultIfEmpty(password, null));
return Redisson.create(config);
}
获取锁
`@Resource
private RedissonClient redisson;
@Override
public WorPtLock lockWaitAMoment(int workOrderId, String itemId, String tenantId, Long millisecond) {
    if (millisecond == null || millisecond <= 0) {
        millisecond = A_MOMENT;
    }
    WorPtLock worPtLock = new WorPtLock(workOrderId, itemId, tenantId);
    try {
        RLock lock = redisson.getLock(worPtLock.buildLockKey());
        boolean b = lock.tryLock(millisecond, TimeUnit.MILLISECONDS);
        if (b) {
            worPtLock.setLock(lock);
            worPtLock.setSuccess(true);
            logger.error("加锁中=====threadname:【{}】。。。。。key【{}】---{}", Thread.currentThread().getName(), worPtLock.buildLockKey(), i);
        } else {
            logger.error("加锁失败=====threadname:【{}】。。。。。key【{}】---{}", Thread.currentThread().getName(), worPtLock.buildLockKey(), i);
            worPtLock.setSuccess(false);
        }
    } catch (Exception e) {
        logger.error("获取锁失败,生产单id:{},itemID:{}", workOrderId, itemId);
        worPtLock.setSuccess(false);
    }
    return worPtLock;
}`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I was working with multimaps and wondered, while they have a cache variant, why don't they have a locally cached variant?
If nothing speaks against it, could one be added?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
no expcetion
Actual behavior
java.lang.NumberFormatException: For input string: "QUEUED"
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:343)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:170)
at org.redisson.command.CommandBatchService.execute(CommandBatchService.java:361)
at org.redisson.RedissonBatch.execute(RedissonBatch.java:267)
at som.executors.basic.RedissonTest.transactionTest(RedissonTest.java:38)
Caused by: java.lang.NumberFormatException: For input string: "QUEUED"
at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043)
at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
at java.lang.Double.parseDouble(Double.java:538)
at java.lang.Double.valueOf(Double.java:502)
at org.redisson.client.protocol.convertor.DoubleReplayConvertor.convert(DoubleReplayConvertor.java:25)
at org.redisson.client.protocol.convertor.DoubleNullSafeReplayConvertor.convert(DoubleNullSafeReplayConvertor.java:27)
at org.redisson.client.protocol.convertor.DoubleNullSafeReplayConvertor.convert(DoubleNullSafeReplayConvertor.java:23)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:434)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:295)
at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:229)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:135)
Steps to reproduce or test case
    RBatch batch = redissonClient.createBatch(BatchOptions.defaults().executionMode(BatchOptions.ExecutionMode.REDIS_WRITE_ATOMIC));

    batch.getScoredSortedSet("myZKey").addScoreAsync("abc", 1d);

    batch.execute();

Redis version
redis_version:4.0.7
Redisson version
Redisson 3.7.2
Redisson configuration
    Config config = new Config();
    config.setCodec(new StringCodec());
    config.useSingleServer()
            .setAddress("redis://localhost:6379")
            .setConnectionMinimumIdleSize(1)
            .setConnectionPoolSize(1);

    RedissonClient redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一台物理机上多tomcat实例可用，多台物理机每台上一个Tomcat实例无法共享Session是怎么回事？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一台机器多tomcat实例可以，多台机器不行，请问应该如何实现
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
add new field to RLO, use get method will get default value.
Actual behavior
throw java.lang.NullPointerException: null
Steps to reproduce or test case
step 1:
@REntity
@Data
@NoArgsConstructor
@JsonIgnoreProperties(value = {"redisson_live_object"})
public class DeviceStatus {
  @RId
  @JsonIgnore
  private String uniqueId;
}
step 2:
use this object to store object to Redis
step 3:
add new private int temperature; to RLO,then call DeviceStatus.getTemperature() will throw a NullPointerException.
Redis version
latest
Redisson version
3.5.4
Redisson configuration
singleServerConfig:
    idleConnectionTimeout: 10000
    pingTimeout: 1000
    connectTimeout: 10000
    timeout: 3000
    retryAttempts: 3
    retryInterval: 1500
    reconnectionTimeout: 3000
    failedAttempts: 3
    password: 111111
    subscriptionsPerConnection: 5
    clientName: null
    address: "redis://ip:port"
    subscriptionConnectionMinimumIdleSize: 1
    subscriptionConnectionPoolSize: 50
    connectionMinimumIdleSize: 10
    connectionPoolSize: 64
    database: 0
    dnsMonitoring: false
    dnsMonitoringInterval: 5000
threads: 0
nettyThreads: 0
#codec: !<org.redisson.codec.JsonJacksonCodec> {}
codec: !<org.redisson.client.codec.StringCodec> {}
useLinuxNativeEpoll: false


Log
2018-06-29 18:38:58 ERROR [http-nio-8080-exec-3] o.a.c.c.C.[.[.[.[dispatcherServlet] 181 - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause
java.lang.NullPointerException: null
	at com.parkbox.domain.DeviceStatus$ByteBuddy$BH8xEsX8.getDstSwitch(Unknown Source)
	at com.parkbox.service.impl.DeviceShadowServiceImpl.getDstSwitch(DeviceShadowServiceImpl.java:411)
	at com.parkbox.service.impl.DeviceStatusServiceImpl.handleTvAppSensor(DeviceStatusServiceImpl.java:139)
	at com.parkbox.service.impl.DeviceStatusServiceImpl$$FastClassBySpringCGLIB$$7118bd92.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:669)
	at com.parkbox.service.impl.DeviceStatusServiceImpl$$EnhancerBySpringCGLIB$$66332b32.handleTvAppSensor(<generated>)
	at com.parkbox.api.ReportController.tvAppSensor(ReportController.java:34)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:661)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
no exception
Actual behavior
19:40:15.066 [redisson-netty-1-2] ERROR o.r.c.handler.CommandPubSubDecoder - Unable to decode data. channel: [id: 0xcecad86a, L:/172.16.249.185:50579 - R:172.16.116.163/172.16.116.163:6379] message: *3
$11
unsubscribe
$18
redisson_sc:{test}
:0
java.util.concurrent.RejectedExecutionException: Task org.redisson.client.handler.CommandPubSubDecoder$2@7b1dcdb0 rejected from java.util.concurrent.ThreadPoolExecutor@44cda025[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1]
at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
at org.redisson.client.handler.CommandPubSubDecoder.enqueueMessage(CommandPubSubDecoder.java:127)
at org.redisson.client.handler.CommandPubSubDecoder.decodeResult(CommandPubSubDecoder.java:90)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:419)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:371)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:111)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
Steps to reproduce or test case
RSemaphore example
public static void main(String[] args) throws InterruptedException {
    Config config = new Config();
    config.useSingleServer()
            .setAddress("redis://172.16.116.163:" + REDIS_DEFAULT_PORT);

    RedissonClient redisson = Redisson.create(config);

    RSemaphore s = redisson.getSemaphore("test");
    s.trySetPermits(5);
    s.acquire(3);

    Thread t = new Thread() {
        @Override
        public void run() {
            RSemaphore s = redisson.getSemaphore("test");
            s.release();
            s.release();
        }
    };

    t.start();

    s.acquire(4);

    redisson.shutdown();
}

Redis version
4.0.7
Redisson version
Redisson 3.7.2
Redisson configuration
view example
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko @jackygurui
Job class
public class HttpJob implements Runnable {

    HttpClient client;

    public HttpJob() {

    }

    public HttpJob(HttpClient client) {
        this.client = client;
    }

    @Override
    public void run() {

        String url = "http://localhost:3000";
        HttpGet request = new HttpGet(url);

        HttpResponse response = null;
        try {
            response = client.execute(request);
            System.out.println("Response Code : " + response.getStatusLine().getStatusCode());
            System.out.println(response.getStatusLine());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
I am running Redisson Nodes in standalone mode, at the time of execution of this job, I am getting following error.
[redisson-3-23] ERROR org.redisson.RedissonRemoteService - Can't execute: RemoteServiceRequest [requestId=010acb018185e3786b777fe305e192b32f, methodName=schedule, signatures=[[java.lang.String, [B, [B, long, java.lang.String, java.lang.String, java.lang.String]], args=[com.webengage.HttpJob, [B@1742e1f, [B@395ed74f, 1530533820000, 0 47 17 2 JUL ? 2018, 15728f50-6654-4c4e-b45a-39ccf60fa8f3, 010acb018185e3786b777fe305e192b32f], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1530533769834]
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:347)
	at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:66)
	at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:312)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalArgumentException: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:281)
	at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:130)
	... 13 more
Caused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter
	at org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:256)
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:274)
	... 14 more
Caused by: com.fasterxml.jackson.databind.JsonMappingException: No suitable constructor found for type [simple type, class org.apache.http.impl.client.InternalHttpClient]: can not instantiate from JSON object (missing default constructor or creator, or perhaps need to add/enable type information?)
 at [Source: io.netty.buffer.ByteBufInputStream@63e0c28d; line: 1, column: 103] (through reference chain: HttpJob["client"])
	at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:256)
	at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1134)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:298)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:168)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:120)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:91)
	at com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserializeWithType(AbstractDeserializer.java:142)
	at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:493)
	at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:163)
	at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:120)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:91)
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:163)
	at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:554)
	at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:63)
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3807)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2867)
	at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:92)
	at org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:252)
	... 15 more

How can I inject such dependencies in redisson, I think this use case is quite natural, and should be definitely be accommodated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
实际通过nginx在一台机器上模拟多服务测试﻿
Expected behavior
多应用服务可以实现session共享，redis记录session数据，正常访问系统
Actual behavior
可以实现session共享redis记录数据，但是访问系统速度变慢
Steps to reproduce or test case
实际操作按照下面操作配置
https://github.com/redisson/redisson/wiki/14.-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88#145-tomcat%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%99%A8tomcat-session-manager
Redis version
4.0.9
Redisson version
3.4.3
Tomcat version
8.5.28
Redisson configuration
Tomcat config配置文件
singleServerConfig:
  address: redis://127.0.0.1:6379
  password: asd123qwe

redisson config
redisson:
    address: redis://127.0.0.1:6379
    password: asd123qwe
    thread: 4
    codec: org.redisson.client.codec.StringCodec
    connectionMinimumIdleSize: 12
    idleConnectionTimeout: 10000
    pingTimeout: 1000
    connectTimeout: 10000
    timeout: 3000
    retryAttempts: 2
    retryInterval: 1500
    reconnectionTimeout: 3000
    failedAttempts: 2
    subscriptionsPerConnection: 5
    clientName: firstClient
    subscriptionConnectionMinimumIdleSize: 1
    subscriptionConnectionPoolSize: 5
    connectionPoolSize: 64
    database: 0
    dnsMonitoring: false
    dnsMonitoringInterval: 5000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior

'readonly' command should not go to master everytime i send read operation.
'readonly' command is going to master or slave only onetime at first when making connection.

Actual behavior

'readonly' command is going to master everytime when i send read operation.
because of added 'readonly' command, master is not distributed throughput

Steps to reproduce or test case

make Redissonclient with ReadMode.MasterSlave
send read operation
redissonClient.eval(Mode.ReadOnly, "return redis.call('get', 'something')"...
'monitor' in redis console.
master node=>
'readonly'
[lua] return redis.call('get'.....
slave node =>
[lua] return redis.call('get'.....

Redis version
4.0.10
Redisson version
2.12.3  6/28 latest version with java7
Redisson configuration
AWS elasticache redis cluster enabled
Shard : 1 master / 1 slave
useClusterMode()
ReadMode : Master_Slave
command : eval(Mode.ReadOnly, "return redis.call('get',......
** actually, read operation is distributed propery, but master node get plus 'readonly' command. even though 'readonly' comman is not working at master node and not affecting anything functionally.
however this is big problem which increase throughput and cpu utilization on master node. finally, it is same as not distributed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I want to create a simple scheduled task with redisson & kotlin.
My Task:
class IncrementRunnableTask(private var counterName: String) : Runnable {

    @RInject
    lateinit var redisson: RedissonClient

    override fun run() {
        redisson.getAtomicLong(counterName).incrementAndGet()
    }

}

My Test:
    @Autowired
    lateinit var redissonClient: RedissonClient

    private lateinit var node: RedissonNode

    @Before
    fun setup() {
        val nodeConfig = RedissonNodeConfig(this.redissonClient.config)
        nodeConfig.executorServiceWorkers = Collections.singletonMap("test", 1)
        node = RedissonNode.create(nodeConfig);
        node.start()
    }

    @After
    fun after() {
        node.shutdown();
    }

    @Test
    @Throws(Exception::class)
    fun testRedisson() {
        val executor = redissonClient.getExecutorService("test", ExecutorOptions.defaults().taskRetryInterval(10, TimeUnit.SECONDS))
        val f = executor.schedule(IncrementRunnableTask("counter"), 1, TimeUnit.SECONDS)
        f.get()
        assertThat(redissonClient.getAtomicLong("counter").get()).isEqualTo(1)
    }


Actual behavior
I get an exception everytime
java.lang.reflect.InvocationTargetException: null
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171]
	at org.redisson.RedissonRemoteService.invokeMethod(RedissonRemoteService.java:347) [redisson-3.7.3.jar:na]
	at org.redisson.RedissonRemoteService.access$400(RedissonRemoteService.java:66) [redisson-3.7.3.jar:na]
	at org.redisson.RedissonRemoteService$2.run(RedissonRemoteService.java:312) [redisson-3.7.3.jar:na]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_171]
	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) [na:1.8.0_171]
	at java.util.concurrent.FutureTask.run(FutureTask.java) [na:1.8.0_171]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_171]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_171]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.25.Final.jar:4.1.25.Final]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]
Caused by: java.lang.IllegalArgumentException: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:281) ~[redisson-3.7.3.jar:na]
	at org.redisson.executor.TasksRunnerService.scheduleRunnable(TasksRunnerService.java:174) ~[redisson-3.7.3.jar:na]
	... 14 common frames omitted
Caused by: java.lang.IllegalStateException: Unable to initialize codec with ClassLoader parameter
	at org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:256) ~[redisson-3.7.3.jar:na]
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:274) ~[redisson-3.7.3.jar:na]
	... 15 common frames omitted
Caused by: com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 25]
	at com.fasterxml.jackson.databind.exc.InvalidTypeIdException.from(InvalidTypeIdException.java:43) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.DeserializationContext.missingTypeIdException(DeserializationContext.java:1638) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.DeserializationContext.handleMissingTypeId(DeserializationContext.java:1217) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._handleMissingTypeId(TypeDeserializerBase.java:300) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:164) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:105) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:193) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013) ~[jackson-databind-2.9.6.jar:2.9.6]
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070) ~[jackson-databind-2.9.6.jar:2.9.6]
	at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:92) ~[redisson-3.7.3.jar:na]
	at org.redisson.executor.TasksRunnerService.decode(TasksRunnerService.java:252) ~[redisson-3.7.3.jar:na]
	... 16 common frames omitted


Steps to reproduce or test case
Redis version
4.0.10
Redisson version
3.7.3
Redisson configuration
    fun redissonClient(): RedissonClient {
        return Redisson.create()
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
配置信息
1, lib/
redisson-all-2.11.3.jar
redisson-tomcat-7-2.12.0.jar

2,conf/content.xml

3,conf/redisson.json

项目在tomcat 部署后，系统正常启动

如果在执行reload 功能后，前端再调用后台服务时error发生了。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
when i use redissonClient.getMapCache，put any key. get error :ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression. only in aliyun redis.
aliyun redis must uses KEYS array in lua. Can you give me some suggestions？
Steps to reproduce or test case
Redis version
Redisson version
2.12.3
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Probably throwing an alert message or slow down but not stuck in infinite cycle.
Actual behavior
Stops executing commands
A lot of exceptions logged
Exception in thread "pool-12-thread-3" org.redisson.client.RedisTimeoutException: Redis server response timeout (1000 ms) occured for command: (LLEN) with params: [purchase_queue_ravil2] channel: [id: 0x9a34862a, L:/192.168.50.135:57482 - R:/192.168.50.167:6380] at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:690) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466) at java.lang.Thread.run(Thread.java:745) Exception in thread "pool-10-thread-3" Exception in thread "pool-12-thread-4" Exception in thread "pool-10-thread-6" Exception in thread "pool-10-thread-2" Exception in thread "pool-10-thread-1" Exception in thread "pool-10-thread-4" Exception in thread "pool-11-thread-1" Exception in thread "pool-12-thread-2" Exception in thread "pool-10-thread-7" Exception in thread "pool-12-thread-1" Exception in thread "pool-10-thread-8" Exception in thread "pool-10-thread-5" org.redisson.client.RedisTimeoutException: Redis server response timeout (1000 ms) occured for command: (LLEN) with params: [purchase_queue_ravil2] channel: [id: 0xc7338ee0, L:/192.168.50.135:57485 - R:/192.168.50.167:6380] at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:690) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466) at java.lang.Thread.run(Thread.java:745) org.redisson.client.RedisTimeoutException: Redis server response timeout (1000 ms) occured for command: (EVAL) with params: [local value = redis.call('get', KEYS[1]); assert(value ~= false, 'Capacity of queue ' .. KEYS[1] .. ..., 2, redisson_bqs:{purchase_queue_ravil2}, purchase_queue_ravil2, 1, PooledUnsafeDirectByteBuf(ridx: 0, widx: 303, cap: 512)] channel: [id: 0xf5b3b299, L:/192.168.50.135:57496 - R:/192.168.50.167:6380] at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:690) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466) at java.lang.Thread.run(Thread.java:745) org.redisson.client.RedisTimeoutException: Redis server response timeout (1000 ms) occured for command: (EVAL) with params: [local value = redis.call('get', KEYS[1]); assert(value ~= false, 'Capacity of queue ' .. KEYS[1] .. ..., 2, redisson_bqs:{purchase_queue_ravil2}, purchase_queue_ravil2, 1, PooledUnsafeDirectByteBuf(ridx: 0, widx: 303, cap: 512)] channel: [id: 0x099dd057, L:/192.168.50.135:57495 - R:/192.168.50.167:6380] at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:690) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466) at java.lang.Thread.run(Thread.java:745)
Thread dump
`"redisson-netty-1-8" #25 prio=5 os_prio=31 tid=0x00007fc41d599800 nid=0x6503 runnable [0x0000700004eed000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x00000007404cc4f8> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x000000074050c1c8> (a java.util.Collections$UnmodifiableSet)
- locked <0x00000007404cc458> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-7" #24 prio=5 os_prio=31 tid=0x00007fc41c3b3000 nid=0x6303 runnable [0x0000700004dea000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x000000074050c428> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x000000074050c440> (a java.util.Collections$UnmodifiableSet)
- locked <0x000000074050c3d8> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-6" #23 prio=5 os_prio=31 tid=0x00007fc41c1b1800 nid=0x6103 runnable [0x0000700004ce7000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x00000007404c5098> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x00000007404783d8> (a java.util.Collections$UnmodifiableSet)
- locked <0x00000007404c4ff8> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-5" #22 prio=5 os_prio=31 tid=0x00007fc41c4f9800 nid=0x5f03 runnable [0x0000700004be4000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x0000000740478638> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x0000000740478650> (a java.util.Collections$UnmodifiableSet)
- locked <0x00000007404785e8> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-4" #21 prio=5 os_prio=31 tid=0x00007fc41df13000 nid=0x5d03 runnable [0x0000700004ae1000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x00000007405da7d0> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x00000007405da7e8> (a java.util.Collections$UnmodifiableSet)
- locked <0x00000007405da780> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-3" #20 prio=5 os_prio=31 tid=0x00007fc41deba800 nid=0x5b03 runnable [0x00007000049de000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x000000074064b300> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x000000074064b318> (a java.util.Collections$UnmodifiableSet)
- locked <0x000000074064b2b0> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-2" #19 prio=5 os_prio=31 tid=0x00007fc41d1a3800 nid=0x5903 runnable [0x00007000048db000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x000000074051aee8> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x00000007406a6880> (a java.util.Collections$UnmodifiableSet)
- locked <0x0000000740515e38> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None
"redisson-netty-1-1" #17 prio=5 os_prio=31 tid=0x00007fc41d9a3000 nid=0x1107 runnable [0x0000700003213000]
java.lang.Thread.State: RUNNABLE
at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
- locked <0x000000074058dbb8> (a io.netty.channel.nio.SelectedSelectionKeySet)
- locked <0x00000007406a6bd8> (a java.util.Collections$UnmodifiableSet)
- locked <0x000000074058daa8> (a sun.nio.ch.KQueueSelectorImpl)
at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:756)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:411)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Locked ownable synchronizers:
- None`
Steps to reproduce or test case

Make a slow docker image for redis 4.0.10 docker run -p 6380:6379 -m 100m --cpus=".5" redis:latest
Write junit test for RBoundedBlockingQueue and run them from remote instance.


Test example below

public static final int TIMEOUT = 1000;
public static final int ATTEMPTS = 1;

private static final RedissonClient redissonClient = RedissonClientFactory
    .getRedissonClient(TIMEOUT, ATTEMPTS);

private static final String QUEUE_NAME = "queue_test";
private static final RBoundedBlockingQueue<Runnable> queue = redissonClient.getBoundedBlockingQueue(QUEUE_NAME);

static class TaskWrite implements Runnable {

    Integer id;

    public TaskWrite(Integer id) {
        this.id = id;
    }

    @Override
    public void run() {
        while (true) {
            SomeTask someTask = new SomeTask("1", "2", id, "3",
                Collections.emptyMap(), Collections.emptyMap());
            queue.offer(someTask);
        }
    }
}

static class TaskRead implements Runnable {

    @Override
    public void run() {
        while (true) {
            queue.poll();
        }
    }
}

static class TaskLLen implements Runnable {

    @Override
    public void run() {
        int i = 0;
        while (true) {
            int size = queue.size();
            if (i % 250 == 0) {
                System.out.println(queue.size());
                i = 0;
            }
            i++;
        }
    }
}

@Test
public void test() throws InterruptedException {

    System.out.println("Remaining capacity: " + queue.remainingCapacity());
    System.out.println("Try set capacity: " + queue.trySetCapacity(5));

    ExecutorService writer = Executors.newFixedThreadPool(8);
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));
    writer.execute(new TaskWrite(1));

    ExecutorService reader = Executors.newFixedThreadPool(1);
    reader.execute(new TaskRead());

    ExecutorService llen = Executors.newFixedThreadPool(4);
    llen.execute(new TaskLLen());
    llen.execute(new TaskLLen());
    llen.execute(new TaskLLen());
    llen.execute(new TaskLLen());

    Thread.sleep(1000000);
}

Redis version
Redis 4.0.10
Redisson version
Redisson 3.7.3
Redisson configuration

{
"singleServerConfig": {
"idleConnectionTimeout": 10000,
"pingTimeout": 1000,
"connectTimeout": 1000,
"timeout": 1000,
"retryAttempts": 1,
"retryInterval": 1500,
"subscriptionsPerConnection": 5,
"sslEnableEndpointIdentification": true,
"sslProvider": "JDK",
"pingConnectionInterval": 10000,
"keepAlive": true,
"tcpNoDelay": false,
"address": "redis://192.168.50.167:6380",
"subscriptionConnectionMinimumIdleSize": 1,
"subscriptionConnectionPoolSize": 50,
"connectionMinimumIdleSize": 32,
"connectionPoolSize": 64,
"database": 0,
"dnsMonitoringInterval": 5000
},
"threads": 0,
"nettyThreads": 0,
"codec": {
"class": "org.redisson.codec.JsonJacksonCodec"
},
"referenceCodecProvider": {
"class": "org.redisson.codec.DefaultReferenceCodecProvider"
},
"referenceEnabled": true,
"transportMode": "NIO",
"lockWatchdogTimeout": 30000,
"keepPubSubOrder": true,
"addressResolverGroupFactory": {
"class": "org.redisson.connection.DnsAddressResolverGroupFactory"
},
"useLinuxNativeEpoll": false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
自己加进去一直锁不住，看下哪里有问题么
@RequestMapping(value="/testLock")
@ResponseBody
public Object testLock(){
	String name = "rMap";
	RMap<String, Integer> intMap = redissonService.getRMap(name);
	RLock lock = redissonService.getRLock(name);
	try{
		// 1. 最常见的使用方法
		//lock.lock();
		// 2. 支持过期解锁功能,10秒钟以后自动解锁, 无需调用unlock方法手动解锁
		//lock.lock(10, TimeUnit.SECONDS);
		// 3. 尝试加锁，最多等待3秒，上锁以后10秒自动解锁
		boolean res = lock.tryLock(3, 10, TimeUnit.SECONDS);
		if(res){ //成功
			Integer num = intMap.get("num");
			if(num==null){
				num=0;
			}else{
				num++;
			}
			System.out.println(" 写入 "+intMap. putIfAbsent("num", num));
		}
	} catch (InterruptedException e) {
		e.printStackTrace();
	} finally {
		lock.unlock();
	}
	System.out.println(intMap.get("num"));
	return intMap;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
3.8.1
Redisson configuration
Because the file https://github.com/redisson/redisson/blob/master/redisson-spring-boot-starter/src/main/resources/META-INF/spring.factories is encoded as UTF-8+ BOM instead of Utf-8. Causes PropertyLoaderUtils.loadProperties(resource); reading this file is garbled.
the key of the property as follows :
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exception thrown if Redis-server is down, causes apps to stop working.
This might be an intended behavior, but the presence of the centralized session backup is not mission critical for our system (only used for failover). But using this session manager will actually introduce a new critical error to our system, when/if the Redis server goes down.
A flag/setting where communication errors with Redis would be logged instead of causing a "crash" would be highly appreciated.
Expected/Wanted behavior
Tomcat uses the local session to service the request and ignores any store/find session issues related to communication with Redis-server.
Actual behavior
An Exception is thrown.
Steps to reproduce or test case
Load a page on tomcat where a session is created and attribute is added to it. Turn of Redis-server and reload the page.
Redis version
3.0.6
Redisson version
3.7.5
Redisson configuration
Manager is set up with readMode="MEMORY" and updateMode="DEFAULT"

singleServerConfig:
address: "redis://localhost:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 32
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
transportMode: "EPOLL"
useLinuxNativeEpoll: true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I'm using LZ4Codec to serialize and deserialize my data. I'm noticing some unclosed streams which are wasting a lot of heap space.
private Codec compositeCodec = new CompositeCodec(new StringCodec(), new LZ4Codec(),  new SerializationCodec()); RLocalCachedMap<String, CachedObject> simpleMap = (RLocalCachedMap<String, CachedObject>) redisson.getLocalCachedMap("simpleMap", compositeCodec);
These are the screenshots from the heap dump I took which shows the problem.



Actual behavior
Steps to reproduce or test case

Using RLocalCacheMap and Composite Codec try to serialize and deserialize a few 100 objects. Do not shutdown redisson.

Redis version
4.0.1
Redisson version
2.13.1
Redisson configuration
SingleServer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I am trying to connect to redis it takes around 2 seconds. This started happening after I upgraded to 3.8.1 maven. This is the code used to connect. I initialize the connection every single time and close it down. Is there something I am doing wrong or is this a bug.
`RedissonClient redisson = null;
Config config = new Config();
config.useSingleServer().setAddress("redis://...:6379").setPassword("Password");
redisson = Redisson.create(config);
redisson.shutdown();
`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When RedisTimeoutException occurs just throw the exception to the user code without printing any warning messages or at least do not include result of the GET command
Actual behavior
We are storing sensitive data in redis cache. On rare occasions when GET command fails on timeout org.redisson.client.handler.CommandDecoder#completeResponse method prints warning message containing the command result which in our case is sensitive data stored in our redis cache
this is happening here : org/redisson/redisson/3.7.3/redisson-3.7.3-sources.jar!/org/redisson/client/handler/CommandDecoder.java:442
Since our code is also using slf4j for logging, this warning message is printed to the same file as other log messages and then is flushed to our log managing server.
At this point we don't have control on this data and thus it will appear in our logging server. Due to GDPR concerns and inner regulations in our company we need to anonymize all user data stored in our systems, but it is hard to do when we have no control on the data dispatched to logs.
While we will seek how to patch this for now, we think that other redisson customers could suffer from the same problem as we are and kindly ask you to remove sensitive contents from warning messages or set log message level to trace or debug or allow user code to control this.
example:
2018-09-22 01:57:16.647,level="WARN",cls="o.r.c.h.CommandDecoder",thread="redisson-netty-4-13",..skipped some of our mdc context, line="response has been skipped due to timeout! channel: [id: 0xdf4f4091, L:/<ip_1(let me know if you need this info)>:36660 - R:<ip_2>/<ip_3>:15001], command: (GET), params: [<redis_key>], result: {sensitive user data in JSON format}",exc=""
Steps to reproduce or test case
It would be easy enough to reproduce timeout - just reduce it to 1ms, but I'm not sure how to reproduce that result will be available after timeout. But even if result is not available warning message will be dispatched, so since we are requesting eliminate warning messages/allow disabling them it would suffice
Redis version
Redis version: 3.2.7
Redisson version
Redisson version: 3.7.3
Redisson configuration
{
  "clusterServersConfig":{
    "password": "our password",
    "nodeAddresses": ["rediss://<our_redis_endpoint_in_azure_redis_cache>:<redis_port>"],
    "sslEnableEndpointIdentification": true
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson serialization will write class information by default, I want to write it with fastjson, but I don't know how to write
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When submitting runnable as anonymous class we fail on NPE in getClassBody method
Actual behavior
Caused by: java.lang.NullPointerException
	at java.io.FilterInputStream.available(FilterInputStream.java:167) ~[?:?]
	at org.redisson.RedissonExecutorService.getClassBody(RedissonExecutorService.java:387) ~[redisson-3.8.1.jar:?]
	at org.redisson.RedissonExecutorService.scheduleWithFixedDelayAsync(RedissonExecutorService.java:899) ~[redisson-3.8.1.jar:?]
	at org.redisson.RedissonExecutorService.scheduleWithFixedDelay(RedissonExecutorService.java:889) ~[redisson-3.8.1.jar:?]

Steps to reproduce or test case
redissonClient.getExecutorService(name).scheduleWithFixedDelay(() -> do something, 1, 1, TimeUnit.SECONDS)
Redis version
Redisson version
3.8.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is it possible to access spring beans from within executor service tasks somehow?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Similarly to #889
at sun.misc.Unsafe.park(Native Method)
-  waiting on java.util.concurrent.CountDownLatch$Sync@f2899ce
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:152)
at org.redisson.RedissonObject.get(RedissonObject.java:75)
at org.redisson.RedissonMap.get(RedissonMap.java:251)
Expected behavior
throw exception
Actual behavior
Thread indefinitely park
Steps to reproduce or test case

Using RMapCache and configure maploader to DB(oracle).
Shutdown DB,
3.RMapCache get operation will be blocked.

Redis version
any
Redisson version
3.6.0
Redisson configuration
standalone
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
If it's not possible to acquire a permission before timeout elapses, tryAcquire should return a boolean false.
Actual behavior
Even if the timeout elapses, the method tryAcquire keeps blocked
Steps to reproduce or test case
@Test
    public void testTryAcquire() {
        RRateLimiter rr = redisson.getRateLimiter("acquire");
        assertThat(rr.trySetRate(RateType.OVERALL, 1, 5, RateIntervalUnit.SECONDS)).isTrue();

        rr.tryAcquire(1, 1, TimeUnit.SECONDS);
        rr.tryAcquire(1, 1, TimeUnit.SECONDS);
        assertThat(rr.tryAcquire()).isFalse();

    }

Redis version
4.0.2
Redisson version
3.8.2-SNAPSHOT
Redisson configuration
standalone
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have Redis cluster with 6 nodes (3 masters and 3 slaves), and using redisson 3.6.5. In redisson cluster setting, we applied default value (SLAVE ) on readMode.
Here are some questions on this setting:


What will happen if one of slave node fails? Will redisson detect the error and switch to master on Read, or it will try to connect to Slave only and throw exception?


If we use MASTER_SLAVE, read operation will go to master/slave randomly or it has a way to go to slave first, and then master when slave fails?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Calling RBatchReactive.execute() should complete successfully.
Actual behavior
RBatchReactive.execute() triggers a ClassCastException to be thrown from org.redisson.command.CommandBatchService.handleSuccess(CommandBatchService.java:224) with the message of org.redisson.misc.RedissonPromise cannot be cast to org.redisson.command.BatchPromise
Steps to reproduce or test case
This was occurring in some code that looks like the following gist: https://gist.github.com/orclev/2e70b1bc269d30d79121fd1e3c6da047
Due to the nature of the code in question so mild anonymization has been applied to it.
Redis version
4.0.10
Redisson version
3.7.5
Redisson configuration
1 master, 2 replicas.
config.useReplicatedServers()
                    .setTimeout(5000)
                    .setRetryAttempts(15)
                    .setMasterConnectionPoolSize(512)
                    .setMasterConnectionMinimumIdleSize(64)
                    .setSlaveConnectionPoolSize(1025)
                    .setSlaveConnectionMinimumIdleSize(128)
                    .setSubscriptionConnectionPoolSize(16)
                    .setSubscriptionConnectionMinimumIdleSize(1)
                    .setRetryInterval(500)
                    .addNodeAddress(redisHosts.stream()
                            .map(host -> "redis://" + host + ":" + redisPort)
                            .collect(Collectors.toList())
                            .toArray(new String[] {}));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
putAllAsync() itself should take care of the batch size, or at least allow the user to provide some chunk size. Increasing direct memory allocation is not a permanent solution because the input map size is indefinite.
Actual behavior
When large number of objects are passed to RMap#putAllAsync(), the following exception is thrown:
Exception in thread "Pool Worker - 16" io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 50331648 byte(s) of direct memory (used: 1070716308, max: 1118830592)
        at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:640)
        at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:594)
        at io.netty.buffer.PoolArena$DirectArena.allocateDirect(PoolArena.java:764)
        at io.netty.buffer.PoolArena$DirectArena.newUnpooledChunk(PoolArena.java:754)
        at io.netty.buffer.PoolArena.allocateHuge(PoolArena.java:260)
        at io.netty.buffer.PoolArena.allocate(PoolArena.java:231)
        at io.netty.buffer.PoolArena.reallocate(PoolArena.java:397)
        at io.netty.buffer.PooledByteBuf.capacity(PooledByteBuf.java:118)
        at io.netty.buffer.AbstractByteBuf.ensureWritable0(AbstractByteBuf.java:285)
        at io.netty.buffer.AbstractByteBuf.ensureWritable(AbstractByteBuf.java:265)
        at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1048)
        at io.netty.buffer.ByteBufOutputStream.write(ByteBufOutputStream.java:68)
        at java.io.ObjectOutputStream$BlockDataOutputStream.drain(ObjectOutputStream.java:1876)
        at java.io.ObjectOutputStream$BlockDataOutputStream.setBlockDataMode(ObjectOutputStream.java:1785)
        at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1188)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:347)
        at org.redisson.codec.SerializationCodec$2.encode(SerializationCodec.java:67)
        at org.redisson.codec.LZ4Codec$2.encode(LZ4Codec.java:90)
        at org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:256)
        at org.redisson.RedissonMap.putAllOperationAsync(RedissonMap.java:332)
        at org.redisson.RedissonMap.putAllAsync(RedissonMap.java:273)
        at ...

Redis version
4.0.11
Redisson version
2.13.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to use Spring Actuator with redis as a single server but I'm getting UnsupportedOperationException at RedisHealthCheck so the application is considering redis DOWN
Expected behavior
Actuator is able to perform health checks to determine the status of Redis server
Actual behavior
java.lang.UnsupportedOperationException is thrown when Actuator tries to do the Redis health check
Steps to reproduce or test case
Add spring actuator to project
Configure RedissonClient as a single server (default configuration from here https://github.com/redisson/redisson/wiki/2.-Configuration#26-single-instance-mode can be used)
Start the application with health check enabled
Redis version
redis_version:4.0.9
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:d3ebfc7feabc1290
redis_mode:standalone
Redisson version
redisson-3.8.1
Redisson configuration
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":32,
"connectionPoolSize":64,
"database":0,
"dnsMonitoringInterval":5000
},
"threads":0,
"nettyThreads":0,
"codec":{
"class":"org.redisson.codec.JsonJacksonCodec"
},
"transportMode":"NIO"
}
redisson-stack-trace.log
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since started to use the parameter pingConnectionInterval after a while the service being up we start getting the following errors on all redis operations:
RedisConnection@1983198386 [redisClient=[addr=redis://100.65.5.107:6379], channel=[id: 0x66c3b445, L:/172.17.0.6:58200 ! R:100.65.5.107/100.65.5.107:6379]] is not active! org.redisson.client.RedisConnectionException: RedisConnection@1983198386 [redisClient=[addr=redis://100.65.5.107:6379], channel=[id: 0x66c3b445, L:/172.17.0.6:58200 ! R:100.65.5.107/100.65.5.107:6379]] is not active! at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:323) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.ConnectionPool.connectTo(ConnectionPool.java:253) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.ConnectionPool.access$300(ConnectionPool.java:53) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.ConnectionPool$3.run(ConnectionPool.java:214) ~[redisson-3.8.1.jar:?] at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:142) ~[redisson-3.8.1.jar:?] at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:125) ~[redisson-3.8.1.jar:?] at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:134) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:161) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:224) ~[redisson-3.8.1.jar:?] at org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:41) ~[redisson-3.8.1.jar:?] at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:450) ~[redisson-3.8.1.jar:?] at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:543) ~[redisson-3.8.1.jar:?] at org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:681) ~[redisson-3.8.1.jar:?] at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:536) ~[redisson-3.8.1.jar:?] at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:625) ~[redisson-3.8.1.jar:?] at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670) ~[netty-common-4.1.29.Final.jar:4.1.29.Final] at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745) ~[netty-common-4.1.29.Final.jar:4.1.29.Final] at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473) ~[netty-common-4.1.29.Final.jar:4.1.29.Final] at java.lang.Thread.run(Thread.java:844) [?:?] 
Eventually leading to messages of the type:
o.r.c.p.SlaveConnectionPool - slave 100.65.5.222/100.65.5.222:6379 has been disconnected after 60000 ms interval since moment of the first failed connection
The only way to resolve this is to restart the server.
Redis at this time is fully functional as all other servers are working fine
Steps to reproduce or test case
Our redisson configuration:
Sentinel cluster with 4 nodes
masterConnectionPoolMinSize=16
masterConnectionPoolMaxSize=64
slaveConnectionPoolMinSize=16
slaveConnectionPoolMaxSize=64
timeout=3000
keepAlive=false
idleConnectionTimeout=10000
connectTimeout=10000
pingConnectionInterval=1000
pingTimeout=1000
Redis version
3.0.7
Redisson version
3.8.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
.takeAsync().whenComplete will retrivehead of the qeueu and evaluate it
Actual behavior
we are not retrieve element from qeueu, but in redis I can see them.
But if offer from same service it's work
Steps to reproduce or test case
I have two microservices frirst retrive elements with RedissonQueueBundle
Second just offer element directly
queue.offer(someObject)
//wrapper for RQueue to make operation over it
public class RedissonQueueBundle<V> implements QueueBundle<V> {
    private RQueue<V> rQueue;
    private final Set<Consumer<V>> handlers;
    private final ScheduledExecutorService executorService;
    private final String queueName;
    private RDelayedQueue<V> rDelayedQueue;

    public RedissonQueueBundle(RedissonClient redissonClient, String queueName, ScheduledExecutorService executorService) {
        this.rQueue = redissonClient.<V>getBlockingQueue(queueName);
        this.handlers = ConcurrentHashMap.newKeySet();
        this.executorService = executorService;
        this.queueName = queueName;
        this.rDelayedQueue = redissonClient.getDelayedQueue(rQueue);
    }


    @PostConstruct
    public void init() {
        executorService.submit(this::fetch);
    }

    @Override
    public void offer(V element) {
        rQueue.offer(element);
    }
    /**
     * Inserts element into this queue with
     * specified transfer delay to destination queue.
     *
     * @param element  the element to add
     * @param delay    for transition
     * @param timeUnit for delay
     */

    @Override
    public void offer(final V element, final long delay, final TimeUnit timeUnit) {
        LOGGER.info("Offer value {} with delay {} {}", element, delay, timeUnit);
        rDelayedQueue.offer(element, delay, timeUnit);
    }

    @Override
    public void register(Consumer<V> handler) {
        if (handler == null){
            return;
        }
        LOGGER.info("Registering handler {}", handler.getClass().getCanonicalName());
        handlers.add(handler);
    }

    public boolean removeIf(Predicate<? super V> filter) {
        return rDelayedQueue.removeIf(filter);
    }

    private void handle(V val) {
        LOGGER.info("Got value {} from {} for {} consumers", val, queueName, handlers.size());
        if (val != null) {
            handlers.forEach(handler -> handler.accept(val));
        }
    }

    private void fetch() {
        if (!handlers.isEmpty()) {
            ((RBlockingQueue<V>) rQueue).takeAsync().whenComplete((val, ex) -> {
                try {
                    if (ex == null) {
                        this.handle(val);
                        executorService.execute(this::fetch);
                    } else {
                        LOGGER.warn("", ex);
                    }
                } catch (Exception exx) {
                    LOGGER.error("", exx);
                }
            });
        } else {
            LOGGER.warn("Handlers set for queue {} is empty", queueName);
            executorService.schedule(this::fetch, 1, TimeUnit.SECONDS);
        }
    }

}

Redis version
3.0.3
Redisson version
3.5.0
Redisson configuration
@Configuration
public class RedissonConfiguration {
    private static final int MAX_CONNECTION_RETRY = 5;
    private final Config config = new Config();
    private final String connectionDescription;

    RedissonConfiguration() {

        String master = null;
        Set<String> sentinels = null;
        try {
            master = PropertiesRetriever.getRedisMaster();
            sentinels = PropertiesRetriever.getRedisSentinels();
        } catch (MissingResourceException ex) { /*_*/ }

        ObjectMapper objectMapper = new JacksonObjectMappers().getDefaultObjectMapper();
        config.setCodec(new JsonJacksonCodec(objectMapper));
        if (sentinels != null && !sentinels.isEmpty() && StringUtils.isNotBlank(master) && !"disabled".equalsIgnoreCase(master)) {
            String[] addresses = sentinels.stream().map(sentinel -> "redis://" + sentinel).toArray(String[]::new);
            config.useSentinelServers()
                    .setMasterName(master)
                    .setDatabase(PropertiesRetriever.getRedisDBData())
                    .setMasterConnectionMinimumIdleSize(5)
                    .setSlaveConnectionMinimumIdleSize(5)
                    .addSentinelAddress(addresses);
            connectionDescription = "Sentinels " + master + "/" + Arrays.asList(addresses);
        } else {
            String redisAddress = PropertiesRetriever.getRedisDataHost() + ":" + PropertiesRetriever.getRedisDataPort();
            config.useSingleServer()
                    .setAddress(redisAddress)
                    .setDatabase(PropertiesRetriever.getRedisDBData());
            connectionDescription = redisAddress;
        }
    }

    @Bean
    public RedissonClient redissonClient() {
        RuntimeException reThrow = null;
        for (int i = 0; i < MAX_CONNECTION_RETRY; i++) {
            try {
                return Redisson.create(config);
            } catch (RedisConnectionException ex) {
                LOGGER.warn("Retry {} of {} FAIL", i + 1, MAX_CONNECTION_RETRY);
                              reThrow = ex;
            }
        }
        LOGGER.error("", reThrow);
        throw reThrow;
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
19:06:03.939  [pool-10-thread-2] ERROR com.nucleus.control - Error in NeutrinoCache.get
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:343) ~[redisson-3.7.2.jar:na]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:170) ~[redisson-3.7.2.jar:na]
at org.redisson.RedissonObject.get(RedissonObject.java:74) ~[redisson-3.7.2.jar:na]
at org.redisson.RedissonMap.get(RedissonMap.java:251) ~[redisson-3.7.2.jar:na]
at com.nucleus.finnone.pro.cache.common.redis.NeutrinoCacheRedisImpl.getFromCache(NeutrinoCacheRedisImpl.java:53) ~[neutrino-core-framework-3.50.00.00-GA.jar:na]
at com.nucleus.finnone.pro.cache.common.NeutrinoCache.get(NeutrinoCache.java:65) ~[neutrino-core-framework-3.50.00.00-GA.jar:na]
at com.nucleus.finnone.pro.cache.common.NeutrinoCachePopulator.get(NeutrinoCachePopulator.java:173) ~[neutrino-core-framework-3.50.00.00-GA.jar:na]
at com.nucleus.finnone.pro.cache.common.MasterCacheServiceImpl.updateMasterCacheForError(MasterCacheServiceImpl.java:164) ~[neutrino-core-framework-3.50.00.00-GA.jar:na]
Expected behavior: Lock should be acquired
Actual behavior: RLock object returned is null
Steps to reproduce or test case:
private void methodA()
{
try{
//some method that throws an Exception or error
}
catch(Throwable th)
{
//calling some other method not related to redisson
}
finally()
{
this.acquireLock);    //getting null Rlock object here in case of exception or error in try block
}
}
private RLock acquireLock()
{
RMap<Integer, String> map = redisson.getMap("lock_test");
RLock lock = map.getLock(key);
lock.tryLock(3, 20,TimeUnit.SECONDS);
return lock;
}
Redis version: 4.0.9
Redisson version:3.7.2, 3.7.5, 3.8.0, 3.8.2
Redisson configuration:
Config config = new Config();
config.useSingleServer().setAddress("redis://10.0.50.128:6379");
config.useSingleServer().setRetryAttempts(3);
config.useSingleServer().setConnectionPoolSize(500);
config.useSingleServer().setRetryInterval(2000);
config.useSingleServer().setConnectTimeout(30000);
FstCodec codec = new FstCodec();
config.setCodec(codec);
redisson = (RedissonClient) Redisson.create(config);

options = TransactionOptions.defaults()

		.syncSlavesTimeout(10, TimeUnit.SECONDS).responseTimeout(10, TimeUnit.SECONDS)
		.retryInterval(5, TimeUnit.SECONDS).retryAttempts(5).timeout(40, TimeUnit.SECONDS);

Note:Same scenario works as expected when there is no exception or error inside the try block.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a webapp using Redisson to handle Hibernate cache, application cache and session persistence.
However, each time my webapp client attempt to READ back from Redis, Redisson give back an java.lang.ClassNotFoundException on every object saved in Redis.
If I remove all lib from the lib folder and disable the session manager, the webapp client work perfectly.
I suspect a class loader conflict, as Redisson's classes are loaded inside the Server Class loader, while the webapp classes inside the Webapp class loader. The sessions objects are working as all is handled at Tomcat level, but the client is jumping between both class loader.
Anyone was able to get both working altogether, or is it require to use 2 Redis Java client implementation, one for the Session and the other for the Webapps?
Expected behavior
Tomcat sessions are saved.
Object are saved and restored from Redis in the Webapps
Actual behavior
Tomcat Session are saved and restored.
Webapps objects are saved but cause a "java.lang.ClassNotFoundException" upon restore.
Steps to reproduce or test case
Create a plain tomcat instance.
Put redisson-all and redisson-tomcat jars in lib folder
Create a war with a 2 serializable entities and a servlet that read and save said entity in the session And the client directly (caching).
Redis version
4.0.9
Redisson version
3.8.2
Redisson configuration
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"password":null,
"subscriptionsPerConnection":5,
"clientName":"tomcat",
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":32,
"connectionPoolSize":64,
"database":1
},
"threads":0,
"nettyThreads":0,
"codec":{
"class":"org.redisson.codec.SnappyCodec"
},
"transportMode":"NIO"
}
RedissonTomcatTest.zip
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Is it possible to use dynamic map names based on the parameter names in @Cacheable
Actual behavior
Unable to set ttl and other configurations for dynamic maps
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I use the config: spring.redis.cluster.nodes=redis1.test:3000  or redis://redis1.test:3000 or rediss://redis1.test:3000, the application can not startup.
the env is:
redisson-spring-boot-starter: 3.8.0/3.8.2
spring-boot: 2.0.4
Expected behavior
startup successfully
Actual behavior
Got error:  Illegal character in scheme name at index 0: [redis1.test]:3000
Steps to reproduce or test case
Redis version
4.2
Redisson version
3.8.2
Redisson configuration
spring.redis.cluster.nodes=redis1.test:3000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am connecting to AWS Elasticache Redis via Redisson from my Amazon EC2 instance. After lots of request of redis connection, I get the following issue. Anybody has solution for it?
2018-10-11 11:02:38,363 ERROR org.redisson.client.handler.CommandsQueue - Exception occured. Channel: [id: 0x46c06a6a, L:0.0.0.0/0.0.0.0:49308 ! R:redis-pa-qc-001.redis-pa-qc.yzmnbg.use1.cache.amazonaws.com/10.0.24.226:6379]
io.netty.handler.codec.DecoderException: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1412)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:943)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1429)
at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535)
at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:813)
at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:781)
at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
at io.netty.handler.ssl.SslHandler$SslEngineType$3.unwrap(SslHandler.java:292)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1248)
at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1159)
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1194)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
... 16 common frames omitted
Caused by: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
at sun.security.validator.PKIXValidator.(PKIXValidator.java:90)
at sun.security.validator.Validator.getInstance(Validator.java:179)
at sun.security.ssl.X509TrustManagerImpl.getValidator(X509TrustManagerImpl.java:312)
at sun.security.ssl.X509TrustManagerImpl.checkTrustedInit(X509TrustManagerImpl.java:171)
at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:239)
at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:136)
at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1493)
at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)
at sun.security.ssl.Handshaker$1.run(Handshaker.java:919)
at sun.security.ssl.Handshaker$1.run(Handshaker.java:916)
at java.security.AccessController.doPrivileged(Native Method)
at sun.security.ssl.Handshaker$DelegatedTask.run(Handshaker.java:1369)
at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1408)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1316)
... 20 common frames omitted
Caused by: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
at java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200)
at java.security.cert.PKIXParameters.(PKIXParameters.java:120)
at java.security.cert.PKIXBuilderParameters.(PKIXBuilderParameters.java:104)
at sun.security.validator.PKIXValidator.(PKIXValidator.java:88)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
During fail-over with a master and single slave Redisson reads may fail. I would like to request that new modes be added to org.redisson.config.ReadMode MASTER_PREFERRED, and SLAVE_PREFERRED (like Lettuce) to allow robust reads.
Actual behavior
Redisson should be able to continue providing the application with reads / data instead of timeouts.
Steps to reproduce or test case
n/a
Redis version
Redisson version
3.8.2
Redisson configuration
    private RedissonClient createRedissonClient(String redisNodes, int database) {
        Config config = new Config();
        if (redisNodes.indexOf(',') > -1) {
            ReplicatedServersConfig clusterConfig = config.useReplicatedServers();
            clusterConfig.setScanInterval(2500);
            clusterConfig.setDnsMonitoringInterval(2500);
            clusterConfig.setDatabase(database);
            clusterConfig.setTcpNoDelay(true);
            clusterConfig.setKeepAlive(true);
            for (String addr : StringUtils.tokenizeToStringArray(redisNodes, ",", true, true)) {
                clusterConfig.addNodeAddress(addSchema(addr));
            }
            clusterConfig.setTimeout(1000);
            clusterConfig.setReadMode(ReadMode.SLAVE);
        } else {
            SingleServerConfig singleServerConfig = config.useSingleServer();
            singleServerConfig.setDatabase(database);
            singleServerConfig.setTimeout(1000);
            singleServerConfig.setTcpNoDelay(true);
            singleServerConfig.setKeepAlive(true);
            singleServerConfig.setAddress(addSchema(redisNodes));
        }
        config.setCodec(new SnappyCodec());
        config.setThreads(redisEventLoop.getThreadPoolSize());
        config.setEventLoopGroup(redisEventLoop.getWorkerGroup());
        config.setUseLinuxNativeEpoll(redisEventLoop.isNativeEpoll());

        return Redisson.create(config);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry if this isn't the correct forum for this question.
Could redisson be used to perform leader election in a cluster? I don't really feel like adding Zookeeper or Consul to our current mix.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
import java.util.concurrent.Semaphore;
import org.redisson.Redisson;

Semaphore semaphore = Redisson.create().getSemaphore("foo");
Actual behavior
Error:(65, 57) java: incompatible types: org.redisson.api.RSemaphore cannot be converted to java.util.concurrent.Semaphore
Just out of curiosity, why doesn't the org.redisson.api.RSemaphore interface extend the java.util.concurrent.Semaphore interface?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According to the Redis documentation, script caching is recommended, using EVALSHA and EVAL only if Redis server does not have the script already loaded, but I don't see this behavior in Redisson when using EVAL.
This seems to be supported in Spring spring-data-redis using the default ScriptExecutor.
Is there any script caching option I am not aware of? Is this going to be implemented if missing?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
It should get the entry save into Reddis
Actual behavior
I got the following exception :
2018-10-15 14:11:24,121 ERROR [stderr] (redisson-3-6) Exception in thread "redisson-3-6" org.redisson.client.RedisException: Unexpected exception while processing command 2018-10-15 14:11:24,121 ERROR [stderr] (redisson-3-6)   at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:378) 2018-10-15 14:11:24,121 ERROR [stderr] (redisson-3-6)   at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:182) 2018-10-15 14:11:24,121 ERROR [stderr] (redisson-3-6)   at org.redisson.RedissonObject.get(RedissonObject.java:76) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.RedissonMap.readAllEntrySet(RedissonMap.java:430) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:97) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:264) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:53) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.PubSubPatternMessageListener.onPatternMessage(PubSubPatternMessageListener.java:81) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:83) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at org.redisson.client.handler.CommandPubSubDecoder$2.run(CommandPubSubDecoder.java:183) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 2018-10-15 14:11:24,122 ERROR [stderr] (redisson-3-6)   at java.lang.Thread.run(Thread.java:748) 2018-10-15 14:11:24,136 ERROR [stderr] (redisson-3-6) Caused by: java.lang.NullPointerException 2018-10-15 14:11:24,136 ERROR [stderr] (redisson-3-6)   at org.redisson.client.handler.CommandDecoder.selectDecoder(CommandDecoder.java:476) 2018-10-15 14:11:24,136 ERROR [stderr] (redisson-3-6)   at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:348) 2018-10-15 14:11:24,136 ERROR [stderr] (redisson-3-6)   at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:128) 2018-10-15 14:11:24,136 ERROR [stderr] (redisson-3-6)   at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 2018-10-15 14:11:24,137 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 2018-10-15 14:11:24,138 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) 2018-10-15 14:11:24,139 ERROR [stderr] (redisson-3-6)   at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) 2018-10-15 14:11:24,139 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) 2018-10-15 14:11:24,139 ERROR [stderr] (redisson-3-6)   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) 2018-10-15 14:11:24,139 ERROR [stderr] (redisson-3-6)   at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) 2018-10-15 14:11:24,139 ERROR [stderr] (redisson-3-6)   at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897) 2018-10-15 14:11:24,140 ERROR [stderr] (redisson-3-6)   ... 2 more
Steps to reproduce or test case
It is very hard to reproduce. It does not appears each time. I only got this error during a load test. It is very random.
We are in Spring 5 with spring-session-core in 2.0.5.RELEASE.
Redis is used to store the httpSession data.
Here is the redis data :
1) "\"passwordLess\"" 2) "\"true\"" 3) "\"SPRING_SECURITY_CONTEXT\"" 4) "{\"@class\":\"org.springframework.security.core.context.SecurityContextImpl\",\"authentication\":{\"@class\":\"ctx.security.CustomUsernamePasswordAuthenticationToken\",\"authenticated\":true,\"details\":{\"@class\":\"org.springframework.security.web.authentication.WebAuthenticationDetails\",\"remoteAddress\":\"88.190.12.13\",\"sessionId\":\"d6266c39-ac4d-4a2b-b3b5-995f1c341b58\"},\"principal\":{\"@class\":\"ctx.security.model.OnAirUserSecurity\",\"email\":\"9612472228_72@mailinator.com\",\"grantedAuths\":[\"java.util.ArrayList\",[{\"@class\":\"org.springframework.security.core.authority.SimpleGrantedAuthority\",\"authority\":\"ROLE_USER\"}]],\"id\":23178686,\"password\":\"$2a$10$iK2ijRQvMMxOXrzVAtLOQelepT1.ry.FE7n8jxO4D7xMkkurHibBO\"}}}" 5) "\"session:maxInactiveInterval\"" 6) "[\"java.lang.Long\",1800]" 7) "\"session:creationTime\"" 8) "[\"java.lang.Long\",1539612489361]" 9) "\"passenger_context\"" 10) "{\"@class\":\"ctx.model.PassengerContext\",\"carrierCode\":\"TEST\",\"deviceIp\":\"10.0.0.0\",\"email\":\"1539612472228_72@mailinator.com\",\"flightId\":1926722,\"locale\":\"en\",\"platform\":\"EKPAC\",\"sessionId\":\"d6266c39-ac4d-4a2b-b3b5-995f1c341b58\",\"theme\":\"TEST\",\"userAgent\":\"Mozilla/5.0 (X11; Linux i686; rv:31.0) Gecko/20100101 Firefox/31.0\",\"userId\":23178686,\"vesselCode\":\"TEST4\"}" 11) "\"selected_product\"" 12) "{\"@class\":\"ice.client.backend.dto.resource.ProductResource\",\"allFlight\":true,\"byteUsageLimit\":26214400,\"carrier\":\"TEST\",\"createdAt\":\"2018-10-12T07:57:51.743871Z\",\"disabled\":false,\"discountable\":true,\"displayOrder\":0,\"displayedByteUsageLimit\":26214400,\"hideFromMenu\":false,\"id\":628,\"initial\":true,\"isAllFlight\":true,\"isInitial\":true,\"isRenewal\":true,\"links\":[\"java.util.ArrayList\",[{\"@class\":\"org.springframework.hateoas.Link\",\"href\":\"http://ppe-core-vip-001.pod.sitaonair.aero/ice-back-end/api/v1/products/LT_TEST_FL_25MB_FREE\",\"rel\":\"self\"}]],\"maxLifeTime\":90,\"meteringType\":\"FLIGHT_LIMITED_VOLUME\",\"pausable\":true,\"price\":0.0,\"productCode\":\"LT_TEST_FL_25MB_FREE\",\"productTranslations\":[\"java.util.ArrayList\",[]],\"productType\":\"REGULAR\",\"renewal\":true,\"speedLimit\":\"ILLIMITED\",\"timeUsageLimit\":0,\"updatedAt\":\"2018-10-12T07:57:51.743871Z\",\"upgradable\":false}" 13) "\"captcha\"" 14) "\"false\"" 15) "\"org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.CSRF_TOKEN\"" 16) "{\"@class\":\"org.springframework.security.web.csrf.DefaultCsrfToken\",\"headerName\":\"X-CSRF-TOKEN\",\"parameterName\":\"_csrf\",\"token\":\"3e3c0d98-3e0a-428e-897a-7078f4bbc949\"}" 17) "\"session:lastAccessedTime\"" 18) "[\"java.lang.Long\",1539612775785]"
i also got NPE with this message
[2018-10-15 12:17:25,026] [ERROR] [o.r.c.h.CommandDecoder] - Unable to decode data. channel: [id: 0x746bf880, L:/127.17.0.5:44662 - R:88.101.47.45/88.101.47.44:6399] message: *8$26"session:lastAccessedTime"$32["java.lang.Long",1539605843679]$22"session:creationTime"$32["java.lang.Long",1539605843676]$19"passenger_context"$272{"@class":"aero.onair.ctx.model.PassengerContext","carrierCode":"PAL","deviceIp":"10.0.0.17","flightId":1926263,"locale":"en","platform":"EKPAC","theme":"PAL","userAgent":"Mozilla/5.0 (X11; Linux i686; rv:31.0) Gecko/20100101 Firefox/31.0","userId":0,"vesselCode":"PAL14"}$29"session:maxInactiveInterval"$23["java.lang.Long",1800]*0*0 java.lang.NullPointerException: null 
Redisson version
3.8.2. It is also appear with the 3.7.5
Redisson configuration
`
@configuration
@EnableRedissonHttpSession
public class RedissonConfig implements BeanClassLoaderAware
{
@Autowired
private ConfigurationWrapper configuration;
private static final int CONNECTION_TIMEOUT = 3000;
private static final int TIMEOUT = 10000;
private static final int THREAD_NUMBER = 4;

private ClassLoader loader;

@Bean(destroyMethod = "shutdown")
public RedissonClient redissonClient()
{
     return Redisson.create(sentinelServers());
}

private Config baseConfig()
{
    return new Config()
            .setNettyThreads(THREAD_NUMBER)
            .setThreads(THREAD_NUMBER)
            .setCodec(new JsonJacksonCodec(mapper()));
}

private Config sentinelServers()
{
    final Config config = baseConfig();
    config.useSentinelServers()
            .setConnectTimeout(CONNECTION_TIMEOUT)
            .setTimeout(TIMEOUT)
            .addSentinelAddress(split(configuration.getAddresses(), ", "))
            .setMasterName(configuration.getMasterName())
            .setPassword(configuration.getPassword());
    return config;
}

@Override
public void setBeanClassLoader(final ClassLoader classLoader)
{
    this.loader = classLoader;
}

private ObjectMapper mapper()
{
    final ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    mapper.registerModules(SecurityJackson2Modules.getModules(this.loader));
    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
    mapper.setSerializationInclusion(Include.NON_NULL);
    mapper.addMixIn(Throwable.class, JsonJacksonCodec.ThrowableMixIn.class);
    mapper.findAndRegisterModules();
    return mapper;
}

}
`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our application using Redis. We are facing response timeout problem and not sure what is the underlying cause.
If we use ENA enabled AWS instances, the problem occurs too often, if we use non ENA the timeout happens once in a while.
Below is sample log:
2018-10-09 10:44:14.739 [redisson-netty-1-6] WARN o.r.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [id: 0xcafbfa01, L:/10.110.1.219:41758 - R:10.110.151.90/10.110.151.90:6379], command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); local expireDate = 92233720368547758; if value ~..., 5, mya.uuid, redisson__timeout__set:{mya.uuid}, redisson__idle__set:{mya.uuid}, redisson__map_cache__last_access__set:{mya.uuid}, {mya.uuid}:redisson_options, 1539081845763, PooledUnsafeDirectByteBuf(freed)], result: false
2018-10-09 10:44:14.741 [mya-service-core-akka.actor.default-dispatcher-3] ERROR o.d.m.s.core.service.GetEventsActor - {"reqid":"10.0.7.53-RequestGetCurrentEvent00000299","path":"/"} - DB operation failed with exception Redis server response timeout (1000 ms) occured for command: (HEXISTS) with params: [mya.auth@46eb06dd-4d24-405e-bffc-bcb7fcf27d9a, PooledUnsafeDirectByteBuf(ridx: 0, widx: 94, cap: 256)] channel: [id: 0x05eea803, L:/10.110.1.219:41796 - R:10.110.151.90/10.110.151.90:6379] WARNING arguments left: 1
Expected behavior
Actual behavior
Steps to reproduce or test case
AWS ENA enabled, linux=centos. if we access redisson frequently, the issue would be observed in an hour. keys=1 million on M5.2xlarge.
Redis version
4.0.9/4.0.11
Redisson version
3.5.7,3.6.5,3.7.5
Redisson configuration
{
"singleServerConfig": {
"idleConnectionTimeout": 10000,
"pingTimeout": 1000,
"connectTimeout": 10000,
"timeout": 3000,
"retryAttempts": 0,
"retryInterval": 1500,
"reconnectionTimeout": 3000,
"failedAttempts": 3,
"password": null,
"subscriptionsPerConnection": 5,
"clientName": null,
"address": "redis://10.110.151.245:6379",
"subscriptionConnectionMinimumIdleSize": 1,
"subscriptionConnectionPoolSize": 50,
"connectionMinimumIdleSize": 10,
"connectionPoolSize": 64,
"database": 0,
"dnsMonitoring": false,
"dnsMonitoringInterval": 5000
},
"threads": 0,
"nettyThreads": 0,
"codec": null,
"useLinuxNativeEpoll": false
}
Tuning timeouts,connectionpoolsize didnt help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for authoring and maintaining this great project.
We are considering moving over to Redisson to make use of it's local cache feature as it provides a performance boost comparing directly retrieving data from redis. Run into this when trying to clear local cache, seems like the cache was not cleared, everything stills stays. Is this the expected behavior, what would be the best to way to clear all caches, could you shed more lights on this please?
Expected behavior
Clears local cache across all instances
https://static.javadoc.io/org.redisson/redisson/3.6.4/org/redisson/api/RLocalCachedMap.html#clearLocalCacheAsync--
Actual behavior
Local cache is not cleared, everything in local cache persists
Steps to reproduce or test case
import org.redisson.Redisson;
import org.redisson.api.LocalCachedMapOptions;
import org.redisson.api.RLocalCachedMap;
import org.redisson.api.RedissonClient;

public class RedissonLocalCache {
    private final RLocalCachedMap<String, String> localMap;
    private static RedissonClient client = Redisson.create();


    public RedissonLocalCache() {
        localMap = client.getLocalCachedMap(
                "myMapName",
                LocalCachedMapOptions.defaults()
        );
    }

    public void clearTest() {
        localMap.fastPut("key", "value");
        localMap.clearLocalCache();

        System.out.println("map size after clear: " + localMap.keySet().size());
    }
}

To run:
RedissonLocalCache test = new RedissonLocalCache();
test.clearTest();

Redis version
4.0.8
Redisson version
3.8.2
Redisson configuration
default
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using redisson session manager in our application, and got RedisException sometimes due to NPE.
Expected behavior
No exception should be thrown.
Actual behavior
Error found randomly, and no more information where NPE was from.
Stack trace:
Unexpected exception while processing command org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:339)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:170)
at org.redisson.RedissonObject.get(RedissonObject.java:74)
at org.redisson.RedissonMap.readAllMap(RedissonMap.java:405)
at org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:131)
at org.apache.catalina.connector.Request.doGetSession(Request.java:2913)
at org.apache.catalina.connector.Request.getSession(Request.java:2310)
at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:897)
at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
at org.springframework.security.web.context.HttpSessionSecurityContextRepository$SaveToSessionResponseWrapper.saveContext(HttpSessionSecurityContextRepository.java:332)
at org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.onResponseCommitted(SaveContextOnUpdateOrErrorResponseWrapper.java:85)
at org.springframework.security.web.context.OnCommittedResponseWrapper.doOnResponseCommitted(OnCommittedResponseWrapper.java:208)
at org.springframework.security.web.context.OnCommittedResponseWrapper.sendRedirect(OnCommittedResponseWrapper.java:114)
at org.apache.struts2.dispatcher.ServletRedirectResult.sendRedirect(ServletRedirectResult.java:257)
at org.apache.struts2.dispatcher.ServletRedirectResult.doExecute(ServletRedirectResult.java:229)
at org.apache.struts2.dispatcher.StrutsResultSupport.execute(StrutsResultSupport.java:193)
at org.apache.struts2.dispatcher.ServletRedirectResult.execute(ServletRedirectResult.java:164)
.....
.....
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)
at org.apache.coyote.ajp.AjpNioProcessor.process(AjpNioProcessor.java:175)
at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:611)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1736)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1695)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NullPointerException
Steps to reproduce or test case
Sometimes error will be found when running:
request.getSession(false);
after the session was removed by:
request.getSession(true).invalidate();
Redis version
4.0.6
Redisson version
3.6.5
Redisson configuration
{
"clusterServersConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":6000,
"retryAttempts":6,
"retryInterval":3000,
"failedSlaveReconnectionInterval":3000,
"failedSlaveCheckInterval":3,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"slaveConnectionMinimumIdleSize":10,
"slaveConnectionPoolSize":610,
"masterConnectionMinimumIdleSize":10,
"masterConnectionPoolSize":610,
"readMode":"SLAVE",
"subscriptionMode":"SLAVE",
"nodeAddresses":[
"redis://RedisServer1:6379",
"redis://RedisServer2:6379",
"redis://RedisServer3:6379",
"redis://RedisServer4:6379",
"redis://RedisServer5:6379",
"redis://RedisServer6:6379"
],
"scanInterval":1000
},
"threads":0,
"nettyThreads": 0,
"codec":!<org.redisson.codec.FstCodec> {},
"useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version
redisson-spring-boot-starter:3.8.2
spring:
redis:
database: 0
timeout: 60000
sentinel:
master: redisMaster
nodes:
- 10.250.100.211:27000
- 10.250.100.211:27001
- 10.250.100.211:27002
2018-10-18 19:22:36.396 [redisson-netty-4-3] ERROR org.redisson.client.handler.CommandsQueue - Exception occured. Channel: [id: 0xdea6dc47, L:/10.250.100.101:57379 - R:10.250.100.211/10.250.100.211:7001]
java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
at sun.nio.ch.SocketDispatcher.read0(Native Method)
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
at sun.nio.ch.IOUtil.read(IOUtil.java:192)
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108)
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:347)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:563)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:480)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
sos !!!
Why is there such an error?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis version
4.0.9
Redisson version
3.8.2
redis集群:三主三从，跑了一段时间就会报这个错误，java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
一个应用节点的连接数最多应该13个（主节点或者从节点）
Actual behavior
总连接数除以节点数，平均连接到170了
Steps to reproduce or test case
Redis version
4.0.2
Redisson version
3.7.2
Redisson configuration
集群模式
setMasterConnectionPoolSize(10)
setMasterConnectionMinimumIdleSize(1)
setSlaveConnectionPoolSize(10)
setSlaveConnectionMinimumIdleSize(1)
setSubscriptionConnectionPoolSize(3)
setSubscriptionConnectionMinimumIdleSize(1)
问题描述
线上出现redis单节点连接数超过4000，但每秒命令数只有700左右，通过client list发现3000多的连接最后执行命令是client，所以推测redisson客户端在执行client命令时单独开了连接，并且未释放
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
一个应用节点的连接数最多应该13个（主节点或者从节点）
Actual behavior
总连接数除以节点数，平均连接到170了
Steps to reproduce or test case
Redis version
4.0.2
Redisson version
3.7.2
Redisson configuration
集群模式
setMasterConnectionPoolSize(10)
setMasterConnectionMinimumIdleSize(1)
setSlaveConnectionPoolSize(10)
setSlaveConnectionMinimumIdleSize(1)
setSubscriptionConnectionPoolSize(3)
setSubscriptionConnectionMinimumIdleSize(1)
问题描述
线上出现redis单节点连接数超过4000，但每秒命令数只有700左右，通过client list发现3000多的连接最后执行命令是client，所以推测redisson客户端在执行client命令时单独开了连接，并且未释放
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi I am trying to use redis-graph with redisson and have trouble figuring out how to read the result set that redis-graph (https://github.com/RedisLabsModules/redis-graph) returns.
A typical result set can look like this.

(empty list or set)


Labels added: 1
Nodes created: 1
"Query internal execution time: 0.625300 milliseconds"



Ive tried a regular bytearray but get only the last line and then it times out.
Any tips?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What are default values for the mentioned below properties?
Are these values from LocalCachedMapOptions::defaults()?
I see that local caches work, but only ttl, idle and maxSize are defined.
 localCacheOptions:
    evictionPolicy: "LRU"
    reconnectionStrategy: "CLEAR"
    syncStrategy: "UPDATE"
    writeMode: "WRITE_THROUGH"
    cacheSize: 1000
    timeToLiveInMillis: 300000
    maxIdleInMillis: 300000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior : redisson-all-2.13.2.jar should be compatible with jdk 1.7 version as per publication .
Actual behavior : redisson-all-2.13.2.jar not compatible with jdk 1.7 version . It is giving following error when try to run the same with jdk 1.7 version
java.lang.UnsupportedClassVersionError: org/redisson/api/listener/MessageListener : Unsupported major.minor version 52.0
Steps to reproduce or test case : redisson-all-2.13.2.jar should work with jdk 1.7
execute the redisson-all-2.13.2.jar under jdk 1.7 version.
Redis version : Redis 3.2 (For windows machine)
Please provide same redisson-all-2.13.2.jar
with jdk 1.7 compiled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When we pass an executor in the redisson config, redisson should never shut it down.
Actual behavior
ReplicatedConnectionManager calls stopThreads from the parent class MasterSlaveConnectionManager.  The stopThreads method calls executor.shutdown() without checking who owns it.
Steps to reproduce or test case
This example should call stopThreads in the ReplicatedConnectionManager constructor because the config doesn't have any node addresses:
ExecutorService es = Executors.newCachedThreadPool();
Config config = new Config().setExecutor(executorService);
config.useReplicatedServers();
Redisson.create(config);

assert !es.isTerminated();
Redis version
3.2.6
Redisson version
3.8.2
Redisson configuration
config.setExecutor(executorService).useReplicatedServers()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
actually our real application is running on Azure but I was able to compile a small application to demonstrate this issue locally. The main issue is that the reconnect behaviour of Redisson seems to be unreliable. Sometimes it works and sometimes it doesn't which seems to be rather independet of the choosen configuration options except for the retryAttempt and retryTimeout options. If those two options are too low the application is not able to recover in any case but this is expected behaviour of Redisson as far as I can tell.
Example project: redissondemo.zip
Am I missing something here?
Any help is appreciated!
Expected behavior
Redisson is trying to reconnect after a failure / failover of the Redis server.
Actual behavior
Redisson seems to be trying to reconnect but fails always except on a few non-reproducible occasions.
Steps to reproduce or test case
Used code to demonstrate the behaviour:
  public static void main(String... args) throws InterruptedException {

    RedissonClient redis = createClient();

    for (int i = 0; ; i++) {
      System.out.printf("%d. Reading queue...\n", i);
      RScoredSortedSet<String> queue = redis.getScoredSortedSet("queue");
      queue.readAll();

      Thread.sleep(2000);
    }
  }
Docker command to run a local instance of Redis:
docker run -p 6379:6379 redis:4.0.1-alpine redis-server --appendonly yes --requirepass 12345
Steps:

Start Redis
Start the test app
If everything seems to be running fine, stop the docker container with "docker stop ".
Wait some time and then start Redis again. I tried different intervals but it didn't seem to matter that much.

Depending on the set of choosen configuration options 1 - 3 the DEBUG log output varies but the end result is the same: no reconnect is going to happen. I tried it with option combinations "1;2;3", "1;3", "2;3" and with significantly lower values for the retryAttempts (option 3.1) such as 3 e.g.. As soon as the connection is lost any retry attempt seems to fail.
Although there seem to be exceptions from this behaviour. Sometimes the ConnectionWatchdog is taking action and is actually able to reconnect to the Redis server (Used configuration options: 1;2;3):
10:53:18.781 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa539c9d3, L:/127.0.0.1:64254 ! R:localhost/127.0.0.1:6379]]
10:53:18.781 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - attempt 2 for command (ZRANGE) and params [queue, 0, -1]
10:53:18.782 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]]
10:53:19.080 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1628212742 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x427ca2d0, L:/127.0.0.1:64252 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.081 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x0ab1cf13, L:/127.0.0.1:64247 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.082 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@616106585 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xdd2417b7, L:/127.0.0.1:64248 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.083 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@237478270 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x5dc987ee, L:/127.0.0.1:64260 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.084 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x623e0129, L:/127.0.0.1:64246 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.085 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa6099b94, L:/127.0.0.1:64267 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.086 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa539c9d3, L:/127.0.0.1:64254 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.088 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@422317778 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc17d9f88, L:/127.0.0.1:64253 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.180 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.182 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb28bb7d7, L:/127.0.0.1:64257 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.183 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2015163104 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb55afe09, L:/127.0.0.1:64249 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.184 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:19.185 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1900298624 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcd907f69, L:/127.0.0.1:64266 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.180 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1628212742 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x427ca2d0, L:/127.0.0.1:64252 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.181 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x0ab1cf13, L:/127.0.0.1:64247 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.182 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@616106585 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xdd2417b7, L:/127.0.0.1:64248 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.184 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@237478270 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x5dc987ee, L:/127.0.0.1:64260 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.184 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x623e0129, L:/127.0.0.1:64246 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.185 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa6099b94, L:/127.0.0.1:64267 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.186 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa539c9d3, L:/127.0.0.1:64254 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.187 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@422317778 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc17d9f88, L:/127.0.0.1:64253 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.279 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb28bb7d7, L:/127.0.0.1:64257 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.280 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.282 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2015163104 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb55afe09, L:/127.0.0.1:64249 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.284 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1900298624 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcd907f69, L:/127.0.0.1:64266 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:22.285 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:23.881 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]]
10:53:23.881 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - attempt 3 for command (ZRANGE) and params [queue, 0, -1]
10:53:23.881 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]]
10:53:27.381 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x0ab1cf13, L:/127.0.0.1:64247 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.382 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@616106585 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xdd2417b7, L:/127.0.0.1:64248 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.383 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1628212742 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x427ca2d0, L:/127.0.0.1:64252 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.385 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@237478270 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x5dc987ee, L:/127.0.0.1:64260 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.386 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x623e0129, L:/127.0.0.1:64246 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.387 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa6099b94, L:/127.0.0.1:64267 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.388 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa539c9d3, L:/127.0.0.1:64254 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.389 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@422317778 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc17d9f88, L:/127.0.0.1:64253 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.480 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.481 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb28bb7d7, L:/127.0.0.1:64257 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.482 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2015163104 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb55afe09, L:/127.0.0.1:64249 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.484 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1900298624 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcd907f69, L:/127.0.0.1:64266 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:27.485 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:28.982 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]]
10:53:28.982 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - attempt 4 for command (ZRANGE) and params [queue, 0, -1]
10:53:28.982 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@711012218 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2135b4fc, L:/127.0.0.1:64263 ! R:localhost/127.0.0.1:6379]]
10:53:34.080 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@711012218 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2135b4fc, L:/127.0.0.1:64263 ! R:localhost/127.0.0.1:6379]]
10:53:34.081 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - attempt 5 for command (ZRANGE) and params [queue, 0, -1]
10:53:34.081 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x623e0129, L:/127.0.0.1:64246 ! R:localhost/127.0.0.1:6379]]
10:53:36.580 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x0ab1cf13, L:/127.0.0.1:64247 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.680 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@616106585 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xdd2417b7, L:/127.0.0.1:64248 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.682 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@422317778 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc17d9f88, L:/127.0.0.1:64253 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.684 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x623e0129, L:/127.0.0.1:64246 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.688 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa539c9d3, L:/127.0.0.1:64254 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.693 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1628212742 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x427ca2d0, L:/127.0.0.1:64252 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.698 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa6099b94, L:/127.0.0.1:64267 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.699 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@237478270 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x5dc987ee, L:/127.0.0.1:64260 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.701 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb28bb7d7, L:/127.0.0.1:64257 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.704 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@2015163104 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xb55afe09, L:/127.0.0.1:64249 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.707 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1900298624 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xcd907f69, L:/127.0.0.1:64266 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.708 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xca894742, L:/127.0.0.1:64250 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:36.780 [pool-1-thread-1] DEBUG org.redisson.client.handler.ConnectionWatchdog - reconnecting RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x2d49db0e, L:/127.0.0.1:64256 ! R:localhost/127.0.0.1:6379]] to localhost/127.0.0.1:6379 
10:53:37.619 [redisson-netty-1-6] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xbdb55f94, L:/127.0.0.1:64464 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5032b572(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.703 [redisson-netty-1-2] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@594558943 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xd658ef5c, L:/127.0.0.1:64468 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@b1f479c(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.704 [redisson-netty-1-4] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@422317778 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x425c25e1, L:/127.0.0.1:64466 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5b5e4ff9(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.704 [redisson-netty-1-6] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x4c602033, L:/127.0.0.1:64472 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@127581ef(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.706 [redisson-netty-1-7] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@402279343 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x1716d128, L:/127.0.0.1:64475 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@d308e5b(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.707 [redisson-netty-1-5] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@1628212742 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x19561a14, L:/127.0.0.1:64469 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@331f1710(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.709 [redisson-netty-1-8] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@2015163104 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc3506c57, L:/127.0.0.1:64473 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@4747ca26(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.711 [redisson-netty-1-8] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@616106585 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xd96f4e8e, L:/127.0.0.1:64465 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@31f0445d(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.711 [redisson-netty-1-3] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@237478270 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x4225feb3, L:/127.0.0.1:64471 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@362fed26(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.712 [redisson-netty-1-4] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@1900298624 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xe7de785b, L:/127.0.0.1:64474 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@703d4570(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.712 [redisson-netty-1-2] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@1820828774 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xabb6a7f6, L:/127.0.0.1:64476 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@5b448656(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.715 [redisson-netty-1-7] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc4161bb2, L:/127.0.0.1:64467 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3bfb8088(success: PONG)], command=(PING), params=[], codec=null]
10:53:37.716 [redisson-netty-1-6] DEBUG org.redisson.client.handler.ConnectionWatchdog - RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa9f59a80, L:/127.0.0.1:64470 - R:localhost/127.0.0.1:6379]] connected to localhost/127.0.0.1:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@583bbe8e(success: PONG)], command=(PING), params=[], codec=null]
10:53:39.181 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@945308439 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xc4161bb2, L:/127.0.0.1:64467 - R:localhost/127.0.0.1:6379]]
10:53:39.181 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - attempt 6 for command (ZRANGE) and params [queue, 0, -1]
10:53:39.181 [pool-1-thread-1] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x4c602033, L:/127.0.0.1:64472 - R:localhost/127.0.0.1:6379]]
10:53:39.186 [redisson-netty-1-6] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1888870336 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x4c602033, L:/127.0.0.1:64472 - R:localhost/127.0.0.1:6379]]
6. Reading queue...
10:53:41.186 [main] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa9f59a80, L:/127.0.0.1:64470 - R:localhost/127.0.0.1:6379]]
10:53:41.188 [redisson-netty-1-6] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1912870382 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xa9f59a80, L:/127.0.0.1:64470 - R:localhost/127.0.0.1:6379]]
7. Reading queue...
10:53:43.188 [main] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xbdb55f94, L:/127.0.0.1:64464 - R:localhost/127.0.0.1:6379]]
10:53:43.190 [redisson-netty-1-6] DEBUG org.redisson.command.CommandAsyncService - connection released for command (ZRANGE) and params [queue, 0, -1] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@2102139180 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xbdb55f94, L:/127.0.0.1:64464 - R:localhost/127.0.0.1:6379]]
8. Reading queue...

Unfortunatelly I wasn't able to reproduce this constistently. I tried killing the Redis server at different points in the programm and restarting it but without any success...
Redis version
4.0.1
Redisson version
3.8.2
Redisson configuration
  private static RedissonClient createClient() {

    Security.setProperty("networkaddress.cache.ttl", "0");

    Config config = new Config();

    config.useSingleServer()
        .setAddress("redis://localhost:6379")
        .setPassword("12345")
        .setTimeout(10000)
        .setPingConnectionInterval(5000)  // Config option 1
        .setKeepAlive(true)   // Config option 2
        .setRetryAttempts(200000)   // Config option 3.1
        .setRetryInterval(5000);   // Config option 3.2

    return Redisson.create(config);
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I would like to be able to set the max and min delay times for the EvictionTask job, so i can ensure that the task will run every 5 seconds for example.
Actual behavior
The task will increase the time between checks to until a max of 1800 seconds.
Redis version
4.0.10
Redisson version
3.8.2
Redisson configuration
Single service configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Since version 3.8.2 Redisson failed to resolve short DNS name.
Steps to reproduce or test case

Configure redis full host name (in our case
redis-test.domain.com)
Add search domain "domain.com" to  /etc/resolv.conf
Verify that short name can be resolved with nslookup:
nslookup redis-test
Server:		192.168.20.167
Address:	192.168.20.167#53

Non-authoritative answer:
Name:	redis-test.domain.com
Address: 135.17.72.111
3) Configure redisson client to connect to "redis-test"
4) Client can't connect to server:
{"time":"2018-10-24T10:36:45.969-07:00","@Version":1,"msg":"failed to resolve 'redis-test' after 3 queries ","logger_name":"org.redisson.cluster.ClusterConnectionManager","thread_name":"main","level":"WARN","level_value":30000,"name":"gws-core-auth","pid":66459}
Redisson version
3.8.2
Redisson configuration
Default config used
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have an AWS ElastiCache for Redis server running in non-cluster configuration. The connection is TLS enabled. Once in a while, we get this error when servers try to establish the connection with Redis server.
Steps to reproduce or test case
Once in a while whenever the services tried to connect to Redis server, I'm getting this error.
Redis version
4.0.10
Redisson version
3.8.2
Redisson configuration
AWS Master-Slave Configuration with TLS enabled.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson版本
 <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.8.2</version>
</dependency>
redis信息
# Server
redis_version:3.2.9
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:d837dd4aae3a6933
redis_mode:standalone
os:Linux 4.9.27-moby x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.9.2
process_id:1
run_id:3c1a4fd32e311a07d2d9c5ece9b937580467a241
tcp_port:6379
uptime_in_seconds:7678
uptime_in_days:0
hz:10
lru_clock:13324804
executable:/data/redis-server
config_file:

# Clients
connected_clients:83
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:2539056
used_memory_human:2.42M
used_memory_rss:4964352
used_memory_rss_human:4.73M
used_memory_peak:3540152
used_memory_peak_human:3.38M
total_system_memory:2095890432
total_system_memory_human:1.95G
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
mem_fragmentation_ratio:1.96
mem_allocator:jemalloc-4.0.3

# Persistence
loading:0
rdb_changes_since_last_save:0
rdb_bgsave_in_progress:0
rdb_last_save_time:1540050984
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok

# Stats
total_connections_received:3548
total_commands_processed:8491
instantaneous_ops_per_sec:0
total_net_input_bytes:2401890
total_net_output_bytes:21135836
instantaneous_input_kbps:0.00
instantaneous_output_kbps:0.00
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:263
keyspace_misses:2
pubsub_channels:1
pubsub_patterns:0
latest_fork_usec:410
migrate_cached_sockets:0

# Replication
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:17.84
used_cpu_user:3.51
used_cpu_sys_children:0.00
used_cpu_user_children:0.01

# Cluster
cluster_enabled:0

# Keyspace
db0:keys=3,expires=0,avg_ttl=0

复现代码
import org.redisson.Redisson;
import org.redisson.api.RTopic;
import org.redisson.api.RedissonClient;

import java.util.UUID;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;

public class RedissonSubErrorTest {

    static RedissonClient redissonClient = Redisson.create();
    static ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 2);


    public static RTopic<String> getRequestTopic() {
        return redissonClient.getTopic("request-topic");
    }

    public static RTopic<String> getResponseTopic(String msgId) {
        return redissonClient.getTopic("response-topic-" + msgId);
    }

    public static void consume(String msgId, Consumer<String> consumer) {
        RTopic<String> topic = getResponseTopic(msgId);
        topic.addListener((channel, msg) -> {
            consumer.accept(msg);

            //*********[删除本行可解决此问题]**********
            topic.removeAllListeners();
        });

    }

    public static void main(String[] args) {
        AtomicLong responseCounter = new AtomicLong();
        AtomicLong requestCounter = new AtomicLong();

        executorService.submit(() -> {
            try {
                getRequestTopic()
                        .addListener((channel, msg) -> {
                            System.out.print("accept [" + msg + "] publish result: ");
                            getResponseTopic(msg).publish("response-" + msg + "(" + responseCounter.incrementAndGet() + ")");
                            System.out.println("ok");
                        });
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        executorService.scheduleAtFixedRate(() -> {
            String msgId = UUID.randomUUID().toString();
            try {
                System.out.print("consume [" + msgId+"] times "+requestCounter.incrementAndGet());
                consume(msgId, msg->{

                });
                System.out.println(" ok");
                System.out.print("publish request [" + msgId+"]");
                getRequestTopic().publish(msgId);
                System.out.println(" ok");
            } catch (Exception e) {
                e.printStackTrace();
            }

        }, 100, 100, TimeUnit.MILLISECONDS);
    }
}

输出
consume [b00ca1ff-f7f4-4c57-994e-66c569ccef59] times 1 ok
publish request [b00ca1ff-f7f4-4c57-994e-66c569ccef59] ok
accept [b00ca1ff-f7f4-4c57-994e-66c569ccef59] publish result: ok
consume [fd3e8c42-6544-46a2-aeb8-fb2e7fff4677] times 2 ok
publish request [fd3e8c42-6544-46a2-aeb8-fb2e7fff4677] ok
accept [fd3e8c42-6544-46a2-aeb8-fb2e7fff4677] publish result: ok
consume [58337154-1947-4429-bd46-ed16c8293cc2] times 3 ok
publish request [58337154-1947-4429-bd46-ed16c8293cc2] ok
accept [58337154-1947-4429-bd46-ed16c8293cc2] publish result: ok
consume [f89b7327-360e-4f1e-ab21-3207e5d1f979] times 4 ok
publish request [f89b7327-360e-4f1e-ab21-3207e5d1f979] ok
accept [f89b7327-360e-4f1e-ab21-3207e5d1f979] publish result: ok
consume [b81afdb8-fe94-4a70-8232-6f8eb5fde86a] times 5 ok
publish request [b81afdb8-fe94-4a70-8232-6f8eb5fde86a] ok
accept [b81afdb8-fe94-4a70-8232-6f8eb5fde86a] publish result: ok
consume [7c294875-7fc6-40c8-a4ce-2fcf9700b83c] times 6 ok
publish request [7c294875-7fc6-40c8-a4ce-2fcf9700b83c] ok
accept [7c294875-7fc6-40c8-a4ce-2fcf9700b83c] publish result: ok
consume [9d3b8e9f-7fdc-440d-84d9-84e915d7a3f6] times 7 ok
publish request [9d3b8e9f-7fdc-440d-84d9-84e915d7a3f6] ok
accept [9d3b8e9f-7fdc-440d-84d9-84e915d7a3f6] publish result: ok
consume [30cf5df0-7da0-461a-a9c9-b87aecd9a0bd] times 8 ok
publish request [30cf5df0-7da0-461a-a9c9-b87aecd9a0bd] ok
accept [30cf5df0-7da0-461a-a9c9-b87aecd9a0bd] publish result: ok
consume [4b5ff736-8728-4a39-af27-a1e6e9cfddb8] times 9 ok
publish request [4b5ff736-8728-4a39-af27-a1e6e9cfddb8] ok
accept [4b5ff736-8728-4a39-af27-a1e6e9cfddb8] publish result: ok
consume [dbbc3354-b3bd-4ab6-8557-f6821ec09948] times 10 ok
publish request [dbbc3354-b3bd-4ab6-8557-f6821ec09948] ok
accept [dbbc3354-b3bd-4ab6-8557-f6821ec09948] publish result: ok
consume [048072d4-8c28-46a2-954e-c05d6577f4db] times 11 ok
publish request [048072d4-8c28-46a2-954e-c05d6577f4db] ok
accept [048072d4-8c28-46a2-954e-c05d6577f4db] publish result: ok
consume [16d10170-58cf-40b3-bb45-187b7bb82da3] times 12 ok
publish request [16d10170-58cf-40b3-bb45-187b7bb82da3] ok
accept [16d10170-58cf-40b3-bb45-187b7bb82da3] publish result: ok
consume [1eecc1db-f479-45c7-9a43-d98b87c2cd7b] times 13 ok
publish request [1eecc1db-f479-45c7-9a43-d98b87c2cd7b] ok
accept [1eecc1db-f479-45c7-9a43-d98b87c2cd7b] publish result: ok
consume [3562cf2e-211e-4ec3-ba29-fa19f28f0159] times 14 ok
publish request [3562cf2e-211e-4ec3-ba29-fa19f28f0159] ok
accept [3562cf2e-211e-4ec3-ba29-fa19f28f0159] publish result: ok
consume [2a30a36e-4144-4619-b4d9-a9a9b2e3b22e] times 15 ok
publish request [2a30a36e-4144-4619-b4d9-a9a9b2e3b22e] ok
accept [2a30a36e-4144-4619-b4d9-a9a9b2e3b22e] publish result: ok
consume [bf85d4bb-f6d3-49e8-ad8c-22154de7f526] times 16 ok
publish request [bf85d4bb-f6d3-49e8-ad8c-22154de7f526] ok
accept [bf85d4bb-f6d3-49e8-ad8c-22154de7f526] publish result: ok
consume [fbd0e428-09bc-466e-a981-c317cc67649f] times 17 ok
publish request [fbd0e428-09bc-466e-a981-c317cc67649f] ok
accept [fbd0e428-09bc-466e-a981-c317cc67649f] publish result: ok
consume [2c38c431-c22d-463e-bbd5-601648dde4d3] times 18 ok
publish request [2c38c431-c22d-463e-bbd5-601648dde4d3] ok
accept [2c38c431-c22d-463e-bbd5-601648dde4d3] publish result: ok
consume [0bd47020-0039-4b66-9485-2a171d0f8b24] times 19 ok
publish request [0bd47020-0039-4b66-9485-2a171d0f8b24] ok
accept [0bd47020-0039-4b66-9485-2a171d0f8b24] publish result: ok
consume [5de00553-50d5-4340-ae18-76951cbc78d4] times 20 ok
publish request [5de00553-50d5-4340-ae18-76951cbc78d4] ok
accept [5de00553-50d5-4340-ae18-76951cbc78d4] publish result: ok
consume [55a7312b-f1ab-49a3-a49a-de7d18f58c02] times 21 ok
publish request [55a7312b-f1ab-49a3-a49a-de7d18f58c02] ok
accept [55a7312b-f1ab-49a3-a49a-de7d18f58c02] publish result: ok
consume [43e1361e-5806-42dc-a6fd-b0efb22c5cc1] times 22 ok
publish request [43e1361e-5806-42dc-a6fd-b0efb22c5cc1] ok
accept [43e1361e-5806-42dc-a6fd-b0efb22c5cc1] publish result: ok
consume [a749aa68-57ea-40fc-8c95-30b5bf7a1a9d] times 23 ok
publish request [a749aa68-57ea-40fc-8c95-30b5bf7a1a9d] ok
accept [a749aa68-57ea-40fc-8c95-30b5bf7a1a9d] publish result: ok
consume [df33ba6a-60ea-4e64-8e9b-69d9fbfe2b81] times 24 ok
publish request [df33ba6a-60ea-4e64-8e9b-69d9fbfe2b81] ok
accept [df33ba6a-60ea-4e64-8e9b-69d9fbfe2b81] publish result: ok
consume [9062568f-5c30-429b-8f46-b65ae7a5a711] times 25 ok
publish request [9062568f-5c30-429b-8f46-b65ae7a5a711] ok
accept [9062568f-5c30-429b-8f46-b65ae7a5a711] publish result: ok
consume [1ff12c28-1586-4086-ab61-b80ad11a2de9] times 26 ok
publish request [1ff12c28-1586-4086-ab61-b80ad11a2de9] ok
accept [1ff12c28-1586-4086-ab61-b80ad11a2de9] publish result: ok
consume [69472202-1aba-492b-ac1c-f9f4554b79a5] times 27 ok
publish request [69472202-1aba-492b-ac1c-f9f4554b79a5] ok
accept [69472202-1aba-492b-ac1c-f9f4554b79a5] publish result: ok
consume [5a75099e-1b9b-4f36-9706-690435ed8048] times 28 ok
publish request [5a75099e-1b9b-4f36-9706-690435ed8048] ok
accept [5a75099e-1b9b-4f36-9706-690435ed8048] publish result: ok
consume [043e5df4-0601-447b-9d99-bf8e388d6d91] times 29 ok
publish request [043e5df4-0601-447b-9d99-bf8e388d6d91] ok
accept [043e5df4-0601-447b-9d99-bf8e388d6d91] publish result: ok
consume [21b57a16-e865-4005-ad4e-14675f7ee729] times 30 ok
publish request [21b57a16-e865-4005-ad4e-14675f7ee729] ok
accept [21b57a16-e865-4005-ad4e-14675f7ee729] publish result: ok
consume [5514e4e6-a5c7-41e1-adac-27103e763c90] times 31 ok
publish request [5514e4e6-a5c7-41e1-adac-27103e763c90] ok
accept [5514e4e6-a5c7-41e1-adac-27103e763c90] publish result: ok
consume [56b41d0f-8b29-4045-8db9-327f4be42f65] times 32 ok
publish request [56b41d0f-8b29-4045-8db9-327f4be42f65] ok
accept [56b41d0f-8b29-4045-8db9-327f4be42f65] publish result: ok
consume [1b231538-79b4-47cd-9599-078c79ae5d17] times 33 ok
publish request [1b231538-79b4-47cd-9599-078c79ae5d17] ok
accept [1b231538-79b4-47cd-9599-078c79ae5d17] publish result: ok
consume [afcb6ad2-8daf-4b19-9850-a7c40a664bf7] times 34 ok
publish request [afcb6ad2-8daf-4b19-9850-a7c40a664bf7] ok
accept [afcb6ad2-8daf-4b19-9850-a7c40a664bf7] publish result: ok
consume [843e0d65-d5d5-41c5-bfc3-933e475faae1] times 35 ok
publish request [843e0d65-d5d5-41c5-bfc3-933e475faae1] ok
accept [843e0d65-d5d5-41c5-bfc3-933e475faae1] publish result: ok
consume [07b2d9f9-631e-4807-84a7-977a737e2e36] times 36 ok
publish request [07b2d9f9-631e-4807-84a7-977a737e2e36] ok
accept [07b2d9f9-631e-4807-84a7-977a737e2e36] publish result: ok
consume [ed5e3995-bee6-4595-8e8a-71c394b88c7d] times 37 ok
publish request [ed5e3995-bee6-4595-8e8a-71c394b88c7d] ok
accept [ed5e3995-bee6-4595-8e8a-71c394b88c7d] publish result: ok
consume [c26ee613-6baf-4b20-ad6c-d77889d64e72] times 38 ok
publish request [c26ee613-6baf-4b20-ad6c-d77889d64e72] ok
accept [c26ee613-6baf-4b20-ad6c-d77889d64e72] publish result: ok
consume [fdb01678-19af-4cc3-a280-a363223d2a2c] times 39 ok
publish request [fdb01678-19af-4cc3-a280-a363223d2a2c] ok
accept [fdb01678-19af-4cc3-a280-a363223d2a2c] publish result: ok
consume [1f6ac25b-537c-45c1-8741-35498c68a9d6] times 40 ok
publish request [1f6ac25b-537c-45c1-8741-35498c68a9d6] ok
accept [1f6ac25b-537c-45c1-8741-35498c68a9d6] publish result: ok
consume [df1cb753-137b-4e41-b2b1-f8993d9042e8] times 41 ok
publish request [df1cb753-137b-4e41-b2b1-f8993d9042e8] ok
accept [df1cb753-137b-4e41-b2b1-f8993d9042e8] publish result: ok
consume [e7e0b01c-d1cc-4d3d-ad77-194679119013] times 42 ok
publish request [e7e0b01c-d1cc-4d3d-ad77-194679119013] ok
accept [e7e0b01c-d1cc-4d3d-ad77-194679119013] publish result: ok
consume [6cc2e099-5a1b-4c1e-90fb-d75d8010d0dd] times 43 ok
publish request [6cc2e099-5a1b-4c1e-90fb-d75d8010d0dd] ok
accept [6cc2e099-5a1b-4c1e-90fb-d75d8010d0dd] publish result: ok
consume [151136a5-2204-40ec-a31b-c0942a362b06] times 44 ok
publish request [151136a5-2204-40ec-a31b-c0942a362b06] ok
accept [151136a5-2204-40ec-a31b-c0942a362b06] publish result: ok
consume [43b1a2f4-b652-4a2f-bd23-3902d00ae3bb] times 45 ok
publish request [43b1a2f4-b652-4a2f-bd23-3902d00ae3bb] ok
accept [43b1a2f4-b652-4a2f-bd23-3902d00ae3bb] publish result: ok
consume [db015885-d6b5-42bc-b953-9af535335190] times 46 ok
publish request [db015885-d6b5-42bc-b953-9af535335190] ok
accept [db015885-d6b5-42bc-b953-9af535335190] publish result: ok
consume [9aa892aa-91b3-41d3-b761-c4cb80263bc7] times 47 ok
publish request [9aa892aa-91b3-41d3-b761-c4cb80263bc7] ok
accept [9aa892aa-91b3-41d3-b761-c4cb80263bc7] publish result: ok
consume [4edc10ed-53b0-412a-98f5-995b1d4bf9f4] times 48 ok
publish request [4edc10ed-53b0-412a-98f5-995b1d4bf9f4] ok
accept [4edc10ed-53b0-412a-98f5-995b1d4bf9f4] publish result: ok
consume [1146df16-f8c1-489b-9be4-5949ad87f787] times 49 ok
publish request [1146df16-f8c1-489b-9be4-5949ad87f787] ok
accept [1146df16-f8c1-489b-9be4-5949ad87f787] publish result: ok
consume [a3e6b48a-4799-4b1f-9933-e874bb2ba6b1] times 50 ok
publish request [a3e6b48a-4799-4b1f-9933-e874bb2ba6b1] ok
accept [a3e6b48a-4799-4b1f-9933-e874bb2ba6b1] publish result: ok
consume [3b43ede5-1bce-45ee-b3c8-16829b09a982] times 51
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
3.x
Redisson version
3.8.2
Redisson configuration
@Bean(name = "redisSingleClient", destroyMethod = "shutdown")
    RedissonClient redisSingleClientInit() {
        Config config = new Config();
        config.setCodec(StringCodec.INSTANCE);
        SingleServerConfig singleConfig = config.useSingleServer();
        singleConfig.setAddress("redis://" + url);
        return Redisson.create(config);
    }

默认选中的数据库是0库，想在代码中动态切换6/7/8库，怎么操作？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
3.x
Redisson version
3.8.2
Redisson configuration
@Bean(name = "redisSingleClient", destroyMethod = "shutdown")
    RedissonClient redisSingleClientInit() {
        Config config = new Config();
        config.setCodec(StringCodec.INSTANCE);
        SingleServerConfig singleConfig = config.useSingleServer();
        singleConfig.setAddress("redis://" + url);
        return Redisson.create(config);
    }

How to dynamically switch other databases?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis version  4.0.0
Redisson version 3.7.5
Redisson configuration 单机
延时放入到队列，执行多次
RBlockingQueue blockingQueue = redissonClient.getBlockingQueue("blockQueue");
RDelayedQueue delayedQueue = redissonClient.getDelayedQueue(blockingQueue);
CallCdr groupCallCdr = new CallCdr();
delayedQueue.offer(groupCallCdr, 60, TimeUnit.SECONDS);
多次测试后，发现
当1分钟过去后，从阻塞队列获取元素，有时可以获取到，有时则获取不到
RBlockingQueue blockingQueue=redissonClient.getBlockingQueue(“blockQueue”);
while (true) {
CallCdr callCdr = blockingQueue.take();
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
The value associated with the key
Actual behavior
org.redisson.client.RedisConnectionClosedException: Command succesfully sent, but channel [xyz] has been closed!
When I debug happy case I am seeing the actual redisClients in connectionFutures in async method of CommandAsyncService have keepAlive = false. I suspect this may the root cause.
The connections seem to go stale after an unknown duration (verified that the server timeout is not affecting this)
Looking in more detail, I see MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg)
in MasterSlaveConnectionManager.java file is not setting keepAlive flag.
This is extremely hard to repro and I couldn't debug a failure case yet; but it seems like we cannot rely on redisClient abstracting connection handling unless we are missing a config.
Please advise.
Steps to reproduce or test case
Connect to a redis cluster by setting keepAlive = true
Not performing any actions for a long time ranges between 1h to 10h.
Trigger a getMap with existing key value.
Redis version
4.0.9
Redisson version
3.8.2
Redisson configuration
redissonConfig.useClusterServers()
.addNodeAddress("host")
.setMasterConnectionMinimumIdleSize(8)
.setMasterConnectionPoolSize(1924)
.setSlaveConnectionMinimumIdleSize(8)
.setSlaveConnectionPoolSize(1924)
.setTimeout(20000)
.setDnsMonitoringInterval(-1)
.setKeepAlive(true);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
怎样获得集群中，每台机器的slot的range？
由于在使用mget或者mset的时候，多个key如果不在一个slot中，会出错，所以想通过slot的range判断一下，将在一台机器上的key放到一块查询
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
多线程读写是否有可能 fail-fast  错误？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisClusterClient.getKeys().getKeysByPattern(pattern);
众所周知redis的keys方法，会卡住整个数据库，生产环境中不允许使用keys，
所以想问一下，redisson的keys方法，是不是单独实现的scan操作来模拟keys，源码没太看懂
跟踪源码，发现最终调用了
public RFuture<ListScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, long startPos, String pattern, int count) {
        if (pattern == null) {
            return commandExecutor.readAsync(client, entry, StringCodec.INSTANCE, RedisCommands.SCAN, startPos, "COUNT", count);
        }
        return commandExecutor.readAsync(client, entry, StringCodec.INSTANCE, RedisCommands.SCAN, startPos, "MATCH", pattern, "COUNT", count);
    }

感觉上，是调用了scan的方式。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior: Transactional put Should take slightly more time than normal put
Actual behavior: Taking almost 3000 times more time
Steps to reproduce or test case:
public final void putInCache(Object key, Object value) {
RTransaction transaction = redisson.createTransaction(redissonTransactionOptions);
RLocalCachedMap<Object, Object> cache = transaction
.getLocalCachedMap(redisson.getLocalCachedMap(this.getNeutrinoCacheName(), localCachedMapOptions));
cache.fastPut(key, value);
transaction.commit();
}
Redis version: 4.0.9
Redisson version: 3.7.2
Redisson configuration:
config.useSingleServer().setAddress("redis://10.0.50.128:6379");
config.useSingleServer().setRetryAttempts(3);
config.useSingleServer().setConnectionPoolSize(500);
config.useSingleServer().setRetryInterval(2000);
config.useSingleServer().setConnectTimeout(30000);
FstCodec codec = new FstCodec();
config.setCodec(codec);
redisson = (RedissonClient) Redisson.create(config);

options = TransactionOptions.defaults()

		.syncSlavesTimeout(10, TimeUnit.SECONDS).responseTimeout(10, TimeUnit.SECONDS)
		.retryInterval(5, TimeUnit.SECONDS).retryAttempts(5).timeout(40, TimeUnit.SECONDS);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for PR!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is it correct if Redis cache ttl is the same as timeToLiveInMillis for local cache?
MY_CACHE:
ttl: 300000
maxIdleTime: 300000
maxSize: 1000
localCacheOptions:
evictionPolicy: "LRU"
reconnectionStrategy: "CLEAR"
syncStrategy: "INVALIDATE"
writeMode: "WRITE_THROUGH"
cacheSize: 1000
timeToLiveInMillis: 300000
maxIdleInMillis: 300000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior: Should provide multiple strategies to choose from like whether to allow reads or not while disconnected
Actual behavior: Reads are allowed by default
Redis version: 4.0.9
Redisson version: 3.8.2
Redisson configuration:
config = new Config();
	config.useSingleServer().setAddress("redis://10.0.50.128:6222");
	config.useSingleServer().setPassword("shivendra");
	config.useSingleServer().setDatabase(0);

	config.useSingleServer().setRetryAttempts(3);
	config.useSingleServer().setConnectionPoolSize(500);
	config.useSingleServer().setRetryInterval(2000);
	config.useSingleServer().setConnectTimeout(30000);
	config.useSingleServer().setPingConnectionInterval(5000);
	config.useSingleServer().setPingTimeout(5000);
	FstCodec codec = new FstCodec();
	config.setCodec(codec);
	redisson = (Redisson) Redisson.create(config);

	options = TransactionOptions.defaults()

			.syncSlavesTimeout(5, TimeUnit.SECONDS).responseTimeout(3, TimeUnit.SECONDS)
			.retryInterval(5, TimeUnit.SECONDS).retryAttempts(3).timeout(40, TimeUnit.SECONDS);


	map = redisson.getLocalCachedMap("lock_test", LocalCachedMapOptions.defaults().syncStrategy(SyncStrategy.INVALIDATE).reconnectionStrategy(ReconnectionStrategy.CLEAR));
	rMap = redisson.getMap("lock_test");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ERROR [2018-10-27 18:08:43,504] [redisson-netty-4-1] ClusterConnectionManager: Can't add slave: redis://100.101.26.91:6379
! org.redisson.client.RedisException: ERR max number of clients reached. channel: [id: 0x03f718df, L:/100.111.217.190:53733 - R:100.101.26.91/100.101.26.91:6379] command: (READONLY), params: []
! at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:331) ~[app.jar:1.0.25]
! at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:128) ~[app.jar:1.0.25]
! at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108) ~[app.jar:1.0.25]
! at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[app.jar:1.0.25]
! at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[app.jar:1.0.25]
! at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[app.jar:1.0.25]
! at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[app.jar:1.0.25]
! at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[app.jar:1.0.25]
! at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[app.jar:1.0.25]
! at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[app.jar:1.0.25]
! at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[app.jar:1.0.25]
! at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) ~[app.jar:1.0.25]
! at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[app.jar:1.0.25]
! at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:647) [app.jar:1.0.25]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582) [app.jar:1.0.25]
! at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499) [app.jar:1.0.25]
! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461) [app.jar:1.0.25]
! ... 3 common frames omitted
! Causing: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 100.101.26.91/100.101.26.91:6379
! at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:138) ~[app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) [app.jar:1.0.25]
! at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:83) [app.jar:1.0.25]
! at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:301) [app.jar:1.0.25]
! at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:54) [app.jar:1.0.25]
! at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:266) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) [app.jar:1.0.25]
! at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) [app.jar:1.0.25]
! at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:83) [app.jar:1.0.25]
! at org.redisson.client.RedisClient$2$1$1$1.run(RedisClient.java:240) [app.jar:1.0.25]
! at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [app.jar:1.0.25]
! at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) [app.jar:1.0.25]
! at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:465) [app.jar:1.0.25]
! at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [app.jar:1.0.25]
! at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [app.jar:1.0.25]
! at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]```

I have been using redisson in my application, since last couple of weeks, I have been getting this error. Kindly help me root cause this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We use Reddison as a client for high load sharded Redis cluster consists of 8 nodes. Main use case -  big number of relatively small lua scripts. We use code like this to do it. (Used version is 3.7.5, but I believe same behavior is in trunk)
RScript script = redisson.getScript();
Long result = script.evalSha(RScript.Mode.READ_WRITE, loadedScript, RScript.ReturnType.VALUE, keys, values);
After some performance tests we noticed that load on Redis cluster nodes is uneven - CPU utilization on node which holds '0 slot' was two times higher then on other nodes. It happens because Reddison sends all scripts to '0 slot' and then this node have to 'MOVED' script to correct node for processing. This overloads '0 slot' node.
So we have to find a workaround to send scripts to correct node:
RedissonScript script = (RedissonScript) redisson.getScript(); // cast to class here to get right method 
Long result = script.evalSha(correctMessageKey, RScript.Mode.READ_WRITE, JsonJacksonCodec.INSTANCE,  loadedScript, RScript.ReturnType.VALUE, keys, values);
So I wonder if this a bug or feature?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
When I debugged the class MultiDnsAddressResolverGroup and compared with this commit:

  
    
      redisson/redisson/src/main/java/org/redisson/connection/dns/MultiDnsAddressResolverGroup.java
    
    
         Line 58
      in
      f08cac4
    
  
  
    

        
          
           groups.add(new DnsAddressResolverGroup(channelType, nameServerProvider)); 
        
    
  


I found that the code deployed to https://search.maven.org/artifact/org.redisson/redisson/3.8.2/bundle is missing this line (that is supposed solve the issue).
Maybe this code is missing in the compiled version too?
Expected behavior
Actual behavior
Steps to reproduce or test case
Redisson version
3.8.2
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I am new redis and AWS elasticache and I am working on a legacy codebase which uses oracle coherent caching. I need to replace it with AWS elasticache and Redission does that. But me being new not able to find how to actually use Redisson for this. Elasticache endpoint is private so that cant be passed to redission client.
Please help me with providing an example so that i can actually progress on this
Thanks
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm playing with the Redisson's great feature for near cache, then did some benchmark testing on it.
It brings a huge performance boost compares to directly interacting with redis, however it's takes much longer than "real" local cache, especially for put operation, around 100~200 times longer. For instance, each Redisson fastPutAsync takes around 175536ns, while real local cache finishes in 1060ns; Redisson get takes 9737ns, real local cache takes 151ns. This can become quite noticeable for read/write intensive applications.
From the reading on document/wiki on RLocalCachedMap, it essentially keeps a local copy of the cache in application's memory, performance should be roughly the same as real local cache. Any thoughts / suggestions on the slowness of RLocalCachedMap please?
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
I got some classCastException :
Exception in thread "redisson-3-38" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long at org.redisson.spring.session.RedissonSessionRepository$RedissonSession.load(RedissonSessionRepository.java:103) at org.redisson.spring.session.RedissonSessionRepository.findById(RedissonSessionRepository.java:310) at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:252) at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:52) at org.redisson.PubSubPatternMessageListener.onPatternMessage(PubSubPatternMessageListener.java:80) at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:87) at org.redisson.client.handler.CommandPubSubDecoder$2.run(CommandPubSubDecoder.java:181) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748) 
Here the payload that redisson trying to decode :
1) "\"session:maxInactiveInterval\"" 2) "1800" 3) "\"session:lastAccessedTime\"" 4) "[\"java.lang.Long\",1540985842940]" 5) "\"session:creationTime\"" 6) "[\"java.lang.Long\",1540985842937]"
If we check into the source code
https://github.com/redisson/redisson/blob/redisson-3.7.5/redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java
at l:103 with see that you are trying to cast into a Long. On older version you used to cast it into an Integer.
Unfortunately i cannot decrease my redisson version because i have updated spring session in 2.x.x .
I think you can keep a cast into an Integer. I don't think people will configure the session ttl to more than 2147483647 seconds.
Steps to reproduce or test case
Redisson version
redisson : 3.7.5
spring boot : 2.0.4.RELEASE
spring session: 2.0.5.RELEASE
Redisson configuration
`
@configuration
@EnableRedissonHttpSession
public class RedissonConfig implements BeanClassLoaderAware
{
@Autowired
private RedisProperties redisProperties;
private static final int CONNECTION_TIMEOUT = 3000;
private static final int TIMEOUT = 10000;
private static final int THREAD_NUMBER = 4;

private ClassLoader loader;

@Bean(destroyMethod = "shutdown")
public RedissonClient redissonClient()
{
    if (redisProperties.isSingleServer()) {
        return Redisson.create(singleServer());
    }
    return Redisson.create(sentinelServers());
}

private Config baseConfig()
{
    return new Config()
            .setNettyThreads(THREAD_NUMBER)
            .setThreads(THREAD_NUMBER)
            .setCodec(new JsonJacksonCodec(mapper()));
}

private Config sentinelServers()
{
    final Config config = baseConfig();
    config.useSentinelServers()
            .setConnectTimeout(CONNECTION_TIMEOUT)
            .setTimeout(TIMEOUT)
            .addSentinelAddress(split(redisProperties.getAddresses(), ", "))
            .setMasterName(redisProperties.getMasterName())
            .setPassword(redisProperties.getPassword());
    return config;
}

private Config singleServer()
{
    final Config config = baseConfig();
    config.useSingleServer()
            .setConnectTimeout(CONNECTION_TIMEOUT)
            .setTimeout(TIMEOUT)
            .setAddress(redisProperties.getAddresses())
            .setPassword(redisProperties.getPassword());
    return config;
}

@Override
public void setBeanClassLoader(final ClassLoader classLoader)
{
    this.loader = classLoader;
}

private ObjectMapper mapper()
{
    final ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    mapper.registerModules(SecurityJackson2Modules.getModules(this.loader));
    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
    mapper.setSerializationInclusion(Include.NON_NULL);
    mapper.addMixIn(Throwable.class, JsonJacksonCodec.ThrowableMixIn.class);
    mapper.findAndRegisterModules();
    return mapper;
}

}`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: ERR Error running script (call to f_c7545856d197b86a5f3527597afb440f1edcafa3): @enable_strict_lua:15: user_script:1: Script attempted to access unexisting global variable 'struct' . channel: [id: 0xf83f8de3, L:/172.18.0.10:55606 - R:10.107.48.9/10.107.48.9:6379] command: (EVAL), params: [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[5]); if v == false then inserta..., 8, UserBindDeviceMap, redisson__timeout__set:{UserBindDeviceMap}, redisson__idle__set:{UserBindDeviceMap}, redisson_map_cache_created:{UserBindDeviceMap}, redisson_map_cache_updated:{UserBindDeviceMap}, redisson__map_cache__last_access__set:{UserBindDeviceMap}, redisson_map_cache_removed:{UserBindDeviceMap},
Expected behavior
Actual behavior
Steps to reproduce or test case
使用带Cache字样的类都会触发,
Redis version
v2.8
Redisson version
3.7.5
Redisson configuration
        config.useSingleServer()
            .setAddress(redisServer);
        Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class RMapCacheMain6 {
private static RedissonClient client;

static {

    Config config = new Config();
    config.useSingleServer()
        .setTimeout(1000000)
        .setAddress("redis://127.0.0.1:6379").setPassword("passwd123");
    client = Redisson.create(config);
}

private static RMapCache<Date, Date> rMapCache = client.getMapCache("RMapCache");

@Before
public void before() {
    client.getKeys().flushall();
}

@After
public void after() {
    client.shutdown();
}

@Test
public void mapCompute() throws Exception {
    while (true) {
        rMapCache.put(new Date(), new Date(), 1, TimeUnit.SECONDS);
        RBatch batch = client.createBatch(BatchOptions.defaults());
        batch.getMapCache("RMapCache").sizeAsync().getNow();
        batch.execute().getResponses().forEach(System.out::println);
        TimeUnit.SECONDS.sleep(1);
    }
}

}
在 RMapCache 中存入数据 保留一秒，使用 RBatch 去获取这个 RMapCache 大小，并不能清除过期的数据。
Expected behavior
1
Actual behavior
1
2
3
4
5
2
3
4
5
6
Redis version
4.0.11
Redisson version
3.9.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
The issue happened on multiple servers minutes after deployment
Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=49, freeConnectionsAmount=16, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://100.65.5.107:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@183817154 [redisClient=[addr=redis://100.65.15.190:6379], channel=[id: 0x2f13b04f, L:0.0.0.0/0.0.0.0:55402]], command: (HMGET), command params: [jlr:METADATA_CACHE_KEY, "CI_JOB_NAMES", "TEST_EXECUTION_OS", "TEST_EXECUTION_NAMES", "LATEST_TEST_EXECUTION_TIME", "TEST_EXECUTION_TAGS", "TEST_EXECUTION_DEVICES_V2", "LATEST_CI_JOB_TIME"] after 3 retry attempts org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=49, freeConnectionsAmount=16, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://100.65.5.107:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@183817154 [redisClient=[addr=redis://100.65.15.190:6379], channel=[id: 0x2f13b04f, L:0.0.0.0/0.0.0.0:55402]], command: (HMGET), command params: [jlr:METADATA_CACHE_KEY, "CI_JOB_NAMES", "TEST_EXECUTION_OS", "TEST_EXECUTION_NAMES", "LATEST_TEST_EXECUTION_TIME", "TEST_EXECUTION_TAGS", "TEST_EXECUTION_DEVICES_V2", "LATEST_CI_JOB_TIME"] after 3 retry attempts at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:837) ~[redisson-3.9.0.jar:?] at org.redisson.command.CommandAsyncService.access$200(CommandAsyncService.java:92) ~[redisson-3.9.0.jar:?] at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:794) ~[redisson-3.9.0.jar:?] at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:791) ~[redisson-3.9.0.jar:?] at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:987) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:869) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1391) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1081) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1128) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1070) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.30.Final.jar:4.1.30.Final] at java.lang.Thread.run(Thread.java:844) [?:?] Caused by: java.nio.channels.ClosedChannelException at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[netty-transport-4.1.30.Final.jar:4.1.30.Final]``
Steps to reproduce or test case
Redis version
3.0.7
Redisson version
3.9.0
Redisson configuration
Our redisson configuration:
Sentinel cluster with 4 nodes
masterConnectionPoolMinSize=16
masterConnectionPoolMaxSize=64
slaveConnectionPoolMinSize=16
slaveConnectionPoolMaxSize=64
timeout=3000
keepAlive=false
idleConnectionTimeout=10000
connectTimeout=10000
pingConnectionInterval=0
pingTimeout=1000
with password auth
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
你好，我在测试关于RLocalCachedMap的功能，发现订阅数的配置数量会引发超时，并且此线程重试读取依然超时。
测试项目如下：
https://github.com/titus12/TestRedissonTemporary2.git
count = 100,会出问题，count < 50 正常，
redisson.yaml 配置中
subscriptionsPerConnection = 5，subscriptionConnectionPoolSize = 10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis version : 3.2.1
redisson: 3.5.4
jdk:1.8
redis cluster : 3 master, 3 slave
Below exception occurred until application restarts when redis cluster master-slave failover .
[ERROR] 2018-11-03 17:30:21.445 [http-nio-8080-exec-33] AppController: In getAddress Exception
org.redisson.client.RedisConnectionException: Can't aquire connection to [freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@794138c3, freeConnectionsAmount=0, freeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@6b32b3e8, freezed=true, freezeReason=MANAGER, client=[addr=/172.1.1.:16379], nodeType=SLAVE, failedAttempts=2]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:206)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.getConnection(LoadBalancerManager.java:197)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:433)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:744)
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:504)
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:585)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Per the main README:
https://github.com/redisson/redisson/blob/master/README.md
Redisson 2.14.0 should work on Java 1.6.
Actual behavior
Redisson 2.13.1 and above have the class files compiled with version 51.0 (Java 1.7), and will no longer work on 1.6.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
We use a score sorted set to store our user story timelines, these scores are in the form of timestamps
        RScoredSortedSet storyTimeLine = redissonClient.getScoredSortedSet("timeline");
        storyTimeLine.add(timestamp,storyId);

Actual behavior
Collection<String> stories = timeline.valueRangeReversed(startDate.intValue(), endDate.intValue());

should return the list of stories but it returns empty.
Steps to reproduce or test case
When i run the same command from the redis terminal it returns the values
ZREVRANGEBYSCORE timeline 1541425420 1540785105 withscores limit 0 100

Redis version
4.0.0
Redisson version
3.8.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for the contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm Using Jcache with AWS Redis in replicatedServersConfig, but observed jcache get / put operation is always using  master node to for both read and write operations.
in my view get request should go to slave (read) node, put request should go to master node.
Please suggest anything to be changed in my configuration / correct me if i'm wrong.
my cache config:
{
"replicatedServersConfig":{
"idleConnectionTimeout":600000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":5000,
"retryAttempts":3,
"retryInterval":1500,
"failedSlaveReconnectionInterval":3000,
"failedSlaveCheckInterval":60000,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"subscriptionConnectionMinimumIdleSize":5,
"subscriptionConnectionPoolSize":50,
"slaveConnectionMinimumIdleSize":30,
"slaveConnectionPoolSize":50,
"masterConnectionMinimumIdleSize":30,
"masterConnectionPoolSize":50,
"readMode":"SLAVE",
"subscriptionMode":"SLAVE",
"nodeAddresses":[
"redis://...cache.amazonaws.com:6379",
"redis://...cache.amazonaws.com:6379"
],
"scanInterval":3000,
},
"threads":0,
"nettyThreads":0,
"codec":{
"class":"org.redisson.codec.SnappyCodec"
},
"transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm using jcache  implementation and using AWS Redis servers in "replicatedServersConfig", i'm getting response time out exception at "getLockedLock" method. raised another issue  related to jcache.
Please do the needful.
javax.cache.CacheException: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (5000 ms) occured for command: (EVAL) with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, {test_ApplicationFormat}:WSFHEHaApjlCL5QG/Ng/dg:key, 30000, a225e312-e347-40ad-8c37-d4c0d9ef9800:120] channel: [id: 0x2519e10d, L:/172.17.0.3:49640 - R:..cache.amazonaws.com/10.0.0.181:6379]
at org.redisson.jcache.JCache.getLockedLock(JCache.java:746)
at org.redisson.jcache.JCache.get(JCache.java:177)
at CacheRedisCacheRedissonImpl.get(CacheRedisCacheRedissonImpl.java:57)
at ApplicationFormatServiceImpl.getApplicationFormatCache(ApplicationFormatServiceImpl.java:500)
at ApplicationFormatServiceImpl.getApplicationFormatCache(ApplicationFormatServiceImpl.java:309)
at sun.reflect.GeneratedMethodAccessor172.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)
at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)
at com.sun.proxy.$Proxy102.getApplicationFormatCache(Unknown Source)
at controllers.CCPlayUtils.getApplicationFormatCache(CCPlayUtils.java:102)
at controllers.CCPlayApplication.getResponseAsJson(CCPlayApplication.java:127)
at controllers.CCLocaleController$1.call(CCLocaleController.java:30)
at controllers.CCPlayUtils$1.apply(CCPlayUtils.java:974)
at controllers.CCPlayUtils$1.apply(CCPlayUtils.java:964)
at play.core.j.FPromiseHelper$$anonfun$promise$2.apply(FPromiseHelper.scala:34)
at scala.concurrent.impl.Future$PromiseCompletingRunnable.liftedTree1$1(Future.scala:24)
at scala.concurrent.impl.Future$PromiseCompletingRunnable.run(Future.scala:24)
at play.core.j.HttpExecutionContext$$anon$2.run(HttpExecutionContext.scala:37)
at akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:42)
at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(AbstractDispatcher.scala:386)
at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)
at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)
at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)
at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)
Caused by: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (5000 ms) occured for command: (EVAL) with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, {test_ApplicationFormat}:WSFHEHaApjlCL5QG/Ng/dg:key, 30000, a225e312-e347-40ad-8c37-d4c0d9ef9800:120] channel: [id: 0x2519e10d, L:/172.17.0.3:49640 - R:.*.0001.use1.cache.amazonaws.com/10.0.0.181:6379]
at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:752)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473)
at java.lang.Thread.run(Thread.java:745)
Thanks,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when i try to get all values in a map redisson return only 100 values
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
服务器是linux，两台机器，做的redis集群。ip是25和26.但是在使用redisson做batch查询的时候，有时候会出现Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://172.16.1.247:7002], redirect=null
这种问题，导致程序报错。
配置中，并没有配置247这个ip，这个ip是一个虚IP。不是真实ip。不清楚为什么，而且不是每次都出现这个错误。
Redis version
3.X
Redisson version
3.9.0
Redisson configuration
# Redis cluster config
spring.redis.cluster.nodes=\
  172.16.1.25:7001\
  ,172.16.1.25:7002\
  ,172.16.1.25:7003\
  ,172.16.1.26:7004\
  ,172.16.1.26:7005\
  ,172.16.1.26:7006

@Configuration
public class RedissonConfig {
    @Value("${spring.redis.cluster.nodes}")
    String nodes;
    @Bean(name = "redisClusterClient", destroyMethod = "shutdown")
    RedissonClient redisClusterClientInit() {
        Config config = new Config();
        config.setCodec(StringCodec.INSTANCE);
        ClusterServersConfig clusterConfig = config.useClusterServers();
        for (String node : nodes.split(",")) {
            clusterConfig.addNodeAddress("redis://" + node);
        }
        return Redisson.create(config);
    }
}

错误描述如下
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - Caused by: org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=[addr=redis://172.16.1.247:7002], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=32, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://172.16.1.26:7004], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1417226931 [redisClient=[addr=redis://172.16.1.247:7002], channel=[id: 0x6e92dd06, L:0.0.0.0/0.0.0.0:2354]], command: (SCAN), command params: [253940, MATCH, ne:alarm:*:*:*, COUNT, 10] after 3 retry attempts
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:837) ~[redisson-3.9.0.jar!/:na]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at org.redisson.command.CommandAsyncService.access$200(CommandAsyncService.java:92) ~[redisson-3.9.0.jar!/:na]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:794) ~[redisson-3.9.0.jar!/:na]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:791) ~[redisson-3.9.0.jar!/:na]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:987) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:869) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1391) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1081) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1128) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1070) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:446) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.29.Final.jar!/:4.1.29.Final]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at java.lang.Thread.run(Thread.java:745) ~[na:1.8.0_111]
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - Caused by: java.nio.channels.ClosedChannelException: null
08-11-2018 12:05:41 CST azkaban-redis-alarm-to-mysql INFO - 	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[netty-transport-4.1.29.Final.jar!/:4.1.29.Final]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In this issue#1333 (comment)  I found that RedissonRedLock supports Redis cluster mode. In the Redlock algorithm https://redis.io/topics/distlock,I don't think it supports  Master/Slave mode.The description is:

In the distributed version of the algorithm we assume we have N Redis masters. Those nodes are totally independent, so we don’t use replication or any other implicit coordination system.

For example:
The Redis cluster 1 is as follows:
Master1 Slave1
Master2 Slave2
Master3 Slave3
The Redis cluster 2 is as follows:
Master1
Master2
Master3
I am troubled. Does it support  type of  Redis cluster 1 ?
.If it supports then how do I add a configuration, whether the master and slave are added or only the master configuration is added.
For example :
Add as type1
Config config = new Config();
config.useClusterServers().addNodeAddress(Master1, Master2,Master3, Slave1,Slave2, Slave3);
RedissonClient redisson = Redisson.create(config);
RLock lock1 = redisson.getLock(lockName + "1");
RLock lock2 = redisson.getLock(lockName + "2");
RLock lock3 = redisson.getLock(lockName + "3");
RLock lock4 = redisson.getLock(lockName + "4");
RLock lock5 = redisson.getLock(lockName + "5");
RLock lock6 = redisson.getLock(lockName + "6");

Add as type2
Config config = new Config();
config.useClusterServers().addNodeAddress(Master1, Master2,Master3);
RedissonClient redisson = Redisson.create(config);
RLock lock1 = redisson.getLock(lockName + "1");
RLock lock2 = redisson.getLock(lockName + "2");
RLock lock3 = redisson.getLock(lockName + "3");

Add as type3
Config config = new Config();
config.useClusterServers().addNodeAddress(Master1, Master2,Master3, Slave1,Slave2, Slave3);
RedissonClient redisson = Redisson.create(config);
RLock lock1 = redisson.getLock(lockName + "1");
RLock lock2 = redisson.getLock(lockName + "2");
RLock lock3 = redisson.getLock(lockName + "3");


Which type should I choose,or they are all wrong?
Redis version
3.x
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson should be able to connect to local redis running on port 6614.
Actual behavior
Redisson won't start and throws this error:
Caused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: localhost/127.0.0.1:6614
        at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:160)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:327)
        at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:53)
        at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:291)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.client.RedisClient$2$1$2.run(RedisClient.java:250)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: failed to create a new resolver
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:71)
        at org.redisson.connection.dns.MultiDnsAddressResolverGroup.getResolver(MultiDnsAddressResolverGroup.java:65)
        at io.netty.bootstrap.Bootstrap.doResolveAndConnect0(Bootstrap.java:200)
        at io.netty.bootstrap.Bootstrap.access$000(Bootstrap.java:49)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:188)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:174)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103)
        at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(AbstractChannel.java:978)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:512)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:423)
        at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:482)
        ... 6 common frames omitted
Caused by: io.netty.channel.ChannelException: Unable to create Channel from class class io.netty.channel.socket.nio.NioDatagramChannel
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:40)
        at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)
        at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:234)
        at io.netty.resolver.dns.DnsNameResolver.<init>(DnsNameResolver.java:394)
        at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:430)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newNameResolver(DnsAddressResolverGroup.java:114)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:94)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:79)
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
        ... 20 common frames omitted
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.GeneratedConstructorAccessor36.newInstance(Unknown Source)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:38)
        ... 28 common frames omitted
Caused by: io.netty.channel.ChannelException: Failed to open a socket.
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:88)
        at io.netty.channel.socket.nio.NioDatagramChannel.<init>(NioDatagramChannel.java:116)
        ... 32 common frames omitted
Caused by: java.net.SocketException: maximum number of DatagramSockets reached
        at sun.net.ResourceManager.beforeUdpCreate(ResourceManager.java:73)
        at sun.nio.ch.DatagramChannelImpl.<init>(DatagramChannelImpl.java:111)
        at sun.nio.ch.SelectorProviderImpl.openDatagramChannel(SelectorProviderImpl.java:42)
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:86)
        ... 33 common frames omitted

Steps to reproduce or test case
Redis version
2.8.19
Redisson version
3.9.0
Redisson configuration
		final org.redisson.config.Config rConfig = new org.redisson.config.Config()
				.setTransportMode(TransportMode.NIO);
		rConfig.useSingleServer()
				.setAddress("redis://localhost:6614")
				.setPassword(password);
So a few things to note.
I'm only having this issue with 3.9.0. 3.8.2 works just fine.
I tried replacing the address with "redis://127.0.0.1:6614", and I got the same error:
Caused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 127.0.0.1/127.0.0.1:6614
        at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:160)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:327)
        at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:53)
        at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:291)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108)
        at org.redisson.client.RedisClient$2$1$2.run(RedisClient.java:250)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: failed to create a new resolver
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:71)
        at org.redisson.connection.dns.MultiDnsAddressResolverGroup.getResolver(MultiDnsAddressResolverGroup.java:65)
        at io.netty.bootstrap.Bootstrap.doResolveAndConnect0(Bootstrap.java:200)
        at io.netty.bootstrap.Bootstrap.access$000(Bootstrap.java:49)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:188)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:174)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
        at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103)
        at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(AbstractChannel.java:978)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:512)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:423)
        at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:482)
        ... 6 common frames omitted
Caused by: io.netty.channel.ChannelException: Unable to create Channel from class class io.netty.channel.socket.nio.NioDatagramChannel
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:40)
        at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:320)
        at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:234)
        at io.netty.resolver.dns.DnsNameResolver.<init>(DnsNameResolver.java:394)
        at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:430)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newNameResolver(DnsAddressResolverGroup.java:114)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:94)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:79)
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:69)
        ... 20 common frames omitted
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.GeneratedConstructorAccessor35.newInstance(Unknown Source)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:38)
        ... 28 common frames omitted
Caused by: io.netty.channel.ChannelException: Failed to open a socket.
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:88)
        at io.netty.channel.socket.nio.NioDatagramChannel.<init>(NioDatagramChannel.java:116)
        ... 32 common frames omitted
Caused by: java.net.SocketException: maximum number of DatagramSockets reached
        at sun.net.ResourceManager.beforeUdpCreate(ResourceManager.java:73)
        at sun.nio.ch.DatagramChannelImpl.<init>(DatagramChannelImpl.java:111)
        at sun.nio.ch.SelectorProviderImpl.openDatagramChannel(SelectorProviderImpl.java:42)
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:86)
        ... 33 common frames omitted

I also tried removing the "redis://" part and only include "localhost:6614" or "127.0.0.1:6614", and I got a completely different error, which is:
Caused by: java.lang.IllegalArgumentException: Illegal character in scheme name at index 0: [localhost]:6614
        at java.net.URI.create(URI.java:852)
        at org.redisson.misc.URIBuilder.create(URIBuilder.java:39)
        at org.redisson.config.SingleServerConfig.setAddress(SingleServerConfig.java:119)

and
Caused by: java.lang.IllegalArgumentException: Illegal character in scheme name at index 0: 127.0.0.1:6614
        at java.net.URI.create(URI.java:852)
        at org.redisson.misc.URIBuilder.create(URIBuilder.java:31)
        at org.redisson.config.SingleServerConfig.setAddress(SingleServerConfig.java:119)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actual behavior
org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=19, freeConnectionsCounter=99, freezed=false, freezeReason=null, client=[addr=redis://xxx:8547], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@71309928 [redisClient=[addr=redis://xxx:8547], channel=[id: 0x5acfe8a4, L:/xxx1:59042 ! R:xxx/xxx:8547]], command: (EXISTS), command params: [2430000015871226] after 3 retry attempts]
at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:837)
at org.redisson.command.CommandAsyncService.access$200(CommandAsyncService.java:92)
at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:794)
at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:791)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:987)
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:869)
at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1391)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1081)
at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1128)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1070)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)

Caused by: java.nio.channels.ClosedChannelException
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)
Redisson version
 3.9.0

Redisson configuration
<redisson:client id="redissonClient">
<redisson:single-server
address="redis://${redis.jedisConnectionFactory.hostName}:${redis.jedisConnectionFactory.port}"
password="${redis.jedisConnectionFactory.password}"
retry-attempts="${redisson.retry-attempts}"
retry-interval="${redisson.retry-interval}"
connection-minimum-idle-size="${redisson.connection-minimum-idle-size}"
connection-pool-size="${redisson.connection-pool-size}"
ping-timeout="${redisson.ping-timeout}"
timeout="${redisson.timeout}"
idle-connection-timeout="${redisson.idle-connection-timeout}"
connect-timeout="${redisson.connect-timeout}"
failed-slave-reconnection-interval=""
database="${redis.session.dbIndex}"/>
redisson.retry-attempts=10
redisson.retry-interval=1500
redisson.connection-minimum-idle-size=20
redisson.connection-pool-size=100
redisson.ping-timeout=1000
redisson.timeout=3000
redisson.idle-connection-timeout=10000
redisson.connect-timeout=10000
</redisson:client>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Have possibility to set lockWatchdogTimeout property in xml redisson:single-server configuration.
Actual behavior
Possible only in "by hand" creation of Redisson client.
Please, explain, how to do it now the best way, when client is creating using xml-config.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: java.lang.NullPointerException
at org.redisson.client.handler.CommandPubSubDecoder.selectDecoder(CommandPubSubDecoder.java:246)
~[redisson-3.9.1.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:351) ~[redisson-3.9.1.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:413) ~[redisson-3.9.1.jar:?] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.9.1.jar:?]
at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:78)
~[redisson-3.9.1.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108) ~[redisson-3.9.1.jar:?]
Expected behavior
在使用多线程调用RLock的时候，时不时出现这个npe.
单线程跑，暂时未发现
RLock lock = redisson.getLock("MATCH_QUEUE_LOCK");
if (lock.tryLock(10, 10, TimeUnit.SECONDS)) {
try {
.....
} finally {
lock.unlock();
}
} else {
return playerPairs;
}
Actual behavior
Steps to reproduce or test case
Redis version
3.2
Redisson version
3.9.1
Redisson configuration
{
"singleServerConfig": {
"idleConnectionTimeout": 10000,
"pingTimeout": 1000,
"connectTimeout": 10000,
"pingConnectionInterval":10000,
"keepAlive":true,
"timeout": 3000,
"retryAttempts": 3,
"retryInterval": 1500,
"password": null,
"subscriptionsPerConnection": 5,
"clientName": null,
"address": "redis://192.168.1.138:6379",
"subscriptionConnectionMinimumIdleSize": 1,
"subscriptionConnectionPoolSize": 50,
"connectionMinimumIdleSize": 32,
"connectionPoolSize": 64,
"database": 1
},
"threads": 5,
"nettyThreads": 5,
"codec": {
"class": "org.redisson.codec.JsonJacksonCodec"
},
"transportMode": "NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Merged! Thanks for improvement!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://pastebin.com/ytNkXnz0
Redis version
5.0.3
Redisson version
3.9.1
Redisson configuration
default (with protected-mode on && requirepass)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior

Actual behavior

Steps to reproduce or test case
1.login the gy-center sys, test some apis
2.wait long time such as 2 hours not to operate gy-center api
3.the 500 Internal Error occurred like screenshot
Redis version
3.2.10
Redisson version
redisson-tomcat-8-3.8.2.jar
redisson-all-3.8.2.jar
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found in spring boot 2.0.3 redission init so slow
log:
[2018-12-17 17:09:12.063][][][][][main] [INFO ] org.redisson.Version - Redisson 3.7.3
[2018-12-17 17:09:12.614][][][][][main] [WARN ] i.n.r.dns.DefaultDnsServerAddressStreamProvider - Default DNS servers: [/2001:4860:4860:0:0:0:0:8888:53, /2001:4860:4860:0:0:0:0:8844:53] (Google Public DNS as a fallback)
[2018-12-17 17:09:14.136][][][][][main] [INFO ] org.redisson.connection.SentinelConnectionManager - master: redis://10.193.78.170:6379 added
[2018-12-17 17:09:14.144][][][][][main] [INFO ] org.redisson.connection.SentinelConnectionManager - slave: redis://10.193.78.171:6379 added
[2018-12-17 17:09:44.432][][][][][redisson-netty-1-5] [INFO ] org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for 10.193.78.171/10.193.78.171:6379
[2018-12-17 17:09:44.432][][][][][redisson-netty-1-1] [INFO ] org.redisson.connection.pool.SlaveConnectionPool - 32 connections initialized for 10.193.78.171/10.193.78.171:6379
[2018-12-17 17:09:44.490][][][][][redisson-netty-1-6] [INFO ] o.r.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for 10.193.78.170/10.193.78.170:6379
[2018-12-17 17:09:44.491][][][][][redisson-netty-1-6] [INFO ] org.redisson.connection.pool.MasterConnectionPool - 32 connections initialized for 10.193.78.170/10.193.78.170:6379
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version 4.0.9
Redisson version 3.7.3
Redisson configuration
spring.redisson.cache-manager.enabled=true
spring.redisson.cache-manager.dynamic=true
spring.redisson.cache-manager.allow-null-values=false
spring.redisson.cache-manager.codec=jackson
#spring.redisson.cache-manager.config-location=classpath:/cache/cache_config.json
spring.redisson.cache-manager.config-location=file:${custom.config.resource-path}/cache/cache_config.json
#redis
redisson.type=sentinel
redisson.sentinel.idle-connection-timeout=20000
redisson.sentinel.keep-alive=true
redisson.sentinel.connect-timeout=30000
redisson.sentinel.timeout=30000
redisson.sentinel.failed-slave-reconnection-interval=60000
redisson.sentinel.retry-interval=6000
redisson.sentinel.retry-attempts=6
redisson.sentinel.database=0
redisson.sentinel.password=redis2018
redisson.sentinel.master-name=mymaster
redisson.sentinel.sentinel-addresses[0]=redis://10.193.78.170:26379
redisson.sentinel.sentinel-addresses[1]=redis://10.193.78.171:26379
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
queue should be empty after calling drainTo()
Actual behavior
if only one element exists, after calling drainTo() element still exists in the queue
Steps to reproduce or test case

create a redisson blocking queue
add only one element
call drainTo on the queue

Redis version
3.2.10
Redisson version
3.7.0
Redisson configuration

More details
drainTo runs command "ltrim key -1 0" under the hood. start index and stop index is the same so element stays in the list. i think this SO question may be helpful: https://stackoverflow.com/questions/40488194/unable-to-ltrim-when-redis-list-is-having-only-one-record
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Deserialization works as expected when key doesn't exist on given node
Actual behavior
Exception is thrown,
2018-12-19 14:13:11,442 ERROR redisson-netty-4-7 [org.redisson.client.handler.CommandDecoder] - Unable to decode data. reply: -MOVED 11508 10.212.33.61:6379
, channel: [id: 0x93a583e7, L:/10.215.23.63:36708 - R:10.215.34.16/10.215.34.16:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@769675be(incomplete)], command=(DEL), params=[securityInfo:sourceAssetId:YODLEE_DESCR_Vanguard Windsor? II Admiral?], codec=org.redisson.codec.SnappyCodec]
java.lang.IllegalArgumentException: Redis url should start with redis:// or rediss:// (for SSL connection)
at org.redisson.misc.URIBuilder.create(URIBuilder.java:33)
at org.redisson.client.RedisRedirectException.(RedisRedirectException.java:36)
at org.redisson.client.RedisMovedException.(RedisMovedException.java:28)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:316)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:128)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Unknown Source)
Redis version
5.0.0
Redisson version
3.9.1
Redisson configuration
{
"clusterServersConfig": {
"idleConnectionTimeout": 60000,
"pingTimeout": 1000,
"connectTimeout": 10000,
"timeout": 10000,
"retryAttempts": 3,
"retryInterval": 1500,
"subscriptionsPerConnection": 5,
"clientName": "HighAvailCluster",
"sslEnableEndpointIdentification": true,
"sslProvider": "JDK",
"pingConnectionInterval": 0,
"keepAlive": true,
"tcpNoDelay": false,
"loadBalancer": {
"class": "org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"slaveConnectionMinimumIdleSize": 1,
"slaveConnectionPoolSize": 1,
"failedSlaveReconnectionInterval": 3000,
"failedSlaveCheckInterval": 180000,
"masterConnectionMinimumIdleSize": 10,
"masterConnectionPoolSize": 40,
"readMode": "MASTER",
"subscriptionMode": "MASTER",
"subscriptionConnectionMinimumIdleSize": 1,
"subscriptionConnectionPoolSize": 50,
"dnsMonitoringInterval": 5000,
"nodeAddresses": [
"redis://some-endpoint:6379"
],
"scanInterval": 5000,
"slaveSubscriptionConnectionMinimumIdleSize": 1,
"slaveSubscriptionConnectionPoolSize": 50
},
"threads": 0,
"nettyThreads": 0,
"codec": {
"class": "org.redisson.codec.SnappyCodec"
},
"referenceCodecProvider": {
"class": "org.redisson.codec.DefaultReferenceCodecProvider"
},
"referenceEnabled": true,
"transportMode": "NIO",
"lockWatchdogTimeout": 30000,
"keepPubSubOrder": true,
"useScriptCache": false,
"addressResolverGroupFactory": {
"class": "org.redisson.connection.DnsAddressResolverGroupFactory"
},
"useLinuxNativeEpoll": false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
related #1583   Channel Inactive but the event not catched by ConnectionWatchdog.channelInactive()
I think it is the same as #1583 ,  when I use kill -9 redisPid, then restart the redis, it seems work fine. But when the program run one or two days,  this issue appeared. I guess there may be a network problem that caused ConnectionWatchdog.channelActive not to be triggered. Is there any parameter setting to avoid this problem?
The exception stack:
2018-12-19 14:30:24.064 [http-nio-8081-exec-1][10.10.3.117-http-nio-8081-exec-1] ERROR c.b.c.s.w.s.m.m.annotation.HandlerMethodAspect - Throw:
org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=10, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://10.10.3.112:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1662347556 [redisClient=[addr=redis://10.10.3.113:6379], channel=[id: 0xb21f069b, L:/10.10.3.117:50884 ! R:10.10.3.113/10.10.3.113:6379]], command: (HGET), command params: [shiro-activeSessionCache, ��t$afb4da38-cf18-4117-9159-ce16fc61b9d9] after 3 retry attempts
at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:837)
at org.redisson.command.CommandAsyncService.access$200(CommandAsyncService.java:92)
at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:794)
at org.redisson.command.CommandAsyncService$11$1.operationComplete(CommandAsyncService.java:791)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:987)
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:869)
at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1391)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
at io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:38)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1104)
at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1151)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1075)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:466)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.nio.channels.ClosedChannelException: null
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)
Redis version
4.0.9
Redisson version
3.9.1
Redisson configuration
        config.useSentinelServers()
            .setTimeout(2000)
            .setConnectTimeout(10000)
            .setRetryAttempts(3)
            .setRetryInterval(1000)
            .setDnsMonitoringInterval(-1)
            .setDatabase(0)
            .setPingConnectionInterval(10000)
            .setMasterName("mymaster")
            .addSentinelAddress(convert(Arrays.asList(getSentinelNodes().split(","))));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson.create()每次都是new一个Redisson。那么在使用时复用同一个Redisson实例，和通过线程池生成多个实例同时复用，哪个性能更好？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
When call RedissonSession.changeSessionId(), the session id did not change in redis. So, when call another request , redisson cannot find the session in redis.
Steps to reproduce or test case
Redis version
3.2.10
Redisson version
3.9.1
Redisson configuration
spring boot autoconfig with single mode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found a problem with the command declared by ZREVRANGE_ENTRY in the RedissonConnection class. It should be ZREVRANGE, not ZRANGE.
redisson version :3.9.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When usingreplicatedServersConfig configuration you cannot set low retryAttempts & retryInterval without getting command execution timeouts for the check master functionality, which ensures that the client knows which nodes that are master and which aren't.
The timeout for getting a connection, sending the command and waiting for the response is calculated by retryInterval * retryAttempts in the version of redisson that we use currently (2.8.24).
From what I can see the command timeout calculation was introduced in following issue, #1280 (commit was kinbod@387ed74)
It actually seemed to have changed in following commit, 338f9d0, which is included in a later version than we use currently. Now the command timeout is instead set by what timeout value you have set. This commit would probably get rid of the exceptions for command execution timeout for our application, since it uses timeout instead of retryInterval * retryAttempts.
I suggest a change to make this a configurable value for the replicatedServersConfig. This would make it would be possible to have very low values configured for timeout, retryAttempts & retryInterval without it affecting the check master functionality.
Since checking if a node is master is scheduled to be done periodically in the background it is not that important, at least for us, that this will timeout quickly. It is however important to us that we do timeout quickly for the app/user initiated commands. Making this value configurable would make sure that it possible to configure redisson for such a scenario.
Expected behavior
The timeout for checking if a node is master or not, using INFO REPLICATION command, should not be shorter than the total time of command timeout and server response timeout for user/app initiated commands. I expected the time for the timeout to be calculated as (retryInterval * retryAttempts + 1) + timeout to give it the same amount of time to get a connection, send the command and await the response as user/app initiated commands.
Actual behavior
The timeout is calculated using retryInterval * retryAttempts. This seems wrong since it makes the total timeout shorter compared to an app/user initiated command. I would expect it to be at least the same amount of time by default.
Steps to reproduce or test case

Install toxiproxy (https://github.com/Shopify/toxiproxy)
Add a latency toxic higher than 50 ms to one of the redis nodes, and ensure that your java application uses the address and port exposed by toxiproxy.
Update your java application to use the redisson configuration defined in this issue.
Start your java service..

You will now get exceptions starting with the message text:

Command execution timeout for command: (INFO REPLICATION)

Redis version
ElastiCache for Redis 2.8.24
Redisson version
3.7.5
Redisson configuration
replicatedServersConfig:
  idleConnectionTimeout: 10000
  pingTimeout: 1000
  connectTimeout: 10000
  timeout: 250
  retryAttempts: 1
  retryInterval: 50
  scanInterval: 5000
  nodeAddresses:
  - "redis://server1:6379"
  - "redis://server2:6379"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko hello,i had view some close issues,but i dont know which version  really solved this problem.
redis on port 7001 is master
redisson version:2.8.2
the following is my error log
18-12-22.00:10:55.177 [redisson-netty-4-5] ERROR ClusterConnectionManager  - Can't execute CLUSTER_NODES with /xxx.xxx.xxx.xxx:7001
java.lang.IllegalArgumentException: java.net.MalformedURLException: unknown protocol: redis
	at org.redisson.misc.URLBuilder.create(URLBuilder.java:125) ~[redisson-2.8.2.jar:na]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This factory should locate Redisson in JNDI tree rather than creating a new one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This manager should locate Redisson in JNDI tree rather than creating a new one.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Exception stack/message print password as ******:
Caused by: org.redisson.client.RedisException: ERR invalid password. channel: [id: 0xb92cdd41, L:/2a00:8a00:4000:20c:0:0:87:2fb:34496 - R:2a00:8a00:4000:20c::87:2fb/2a00:8a00:4000:20c:0:0:87:2fb:6379] command: (AUTH), params: [ ***** ]
Actual behavior
Exception stack/message print password as plain text which is insecure:
org.redisson.client.RedisConnectionException: Unable to connect to Redis server: 2a00:8a00:4000:20c::87:2fb/2a00:8a00:4000:20c:0:0:87:2fb:6379
at org.redisson.connection.pool.ConnectionPool$2$1.operationComplete(ConnectionPool.java:138) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) ~[?:?]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108) ~[?:?]
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:301) ~[?:?]
at org.redisson.connection.pool.ConnectionPool.access$400(ConnectionPool.java:54) ~[?:?]
at org.redisson.connection.pool.ConnectionPool$4.operationComplete(ConnectionPool.java:266) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[?:?]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121) ~[?:?]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:108) ~[?:?]
at org.redisson.client.RedisClient$2$1$1$1.run(RedisClient.java:240) ~[?:?]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[?:?]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[?:?]
at io
Caused by: org.redisson.client.RedisException: ERR invalid password. channel: [id: 0xb92cdd41, L:/2a00:8a00:4000:20c:0:0:87:2fb:34496 - R:2a00:8a00:4000:20c::87:2fb/2a00:8a00:4000:20c:0:0:87:2fb:6379] command: (AUTH), params: [abcde]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:314) ~[?:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:124) ~[?:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[?:?]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[?:?]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[?:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[?:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[?:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[?:?]
Steps to reproduce or test case
Configure wrong password in redisson("abcde") when connect redis("abcd")
Redis version
any
Redisson version
3.7.0
Redisson configuration
sentinel
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please make PR against latest changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
使用哨兵模式时,将redis集群全部重启后。怎么自动恢复。现在redis集群重启了,应用也必须重启,不然就一直报 SlaveConnectionPool no available Redis entries.  Disconnected hosts [ ......]  Hosts disconnected due to errors during failedSlaveCheckInterval
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
LocalCachedMap.readAllValues() should be very fast, using local cache and should  not query redis.
Actual behavior
LocalCachedMap.readAllValues() cost 100ms+ to read 800+ POJO objects.
In redis-cli monitor, I saw incoming query by redisson
Steps to reproduce or test case
Redis version
Redisson version
2.14.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to reproduce or test case
We're using 1 node in ElasticCache with the following config:
        ReplicatedServersConfig serversConfig = config.useReplicatedServers()
                .setRetryInterval(15000)
                .setRetryAttempts(2);

Already checked the network latency, CPU, memory, everything seems to be normal when the exception happens.
Redis version
4.0.10
Redisson version
3.8.2
This happens around once a day or less, pretty consistently, usually during midnight when system is idle. Seems to be related to reconnection / retry strategy, already tried to bump up retryInterval and retryAttempts following the suggestion in #576.
Full stack trace:
org.redisson.client.RedisTimeoutException: Command execution timeout for command: (INFO REPLICATION), command params: [], Redis client: [addr=http://****cache.amazonaws.com:6379]
    at org.redisson.client.RedisConnection$2.run(RedisConnection.java:214)
    at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
    at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)

Any inputs are welcome, thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson seems to keep the connection to the removed node, and try to reconnect after I shutdown the node. As the figures shown, I had removed 11.4.66.112:43791 and the log confirmed the node had been removed. But Redisson was still trying to connect to the node. After resetting and restarting the node, Redisson reconnected to it and leaded "CLUSTERDOWN Hash slot not served" exception.


Redis version
5.0.2
Redisson version
3.9.1
Redisson configuration
val serversConfig = config.useClusterServers()
serversConfig.readMode = ReadMode.MASTER_SLAVE
serversConfig.masterConnectionMinimumIdleSize = 50
serversConfig.slaveConnectionMinimumIdleSize = 50
serversConfig.subscriptionConnectionMinimumIdleSize = 5
serversConfig.scanInterval = 5000
serversConfig.masterConnectionPoolSize = 512
serversConfig.slaveConnectionPoolSize = 512
serversConfig.idleConnectionTimeout = 180000
serversConfig.connectTimeout = 30000
serversConfig.timeout = 10000
serversConfig.retryInterval = 1000
BTW
When will Redisson distribute the new version that fixed some bugs about "MOVE"?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actually it causes NPE at LoadBalancerManager:192. getEntry method returns null in isUnfreezed call.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson-spring-boot-starter 的自动配置是通过以下属性实现的
spring.redis.redisson.config=classpath:redisson.yaml
而通常springcloud是通过远程拉取的方式，上述的配置方式需要在本地按环境配置多套，又背弃了configserver的初衷。希望官方能符合spring的规范提供api，让spring框架使用者更容易接入redisson
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357) ~[fst-2.56.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.56.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.56.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.56.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:70) ~[redisson-3.10.0.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330) ~[redisson-3.10.0.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130) ~[redisson-3.10.0.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110) ~[redisson-3.10.0.jar:?]

Redis version
3.0.7
Redisson version
3.10.0
Redisson configuration
Our redisson configuration:
Sentinel cluster with 4 nodes
masterConnectionPoolMinSize=16
masterConnectionPoolMaxSize=64
slaveConnectionPoolMinSize=16
slaveConnectionPoolMaxSize=64
timeout=3000
keepAlive=false
idleConnectionTimeout=10000
connectTimeout=10000
pingConnectionInterval=0
pingTimeout=1000
with password auth
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RBlockingQueue.pollFromAny should send the appropriate number of BLPOP instructions to the appropriate number of masters in a redis-cluster configuration.
Actual behavior
RBlockingQueue.pollFromAny sends a single BLPOP instruction regardless of hash-slots and sometimes returns a CROSSSLOT error.
Steps to reproduce or test case

Set up a multi-node redis-cluster with multiple slots ranges going to different masters.
Connect redisson to redis-cluster.
Call RBlockingQueue.pollFromAny with at least two queue names that reside on different masters.
See exception thrown.

Redis version
3.2.5
Redisson version
3.8.1
Redisson configuration
redisson:
  clusterServersConfig:
    nodeAddresses:
    - "redis://redis-0.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-1.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-2.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-3.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-4.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-5.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-6.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-7.redis-main.v1x1.svc.cluster.local:6379"
    - "redis://redis-8.redis-main.v1x1.svc.cluster.local:6379"
    clientName: "v1x1-{{module_name}}"
    readMode: MASTER
    masterConnectionPoolSize: 1024
    retryAttempts: 10
    failedSlaveCheckInterval: 10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ref Redisson Releases History#27-Dec-2018 - versions 2.15.0 and 3.10.0 released

Improvement - default codec changed to FSTCodec

ref NPE after upgrade to 3.10.0
3.10.0以前的版本默认使用 org.redisson.codec.JsonJacksonCodec,而3.10.0改用FSTCodec
意味着升级后，如果要用历史数据，必须 要改代码，改成redisson.getXX("key",JsonJacksonCodec.INSTANCE),否则会报NPE。
感谢 @jackygurui 指出，在创建redisson对象时，指定默认Codec即可
并且使用fst后，无法使用redis工具来查询，修改数据
请谨慎升级。
私认为版本号不应该沿用3.x，而应该改成4.x，或者在changelog上，注明升级后会引起的后果，而不是简单的介绍修改了默认Codec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sry. I meant to apply the changes on tag redisson-3.10.0. Anyway, I will recommit my changes on master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.lang.ArrayIndexOutOfBoundsException
at java.util.ArrayList.elementData(ArrayList.java:433)
at java.util.ArrayList.get(ArrayList.java:446)
at org.redisson.cache.LRUCacheMap.getQueue(LRUCacheMap.java:57)
at org.redisson.cache.LRUCacheMap.onValueCreate(LRUCacheMap.java:52)
at org.redisson.cache.AbstractCacheMap.put(AbstractCacheMap.java:190)
at org.redisson.cache.AbstractCacheMap.put(AbstractCacheMap.java:179)
at org.redisson.liveobject.misc.ClassUtils.isAnnotationPresent(ClassUtils.java:137)
at org.redisson.misc.RedissonObjectFactory.toReference(RedissonObjectFactory.java:166)
at org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:273)
at org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1052)
at org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1037)
at org.redisson.RedissonMap.fastPut(RedissonMap.java:1057)
at org.redisson.tomcat.RedissonSession.fastPut(RedissonSession.java:153)
at org.redisson.tomcat.RedissonSession.setAttribute(RedissonSession.java:200)
at org.apache.catalina.session.StandardSession.setAttribute(StandardSession.java:1415)
at org.apache.catalina.session.StandardSessionFacade.setAttribute(StandardSessionFacade.java:137)
Expected behavior
No ArrayIndexOutOfBoundsException
Actual behavior
Throwing ArrayIndexOutOfBoundsException when setting object into HTTP session using setAttribute
Steps to reproduce or test case
Configure Tomcat 8.5 server with redisson-tomcat-8-2.15.0.jar and redisson-all-2.15.0.jar - try to set object into http session using setAttribute
Redis version
Redis server v=3.0.504 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=a4f7a6e86f2d60b3
Redisson version
redisson-all-2.15.0
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: null
subscriptionsPerConnection: 5
clientName: null
address: "redis://127.0.0.1:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 32
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.SerializationCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
geo.pos(element) returns a map
Actual behavior
Throws exception for trying to cast an ArrayList into a Map
Steps to reproduce or test case
    RGeo geo = redisson.getGeo("features");
    geo.add(0,0,"hi");
    System.out.println(geo.pos("hi"));

Exception in thread "main" java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.util.Map
at org.redisson.RedissonGeo.pos(RedissonGeo.java:126)
at com.examples.redis.MyRedis.main(MyRedis.java:32)
It seems that on RedissonGeo.java line 137 you are using a ListMultiDecoder rather than a GeoDistanceMapDecoder or something more appropriate.  I tested this on 3.7.3 and it was still there.  You should probably have had a unit test for this API.
Redis version
Any
Redisson version
3.9.1
Couldn't confirm 3.10.0 due to inability to find list of dependencies to import
Redisson configuration
Plain jane redisson setup
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Master connection pool can be re-established later even if participal changemaster failed in redisson.
Actual behavior
If participal changemaster failed,  then always throw "RedisTimeoutException: Unable to get connection" and cannot be recoverred.  And seems there are two masterEntry target to both old and new master address.
2019-01-07-T05:41:34.523+0200 | redisson-netty-1-2 | ERROR | org.redisson.connection.SingleEntry | Can't change master to: redis://[2a00:8a00:4000:20c::87:ace]:6379
2019-01-07-T05:44:41.319+0200 | redisson-netty-1-1 | INFO  | org.redisson.connection.pool.MasterPubSubConnectionPool | 1 connections initialized for 2a00:8a00:4000:20c::87:ace/2a00:8a00:4000:20c:0:0:87:ace:6379
2019-01-07-T05:44:41.320+0200 | redisson-netty-1-2 | INFO  | org.redisson.connection.pool.MasterConnectionPool | 32 connections initialized for 2a00:8a00:4000:20c::87:ace/2a00:8a00:4000:20c:0:0:87:ace:6379
2019-01-07-T05:44:41.331+0200 | redisson-netty-1-2 | INFO  | org.redisson.connection.SingleEntry | master 2a00:8a00:4000:20c::87:acf/2a00:8a00:4000:20c:0:0:87:acf:6379 has changed to 2a00:8a00:4000:20c::87:ace/2a00:8a00:4000:20c:0:0:87:ace:6379
2019-01-07-T05:44:43.781+0200 | register-consumer | ERROR | RegisterConsumer | Exception when consume registration/unregistration task
org.redisson.client.RedisTimeoutException: Unable to get connection! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@1822f118, freeConnectionsAmount=32, freeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@64a6870d, freezed=false, freezeReason=null, client=[addr=redis://[2a00:8a00:4000:20c::87:acf]:6379], nodeType=MASTER, firstFail=0]]], command: (BLPOP), command params: [register-queue, 10] after 3 retry attempts
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:532) ~[?:?]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668) ~[?:?]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743) ~[?:?]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471) ~[?:?]
2019-01-07-T05:44:53.981+0200 | thread-14492 | ERROR | TEST | General reason ::
org.redisson.client.RedisTimeoutException: Unable to get connection! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@6dd14177, freeConnectionsAmount=32, freeConnectionsCounter=org.redisson.pubsub.AsyncSemaphore@db605f5, freezed=false, freezeReason=null, client=[addr=redis://[2a00:8a00:4000:20c::87:ace]:6379], nodeType=MASTER, firstFail=0]]], command: (EVAL), command params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, NE3SWS-NeInfo, redisson__timeout__set:{Info}, redisson__idle__set:{Info}, redisson__map_cache__last_access__set:{Info}, {Info}:redisson_options, 1546832687609, PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 256)] after 3 retry attempts
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:532) ~[?:?]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668) ~[?:?]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743) ~[?:?]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471) ~[?:?]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_191]
Steps to reproduce or test case
If any changeMaster activity failed and got "Can't change master to: redis://[2a00:8a00:4000:20c::87:ace]:6379" error, then masterConnection pool will not able to get connection in later phase even master connection recoverred.
Redis version
any
Redisson version
3.7.0
Redisson configuration
3 sentinels + 1 master + 1 slave
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RSetMultimapCache support Read-through, Write-through and so on.
Actual behavior
Read-through strategy
If requested entry doesn't exist in the Redisson Map object when it will be loaded using provided MapLoader object.
Write-through (synchronous) strategy
When the Map entry is being updated method won't return until Redisson update it in an external storage using MapWriter object.
Write-behind (asynchronous) strategy
Updates to the Map object are asynchronously written to external storage using MapWriter object. Threads amount participate in write operation execution in background are controlled by writeBehindThreads setting.
This feature only available for RMap, RMapCache, RLocalCachedMap and RLocalCachedMapCache objects.
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Exception in thread "redisson-3-1" java.lang.NullPointerException at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:251) at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:52) at org.redisson.PubSubPatternMessageListener.onPatternMessage(PubSubPatternMessageListener.java:82) at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84) at org.redisson.client.handler.CommandPubSubDecoder$2.run(CommandPubSubDecoder.java:186) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748)
Steps to reproduce or test case
I got this issue at my application startup. It is not happens at each startup
Redis version
4.0.11
Redisson version
3.10.0
Redisson configuration
`@configuration
@EnableRedissonHttpSession
public class RedissonConfig implements BeanClassLoaderAware
{
@Autowired
private RedisProperties redisProperties;
private static final int CONNECTION_TIMEOUT = 3000;
private static final int TIMEOUT = 10000;
private static final int THREAD_NUMBER = 4;
private ClassLoader loader;
@bean(destroyMethod = "shutdown")
public RedissonClient redissonClient()
{
return Redisson.create(sentinelServers());
}
private Config baseConfig()
{
return new Config()
.setNettyThreads(THREAD_NUMBER)
.setThreads(THREAD_NUMBER)
.setCodec(new JsonJacksonCodec(mapper()));
}
private Config sentinelServers()
{
final Config config = baseConfig();
config.useSentinelServers()
.setConnectTimeout(CONNECTION_TIMEOUT)
.setTimeout(TIMEOUT)
.addSentinelAddress(split(redisProperties.getAddresses(), ", "))
.setMasterName(redisProperties.getMasterName())
.setPassword(redisProperties.getPassword())
.setDatabase(redisProperties.getDatabase());
return config;
}
@OverRide
public void setBeanClassLoader(final ClassLoader classLoader)
{
this.loader = classLoader;
}
private ObjectMapper mapper()
{
final ObjectMapper mapper = new ObjectMapper();
mapper.registerModule(new JavaTimeModule());
mapper.registerModules(SecurityJackson2Modules.getModules(this.loader));
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);
mapper.setSerializationInclusion(Include.NON_NULL);
mapper.addMixIn(Throwable.class, JsonJacksonCodec.ThrowableMixIn.class);
mapper.findAndRegisterModules();
return mapper;
}
}
`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
延迟队列offer给定的时间到了后可以获取到通知
Actual behavior
使用队列或者阻塞队列都在有的时候不能获取到到期信息
Steps to reproduce or test case
添加时候的写法
RQueue queue = redissonClient.getQueue(queueKey);
RDelayedQueue delayedQueue = redissonClient.getDelayedQueue(queue);
delayedQueue.offer(id, nextStartSecond, TimeUnit.SECONDS);
delayedQueue.destroy();
获取数据的写法
@PostConstruct
public void initBlessFinishDelayedQueue() {
try {
execConsume();
} catch (Exception e) {
logger.error("启动监听赐福到期开始定时任务异常-->", e);
}
}

//执行消费线程
protected void execConsume() throws ConfigurationException, IOException, InterruptedException{
	RedissonClient redissonClient = RedissonUtil.getInstance().getRedissonClient();
	final RQueue<Object> queue = redissonClient.getQueue(queueKey);
	ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
         ses.scheduleWithFixedDelay(new Runnable() {
         public void run() {
        	Object takeValue = null;
        	try {
        		takeValue = queue.poll();
            	if(takeValue != null) {
					handlerStartBless(takeValue.toString());
    			}
        	} catch (Exception e) {
				logger.error("监听赐福到期开始业务处理异常-->" + (takeValue == null ? "" : takeValue.toString()), e);
			}
        }
    },
    1l, 1l,TimeUnit.SECONDS);
}

Redis version
2.7.3
Redisson version
2.12.5
Redisson configuration
{
"singleServerConfig":
{
"address": "redis://${redis_host}:${redis_port}",
"password":"${redis_password}",
"clientName":"${redis_clientName}",
"database":"${redis_database}"
}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual client is keepAlive
Actual behavior
Actual client is not  keepAlive
Steps to reproduce or test case
Config config = new Config();
config.useSingleServer()
.setAddress("redis://localhost:6379")
.setKeepAlive(true)
.setConnectionPoolSize(1)
.setConnectTimeout(3000)
.setConnectionMinimumIdleSize(1);
	RedissonClient redisson = Redisson.create(config);

Redis version
4.0
Redisson version
3.8
Redisson configuration
Config config = new Config();
config.useSingleServer()
.setAddress("redis://localhost:6379")
.setKeepAlive(true)
.setConnectionPoolSize(1)
.setConnectTimeout(3000)
.setConnectionMinimumIdleSize(1);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
slience log
Actual behavior
...
2019-01-09 16:51:09.096 [redisson-netty-5-3] TRACE o.r.client.handler.CommandDecoder - reply: *2
*40
$4
name
$15
172.21.0.9:6380
$2
ip
$10
...

Steps to reproduce or test case
    val config = Config()
    config.transportMode = TransportMode.NIO
    config.useSentinelServers()
        .setMasterName("redis-master")
        .addSentinelAddress("redis://127.0.0.1:26379")
        .password = "xxx"

    val redisson = Redisson.create(config)
    
    val keyObject = redisson.getBucket<String>("key")
    keyObject.set("value")

Redis version
5.0.3
Redisson version
3.10.0
Redisson configuration
    val config = Config()
    config.transportMode = TransportMode.NIO
    config.useSentinelServers()
        .setMasterName("redis-master")
        .addSentinelAddress("redis://127.0.0.1:26379")
        .password = "xxx"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tested AWS Elasticache Redis failover (manual test). First I started my app which creates one  Redissonclient. It established 67 connections to primary Redis node. Then I manually did failover primary test.
Expected behavior
All 67 connections point to new primary Redis node.
Actual behavior
33 connections still point to previous (failed) primary Redis node, 34 connections point to new primary Redis node.
Steps to reproduce or test case

Start my app which creates one Redissonclient.
From command line run:   netstat -nt | sort +5 | fgrep .6379 | grep -n ^         This commands show 67 connections to primary Redis node.
Go to AWS Console, Elasticache, Redis and select redis cluster you are using. It shows all of nodes of the cluster. Check the primary node, go to Action and select "Failover primary".
Wait for a while, run step 2 command, out of 67 connections, half of them are pointing to previous primary node, half of them are pointing to new primary node.
I have a cache called "foo". My code calls redissonClient.getMapCache(foo).size() and it ends up with errors like "SlaveConnectionPool no available Redis entries.  Disconnected hosts: [xxxxx.usw2.cache.amazonaws.com/ipaddress:6379]" The ipaddress here points to previous primary node.
From AWS Console, if you select previous and new Redis primary nodes, then look at "Current Connections" of CloudWatch metrics, you can get the same result: Redisson client points to both previous and new Redis primary nodes. Following screenshot shows Redis primary node failover from 003 to 004.


Redis version
3.2.6 (Elasticache on AWS)
Redisson version
3.10.0
Redisson configuration
        Config config = new Config();

        ReplicatedServersConfig replicatedConfig = config.useReplicatedServers();
        replicatedConfig.addNodeAddress(Primary Endpoint of redis);
        
        replicatedConfig.setTimeout(3000);
        replicatedConfig.setRetryAttempts(3);
        replicatedConfig.setRetryInterval(1500);
        replicatedConfig.setPingConnectionInterval(5000);

        redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
I am testing failover behavior of redisson on AWS Elasticache in replicatedServers mode with one master and one slave. I am using read mode MASTER_SLAVE. After the failover is finished redisson correctly detects the new master and redirects all traffic to the master. The slave needs around 5 minutes to recover on Elasticache. Redisson is continously checking that connection, but after recovering that connection it does not move traffic to the slave.
Expected behavior
Traffic should again be load balanced between master and slave after failover is completed.
Actual behavior
Connections to master and slave are established but all traffic is routed to master.
By debugging i identified that the slave connection will remain freezed with FreezeReason Manager.
Steps to reproduce or test case

Start app with replicateServers mode with one slave and one master
Start failover on AWS console and wait until it is finished.
Watch traffic on slave. -> nothing

Redis version
4.0.10
Redisson version
3.10.0
Redisson configuration
        config.useReplicatedServers()
            .setReadMode(ReadMode.MASTER_SLAVE)
            .addNodeAddress(connections)
            .setMasterConnectionPoolSize(maxConnections)
            .setSlaveConnectionPoolSize(maxConnections)
            .setScanInterval(1000);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
java.util.concurrent.CompletionException: org.redisson.client.RedisTimeoutException: Subscribe timeout: (7500ms) at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:197) ~[redisson-3.10.0.jar:?] at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:206) ~[redisson-3.10.0.jar:?] at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:159) ~[redisson-3.10.0.jar:?] at org.redisson.RedissonLock.lockInterruptibly(RedissonLock.java:149) ~[redisson-3.10.0.jar:?] at org.redisson.RedissonLock.lockInterruptibly(RedissonLock.java:136) ~[redisson-3.10.0.jar:?] at org.redisson.RedissonLock.lock(RedissonLock.java:118) ~[redisson-3.10.0.jar:?] Caused by: org.redisson.client.RedisTimeoutException: Subscribe timeout: (7500ms) at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:160) ~[redisson-3.10.0.jar:?] ... 23 more
Redis version
3.0.7
Redisson version
3.10.0
Redisson configuration
Our redisson configuration:
Sentinel cluster with 4 nodes
masterConnectionPoolMinSize=16
masterConnectionPoolMaxSize=64
slaveConnectionPoolMinSize=16
slaveConnectionPoolMaxSize=64
timeout=3000
keepAlive=false
idleConnectionTimeout=10000
connectTimeout=10000
pingConnectionInterval=0
pingTimeout=1000
with password auth
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I did it according to your configuration.But there was a problem：
java.lang.ClassCastException: org.springframework.security.web.savedrequest.DefaultSavedRequest cannot be cast to org.springframework.security.web.savedrequest.SavedRequest。
so，what should i do？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If there are 10000+ values in a RMap。Why do I take all the values out when I use it?
for example:
RMap<String, String> rmap = redisson.getMap("TEST")
Then this map is full of all values。But  I just want to store a value in the map, no need to take out all the values. I just want to get a instance of RMap whithout all of value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I did it according to your configuration.But there was a problem：
java.lang.ClassCastException: org.springframework.security.web.savedrequest.DefaultSavedRequest cannot be cast to org.springframework.security.web.savedrequest.SavedRequest。
so，what should i do？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
To load config values from redisson.yaml
Actual behavior
Tries to load redisson.json first and aborts even if redisson.yaml is present
Steps to reproduce or test case
Create a redisson.yaml config and without a redisson.json config present.
Redis version
4.0.9
Redisson version
"org.redisson" % "redisson-hibernate-52" % "3.10.0"
Redisson configuration
singleServerConfig:
address: "redis://127.0.0.1:6379"
database: 0
The error is in RedissonRegionFactory.java on line 126. A possible fix would be to nest the config loading like it's done when loading a file without the class loader.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please apply your patch against master branch
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Problem
I initialize a bloom filter like this：
final String filterName = "Birth:Msg:"+ req.getPid() + ":" + req.getActivityId();
final String key = "Birth:Msg:" + req.getWid() + ":" + req.getPid() + ":" + req.getActivityId();
RBloomFilter<String> bloomFilter=redissonClient.getBloomFilter(filterName);
bloomFilter.tryInit(5_000_000, 0.01);
bloomFilter.expire(12, TimeUnit.HOURS);

mostly is works,but sometimes the key likes "Birth:Msg:100000000901:612" is not deleted,and the config hash is deleted
Env details
Java version: 1.7
Redis server v=3.0.7
Redisson Version : 2.15.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am unable to build redisson from master. I have OpenJDK8 on Mac and I am able to build and test 3.0.0 branch and not master
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
2019-01-12 12:53:15.134 ERROR 1 --- [isson-netty-1-3] o.r.client.handler.CommandDecoder        : Unable to decode data. channel: [id: 0x51b60460, L:/10.42.1.145:35170 - R:10.42.3.8/10.42.3.8:6379] message: +PONG
java.util.concurrent.CancellationException: null
java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2263) org.redisson.misc.RedissonPromise.cancel(RedissonPromise.java:239)
org.redisson.client.handler.PingConnectionHandler$1.run(PingConnectionHandler.java:59)
io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670)
io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745)
io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473)
java.lang.Thread.run(Thread.java:745)

Redis version
4.0.11
Redisson version
3.10.0
Redisson configuration
                Config config = new Config();
                config.useSentinelServers()
                        .setScanInterval(1000)
                        .setPingConnectionInterval(1000)
                        .setFailedSlaveCheckInterval(5000)
                        .setFailedSlaveReconnectionInterval(3000)
                        .setKeepAlive(true)
                        .addSentinelAddress(address)
                        .setMasterConnectionPoolSize(128)
                        .setSlaveConnectionPoolSize(128)
                        .setConnectTimeout(10000)
                        .setTimeout(10000)
                        .setMasterName("redis-master")
                        .setPassword("password")
                        .setDatabase(0);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixed in 44ea59f
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko is ready for merge
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Accorking to Redis command mapping RMap.readAllKeySet() should internally call HKEYS but its calling HGETALL

(Link : https://github.com/redisson/redisson/wiki/11.-Redis-commands-mapping)
Actual behavior
Error:
@user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0xaa2b8781, L:/10.105.191.101:54144 - R:10.105.191.127/10.105.191.127:7001] command: (EVAL), params: [local s = redis.call('hgetall', KEYS[1]); local result = {}; local maxSize = tonumber(redis.call('hg..., 5, CacheMap, redisson__timeout__set:{CacheMap}, redisson__idle__set:{CacheMap}, redisson__map_cache__last_access__set:{CacheMap}, {CacheMap}:redisson_options, 1547511000521]"
Steps to reproduce or test case
Redis version
4
Redisson version
3.10.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson: 3.10.0
Tomcat:7
Centos 64bit
Oracle jdk 1.8.0_111
严重: Session event listener threw exception java.lang.NullPointerException at org.redisson.tomcat.RedissonSession.getAttribute(RedissonSession.java:77) at org.apache.catalina.session.StandardSessionFacade.getAttribute(StandardSessionFacade.java:120) at net.bull.javamelody.SessionListener.sessionCreated(SessionListener.java:301) at org.apache.catalina.session.StandardSession.tellNew(StandardSession.java:422) at org.apache.catalina.session.StandardSession.setId(StandardSession.java:394) at org.redisson.tomcat.RedissonSession.setId(RedissonSession.java:85) at org.apache.catalina.session.StandardSession.setId(StandardSession.java:375) at org.redisson.tomcat.RedissonSessionManager.createSession(RedissonSessionManager.java:126) at org.apache.catalina.connector.Request.doGetSession(Request.java:3020) at org.apache.catalina.connector.Request.getSession(Request.java:2384) at org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:897) at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229) at org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy.onAuthentication(SessionFixationProtectionStrategy.java:91) at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:204) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:380) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:380) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:79) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:380) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:169)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am curious why RMapCache is designed to use Hash instead of simple key-value structure? Simple key-value can use TTL while Hash cannot. What benefit does RMapCache get when using Hash compared with using key-value?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Type Exception Report
Message Unexpected exception while processing command
Description The server encountered an unexpected condition that prevented it from fulfilling the request.
Exception
org.redisson.client.RedisException: Unexpected exception while processing command
org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:403)
org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:200)
org.redisson.RedissonObject.get(RedissonObject.java:87)
org.redisson.RedissonMap.get(RedissonMap.java:281)
org.redisson.tomcat.RedissonSession.getAttribute(RedissonSession.java:77)
org.apache.catalina.session.StandardSessionFacade.getAttribute(StandardSessionFacade.java:103)
com.cloud.icenter.common.filter.SSOFilter.doFilter(SSOFilter.java:91)
org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:85)
org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
Root Cause
com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Could not resolve type id 'com.cloud.icenter.system.login.bean.SSOKey' as a subtype of [simple type, class java.lang.Object]: no such class found
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 11]
com.fasterxml.jackson.databind.exc.InvalidTypeIdException.from(InvalidTypeIdException.java:43)
com.fasterxml.jackson.databind.DeserializationContext.invalidTypeIdException(DeserializationContext.java:1635)
com.fasterxml.jackson.databind.DeserializationContext.handleUnknownTypeId(DeserializationContext.java:1187)
com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver._typeFromId(ClassNameIdResolver.java:53)
com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver.typeFromId(ClassNameIdResolver.java:44)
com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._findDeserializer(TypeDeserializerBase.java:156)
com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.ja
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Config config = new Config();
config.setTransportMode(TransportMode.NIO);
config.useClusterServers()
    .addNodeAddress("redis://127.0.0.1:6379");
this.client = Redisson.create(config);

The above code throws an IllegalArgumentException exception.
15:44:48.543 [vert.x-worker-thread-7] INFO  org.redisson.Version - Redisson 3.10.0
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@795370a9
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@2cd12a30
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1d8c0a7f
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@5aeffab6
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@385b1f7a
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@1dfe32eb
15:44:48.544 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@605c1cd9
15:44:48.545 [vert.x-worker-thread-7] TRACE io.netty.channel.nio.NioEventLoop - instrumented a special java.util.Set into: sun.nio.ch.KQueueSelectorImpl@4543602e
15:44:48.560 [vert.x-worker-thread-7] DEBUG i.n.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@217c7e8d
15:44:48.622 [redisson-netty-2-2] TRACE o.r.client.handler.CommandEncoder - channel: [id: 0x9f8c4594, L:/127.0.0.1:64074 - R:127.0.0.1/127.0.0.1:6379] message: *2
$7
CLUSTER
$5
NODES

15:44:48.637 [redisson-netty-2-2] TRACE o.r.client.handler.CommandDecoder - reply: $106
38179639ecf0518fb987c460b96bec66a84c654d :6379@16379 myself,master - 0 0 0 connected 3207 4417 5474 12539

, channel: [id: 0x9f8c4594, L:/127.0.0.1:64074 - R:127.0.0.1/127.0.0.1:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2b4dfad0(incomplete)], command=(CLUSTER NODES), params=[], codec=null]
15:44:48.642 [redisson-netty-2-2] ERROR o.r.client.handler.CommandDecoder - Unable to decode data. reply: $106
38179639ecf0518fb987c460b96bec66a84c654d :6379@16379 myself,master - 0 0 0 connected 3207 4417 5474 12539

, channel: [id: 0x9f8c4594, L:/127.0.0.1:64074 - R:127.0.0.1/127.0.0.1:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2b4dfad0(incomplete)], command=(CLUSTER NODES), params=[], codec=null]
java.lang.IllegalArgumentException: Illegal character in scheme name at index 0: []r[]e[]d[]i[]s[]:[]/[]/[]:[]6[]3[]7[]9[]


This line Illegal character in scheme name at index 0: []r[]e[]d[]i[]s[]:[]/[]/[]:[]6[]3[]7[]9[] looks like says that I have a wrong encoding but this is not possible.
The cluster settings are as follows:
cluster-enabled yes
cluster-node-timeout 15000
cluster-slave-validity-factor 10
cluster-migration-barrier 1
cluster-require-full-coverage yes

Finaly, the connection is established when I use config.useSingleServer() instead of config.useClusterServers()
Redis version
5..0.3
Redisson version
3.10.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
In RedissonSessionRepository.onMessage(), if a body not starts with "redisson_spring_session:", just return.
Actual behavior
In my application, there are other keys contains char ':'.
RedissonSessionRepository try to HGETALL a session key not exist.
It's not necessary and print a lot debug log:
acquired connection for command ...

Steps to reproduce or test case
Redis version
Redisson version
3.9.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
I have two applications, one read and another write on redis:
My entity
@Data
@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)
public class Job implements Serializable {
    private static final long serialVersionUID = 1L;
    private String a;
    private String b;
}

For save i use this code:
RList<Job> list = redissonClient.getList(key); list.addAll(jobList);
The value is saved in redis just like that:

{"a":"test","b":"test"}

My problem is when I try to read the redis list at another java application.
I have a method that use this code to read the list:
List<Job> allJobs = redissonClient.getList(key);
But when i execute the project i receive this error:

io.netty.handler.codec.DecoderException: com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@Class'
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 322]

My redisson.json file has the same configuration in both projects:
{ "singleServerConfig": { "idleConnectionTimeout": 10000, "pingTimeout": 1000, "connectTimeout": 10000, "timeout": 3000, "retryAttempts": 3, "retryInterval": 1500, "reconnectionTimeout": 3000, "failedAttempts": 3, "password": null, "subscriptionsPerConnection": 5, "clientName": null, "address": "redis://127.0.0.1:6379", "subscriptionConnectionMinimumIdleSize": 1, "subscriptionConnectionPoolSize": 50, "connectionMinimumIdleSize": 10, "connectionPoolSize": 64, "database": 0, "dnsMonitoringInterval": 5000 }, "threads": 0, "nettyThreads": 0, "codec": null, "useLinuxNativeEpoll": false }
Version of redisson:



    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.9.1</version>
    </dependency>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redis as cachig solution with Redisson as java client client.
I am doing it with sping cahce abstraction.
So my I have noticed redisson sotres data in redis as whole map and inside that map I have all my cahce data.
Is it possible that I can store all data individually as key value directly to redis.
Actual behavior
Currently,  The way data is stored in redis is:  it has one TestsCacheMap and inside that map all the cahce data is stored
TestsCacheMap

Key1 value1
Key2 value2
Key3 value3

Problem with this: If I am using redis cluster then this map will be stored in one redis node so all my data will indirectly stay on one node at a given time.
Expected behavior
But I am looking for the way which directly stored key value in redis:
Key1 value1
Key2 value2
Key3 value3
Steps to reproduce or test case
================================== RedisConfiguration =======================================
public class RedisConfiguration {
@Bean(destroyMethod = "shutdown")
RedissonClient redisson() throws IOException {
    Config config = new Config();
    String prefix = "redis://";

    //Redis-cluster configuration
    config.useClusterServers().addNodeAddress(prefix + "10.108.191.127" + ":" + "7000", prefix + "10.108.191.127" + ":" + "7001",
                    prefix + "10.108.191.127" + ":" + "7002");

   
    return Redisson.create(config);
}

@Bean
CacheManager cacheManager(RedissonClient redissonClient) {
    Codec serializationCodec = new SerializationCodec();
    Codec stringCodec = new StringCodec();
    CompositeCodec compositeCodec = new CompositeCodec(stringCodec, serializationCodec);

    Map<String, CacheConfig> config = new HashMap<String, CacheConfig>();

    // create "testMap" cache with ttl = 24 minutes and maxIdleTime = 12 minutes
    config.put("TestsCacheMap", new CacheConfig(24 * 60 * 1000, 12 * 60 * 1000));
    return new RedissonSpringCacheManager(redissonClient, config, compositeCodec);
}

=================================== CachedTestService ========================================
public class CachedTestService {

@Autowired
private TestRepository TestRepository;

@Autowired
private RedissonClient redissonClient;

@CachePut(value = "TestsCacheMap")
public List<Test> getActiveByKey(String Key) {
    return TestRepository.getActiveByKey(Key);
}

@CacheEvict(value = "TestsCacheMap")
public void removeFromCacheByKey(String Key) {}

@CacheEvict(value = "TestsCacheMap", allEntries = true)
public void clearCache() {}

}
Redis version
4.X
Redisson version
3.10
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior

When web application gets an object from the http session, then the same object should be returned during the request processing instead of returning deserialized version of the object each time.
Also each object that is "mutable" should be kept track on and at the end of the request processing should be updated to Redis server as web application could have altered the object without invoking session.setAttribute

Actual behavior

When in readMode=REDIS each time session.getAttribute will return a new object instead of returning the same object returned by the first session.getAttribute during request processing.
When web application retrieves an object from the session and alters it then at the end of the session the Redis server won't be updated with the updated copy of the object.

Steps to reproduce or test case

Try to get the object in readMode=REDIS and each time a new copy is returned during the same request processing
Try to update the object returned by session.getAttribute - the modified version of the attribute won't be in Redis server at the end of the request processing and the next request processing will have the old version of the object deserialized from Redis server

Redis version
Redisson version
redisson-tomcat-8-2.15.1-SNAPSHOT.jar
redisson-all-2.15.1-SNAPSHOT.jar
Tomcat 8.5.35
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 3.10.0
When a scheduleWithFixedDelay job is running, cancel the job using cancelTask, the job can be terminated. But when the job is over, the taskId will be inserted into redis again.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Each client should acquire their own permission when using RateType.PER_CLIENT in RRateLimiter.
Actual behavior
When one client acquire the permission, the other client fails to acquire the permission at the same time even though using RateType.PER_CLIENT.
Steps to reproduce or test case
        //Two clients run the test case at the same time,the first client acquires the permission, the other one fails.
        @Test
	public static void test2() throws Exception
	{
		Config config = RedissionConfigBuilder.build();
		RedissonClient redisson = Redisson.create(config);
    	        RRateLimiter rateLimiter = redisson.getRateLimiter("myRateLimiter_client");
    	        rateLimiter.trySetRate(RateType.PER_CLIENT, 5, 5, RateIntervalUnit.SECONDS);
    	        System.out.println(rateLimiter.tryAcquire(5));    	
    	        redisson.shutdown();
	}

By the way, I checked the source code of  method "tryAcquireAsync" in class "RedissonRateLimiter" , I found the condition judgment below does not work:
+ "if type == 1 then "
   + "valueName = KEYS[3];"
 + "end;"

It works when the code is:
+ "if type == '1' then "
   + "valueName = KEYS[3];"
 + "end;"

Redis version
3.2.9
Redisson version
3.8.1
Redisson configuration
standalone
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在同一个进程中维护大量的RLocalCachedMap会不会存在问题。如果会，该怎么处理。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When an exception is thrown upon the AUTH command the exception contains the actual password as a param. This happens because LogHelper.toString called by RedisConnection.async nowadays accepts a "Object..." all the time, and LogHelper redacts the password only when a single object of the type CommandData is passed.
Actual behavior
Caused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), command params: [our actual password], Redis client: [addr=rediss://server:6379]
at org.redisson.client.RedisConnection$2.run(RedisConnection.java:214)
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
... 6 common frames omitted
Steps to reproduce or test case
Redis version
Redisson version
3.10.4
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using RMapCache to handle my distributed collections.
When adding to the map, i use:
	map.put("DTO1", dto, 20, TimeUnit.SECONDS);

So the key should expire after 20 seconds. This works, if the process is not terminated before the expiration timestamp. However, if the process dies for any reason, the key never expires.
By observing this behavior, I have concluded that is the Java process that makes the Key expire. I would like Redisson to use Redis EXPIRE behavior for keys, so that the Java process is not responsible for expiring the key.
This way, i will know for sure that the key will expire after the given time, even if for any reason the java process dies.
Is this possible to do with Redisson?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I should be able to connect to a sentinel node of Redis 5.
Actual behavior
I am trying to connect to the sentinel node of a Redis setup in AWS, and I am getting the message:
NOAUTH Authentication required.

Steps to reproduce or test case
Redis version
5.0.1
Redisson version
3.10.4
Redisson configuration
Config config = new Config();
SentinelServersConfig sentinelConfig = config.useSentinelServers();
sentinelConfig.setPassword("**************");
sentinelConfig
                .setMasterName("redis-master")
                .addSentinelAddress("redis://redis-sentinel");

RedissonClient client = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I should be able to connect to a sentinel node of Redis 5.
Actual behavior
I am trying to connect to the sentinel node of a Redis setup in AWS, and I am getting the message:
NOAUTH Authentication required.

Steps to reproduce or test case
Redis version
5.0.1
Redisson version
3.10.4
Redisson configuration
Config config = new Config();
SentinelServersConfig sentinelConfig = config.useSentinelServers();
sentinelConfig.setPassword("**************");
sentinelConfig
                .setMasterName("redis-master")
                .addSentinelAddress("redis://redis-sentinel");

RedissonClient client = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
For a while I've been using a single redis instance, therefore configured in SingleServer mode. Recently I decided to add a read replica into the mix for failover protection. Also assumed I would get a performance boost too... I was wrong!
Below are some performance results. The test writes 10,000 objects into the cache with a random key. The test runs 10 times. For each key, I measure the time it takes to do a GET & PUTASYNC. e.g.
long before = System.currentTimeMillis();
try {
    client.getBucket(key).get();
    client.getBucket(key).setAsync(value);
} catch (Exception e) {}
long time = System.currentTimeMillis() - before;
The results are really surprising;

The ReplicatedMode is MUCH slower than SingleServer using the default read mode.
Changing to MASTER_SLAVE read mode helps, but it's still much slower with lots of spikes in the perf.

Results
SingleServer Mode
config
    .useSingleServer()

Took: 3932ms {count=10000, sum=75723, min=0, average=7.572300, max=203}
Took: 2072ms {count=10000, sum=40986, min=0, average=4.098600, max=130}
Took: 1096ms {count=10000, sum=21496, min=0, average=2.149600, max=32}
Took: 1700ms {count=10000, sum=33432, min=0, average=3.343200, max=93}
Took: 1383ms {count=10000, sum=26749, min=0, average=2.674900, max=209}
Took: 755ms {count=10000, sum=14541, min=0, average=1.454100, max=28}
Took: 878ms {count=10000, sum=16598, min=0, average=1.659800, max=89}
Took: 752ms {count=10000, sum=14839, min=0, average=1.483900, max=40}
Took: 747ms {count=10000, sum=14202, min=0, average=1.420200, max=16}
Took: 690ms {count=10000, sum=12983, min=0, average=1.298300, max=53}

Average is pretty good and the max is usually much less than 100ms.
ReplicatedServers Mode
config
    .useReplicatedServers()

Took: 5194ms {count=10000, sum=87856, min=0, average=8.785600, max=1599}
Took: 3579ms {count=10000, sum=63774, min=0, average=6.377400, max=1595}
Took: 2599ms {count=10000, sum=37945, min=0, average=3.794500, max=1582}
Took: 2299ms {count=10000, sum=36491, min=0, average=3.649100, max=1612}
Took: 2099ms {count=10000, sum=34442, min=0, average=3.444200, max=1601}
Took: 1799ms {count=10000, sum=26879, min=0, average=2.687900, max=1598}
Took: 2199ms {count=10000, sum=33478, min=0, average=3.347800, max=1599}
Took: 1999ms {count=10000, sum=23772, min=0, average=2.377200, max=1600}
Took: 1999ms {count=10000, sum=22433, min=0, average=2.243300, max=1595}
Took: 2099ms {count=10000, sum=30133, min=0, average=3.013300, max=1597}

Average is quite a bit slower here but the max is massively slower!
ReplicatedServers Mode using ReadMode.MASTER_SLAVE
config
    .useReplicatedServers()
    .setReadMode(ReadMode.MASTER_SLAVE)

Took: 4092ms {count=10000, sum=79188, min=0, average=7.918800, max=226}
Took: 1922ms {count=10000, sum=38011, min=0, average=3.801100, max=48}
Took: 3848ms {count=10000, sum=76613, min=0, average=7.661300, max=201}
Took: 10591ms {count=10000, sum=211402, min=0, average=21.140200, max=180}
Took: 4633ms {count=10000, sum=92325, min=0, average=9.232500, max=177}
Took: 1823ms {count=10000, sum=36266, min=0, average=3.626600, max=123}
Took: 1105ms {count=10000, sum=21636, min=0, average=2.163600, max=47}
Took: 5441ms {count=10000, sum=108626, min=0, average=10.862600, max=107}
Took: 12928ms {count=10000, sum=257737, min=0, average=25.773700, max=452}
Took: 982ms {count=10000, sum=19493, min=0, average=1.949300, max=31}

Things get interesting here. Averages are all over the place, low as 1.9ms but high as 25.7ms. Max is generally lower, but it's still eratic.
So, my questions are;

Is this expected? I assumed replicated mode would be a performance improvement.
Is there anything I can do to improve this. If I can get the replicated performance similar to single server that would be ideal, if possible. Right now the only option might be to not have a read replica which will be a real shame.

Thanks in advance!
Details

Redis version: 4.0.10
Redisson version: 3.6.2
Redisson configuration: See above, I've omitted the timeouts and retry attempts, I think they are not relevant to this issue.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RedisException stack traces from CommandAsyncService should contain a causal exception wrapped inside a Redis exception. At least that's what I would expect from this code in CommandAsyncService:
    public <V> V get(RFuture<V> future) {
...
        if (future.isSuccess()) {
            return future.getNow();
        }

        throw convertException(future);
    }
...
    public <V> RedisException convertException(RFuture<V> future) {
        return future.cause() instanceof RedisException
                ? (RedisException) future.cause()
                : new RedisException("Unexpected exception while processing command", future.cause());
    }

Actual behavior
I'm seeing a small number of sporadic RedisException stack traces without any causal information. This is all there is:
org.redisson.client.RedisException: Unexpected exception while processing command
    at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:414)
    at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:211)
    at org.redisson.RedissonKeys.deleteByPattern(RedissonKeys.java:207)
    <my stack trace leading up to a redisson operation>
    <netflix hystrix stack trace> 
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    at java.lang.Thread.run(Thread.java:748)

Looking at the redisson code, I can't quite see how we would end up with an unsuccessful future without an exception.

Is the causal exception swallowed somewhere?
Are there conditions under which the future can fail without an exception?

Steps to reproduce or test case
No test case unfortunately.
This happens very sporadically, and only under load.
Redis version
Azure Redis 3.2.7
Redisson version
3.10.2
Redisson configuration
Single server.
codec=org.redisson.codec.SerializationCodec 
timeout=300
retryAttempts=3
retryInterval=100
pingConnectionInterval=0
keepAlive=true
dnsMonitoringInterval=5000
connectionPoolSize=64
connectionMinimumIdleSize=32
idleConnectionTimeout=10000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RLock lock = redisson.getLock("anyLock");
lock.lock();时异常
只有获取锁的时候异常，其它的集合类操作都没有问题。
Actual behavior
ERR Error running script (call to f_9401052d872adfd0179ef8c8e8c028512707629a): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script . channel: [id: 0xa5ae7592, L:/192.168.1.110:61979 - R:188.188.2.195/188.188.2.195:6379] command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, api:match🔒robotMoneyReturn, 30000, 9734124f-2104-4554-8a0f-235d3f60912f:71]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:355)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Steps to reproduce or test case
Redis version
redis_version:5.0.3
Redisson version
3.10.4
Redisson configuration
#redis
spring.redis.host=188.188.2.195
spring.redis.port=6379
spring.redis.password=12345678
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
According to Redissons documentation, it uses Jackson as JSON codec, using the @Class field to store the type.
How does redisson set this configuration to jacksons object mapper? The only way i know is to decorate the class with the @JSonTypeInfo annotation, but this means that for every serialization / deserialization of the class, the @Class field will and needs to exist.
I have a rest service that receives a json of a custom class without the @Class annotation, so i cannot afford jackson to always require the @Class field in deserialization.
Will using said custom class in a RBucket cause my custom class to be annotated by JsonTypeInfo, if not, how does redisson manage to set that for some deserializations of a custom class a @Class field is required, but for others it is not?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to do a get and a set simultaneously but the getandset() method of the RBucket does not support setting a ttl for the key.
I have tried to use an RTransaction and obtaining the bucket from the transaction instead of the client, but calling get() on the bucket always returns the value.
Is there any way to perform a get and a set with ttl using the RTransaction for RBucket types?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using lots of RBuckets which serialize with Jackson Codec:
        config.setCodec( new JsonJacksonCodec());
In a stress test environment, sometimes happens that i get an error when asking for the value of a bucket, and i see that the problem is in the deserialization of the JSON:
2019-03-15 18:07:11,357 ERROR [] [redisson-netty-1-20] o.r.c.h.CommandDecoder - Unable to decode data. channel: [id: 0xbc3d2096, L:/10.200.110.90:45674 - R:master.cvault-test-2.mcxawi.euw1.cache.amazonaws.com/10.200.111.253:6379], reply: ReplayingDecoderByteBuf(ridx=91, widx=91), command: (GET), params: [BIN_MAP_KEY:KEY|AR] com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 1)): only regular white space (\r, \n, \t) is allowed between tokens at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1804) at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:669) at com.fasterxml.jackson.core.base.ParserMinimalBase._throwInvalidSpace(ParserMinimalBase.java:620) at com.fasterxml.jackson.core.json.ReaderBasedJsonParser._skipWSOrEnd(ReaderBasedJsonParser.java:2350) at com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:646) at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4141) at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4000) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070) at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1436) at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1203) at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1247) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) 2019-03-15 18:07:11,358 WARN  [] [redisson-netty-1-20] i.n.c.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception. io.netty.handler.codec.DecoderException: com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 1)): only regular white space (\r, \n, \t) is allowed between tokens at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1436) at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1203) at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1247) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) Caused by: com.fasterxml.jackson.core.JsonParseException: Illegal character ((CTRL-CHAR, code 1)): only regular white space (\r, \n, \t) is allowed between tokens at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 2] at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1804) at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:669) at com.fasterxml.jackson.core.base.ParserMinimalBase._throwInvalidSpace(ParserMinimalBase.java:620) at com.fasterxml.jackson.core.json.ReaderBasedJsonParser._skipWSOrEnd(ReaderBasedJsonParser.java:2350) at com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:646) at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4141) at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4000) at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070) at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
Any idea what is happening? The error seems to be totally random and non deterministic. Redisson handles serialization and deserialization entirely, so i do not know how an invalid character is being stored in Redis.
Is there a way i could attach to a listener to gain some insight on this process? Something like being notified right before saving the bucket to redis, so i can check for that character (CHAR-1) or when reading?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redission 3.10.4
boot 2.0.6
redis 3.2
properties
redisson.address=redis://192.168.1.222:6379
redisson.password=
2019-03-18 17:09:29.787  WARN 53256 --- [sson-netty-1-27] io.netty.util.concurrent.DefaultPromise  : An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$569/0x00000008005ffc40.operationComplete()
java.lang.AbstractMethodError: Receiver class org.redisson.spring.data.connection.RedissonReactiveRedisConnection does not define or inherit an implementation of the resolved method abstract close()V of interface org.springframework.data.redis.connection.ReactiveRedisConnection.
at org.springframework.boot.actuate.redis.RedisReactiveHealthIndicator.lambda$doHealthCheck$1(RedisReactiveHealthIndicator.java:50) ~[spring-boot-actuator-2.0.6.RELEASE.jar:2.0.6.RELEASE]
at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.runFinally(FluxDoFinally.java:156) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onComplete(FluxDoFinally.java:139) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:130) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:1318) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:77) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.FluxCreate$BufferAsyncSink.drain(FluxCreate.java:726) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.FluxCreate$BufferAsyncSink.next(FluxCreate.java:657) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at reactor.core.publisher.FluxCreate$SerializedSink.next(FluxCreate.java:151) ~[reactor-core-3.1.10.RELEASE.jar:3.1.10.RELEASE]
at org.redisson.reactive.CommandReactiveService.lambda$null$1(CommandReactiveService.java:54) ~[redisson-3.10.4.jar:na]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.10.4.jar:na]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82) ~[redisson-3.10.4.jar:na]
at org.redisson.command.CommandAsyncService.handleSuccess(CommandAsyncService.java:1096) ~[redisson-3.10.4.jar:na]
at org.redisson.command.CommandAsyncService.checkAttemptFuture(CommandAsyncService.java:1076) ~[redisson-3.10.4.jar:na]
at org.redisson.command.CommandAsyncService.lambda$async$6(CommandAsyncService.java:800) ~[redisson-3.10.4.jar:na]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.10.4.jar:na]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:444) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:439) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143) ~[redisson-3.10.4.jar:na]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) ~[redisson-3.10.4.jar:na]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.29.Final.jar:4.1.29.Final]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.29.Final.jar:4.1.29.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysPlain(NioEventLoop.java:528) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:482) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442) ~[netty-transport-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.29.Final.jar:4.1.29.Final]
at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
No error
Actual behavior
When starting hiberate-redisson53 with hibernate-core-5.3.2.FINAL i got this error
java.lang.NoClassDefFoundError: org/hibernate/cache/spi/support/DomainDataRegionImpl
at org.redisson.hibernate.RedissonRegionFactory.buildDomainDataRegion(RedissonRegionFactory.java:178)
at org.hibernate.cache.internal.EnabledCaching.prime(EnabledCaching.java:108)
at org.hibernate.metamodel.internal.MetamodelImpl.primeSecondLevelCacheRegions(MetamodelImpl.java:304)
at org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:133)
at org.hibernate.internal.SessionFactoryImpl.(SessionFactoryImpl.java:295)
at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467)
at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:708)
at io.dropwizard.hibernate.SessionFactoryFactory.buildSessionFactory(SessionFactoryFactory.java:96)
at io.dropwizard.hibernate.SessionFactoryFactory.build(SessionFactoryFact
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using Sentinels with Reddison 3.10.4, the reddison clients always select the same sentinel server due to the predictability of the backing ConcurrentHashMap

  
    
      redisson/redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
    
    
         Line 71
      in
      488fe8f
    
  
  
    

        
          
           private final ConcurrentMap<String, RedisClient> sentinels = new ConcurrentHashMap<>(); 
        
    
  


In a large enough cluster this causes the CPU load on that Sentinel server to be considerably higher than the other servers.  The following PR
#1979
Shuffles the sentinel list so that clients distribute the load to all sentinel servers.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I am using dropwizard. The factory class and redisson.yaml path  is configured in config.yaml in databsase properties
hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory
Where should i configure cache settings, in the same file ? From where redisson read this properties ?
hibernate.cache.redisson.[REGION_NAME].eviction.max_entries - max size of cache. Superfluous entries in Redis are evicted using LRU algorithm. 0 value means unbounded cache. Default value: 0
hibernate.cache.redisson.[REGION_NAME].expiration.time_to_live - time to live per cache entry in Redis. Defined in milliseconds. 0 value means this setting doesn't affect expiration. Default value: 0
hibernate.cache.redisson.[REGION_NAME].expiration.max_idle_time - max idle time per cache entry in Redis. Defined in milliseconds. 0 value means this setting doesn't affect expiration. Default value: 0
Thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
I have changed to hibernate-5,2,2,Final and redisson-hibernate-52
 <dependency>
          <groupId>org.redisson</groupId>
          <artifactId>redisson-hibernate-52</artifactId>
         <version>3.10.4</version>
 </dependency>


And i'm getting this error on start up

INFO  [2019-03-19 11:04:35,236] [redisson-netty-1-14] [] [MasterConnectionPool] 5 connections initialized for srvaxivln213/10.216.0.213:6379
java.lang.NoSuchFieldError: INSTANCE
        at org.redisson.hibernate.RedissonRegionFactory.start(RedissonRegionFactory.java:97)
        at org.hibernate.cache.spi.RegionFactory.start(RegionFactory.java:63)
        at org.hibernate.internal.CacheImpl.<init>(CacheImpl.java:71)
        at org.hibernate.engine.spi.CacheInitiator.initiateService(CacheInitiator.java:28)
        at org.hibernate.engine.spi.CacheInitiator.initiateService(CacheInitiator.java:20)
        at org.hibernate.service.internal.SessionFactoryServiceRegistryImpl.initiateService(SessionFactoryServiceRegistryImpl.java:55)
        at org.hibernate.service.internal.AbstractServiceRegistryImpl.createService(AbstractServiceRegistryImpl.java:257)
        at org.hibernate.service.internal.AbstractServiceRegistryImpl.initializeService(AbstractServiceRegistryImpl.java:231)
        at org.hibernate.service.internal.AbstractServiceRegistryImpl.getService(AbstractServiceRegistryImpl.java:210)
        at org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:238)
        at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:490)
        at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:710)
        at io.dropwizard.hibernate.SessionFactoryFactory.buildSessionFactory(SessionFactoryFactory.java:96)
        at io.dropwizard.hibernate.SessionFactoryFactory.build(SessionFactoryFactory.java:49)
        at io.dropwizard.hibernate.SessionFactoryFactory.build(SessionFactoryFactory.java:39)
        at io.dropwizard.hibernate.HibernateBundle.run(HibernateBundle.java:62)
        at io.dropwizard.hibernate.HibernateBundle.run(HibernateBundle.java:15)
        at io.dropwizard.setup.Bootstrap.run(Bootstrap.java:200)
        at io.dropwizard.cli.EnvironmentCommand.run(EnvironmentCommand.java:42)
        at io.dropwizard.cli.ConfiguredCommand.run(ConfiguredCommand.java:85)
        at io.dropwizard.cli.Cli.run(Cli.java:75)
        at io.dropwizard.Application.run(Application.java:93)
        at com.triggle.middleware.user.UserApplication.main(UserApplication.java:17)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
As the document said, Redisson 2.15.2 should support jdk6.
Actual behavior
Redisson 2.15.2 didn't support jdk6
Steps to reproduce or test case
Run Redisson 2.15.2 in jdk6
Redis version
5.0.2
Redisson version
2.15.2
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson includes an implementation of the permit expirable semaphore which can only acquire or release a permit. This may limit the usage. I added the interfaces that acquire or release multiple permits at once by adding a sorted set to memorize the permits acquired each time. It works in non-fair mode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson version
3.6.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using following basic code to point to elastic cache configuration endpoint. (I have also tried adding all 6 node addresses, but no change of behavior).
I have an elastic cache cluster with, 3 shards (2 nodes each, 1 replica)
When I just put 10,000 to a cache, and later read them, in cloud watch I can see cache hits coming only from one node(first node). But cache size in bytes in each node shows each node keeps replicas of the data set. I would like to distribute the reddison read requests among read replicas.
Config config = new Config();
config.useClusterServers().addNodeAddress("rediss://clustercfg.xxx-xxxx.amazonaws.com:6379").setReadMode(ReadMode.MASTER_SLAVE);
Cache put code is simple as follows
client.getMapCache("cache1").put(x+i,   x+i);
And cache get code as follows.
client.getMapCache("cache1").get(x+i)
Redis version: 5.0.3
Redisson version: 3.10.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/1999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Upgraded from 3.8.2 to 3.10.4 Redisson community version and started seeing this error as we use Redisson in a Jboss application server with managed executor service.
Does this create any issues with Redis behavior?
The managed executor spec considers this as valid behavior.
Expected behavior
Should not throw an exception.
Actual behavior
The new code added in the CommandPubSubDecoder decodeResult to check if executor service is shutdown is throwing an IllegalStateException.
Steps to reproduce or test case
Please use a managed executor for plugging in an external executor service.
Exception trace:
ERROR [redisson-netty-3-12]  org.redisson.client.handler.CommandPubSubDecoder(:80) - Unable to decode data. channel: [id: 0x29e713ad, L:/127.0.0.1:50436 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=70, widx=70) java.lang.IllegalStateException: Lifecycle operation not supported
Redis version
5.0.2
Redisson version
3.10.4
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
你好，这个能否设置下，如果当前是string的话，就不用走json的序列化，因为如果继续走的话，就会出现多了一对""或者\转义符
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I init client like this :
"   Config config = new Config();
String[] servers = new String[conf.getServers().size()];
config.useSentinelServers()
.addSentinelAddress(conf.getServers().toArray(servers))
.setMasterName(conf.getMasterName())
.setPassword(conf.getAuth())
.setTimeout(conf.getTimeout());
client = Redisson.create(config); "
But error reporting when I run the program , please see the following exception information:
"org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=org.redisson.connection.MasterSlaveEntry@77cbf622], connection: [id: 0x872874f5, L:/172.21.128.61:59850 - R:192.168.27.23/192.168.27.23:6379], command: (EXISTS)"
The server's IP is the sentry machine's IP，What's the problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
No exception and return the command result
Actual behavior
[redisson-netty-1-2] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x11746c30, L:/127.0.0.1:53924 - R:127.0.0.1/127.0.0.1:6380], reply: ReplayingDecoderByteBuf(ridx=18, widx=28), command: (HGETALL), params: [capacity_plan]
java.io.IOException: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
... 37 more
[redisson-netty-1-2] WARN io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.io.IOException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
... 28 more
Caused by: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
... 37 more
Steps to reproduce or test case
sentinelConfigFilePath = config.getProperty("", "/etc/config/redis-sentinel.yml");
Config redissonConfig = Config.fromYAML(new File(sentinelConfigFilePath));
redisson = Redisson.create(redissonConfig);
Map<String, String> plan = (Map<String, String>) redisson.getMap("plan").readAllEntrySet();
Redis version
5.0.3
Redisson version
3.10.4     netty 4.1.33.Final
Redisson configuration

sentinelServersConfig:
idleConnectionTimeout: 15000
connectTimeout: 15000
timeout: 15000
retryAttempts: 3
retryInterval: 1500
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 60000
password: null
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "SLAVE"
sentinelAddresses:

"redis://127.0.0.1:5000"
"redis://127.0.0.1:5001"
"redis://127.0.0.1:5002"
masterName: "mymaster"
database: 0
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My application running with multiple replicas, so each replicate have map entry listener
I am doing some task (database update) on entry expire, so in my case, each replica get notify and each replica executes update query in the database.
Any solution/suggestion to avoid this scenario.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Current YAML support expects to provide separate YAML file which has redis configs only. But in real world, redis clients will be used with in a  main application(which also bootstraped from a main yaml file).  It's convenient to support creating Config from a block of some main yaml file as follows.
Even now I can get ClusterServersConfig created pointing to the clusterServersConfig block as in following example, but Config API does now allow to pass a ClusterServerConfig.
Suggestion:
If you can make Config class's following method public, then users can inject ClusterServersCondfig(or any other type) and create a Config object from a existing big yaml file.
ClusterServersConfig useClusterServers(ClusterServersConfig config)
mainConfig:

   appName: test
   appSecret: 123
   mysqlURL: 

   redis: 
      clusterServersConfig:
          nodeAddresses:
               -
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a primary node fails over, redisson appears to detect this and correctly pick up the new primary. However, after this point, pub/sub subscriptions no longer work.
This occurred in our production env when AWS Elasticache triggered a failover by itself. I was able to reproduce using https://aws.amazon.com/blogs/database/testing-automatic-failover-to-a-read-replica-on-amazon-elasticache-for-redis/ .
Here's a log from the client during the failover:
2019-03-23 16:05:00.900 ERROR [redisson-netty-6-18]  org.redisson.cluster.ClusterConnectionManager - Can't update cluster state
io.netty.channel.ConnectTimeoutException: connection timed out: 10.101.59.175/10.101.59.175:6379
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
2019-03-23 16:05:15.927 ERROR [redisson-netty-6-23]  org.redisson.cluster.ClusterConnectionManager - Can't update cluster state
io.netty.channel.ConnectTimeoutException: connection timed out: 10.101.59.175/10.101.59.175:6379
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
2019-03-23 16:05:21.005 INFO  [redisson-netty-6-19]  org.redisson.connection.MasterSlaveEntry - master 10.101.63.131/10.101.63.131:6379 used as slave
2019-03-23 16:05:21.046 INFO  [redisson-netty-6-19]  org.redisson.cluster.ClusterConnectionManager - slave redis://10.101.63.131:6379 removed for slot ranges: [[0-16383]]
2019-03-23 16:05:21.053 INFO  [redisson-netty-6-5]  org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for 10.101.63.131/10.101.63.131:6379
2019-03-23 16:05:21.099 ERROR [redisson-netty-6-19]  org.redisson.cluster.ClusterConnectionManager - cluster_state:fail for 10.101.63.131/10.101.63.131:6379
2019-03-23 16:05:21.115 INFO  [redisson-netty-6-3]  org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for 10.101.63.131/10.101.63.131:6379
2019-03-23 16:05:21.140 INFO  [redisson-netty-6-30]  org.redisson.connection.MasterSlaveEntry - master 10.101.59.175/10.101.59.175:6379 has changed to 10.101.63.131/10.101.63.131:6379
2019-03-23 16:05:21.140 INFO  [redisson-netty-6-30]  org.redisson.connection.pool.MasterConnectionPool - 32 connections initialized for 10.101.63.131/10.101.63.131:6379
2019-03-23 16:05:21.155 INFO  [redisson-netty-6-31]  org.redisson.connection.pool.SlaveConnectionPool - 32 connections initialized for 10.101.63.131/10.101.63.131:6379

Redis version
5.0.0, AWS Elasticache Cluster
Redisson version
3.10.5
Redisson configuration
ClusterServersConfig
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RedissonSpringCacheManager redissonSpringCacheManager=  new
RedissonSpringCacheManager(redissonClient,config);
redissonSpringCacheManager.setAllowNullValues(false);
Actual behavior
in redis value is org.redisson.spring.cache.NullValue
Steps to reproduce or test case
org.redisson.spring.cache.RedissonCache#putValue
Line 176  value = toStoreValue(valueLoader.call());
tranfer null  2 NullValue
why need this op?
Redis version
3.21.
Redisson version
3.10.5
Redisson configuration
normal
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Deserializing Jsons that contain Optionals. In buckets or maps, with JsonJacksonCodec or TypedJsonJacksonCodec
Actual behavior
ObjectMapper does not behave as expected, it does not deserialize Optional even though the provided ObjectMapper has the JDK8Module.
The issue resides in org.redisson.command.CommandAsyncService#getCodec. More specifically:
org/redisson/command/CommandAsyncService.java:833
codecToUse = codec.getClass().getConstructor(ClassLoader.class, codec.getClass()).newInstance(threadClassLoader, codec);
I've managed to trigger NoSuchMethodException (by providing an anonymous class JsonJacksonCodec() {}) there so that  codecToUse = codec; ObjectMapper works this way.
ObjectMapper is replaced in org.redisson.codec.JsonJacksonCodec#createObjectMapper
Steps to reproduce or test case
Try to deserialize any object that contains an Optional.
Redis version
4.0.2
Redisson version
3.10.1 onwards
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2019-03-28 00:47:14.367  INFO 45088 --- [           main] org.redisson.Version                     : Redisson 3.10.5
2019-03-28 00:47:14.641  INFO 45088 --- [           main] o.r.c.SentinelConnectionManager          : master: redis://127.0.0.1:6380 added
2019-03-28 00:47:14.644  INFO 45088 --- [           main] o.r.c.SentinelConnectionManager          : slave: redis://127.0.0.1:6381 added
2019-03-28 00:47:14.644  INFO 45088 --- [           main] o.r.c.SentinelConnectionManager          : slave: redis://127.0.0.1:6382 added
2019-03-28 00:47:14.646  INFO 45088 --- [           main] o.r.c.SentinelConnectionManager          : sentinel: redis://127.0.0.1:26382 added
2019-03-28 00:47:14.647  INFO 45088 --- [           main] o.r.c.SentinelConnectionManager          : sentinel: redis://127.0.0.1:26381 added
2019-03-28 00:47:14.679  INFO 45088 --- [sson-netty-4-13] o.r.connection.pool.SlaveConnectionPool  : 10 connections initialized for 127.0.0.1/127.0.0.1:6381
2019-03-28 00:47:14.681 ERROR 45088 --- [isson-netty-4-3] o.redisson.client.handler.CommandsQueue  : Exception occured. Channel: [id: 0xb5ffdd00, L:/127.0.0.1:58815 - R:127.0.0.1/127.0.0.1:26380]
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
at sun.nio.ch.SocketDispatcher.read0(Native Method) ~[na:1.8.0_181]
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43) ~[na:1.8.0_181]
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) ~[na:1.8.0_181]
at sun.nio.ch.IOUtil.read(IOUtil.java:192) ~[na:1.8.0_181]
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) ~[na:1.8.0_181]
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288) ~[netty-buffer-4.1.33.Final.jar:4.1.33.Final]
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132) ~[netty-buffer-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:347) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) [netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) [netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) [netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) [netty-transport-4.1.33.Final.jar:4.1.33.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) [netty-common-4.1.33.Final.jar:4.1.33.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.33.Final.jar:4.1.33.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]
2019-03-28 00:47:14.683  INFO 45088 --- [isson-netty-4-3] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for 127.0.0.1/127.0.0.1:6382
2019-03-28 00:47:14.685  INFO 45088 --- [isson-netty-4-6] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for 127.0.0.1/127.0.0.1:6381
2019-03-28 00:47:14.692  INFO 45088 --- [isson-netty-4-8] o.r.connection.pool.SlaveConnectionPool  : 10 connections initialized for 127.0.0.1/127.0.0.1:6382
2019-03-28 00:47:14.700  INFO 45088 --- [sson-netty-4-10] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for 127.0.0.1/127.0.0.1:6380
2019-03-28 00:47:14.701  INFO 45088 --- [isson-netty-4-9] o.r.c.pool.MasterConnectionPool          : 10 connections initialized for 127.0.0.1/127.0.0.1:6380
2019-03-28 00:47:15.062  INFO 45088 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 2 endpoint(s) beneath base path '/actuator'
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redis version 3.2.100
spring.boot.version>2.1.3.RELEASE
Redisson version
3.10.5
Redisson configuration
sentinelServersConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 3
password:
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveSubscriptionConnectionMinimumIdleSize: 1
slaveSubscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 10
slaveConnectionPoolSize: 32
masterConnectionMinimumIdleSize: 10
masterConnectionPoolSize: 32
readMode: "SLAVE"
sentinelAddresses:

"redis://127.0.0.1:26380"
"redis://127.0.0.1:26381"
"redis://127.0.0.1:26382"
masterName: "mymaster"
database: 1
#dnsMonitoring: false
dnsMonitoringInterval: -1
threads: 0
nettyThreads: 0
codec:
class: "org.redisson.codec.JsonJacksonCodec"
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
All entries are returned.
Actual behavior
A RedisException is thrown:
javax.cache.CacheException: org.redisson.client.RedisException: ERR Error running script (call to f_d886289bc2022124a889b8e8783a7a3637e98521): @user_script:1: user_script:1: too many results to unpack . channel: [id: 0x7a41093f, L:/<client-address> - R:<redis-address>] command: (EVAL), params: [local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');local accessTimeout = ARGV[1]; ..., 3, hitf-idCache-Employee, jcache_timeout_set:{hitf-idCache-Employee}, jcache_removed_channel:{hitf-idCache-Employee}, -1, 1553688656762, PooledUnsafeDirectByteBuf(ridx: 0, widx: 48, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 48, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 48, cap: 256), ...]
	at org.redisson.jcache.JCache.evalRead(JCache.java:404)
	at org.redisson.jcache.JCache.getAll(JCache.java:671)

Steps to reproduce or test case

Add more than 10k entries to a JCache.
Try to pull them all by ids.

Redis version
5.0.0
Redisson version
3.10.3
Redisson configuration
{
  "singleServerConfig": {
    "idleConnectionTimeout": 10000,
    "connectTimeout": 10000,
    "timeout": 30000,
    "retryAttempts": 5,
    "retryInterval": 15000,
    "password": null,
    "subscriptionsPerConnection": 5,
    "clientName": null,
    "address": "<redis-address>",
    "subscriptionConnectionMinimumIdleSize": 1,
    "subscriptionConnectionPoolSize": 50,
    "connectionMinimumIdleSize": 32,
    "connectionPoolSize": 64,
    "database": 0,
    "dnsMonitoringInterval": 5000
  },
  "threads": 0,
  "nettyThreads": 0,
  "codec": {
    "class": "org.redisson.codec.FstCodec"
  },
  "transportMode": "NIO"
}

Just wanted to wonder if it is a correct behavior and there is just a limit of entities I can retrieve in one batch or it is actually a bug somewhere.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
非常抱歉，英语没达到能够准确描述问题的水平，所以，请允许我用中文。

    使用布隆过滤器的测试过程中，初始化expectedInsertions值为100，已经插入了部分值，当发现不够用扩大到1000，发现add已经add过的值依然返回true。后来看代码expectedInsertions的改变将会对hash计算结果slot位置产生影响，最终导致同一个值在调整expectedInsertions值以后，都会返回true的情况。请问下如果想扩容不影响相同值计算结果的slot，重写hash实现的可行性有多少？

Expected behavior
    字符串“abc”在expectedInsertions初始值10插入后，在expectedInsertions设置为100后，add结果也返回false

Actual behavior
    字符串“abc”在expectedInsertions初始值10插入后，在expectedInsertions设置为100后，add结果返回了true

Steps to reproduce or test case
RBloomFilter bloomFilter = client.getBloomFilter("sample");
bloomFilter.tryInit(1000L, 0.001);
System.out.println(bloomFilter.add("Abc"));
Redis version
    单机版4.0.10

Redisson version
    redisson 开源版 3.10.5

Redisson configuration
    cache:

redis:
address: redis://127.0.0.1:6379
password:
expire-time: 30
pool-config:
min-idle: 10
pool-size: 32
connect-timeout: 15000
max-wait-timeout: 10000
retry-attempts: 3
retry-interval: 1000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LockWatchdogTimeout不会自动续租
lock将在30ms后自动失效
Steps to reproduce or test case
   `Config config = new Config();
    config.useSingleServer().setAddress("redis://192.168.9.150:6379");
    RedissonClient client = Redisson.create(config);
    try {
        RLock lock = client.getLock("lock");
        lock.lock();
        try {
            Thread.sleep(1000);
        } finally {
            lock.unlock();
        }
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        client.shutdown();
    }`

redis-cli中ttl如下：
127.0.0.1:6379> ttl lock
(integer) 2
127.0.0.1:6379> ttl lock
(integer) 1
127.0.0.1:6379> ttl lock
(integer) 0
127.0.0.1:6379> ttl lock
(integer) -2
127.0.0.1:6379> ttl lock
(integer) -2
Redis version
3.0.0
Redisson version
3.10.5
Redisson configuration
默认配置
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RMap containing 11000 entries (RMap<String, Map<Integer, Data>>) .Total size 207 mb.
Time taken to retrieve all keys - 8-10 seconds.
My Rmap is getting updated every minute. So i need to get data from RMap every minute
Is there a way to fasten get call.
Redis version - 5.0.1
Redisson version - 3.10.4
Redisson configuration - single node
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
使用redisson-tomcat，代码中 session.invalidate()后，期望redis中session key值被删除
Actual behavior
使用redisson-tomcat，代码中 session.invalidate()后，实际redis中session key值没被删除，ttl值为-1
Steps to reproduce or test case
session.invalidate()
Redis version
单机版4.0.11
Redisson version
redisson 开源版 3.10.5
Redisson configuration
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"password":password,
"subscriptionsPerConnection":5,
"clientName":null,
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":32,
"connectionPoolSize":64,
"database":0,
"dnsMonitoringInterval":5000
},
"threads":0,
"nettyThreads":0,
"codec":{
"class":"org.redisson.codec.JsonJacksonCodec"
},
"transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have a 2 instances of tomcat running in front of apache (with sticky session).
We have a single redis instance and we are using the redisson tomcat 8 session manager (setup in the context.xml in the /conf dir). Version redisson-tomcat-8-3.7. Tomcat version 8.0.32.
This is similar to bug #1311 . We have a session timeout of 30mins.
What is happening:

User logs onto instance 1, session created.
User uses session on instance 1
Apache loadbalancers the request over to instance 2 (perhaps load was too great on instance1)
New session created on instance 2 and loaded with session info via redis, user carries on without loosing session. All good so far.
15 mins later user makes another request and apache loadbalancers back to instance 1. User carries on without issue.
User keeps using their session on instance 1.
7 ) On instance 2 the session timesout after 30 mins. This then invalidates the session on instance 1 even though the user is still using it and user looses session . This is the problem.

It seems that  in RedissonSessionManager.java -> startInternal() -> onMessage() when receiving a AttributesPutAllMessage is NOT updating the timing on the session (at least in readMode MEMORY)  and then tomcat MangerBase times the session out. I can see session values session:lastAccessedTime and session:thisAccessedTime are sent in the map, however debugging into superSetAttribute() on Tomcat 8 does NOT update these member variables, and therefore the session timesout.
I made a local patch to test my thoery by calling session.superEndAccess() instead:
if (msg instanceof AttributesPutAllMessage) {
      AttributesPutAllMessage m = (AttributesPutAllMessage) msg;
                                for (Entry<String, Object> entry : m.getAttrs().entrySet()) {
                                    session.superSetAttribute(entry.getKey(), entry.getValue(), true);
                                    if (entry.getKey().equals("session:lastAccessedTime") ) {
                                    	session.superEndAccess(); // so tomcat doesn't time the session out on this instance
                                    }
                                
                                }
                            }

This now works as expected. However I'm not sure this is the best implementation and looking for your guidence/fix. This is consistently reproducable.
Many thanks
Context.xml:

Redisson.conf:
singleServerConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: null
subscriptionsPerConnection: 5
clientName: null
address: "redis://127.0.0.1:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 32
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
pingConnectionInterval: 1000
keepAlive: true
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.SerializationCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version 4.0.1
Redisson version 3.7.1
Redisson configuration
@component
public class ModelAutoOfflineInitializr {
private static final Logger logger = LoggerFactory.getLogger(ModelAutoOfflineInitializr.class);

@Autowired
private RedissonClient redissonClient;

@Autowired
private ModelService modelService;

@Value("${train.model.auto.offline.time}")
private Long autoOfflineTime;

@Async
public void executeAsync() {
	logger.info("准备加载已发布在云服务上的模型...");
	RMapCache<String, ModelRecord> map = redissonClient.getMapCache(RedisConstant.ALGORITHMTRAINING_ONLINE_MODEL_MAP);
	map.addListener(new EntryExpiredListener<String, ModelRecord>() {
		@Override
		public void onExpired(EntryEvent<String, ModelRecord> entryEvent) {
			String algorithmServiceId = entryEvent.getValue().getAlgorithmServiceId();
			try {
				logger.info(algorithmServiceId+"模型1个小时内没有被调用，置入下线处理队列..");
			} catch (Exception e) {
				logger.error("云服务模型下线异常", e);
			} 
		}
	});
	loadCloudServiceModelRecord(map);
}

private void loadCloudServiceModelRecord(RMapCache<String, ModelRecord> map) {
	List<ModelRecord> modelRecords = modelService.getAllCloudServiceModelRecord();
	for (ModelRecord modelRecord : modelRecords) {
		if(!map.containsKey(modelRecord.getAlgorithmServiceId())){
			logger.info("加载云服务模型--"+modelRecord.getAlgorithmServiceId());
			map.put(modelRecord.getAlgorithmServiceId(), modelRecord, autoOfflineTime, TimeUnit.SECONDS);
		}
	}
}

}
15:03:00.688 [main] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 加载云服务模型--258
15:03:00.699 [main] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 加载云服务模型--259
15:03:00.704 [main] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 加载云服务模型--260
15:03:00.709 [main] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 加载云服务模型--256
15:03:00.760 [main] INFO  c.y.s.a.SaasAlgorithmtrainingApplication - Started SaasAlgorithmtrainingApplication in 37.839 seconds (JVM running for 38.498)
15:03:05.063 [Timer-0] INFO  c.y.p.k.c.masterkey.MasterKeyManager - MasterKeyManager Refresh kms.3alevel.saas,100 Success!
15:03:15.316 [redisson-3-2] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 258模型1个小时内没有被调用，置入下线处理队列..
15:03:15.316 [redisson-3-2] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 259模型1个小时内没有被调用，置入下线处理队列..
15:03:15.316 [redisson-3-2] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 260模型1个小时内没有被调用，置入下线处理队列..
15:03:15.316 [redisson-3-2] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 256模型1个小时内没有被调用，置入下线处理队列..
15:03:15.316 [redisson-3-2] INFO  c.y.s.a.b.ModelAutoOfflineInitializr - 258模型1个小时内没有被调用，置入下线处理队列..
258这个模型，监听器监听到2次，但是实际只放进去一次，并且，我查看了RMapCache里也的确是一条数据，每次都是第一条数据会被监听到2次，so,问题是个什么情况？求大神解答！！！
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
exception：
2019-03-27-11:59:46 [pool-4-thread-2] ERROR c.i.c.p.n.n.u.ImportUtil - 更新导入接口详情表出错，出错原因：
Redis server response timeout (3000 ms) occured for command: (GET) with params: [99999999999999_20190327001PigcGuaracctbsinfsgmt_P] channel: [id: 0x533ebf98, L:/127.0.0.1:56650 - R:127.0.0.1/127.0.0.1:6379]
2019-03-27-11:59:49 [pool-4-thread-2] ERROR c.i.c.p.n.n.u.ImportUtil - 更新导入接口详情表出错，出错原因：Redis server response timeout (3000 ms) occured for command: (GET) with params: [99999999999999_20190327001PigcGuaracctbsinfsgmt_P] channel: [id: 0x0559f2c4, L:/127.0.0.1:56638 - R:127.0.0.1/127.0.0.1:6379]
2019-03-27-11:59:49 [pool-4-thread-2] ERROR c.i.c.p.n.n.i.ImportServiceImpl - pig---error:{}
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured for command: (GET) with params: [99999999999999_20190327001PigcGuaracctbsinfsgmt_P] channel: [id: 0x0559f2c4, L:/127.0.0.1:56638 - R:127.0.0.1/127.0.0.1:6379]
at org.redisson.command.CommandAsyncService$11.run(CommandAsyncService.java:752) ~[redisson-3.8.2.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670) ~[netty-common-4.1.30.Final.jar:4.1.30.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745) ~[netty-common-4.1.30.Final.jar:4.1.30.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473) ~[netty-common-4.1.30.Final.jar:4.1.30.Final]
at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]
2019-03-27-11:59:51 [http-nio-8080-exec-2] ERROR c.i.c.c.a.filter.Authorization - isUrlInList:org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@278152080 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0x9d5e6eae, L:/127.0.0.1:56640 - R:127.0.0.1/127.0.0.1:6379]], command: (LINDEX), command params: [k_d_a, 2] after 3 retry attempts
2019-03-27-11:59:58 [http-nio-8080-exec-2] ERROR c.i.c.c.a.filter.Authorization - error:org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=31, freeConnectionsCounter=63, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@57801302 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0x5786d31c, L:/127.0.0.1:56652 - R:127.0.0.1/127.0.0.1:6379]], command: (EVAL), command params: [local key = KEYS[1] local obj = ARGV[1] local items = redis.call('lrange', key, 0, -1) for i=1,#item..., 1, 57258884-c583-4969-9a32-186880898c88k_i_l, PooledUnsafeDirectByteBuf(ridx: 0, widx: 29, cap: 256)] after 3 retry attempts
2019-03-27-12:00:04 [redisson-netty-1-14] WARN  o.r.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [id: 0x0559f2c4, L:/127.0.0.1:56638 - R:127.0.0.1/127.0.0.1:6379], command: (GET), params: [99999999999999_20190327001PigcGuaracctbsinfsgmt_P], result: com.icfcc.credit.common.interfaceimport.entity.PsgImportsDetailSerialize@31275b42
2019-03-27-12:00:04 [redisson-netty-1-1] WARN  o.r.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [id: 0x533ebf98, L:/127.0.0.1:56650 - R:127.0.0.1/127.0.0.1:6379], command: (GET), params: [99999999999999_20190327001PigcGuaracctbsinfsgmt_P], result: com.icfcc.credit.common.interfaceimport.entity.PsgImportsDetailSerialize@3ecb0ae3
2019-03-27-12:01:14 [pool-4-thread-5] INFO  c.i.c.p.n.m.i.bImportServiceImpl - B data import end
2019-03-27-12:01:37 [pool-4-thread-5] INFO  c.i.c.p.n.m.i.cImportServiceImpl - C data import start,count=500000
This paper：
I tried many way, but there has been no redis overtime this solution. Hope to get a great god for help, thank you.
Redis version
redis-windows -x64-3.2.1
Redisson version
two version :2.8.2 or 3.8.2
Redisson configuration
new Config().userSingleServer().setAdddress("redis://127.0.0.1:6379");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2023
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For the record, we are using Redisson 3.10.4 with Redisson Tomcat 8.
In som cases we end up with shallow sessions without a TTL that fills up Redis. These junk sessions should probably not end up in Redis in the first place, but due to our complex application that is the situation for now. Anyway, there should be a guard in the Redis code that avoid sessions beeing created without a TTL. I'll explain why this happens and a suggestion for a solution which we are running ourselves in production.
This particular case arises when a request includes a session id which is neither stored locally in Tomcat or in Redis and it is immediately abandoned(no more interaction with the session). Then the public Session findSession(String id)  code in RedissonSessionManager is triggered, it doesn't find the session of course, but a new empty session is created and persisted in Redis where they stay forever. The fix is obviously to setMaxInactiveInterval on the session, which we in fact have done. But to accomplish this we have overriden the default RedissonSessionManager with out own custom RedissonSessionManager and added only session.setMaxInactiveInterval(getContext().getSessionTimeout() * 60), reusing the logic used when creating new sessions. Ideally we wan't to avoid having a custom RedissonSessionManager to solve what should probably be part of the default RedissonSessionManager.
@mrniko Could you please add this task to the next milestone?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reconsider MapWriter object - introduce two methods instead of current four.
Remove MapOptions.writeBehindThreads setting
Add MapOptions.writeBehindDelay setting
Add MapOptions.writeBehindBatchSize setting
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when user RMap
`@Autowired
private RedissonClient redisson;
@Test
public void testRedissonMap(){
	try {
		String mapGroup = "TEST_MAP_GROUP_2";
		String key = "TEST_KEY_2";
	
		RMap<String, Map<Integer, Integer>> rMap = redisson.getMap(mapGroup);
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for(int i = 0; i < 10; i++){
			map.put(i, i);
		}
		rMap.put(key, map);
		map = rMap.get(key);
		map.forEach(new BiConsumer<Integer, Integer>() {
			@Override
			public void accept(Integer t, Integer u) {
				System.out.println("数据集:" + t + "," + u);
			}
		});
	} catch (Exception e) {
		e.printStackTrace();
	}
}`

throw java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
fromByteArrayReverse方法为什么不检查bytes为null的情况，并返回new BitSet()；
Expected behavior
if (bytes == null) {
return new BitSet();
}
Actual behavior
throw new NullPointerException();
Steps to reproduce or test case
Redis version
Redisson version
3.10.5
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
When our server reach some load we are getting this errors from Redis:
Caused by: org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=50, freeConnectionsAmount=1, freeConnectionsCounter=64, freezed=false, freezeReason=null, client=[addr=redis://10.52.X.XXX:7000], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1993466873 [redisClient=[addr=redis://10.XX.1.XX:7000], channel=[id: 0x2cee8cb1, L:/10.XX.90.XXX:41292 - R:10.XX.1.XX/10.XX.1.XX:7000]], command: (GET), command params: [ConversationKey{conversationId='TEST-2be-1d2c-4ac6-8eb3-896d2ce9f0ef', channelId='broker'}] after 3 retry attempts
I have read a lot about this error in the issues but i cannot find how to solve :-(, what i have notice is that the freeConnectionsAmount is equals to 1, can this means that our code is unable to create more connections and this is what is causing the problem? I also see that freeConnectionsCounter=64 so this means that there are free connections?
Redisson version: 3.10.1
Best Regards.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
业务中可能需要创建大量的队列，测试发现队列数量和ConnectionPoolSize 成正比，还有什么其他玩法么。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, i have just migrate my project from Java 8 to Java 11 and i have encounter the following warning message when i am loading a redissonClient:
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.redisson.misc.URIBuilder (USERFOLDER/.m2/repository/org/redisson/redisson/3.10.5/redisson-3.10.5.jar) to field java.lang.reflect.Field.modifiers
WARNING: Please consider reporting this to the maintainers of org.redisson.misc.URIBuilder
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
I am using Intellij IDEA 2019.1 (Community Edition), Java 11, Redisson-3.10.5, on Windows 10 and Ubuntu 18.04.
Does anyone has the same issue? Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am doing a POC on Redisson. We added 600K  records as List into Rmap
RMap<String, List> dlMap = client.getMap(key);
dlMap.put(dt.toString(), UsersList)
While doing dlMap.get(key); it is causing the above error.
ERROR CommandDecoder - Unable to decode data. reply: $85998717
The good thing is , it is working fine if users list is 150k.
UserList is a list of Users object. is there a way i can get rid of this issue. or even better if i can get a particular user object say having user.getId = 181062
Thanks for the help in advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Hadoop yarn application should run successfully
Actual behavior
2019-04-07 23:15:58 INFO  [THREAD ID=LTM-worker-thd-128] Job:1406 - Task Id : attempt_1554192178061_15274_m_000003_2, Status : FAILED
@400000005caa37602da1dca4 Error: io.netty.util.internal.StringUtil.indexOfNonWhiteSpace(Ljava/lang/CharSequence;I)I
@400000005caa37602da1e474 Container killed by the ApplicationMaster.
@400000005caa37602da1e474 Container killed on request. Exit code is 143
@400000005caa37602da1e85c Container exited with a non-zero exit code 143
Steps to reproduce or test case
Redis version
redis-3.*
Redisson version
3.10.5
Redisson configuration
programatic configuration with sentinel servers
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
No NullPointer Error
Actual behavior
2019-04-08 20:24:44,901 WARN [redisson-netty-1-13] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.io.IOException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:364)
at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:265)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:210)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:139)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
... 28 more
Caused by: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
... 36 more
Steps to reproduce or test case
RBatch batch = cacheClient.createBatch(BatchOptions.defaults());
for (String cacheKey : cacheKeys) {
batch.getBucket(cacheKey).getAsync();
}
BatchResult result = batch.execute();
List response = result.getResponses();
Redis version
3.2.10
Redisson version
3.10.6 and 3.10.5
Redisson configuration
threads: 10
clusterServersConfig:
connectTimeout: 500
failedSlaveCheckInterval: 10000
idleConnectionTimeout: 10000
keepAlive: true
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
nodeAddresses:

"{{ $redis_endpoint }}"
pingTimeout: 1000
retryAttempts: 0
retryInterval: 0
scanInterval: 15000
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 100
tcpNoDelay: true
timeout: 750
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Can't connect to sentinel server. Unable to connect to: redis://110.210.110.31:26479
Actual behavior
INFO: 1 Spring WebApplicationInitializers detected on classpath
Apr 09, 2019 10:00:17 AM org.apache.catalina.util.SessionIdGeneratorBase createSecureRandom
WARNING: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [7,310] milliseconds.
[partner.ubpay.com-startStop-1] WARN org.redisson.connection.SentinelConnectionManager - Can't connect to sentinel server. Unable to connect to: redis://110.210.110.31:26479
[partner.ubpay.com-startStop-1] WARN org.redisson.connection.SentinelConnectionManager - Can't connect to sentinel server. Unable to connect to: redis://110.210.110.32:26479
[partner.ubpay.com-startStop-1] WARN org.redisson.connection.SentinelConnectionManager - Can't connect to sentinel server. Unable to connect to: redis://110.210.110.33:26479
Apr 09, 2019 10:00:20 AM org.apache.catalina.core.StandardContext startInternal
SEVERE: The session manager failed to start
org.apache.catalina.LifecycleException: Failed to start component [org.redisson.tomcat.RedissonSessionManager[]]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:162)
at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5714)
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1707)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1697)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
Caused by: org.apache.catalina.LifecycleException: org.redisson.client.RedisConnectionException: At least two sentinels should be defined in Redis configuration! SENTINEL SENTINELS command returns empty result!
at org.redisson.tomcat.RedissonSessionManager.buildClient(RedissonSessionManager.java:289)
at org.redisson.tomcat.RedissonSessionManager.startInternal(RedissonSessionManager.java:209)
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)
... 8 more
Caused by: org.redisson.client.RedisConnectionException: At least two sentinels should be defined in Redis configuration! SENTINEL SENTINELS command returns empty result!
at org.redisson.connection.SentinelConnectionManager.(SentinelConnectionManager.java:161)
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:232)
at org.redisson.Redisson.(Redisson.java:118)
at org.redisson.Redisson.create(Redisson.java:157)
at org.redisson.tomcat.RedissonSessionManager.buildClient(RedissonSessionManager.java:287)
... 10 more
Apr 09, 2019 10:00:20 AM org.apache.catalina.core.StandardContext startInternal
SEVERE: Context [] startup failed due to previous errors
Apr 09, 2019 10:00:20 AM org.apache.catalina.loader.WebappClassLoaderBase clearReferencesThreads
SEVERE: The web application [] appears to have started a thread named [logback-1] but has failed to stop it. This is very likely to create a memory leak.
Steps to reproduce or test case
Telnet and redis-cli -h {ip} -p {port} -a {password} will all host connect normally.
Redis version
Redis 5.0
Redisson version
Apache-Tomcat 7.0.93
redisson-all-3.10.5
redisson-tomcat-7.3.10.5
Redisson configuration
{
"sentinelServersConfig":{
"idleConnectionTimeout":10000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"failedSlaveReconnectionInterval":3000,
"failedSlaveCheckInterval":60000,
"password":"4d8dab5dbdaac2995a61f41698972c4b00ca0dbe",
"subscriptionsPerConnection":5,
"clientName":null,
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"slaveConnectionMinimumIdleSize":32,
"slaveConnectionPoolSize":64,
"masterConnectionMinimumIdleSize":32,
"masterConnectionPoolSize":64,
"readMode":"SLAVE",
"subscriptionMode":"SLAVE",
"sentinelAddresses":[
"redis://110.210.110.31:26379",
"redis://110.210.110.32:26379",
"redis://110.210.110.33:26379"
],
"masterName":"mymaster",
"database":0
},
"threads":16,
"nettyThreads":32,
"codec":{
"class":"org.redisson.codec.FstCodec"
},
"transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson is not able to send request to redis cluster deployed in kubernetes when master/slave are down.
Actual behavior
Below are the exceptions caught when requests were sent to Redisson; the exceptions are alternating (i.e. I got exception #1 in one request - then got exception #2 in an other request for the same test)

exeception #1:

org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://10.244.0.65:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@223124557 [redisClient=[addr=redis://10.244.6.102:6379], channel=[id: 0x43c6edb3, L:0.0.0.0/0.0.0.0:39840], command=null], command: (GET), params: [http:device:http-gw-lan-test-6666] after 3 retry attempts
at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:873)
at org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:97)
at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:792)
at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:789)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:991)
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:873)
at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1365)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:738)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:730)
at io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:38)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1127)
at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1174)
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1098)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.nio.channels.ClosedChannelException
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source)

exception #2:
2019-04-09 23:48:59.141 ERROR 1 --- [tor-tcp-epoll-2] o.r.connection.pool.SlaveConnectionPool  : slave 10.244.6.102/10.244.6.102:6379 has been disconnected after 60000 ms interval since moment of the first failed connection
23:48:59.141 [reactor-tcp-epoll-2] ERROR o.r.c.pool.SlaveConnectionPool - slave 10.244.6.102/10.244.6.102:6379 has been disconnected after 60000 ms interval since moment of the first failed connection
org.redisson.client.RedisTimeoutException: Unable to get connection! Try to increase 'nettyThreads' and 'connection pool' settings or set decodeInExecutor = true and increase 'threads' settingNode source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://10.244.0.65:6379], nodeType=MASTER, firstFail=0]]], command: (GET), params: [http:device:http-gw-lan-test-8888] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:703)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)

Steps to reproduce or test case
Deploy redis cluster in kubernetes (3 masters: redis-cluster-0, redis-cluster-1, redis-cluster-2; 3 slaves: redis-cluster-3, redis-cluster-4, redis-cluster5)
Kill redis-cluster-0 and redis-cluster-3.
Wait for redis-cluster-0 and redis-cluster3 to have state RUNNING and READY
Kill redis-cluster-1, redis-cluster-2, redis-cluster-4, redis-cluster-5
Send requests to see exceptions
I am using redisson reactive clien
redisDownError-Report.txt
t.
Redis version
5.0.3
Redisson version
3.10.5
Redisson configuration
clusterServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 60000
password: Redis123456
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "SLAVE"
nodeAddresses:
- "redis://redis-cluster:6379"
scanInterval: 1000
pingConnectionInterval: 10000
keepAlive: false
tcpNoDelay: false
threads: 8
nettyThreads: 16
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
In  Redis cluster mode, when we use scan to get the keys with in a pattern mode like (test_key*), we want to get the results in a certain order.
Actual behavior
In  Redis cluster mode, when we use scan to get the keys with in a pattern mode like (test_key*), in on redis instance, we can get the keys in order, bug in different nodes, the order is random.
Steps to reproduce or test case
1: a redis cluter with 2 master and 2 slave
2 put kv like :
test_key -> testvalue
test_key1 -> testvalue1
test_key2  -> testvalue2
3 : we scan the keys with test_key* in the following way
keys = redissonClient.getKeys().getKeysByPattern("test_key*",100);
iter = keys.iterator();
i=1;
while (iter.hasNext()) {
Object o = iter.next();
System.out.println( (i++) +") "+o.toString());
}
Some times we get the reuslt :
1) test_key2
2) test_key1
3) test_key
while some times ,we get the result :
1) test_key1
2) test_key
3) test_key2
Redis version
4.0.2
Redisson version
3.10.5
Redisson configuration
default;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Sentinel support for authentication with password was added in Redis 5. Redisson will authenticate to Redis Sentinel's started with requirepass <password.here> in sentinel.conf.  The work around for now is to simply have the sentinel's not run in protected mode even if Redis Master/Slave instances have password requirements.  This works, however when auth is required on the sentinel nodes (as set by sentinel.conf requirepass <foo.bared.blahblahblah>) themselves, RedissonClient cannot perform commands to the sentinel nodes (Sentinel Sentinels, Sentinel Master, yada yada)
Commit adding authentication support for sentinels:  redis/redis@fa67525
Expected behavior is that RedissonClient sends the auth with a password value that's set in a config.
Actual behavior
Redisson does not appear to authenticate with the redis password stored in BaseConfig, and there doesn't appear to be a place to add one in the SentinelConfig.  On Spring boot application with redis password set and requirepass in sentinel.conf, startup has the following error:
Caused by: org.redisson.client.RedisException: NOAUTH Authentication required.. channel: [id: 0x37c4957c, L:/172.19.0.1:34720 - R:172.19.0.3/172.19.0.3:26379] command: (SENTINEL GET-MASTER-ADDR-BY-NAME), params: [masternamehereblahblahblah]
    at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:314)
    at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130)
    at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
    at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)

Steps to reproduce or test case
Start a Redis Master, Replica, and Sentinels all with requirepass set to some value, then attempt to get RedissonClient with SentinelServersConfig set up, setting password to whatever your password is, master name to whatever your master name is, and your nodes as appropriate.
Redis version
5.0.4
Redisson version
3.10.X
Redisson configuration
SentinelServersConfig sentinelServersConfig = config.useSentinelServers();
            sentinelServersConfig.setMasterName(sentinelProperties.getMasterName());
            List<String> nodes = sentinelProperties.getNodes();
            String[] nodeStr = nodes.toArray(new String[nodes.size()]);
            sentinelServersConfig.addSentinelAddress(nodeStr);
            sentinelServersConfig.setReadMode(ReadMode.MASTER);
            sentinelServersConfig.setPassword(sentinelProperties.getPassword());

Due to sensitive nature of passwords, names etc, these will remain abstracted in my configuration snippet here.  None of these values are null, they are all set via a configuration setting.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In springboot 2.1.4
the jackson-core version is 2.8.7
How can I resolve this version conflict?
I tried to filter the jackson-core in spring json, but it didn't work.
- org.redisson:redisson-spring-data-21:jar:3.10.6:compile
- org.redisson:redisson:jar:3.10.6:compile
+- de.ruedigermoeller:fst:jar:2.29:provided (version managed from 2.57; scope managed from compile)
|  - (com.fasterxml.jackson.core:jackson-core:jar:2.8.7:compile - version managed from 2.9.8; scope updated from provided; omitted for duplicate)
+- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.9.8:compile
|  - (com.fasterxml.jackson.core:jackson-core:jar:2.8.7:compile - version managed from 2.9.8; omitted for duplicate)
- com.fasterxml.jackson.core:jackson-core:jar:2.8.7:compile
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
handle org.redisson.client.WriteRedisConnectionException for example same way as others in spring CacheErrorHandler
Actual behavior
I try sentinel, master-slave and also single server redisson config. In each configuration is problem when cached method with sync=true and connection to redis server is broken or redis server is down.
 org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:100:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:255:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1737055972 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0x4aa21a8b, L:0.0.0.0/0.0.0.0:58873], command=null], command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, migrationDispatcher, redisson__timeout__set:{migrationDispatcher}, redisson__idle__set:{migrationDispatcher}, redisson__map_cache__last_access__set:{migrationDispatcher}, {migrationDispatcher}:redisson_options, 1555312017905, PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 256)] after 1 retry attempts at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:873) ~[redisson-3.10.5.jar:?] at org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:97) ~[redisson-3.10.5.jar:?] at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:792) ~[redisson-3.10.5.jar:?] at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:789) ~[redisson-3.10.5.jar:?] at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:476) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1018) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:874) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1365) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:706) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:698) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1091) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1138) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1062) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.34.Final.jar:4.1.34.Final] at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181] Caused by: io.netty.channel.ExtendedClosedChannelException at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
IF WE USE method without SYNC=true then exception is similar but is HANDLED by org.springframework.cache.interceptor.CacheErrorHandler and is behavior OK
`org.redisson.client.WriteRedisConnectionException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value💯queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:255:queue:0, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1737055972 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0x4aa21a8b, L:0.0.0.0/0.0.0.0:58873], command=null], command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, migrationDispatcher, redisson__timeout__set:{migrationDispatcher}, redisson__idle__set:{migrationDispatcher}, redisson__map_cache__last_access__set:{migrationDispatcher}, {migrationDispatcher}:redisson_options, 1555312017905, PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 256)] after 1 retry attempts
at org.redisson.command.CommandAsyncService.checkWriteFuture(CommandAsyncService.java:873) ~[redisson-3.10.5.jar:?]
at org.redisson.command.CommandAsyncService.access$000(CommandAsyncService.java:97) ~[redisson-3.10.5.jar:?]
at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:792) ~[redisson-3.10.5.jar:?]
at org.redisson.command.CommandAsyncService$7.operationComplete(CommandAsyncService.java:789) ~[redisson-3.10.5.jar:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:476) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1018) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:874) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1365) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:706) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:698) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.access$1700(AbstractChannelHandlerContext.java:38) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1091) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1138) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1062) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:163) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:495) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
Caused by: io.netty.channel.ExtendedClosedChannelException
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
`

Steps to reproduce or test case
Start app for example with SingleServer config and method with spring annotation
Redis version
4.0.12
Redisson version
3.10.5
Redisson configuration
compile("org.redisson:redisson-spring-data-21:3.10.5")
/////////
@bean
public RedissonClient redissonSingleServerClient() {
Config config = new Config();
config.useSingleServer()
.setAddress("redis://127.0.0.1:6379")
.setRetryInterval(RETRY_INTERVAL)
.setRetryAttempts(RETRY_ATTEMPTS)
.setConnectionPoolSize(CONNECTION_POOL_SIZE)
.setSubscriptionConnectionPoolSize(SUBSCRIPTION_POOL_SIZE);
return Redisson.create(config);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using a fixed connection pool of min=64 and max=64 to every node (masters and slaves) on cluster config. Redisson is able to open a healthy connection pool of 64 to each of the nodes
Actual behavior
It seems that on some cases when our app container (dockerized app) starts there might be some network/warm up issues (also seen by getting a few CLUSTER_NODES and CLUSTER_INFO timeouts during startup) leads to some connections on the pool to be broken. No issue is easily observed at low traffic after but after increasing a bit the load, it seems some requests to those instances (we deployed 20 instances and 2 ended up like this) fail with timeouts. This doesn't seem to happen to instances that started and opened all the connections properly at startup but seems this faulty startup instances remain in a broken state and do not recover and/or re-create those broken connections.
On any case, as said, this only happens on those cases during startup. So that's our primary hypothesis. If any logic can be put into place to deal with potential broken connections on the pool or some monitoring of the pool we can enable or some config we could do differently. Please advice
example timeout:
	at rapid.shaded.org.redisson.command.CommandBatchService$3.run(CommandBatchService.java:675)
	at rapid.shaded.io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
	at rapid.shaded.io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)

Steps to reproduce or test case
Trying to isolate an easy way to reproduce it at the moemnt
Redis version
3.2.8
Redisson version
3.10.4
Redisson configuration
                            "connectTimeout": 10000,
                            "timeout": 100,
                            "retryInterval": 50,
                            "retryAttempts": 4,
                            "masterConnectionMinimumIdleSize": 64,
                            "masterConnectionPoolSize": 64,
                            "slaveConnectionMinimumIdleSize": 64,
                            "slaveConnectionPoolSize": 64,
                            "keepAlive": true,
                            "tcpNoDelay": true,
                            "readMode": "MASTER_SLAVE",
                            "nodeAddresses": [
                                "redis://redis001.prod.local:6329",
                                "redis://redis001.prod.local:6339",
                                "redis://redis001.prod.local:6349",
                                "redis://redis002.prod.local:6329",
                                "redis://redis002.prod.local:6339",
                                "redis://redis002.prod.local:6349",
                                "redis://redis003.prod.local:6329",
                                "redis://redis003.prod.local:6339",
                                "redis://redis003.prod.local:6349",
                                "redis://redis004.prod.local:6329",
                                "redis://redis004.prod.local:6339",
                                "redis://redis004.prod.local:6349",
                                "redis://redis005.prod.local:6329",
                                "redis://redis005.prod.local:6339",
                                "redis://redis005.prod.local:6349",
                                "redis://redis006.prod.local:6329",
                                "redis://redis006.prod.local:6339",
                                "redis://redis006.prod.local:6349"
                            ]
                        },
                        "useLinuxNativeEpoll": true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
对于这两个，我有些不明白，提出几个问题，希望能得到解答。
运行环境：redis 是一个3主3从的集群，并只创建了一个 redisClient
1、使用 redisClient.getLock 方法，是根据 key 的名称选择一个实例并进行操作么？
2、使用  redissonClient.getRedLock 方法，传入的 Rlock 是上面所说的 redisClient 创建出来的，是否能达到 RedLock 算法所说的效果？
3、按照之前的理解，是否这样的一个 3主3从的集群，必须创建3个 redisClient ?
4、如果是创建了3个redisClient , 使用如 Semaphore 这样只支持在单个redisClient上创建的锁对象时，是只能由自行选择其中一个进行操作么？
谢谢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior   when machine is down, RedissonSemaphore should release
Actual behavior  it never released.
Steps to reproduce or test case
Redis version 5.0.4（ jedis 2.9.0 ）
Redisson version  3.8.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
JVM1:
lock = redissonClient.getRedLock(
                  redissonClient.getReadWriteLock("name").readLock(), 
                  some_other_lock_1)

Then call lock.tryLock() first, return true.
JVM2:
lock = redissonClient.getRedLock(
                  redissonClient.getReadWriteLock("name").writeLock(), 
                  some_other_lock_2)

Then call lock.tryLock() after the previous call has been made, now it should return false because there is a readLock under the same name.
Actual behavior
JVM1:
lock = redissonClient.getRedLock(
                  redissonClient.getReadWriteLock("name").readLock(), 
                  some_other_lock_1)

Then call lock.tryLock() first return true as expected.
JVM2:
lock = redissonClient.getRedLock(
                  redissonClient.getReadWriteLock("name").writeLock(), 
                  some_other_lock_2)

Then call lock.tryLock() after the previous one, now it return true i.e. have both write lock and read lock on the same ReadWriteLock.
Steps to reproduce or test case
As described above.
In case if this is useful information, if replace getRedLock with getMultiLock it actually works. Also if having only one JVM it also works.
Redis version
Redis server v=3.2.0 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=8d88dc6cfd069418
Redisson version
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.11.0</version>
        </dependency>

java version "1.8.0_191"
Java(TM) SE Runtime Environment (build 1.8.0_191-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)

Redisson configuration
One redis standalone instance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
startup
Actual behavior
get error
Caused by: java.lang.IllegalStateException: Default configuration hasn't been specified! at org.redisson.jcache.JCacheManager.createCache(JCacheManager.java:118) at org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration.jCacheCacheManager(JCacheCacheConfiguration.java:101) at org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration$$EnhancerBySpringCGLIB$$a6ce7558.CGLIB$jCacheCacheManager$1(<generated>) at org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration$$EnhancerBySpringCGLIB$$a6ce7558$$FastClassBySpringCGLIB$$3ebd8bcd.invoke(<generated>) at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358) at org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration$$EnhancerBySpringCGLIB$$a6ce7558.jCacheCacheManager(<generated>) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
Steps to reproduce or test case

use redisson with springboot
use spring.cache.chach-name=default in application.properties

Redis version
server :2.6.9
Redisson version
3.7.5
Redisson configuration
Config config = new Config(); config.setTransportMode(TransportMode.NIO); config.useSingleServer().setAddress("redis://"+this.redisProperties.getHost()+":"+this.redisProperties.getPort()); config.useSingleServer().setPassword(this.redisProperties.getPassword()); config.useSingleServer().setTimeout(this.redisProperties.getTimeout());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
SUCCESS
Actual behavior
Redisson is shutdown
Steps to reproduce or test case
    @Autowired
    private RedissonDistributedLocker distributedLocker;

    @Test
    public void lockTest() {

        String lockKey = "test";

        for (int i = 0; i < 50; i++) {
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        System.err.println("=============线程开启============" + Thread.currentThread().getName());
                        distributedLocker.lock(lockKey, 10L); //直接加锁，获取不到锁则一直等待获取锁
                        Thread.sleep(100); //获得锁之后可以进行相应的处理
                        System.err.println("======获得锁后进行相应的操作======" + Thread.currentThread().getName());
                        distributedLocker.unlock(lockKey);  //解锁
                        System.err.println("=============================" + Thread.currentThread().getName());

                        //尝试获取锁，等待5秒，自己获得锁后一直不解锁则10秒后自动解锁
//                        boolean isGetLock = distributedLocker.tryLock(lockKey, TimeUnit.SECONDS, 1L, 10L);
//                        if (isGetLock) {
//                            Thread.sleep(5000); //获得锁之后可以进行相应的处理
//                            System.err.println("======获得锁后进行相应的操作======" + Thread.currentThread().getName());
//                            distributedLocker.unlock(lockKey);
//                            System.err.println("=============================" + Thread.currentThread().getName());
//                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
            t.start();
        }
    }


Redis version
5.0.4
Redisson version
3.10.7
Redisson configuration
# Redisson配置。支持单机，主从，哨兵，集群等模式
# 此为单机模式
singleServerConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  password: foo
  subscriptionsPerConnection: 5
  clientName: null
  address: "redis://192.168.3.53:6379"
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 32
  connectionPoolSize: 64
  database: 0
  dnsMonitoringInterval: 5000
threads: 16
nettyThreads: 32
codec:
  class: "org.redisson.codec.JsonJacksonCodec"
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
4.0.6
Redisson version
3.11.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have a testing redis cluster environment with only 1 master and 1 slave. When using redisson client with RedissonBinaryStream to write byte array to redis server, we encountered the exception logged below.
Expected behavior
Successfully write and read from Redis Cluster using RedissonBinaryStream implementation
Actual behavior
Seeing exception:
Exception in thread "main" org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0x6264422d, L:/<hide ip>:61627 - R:/<hide ip>:6379] command: CommandData [promise=org.redisson.misc.RedissonPromise@5ebfe264[Not completed], command=(EVAL), params=[local parts = redis.call('get', KEYS[2]); local lastPartName = KEYS[1];if parts ~= false then lastPa..., 2, stream-test, stream-test:parts], codec=org.redisson.client.codec.ByteArrayCodec@16e94982]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:267)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:127)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:563)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:480)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)

Steps to reproduce or test case
Redis version
3.2.8
Redisson version
3.4.1
Redisson configuration
 String redisClusterEntryEndpoint = bcConfig.getEndpoint();
        Config config = new Config();
        config.useClusterServers().addNodeAddress(redisClusterEntryEndpoint);
        return Redisson.create(config);

OutputStream os = redissonClient.getBinaryStream(key).getOutputStream();
os.write(bytes);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson fails to connect to slave node.
Expected behavior
successful connection.
Actual behavior

Can't add slave: rediss://[ip]:[port]",mhash="6ff2ffa1",exc="org.redisson.client.RedisConnectionException: Unable to connect to Redis server: [ip1]/[ip2]:[port]
at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:160)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:485)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:330)
at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:296)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
at org.redisson.client.RedisClient$2$2.run(RedisClient.java:245)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.nio.channels.ClosedChannelException: null
at io.netty.channel.nio.AbstractNioChannel.doClose()(Unknown Source)

Steps to reproduce or test case
Redis version
3.2.7
Redisson version
3.10.7
Redisson configuration

{
"clusterServersConfig" : {
"idleConnectionTimeout" : 10000,
"pingTimeout" : 1000,
"connectTimeout" : 10000,
"timeout" : 3000,
"retryAttempts" : 3,
"retryInterval" : 3500,
"password" : "1",
"subscriptionsPerConnection" : 15,
"sslEnableEndpointIdentification" : true,
"sslProvider" : "JDK",
"pingConnectionInterval" : 0,
"keepAlive" : false,
"tcpNoDelay" : false,
"loadBalancer" : {
"class" : "org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"slaveConnectionMinimumIdleSize" : 10,
"slaveConnectionPoolSize" : 35,
"failedSlaveReconnectionInterval" : 3000,
"failedSlaveCheckInterval" : 60000,
"masterConnectionMinimumIdleSize" : 10,
"masterConnectionPoolSize" : 35,
"readMode" : "MASTER",
"subscriptionMode" : "MASTER",
"subscriptionConnectionMinimumIdleSize" : 1,
"subscriptionConnectionPoolSize" : 30,
"dnsMonitoringInterval" : 5000,
"natMap" : { },
"nodeAddresses" : [ "rediss://[ip]:[port]" ],
"scanInterval" : 10000,
"slaveSubscriptionConnectionPoolSize" : 30,
"slaveSubscriptionConnectionMinimumIdleSize" : 1
},
"threads" : 0,
"nettyThreads" : 0,
"codec" : {
"class" : "org.redisson.codec.JsonJacksonCodec"
},
"referenceEnabled" : true,
"transportMode" : "NIO",
"lockWatchdogTimeout" : 30000,
"keepPubSubOrder" : true,
"decodeInExecutor" : false,
"useScriptCache" : false,
"minCleanUpDelay" : 5,
"maxCleanUpDelay" : 1800,
"addressResolverGroupFactory" : {
"class" : "org.redisson.connection.RoundRobinDnsAddressResolverGroupFactory"
}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Spring bean created successfully
Actual behavior
Caused by: java.lang.NullPointerException: null
    at org.redisson.liveobject.core.RedissonObjectBuilder.fillCodecMethods(RedissonObjectBuilder.java:192)
    at org.redisson.liveobject.core.RedissonObjectBuilder.<init>(RedissonObjectBuilder.java:108)
    at org.redisson.command.CommandAsyncService.enableRedissonReferenceSupport(CommandAsyncService.java:155)
    at org.redisson.command.CommandAsyncService.enableRedissonReferenceSupport(CommandAsyncService.java:124)
    at org.redisson.Redisson.enableRedissonReferenceSupport(Redisson.java:701)
    at org.redisson.Redisson.create(Redisson.java:166)
    at com.canva.embed.server.RpcLauncherConfiguration.embedRedisClient(RpcLauncherConfiguration.java:192)
    at com.canva.embed.server.RpcLauncherConfiguration$$EnhancerBySpringCGLIB$$7265447b.CGLIB$embedRedisClient$5(<generated>)
    at com.canva.embed.server.RpcLauncherConfiguration$$EnhancerBySpringCGLIB$$7265447b$$FastClassBySpringCGLIB$$851420f7.invoke(<generated>)
    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244)
    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363)
    at com.canva.embed.server.RpcLauncherConfiguration$$EnhancerBySpringCGLIB$$7265447b.embedRedisClient(<generated>)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:564)
    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154)

Steps to reproduce or test case
We have several spring beans that initialise in prallel
Redis version
?
Redisson version
3.10.1
Redisson configuration
@Bean
  RedissonClient embedRedisClient( //
      @Value("${embed.cache.nodes}") String nodes, //
      @Value("${embed.cache.connections}") int connections, //
      @Value("${embed.cache.command.retry.attempts}") int retryAttempts, //
      @Value("${embed.cache.command.retry.interval.ms}") int retryInterval, //
      @Value("${embed.cache.command.server.timeout.ms}") int timeout
  ) {
    String[] splitNodes = nodes.split("\\s*,\\s*");
    Preconditions.checkArgument(splitNodes.length > 0);

    int maxConnections = connections * 2;

    Config config = new Config();
    if (splitNodes.length == 1) {
      config.useSingleServer()
          .setAddress(splitNodes[0])
          .setConnectionPoolSize(connections)
          .setRetryAttempts(retryAttempts)
          .setRetryInterval(retryInterval)
          .setTimeout(timeout);
    } else {
      config.useReplicatedServers() //
          .addNodeAddress(splitNodes)
          .setMasterConnectionMinimumIdleSize(connections)
          .setMasterConnectionPoolSize(maxConnections)
          .setSlaveConnectionMinimumIdleSize(connections)
          .setSlaveConnectionPoolSize(maxConnections)
          .setRetryAttempts(retryAttempts)
          .setRetryInterval(retryInterval)
          .setTimeout(timeout);
    }
    return Redisson.create(config);
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在执行大量的 异步操作时,速度很慢,而且大量报错。nettyThreads和'connection pool'也不能无限增加吧.  而且报错都集中在线程 eventloop-thread-1
org.redisson.client.RedisTimeoutException: Unable to get connection! Try to increase 'nettyThreads' and 'connection pool' settings or set decodeInExecutor = true and increase 'threads' settingNode source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:32:queue:1, freezed=false, freezeReason=null, client=[addr=redis://127.0.0.1:6379], nodeType=MASTER, firstFail=0]]], command: (HGET), params: [test-map, PooledUnsafeDirectByteBuf(ridx: 0, widx: 6, cap: 256)] after 3 retry attempts
	at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:703)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
	at java.lang.Thread.run(Thread.java:748)

Steps to reproduce or test case
    public static RedissonClient newRedissonClient() {
        Config config = new Config();
        config.useSingleServer()
                .setAddress(System.getProperty("redis.host", "redis://127.0.0.1:6379"))
                .setDatabase(0)
                .setTimeout(10000)
                .setConnectionPoolSize(1024)
                .setConnectTimeout(10000);
        config.setThreads(32);
        config.setNettyThreads(32);

        return Redisson.create(config);
    }


    @SneakyThrows
    public static void main(String[] args) {
        RedissonClient client = newRedissonClient();

        RMap<String, Object> map = client.getMap("test-map");
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        CountDownLatch latch = new CountDownLatch(100000);
        for (int i = 0; i < 100000; i++) {
            int fi = i;
            map.getAsync("key1")
                    .whenComplete((val, err) -> {
                        System.out.println(val + " => " + fi+" =>"+Thread.currentThread().getName());

                        if(null!=err){
                            err.printStackTrace();
                        }
                        latch.countDown();

                    });
        }
        latch.await();
        client.shutdown();
    }
Redis version
5.0.4
Redisson version
3.10.6
Redisson configuration
 Config config = new Config();
        config.useSingleServer()
                .setAddress(System.getProperty("redis.host", "redis://127.0.0.1:6379"))
                .setDatabase(0)
                .setTimeout(10000)
                .setConnectionPoolSize(1024)
                .setConnectTimeout(10000);
        config.setThreads(32);
        config.setNettyThreads(32);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson version 3.10.7
Linked with https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6587184
Problem is in RedisClient.java,  line 172:
        byte[] addr = NetUtil.createByteArrayFromIpAddressString(uri.getHost());
uri.getHost() is returning null, so validation of address inside netty is throwing NPE when it tries to get length of the string that is null.
I'm providing the stack trace:
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622)
	... 42 more
Caused by: java.lang.NullPointerException
	at io.netty.util.NetUtil.isValidIpV4Address(NetUtil.java:648)
	at io.netty.util.NetUtil.createByteArrayFromIpAddressString(NetUtil.java:368)
	at org.redisson.client.RedisClient.resolveAddr(RedisClient.java:172)
	at org.redisson.connection.MasterSlaveEntry.setupMasterEntry(MasterSlaveEntry.java:123)
	at org.redisson.connection.MasterSlaveEntry.setupMasterEntry(MasterSlaveEntry.java:118)
	at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:345)
	at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:163)
	at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:34)
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:229)
	at org.redisson.Redisson.<init>(Redisson.java:119)
	at org.redisson.Redisson.create(Redisson.java:159)
	at net.icpweb.messaging.broker.configuration.MessagingAutoConfiguration.redissonClient(MessagingAutoConfiguration.java:114)
	at net.icpweb.messaging.broker.configuration.MessagingAutoConfiguration$$EnhancerBySpringCGLIB$$30111eb4.CGLIB$redissonClient$1(<generated>)
	at net.icpweb.messaging.broker.configuration.MessagingAutoConfiguration$$EnhancerBySpringCGLIB$$30111eb4$$FastClassBySpringCGLIB$$ba41b375.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244)
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363)
	at net.icpweb.messaging.broker.configuration.MessagingAutoConfiguration$$EnhancerBySpringCGLIB$$30111eb4.redissonClient(<generated>)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154)
	... 43 more


Configuration is YAML based:
singleServerConfig:
  idleConnectionTimeout: 10000
  pingTimeout: 1000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  subscriptionsPerConnection: 5
  sslEnableEndpointIdentification: true
  sslProvider: "JDK"
  pingConnectionInterval: 0
  keepAlive: false
  tcpNoDelay: false
  address: "redis_test:3809"
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 32
  connectionPoolSize: 64
  database: 0
  dnsMonitoringInterval: 5000
threads: 16
nettyThreads: 32
referenceEnabled: true
transportMode: "NIO"
lockWatchdogTimeout: 30000
keepPubSubOrder: true
decodeInExecutor: false
useScriptCache: false
minCleanUpDelay: 5
maxCleanUpDelay: 1800
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
it seems RRemoteService.getFreeWorkers api code issue?
from the document RRemoteService.getFreeWorkers, I get the follow description
int getFreeWorkers(Class<?> remoteInterface)
Returns free workers amount available for tasks
code:
      RedissonClient client = Redisson.create(config);
      RRemoteService rpc = client.getRemoteService();
      System.out.println(rpc.getFreeWorkers())
      System.out.println(rpc.getFreeWorkers())

print:
100
0

Then I find the source code
RedissonRemoteService.java
Expected behavior
    @Override
    public int getFreeWorkers(Class<?> remoteInterface) {
        Entry entry = remoteMap.get(remoteInterface);
        if (entry == null) {
            return 0;
        }
        return entry.getCounter().get();
    }
Actual behavior
    @Override
    public int getFreeWorkers(Class<?> remoteInterface) {
        Entry entry = remoteMap.remove(remoteInterface);
        if (entry == null) {
            return 0;
        }
        return entry.getCounter().get();
    }
are you kidding me？
why remove? it should be get
Entry entry = remoteMap.remove(remoteInterface);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
What I want to do is depending on PRINCIPAL_NAME_INDEX_NAME in redis to control the Spring Security's maximum session management through SpringSessionBackedSessionRegistry class.
The first look at RedissonSessionRepository.save() confused me that it is an empty method which says "session changes are stored in real-time". In comparison, the standard RedisOperationsSessionRepository.save() of spring-session-data-redis has codes to create PRINCIPAL_NAME_INDEX_NAME. In fact, these codes are in RedisOperationsSessionRepository$RedisSession.saveDelta().
Expected behavior
The PRINCIPAL_NAME_INDEX_NAME key is created with Spring Security's principal information
Actual behavior
The PRINCIPAL_NAME_INDEX_NAME key is not created
Steps to reproduce or test case
Using Spring Boot 2.1.3/Spring Security 5.1.4/Spring Session 2.1.4, during which the Spring Session java configuration is:
@EnableRedissonHttpSession(keyPrefix = "xxx:")
public class SessionConfig {
    @Bean
    public static ConfigureRedisAction configureRedisAction() {
        return ConfigureRedisAction.NO_OP;
    }
}
Redis version
5.0.0 on AWS Elasticache
Redisson version
3.11.0
Redisson configuration
clusterServersConfig:
   retryAttempts: 6
   retryInterval: 20000
   readMode: "MASTER_SLAVE"
   nodeAddresses:
   - "redis://xxx.xxxxxx.clustercfg.apne1.cache.amazonaws.com:6379"
   scanInterval: 5000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
09-Jun-2019 14:13:21.573 WARNING [main] org.apache.catalina.startup.Catalina.load Permissions incorrect, read permission is not allowed on the file.
09-Jun-2019 14:13:21.573 SEVERE [main] org.apache.catalina.startup.Catalina.start Cannot start server. Server instance is not configured.
OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=64m; support was removed in 8.0
09-Jun-2019 14:14:06.084 WARNING [main] org.apache.catalina.startup.Catalina.load Unable to load server configuration from [/usr/share/tomcat8/conf/server.xml]
After deploying the following error encounters Please help us to resolve.
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please retain changes related to bug fix only. Use master branch and not 3.0.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I'm getting a timeout when I try to read some keys from an RMapCache.  This also seems to trigger a catastrophic out of memory error in the application
Setup:
	RMapCache<String, ChartSettings> chartSettingsMap
		=client.getMapCache("chart_settings_v493" kryoCodec);
	System.out.println(chartSettingsMap.get("203658_71497") != null);

This should generally print true/false, and it works most of the time.   But about 1 key out of 500 or so, this throws a timeout error.
Actual behavior
In debug mode, I'm getting the following information, with a hard error.  If I do this on production, with this key, the server will fail within about 30 minutes.
[DEBUG] 2019-06-10 11:21:13.988 [pool-2-thread-1] CommandAsyncService - connection released for command (EVAL) and params [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=9, freeSubscribeConnectionsCounter=value:499:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:640:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisURL:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@317440608 [redisClient=[addr=redis://redisURL:6379], channel=[id: 0x5f92a270, L:/redisURL:51719 - R:redisURL/redisURL:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@16f27bad(failure: java.util.concurrent.CancellationException)], command=(EVAL), params=[local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)], codec=org.redisson.codec.KryoCodec]]
[DEBUG] 2019-06-10 11:21:13.988 [pool-2-thread-1] CommandAsyncService - attempt 3 for command (EVAL) and params [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)]
[DEBUG] 2019-06-10 11:21:13.989 [pool-2-thread-1] CommandAsyncService - acquired connection for command (EVAL) and params [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=9, freeSubscribeConnectionsCounter=value:499:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:639:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisURL:6379], nodeType=MASTER, firstFail=0]]] using node redisURL/redisURL:6379... RedisConnection@937932367 [redisClient=[addr=redis://redisURL:6379], channel=[id: 0xeddb5e30, L:/redisURL:51687 - R:redisURL/redisURL:6379], command=null]
[DEBUG] 2019-06-10 11:21:14.331 [redisson-netty-2-28] ClusterConnectionManager - slot 13278 for chart_settings_v493
[DEBUG] 2019-06-10 11:21:14.331 [redisson-netty-2-28] CommandAsyncService - acquired connection for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson_map_cache_expired:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, redisson__execute_task_once_latch:{chart_settings_v493}, 1560190874331, 100, ...] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=9, freeSubscribeConnectionsCounter=value:499:queue:0, freeConnectionsAmount=30, freeConnectionsCounter=value:638:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisURL:6379], nodeType=MASTER, firstFail=0]]] using node redisURL/redisURL:6379... RedisConnection@1194676392 [redisClient=[addr=redis://redisURL:6379], channel=[id: 0xf5e2e193, L:/redisURL:51695 - R:redisURL/redisURL:6379], command=null]
[DEBUG] 2019-06-10 11:21:14.436 [redisson-netty-2-9] CommandAsyncService - connection released for command (EVAL) and params [if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson_map_cache_expired:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, redisson__execute_task_once_latch:{chart_settings_v493}, 1560190874331, 100, ...] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=9, freeSubscribeConnectionsCounter=value:499:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:639:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisURL:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@1194676392 [redisClient=[addr=redis://redisURL:6379], channel=[id: 0xf5e2e193, L:/redisURL:51695 - R:redisURL/redisURL:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@4deb5c36(success: 0)], command=(EVAL), params=[if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then return -1;end;redis.call('expire', KEYS[6], ARGV[..., 6, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson_map_cache_expired:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, redisson__execute_task_once_latch:{chart_settings_v493}, 1560190874331, 100, ...], codec=org.redisson.client.codec.LongCodec]]
[DEBUG] 2019-06-10 11:21:14.436 [redisson-netty-2-9] MapCacheEvictionTask - 0 elements evicted. Object name: chart_settings_v493
[DEBUG] 2019-06-10 11:21:15.921 [redisson-netty-2-30] DnsQueryContext - [id: 0x5d625e3a] WRITE: [9457: /redisURL:53], DefaultDnsQuestion(redisDNSEntry. IN A)
[DEBUG] 2019-06-10 11:21:15.922 [redisson-netty-2-30] DnsQueryContext - [id: 0x5d625e3a] WRITE: [53085: /redisURL:53], DefaultDnsQuestion(redisDNSEntry. IN AAAA)
[DEBUG] 2019-06-10 11:21:15.926 [redisson-netty-2-30] DnsNameResolver - [id: 0x5d625e3a] RECEIVED: [53085: /redisURL:53], DatagramDnsResponse(from: /redisURL:53, to: /0:0:0:0:0:0:0:0:60483, 53085, QUERY(0), NoError(0), RD RA)
DefaultDnsQuestion(redisDNSEntry. IN AAAA)
DefaultDnsRawRecord(use1.cache.amazonaws.com. 274 IN SOA 69B)
DefaultDnsRawRecord(OPT flags:0 udp:4000 0B)
[DEBUG] 2019-06-10 11:21:15.946 [redisson-netty-2-30] DnsNameResolver - [id: 0x5d625e3a] RECEIVED: [9457: /redisURL:53], DatagramDnsResponse(from: /redisURL:53, to: /0:0:0:0:0:0:0:0:60483, 9457, QUERY(0), NoError(0), RD RA)
DefaultDnsQuestion(redisDNSEntry. IN A)
DefaultDnsRawRecord(redisDNSEntry. 15 IN A 4B)
DefaultDnsRawRecord(redisDNSEntry. 15 IN A 4B)
DefaultDnsRawRecord(redisDNSEntry. 15 IN A 4B)
DefaultDnsRawRecord(OPT flags:0 udp:4000 0B)
[DEBUG] 2019-06-10 11:21:16.016 [redisson-netty-2-5] ClusterConnectionManager - cluster nodes state got from redisURL/redisURL:6379:
30502c66324cedca9bfab2be72c50d6adc77abc3 10.99.41.203:6379@1122 slave 29500303a7c5f9d4dbfe6fff2f007df6fd050285 0 1560190875000 1 connected
e4dad2ac204e4bc5e9ca85827ae50d5b340f11c4 redisURL:6379@1122 slave 29500303a7c5f9d4dbfe6fff2f007df6fd050285 0 1560190875505 1 connected
29500303a7c5f9d4dbfe6fff2f007df6fd050285 redisURL:6379@1122 myself,master - 0 1560190873000 1 connected 0-16383
[DEBUG] 2019-06-10 11:21:17.088 [pool-2-thread-1] CommandAsyncService - connection released for command (EVAL) and params [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=9, freeSubscribeConnectionsCounter=value:499:queue:0, freeConnectionsAmount=32, freeConnectionsCounter=value:640:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redisURL:6379], nodeType=MASTER, firstFail=0]]] using connection RedisConnection@937932367 [redisClient=[addr=redis://redisURL:6379], channel=[id: 0xeddb5e30, L:/redisURL:51687 - R:redisURL/redisURL:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@6e811051(failure: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)], channel: [id: 0xeddb5e30, L:/redisURL:51687 - R:redisURL/redisURL:6379])], command=(EVAL), params=[local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)], codec=org.redisson.codec.KryoCodec]]
Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)], channel: [id: 0xeddb5e30, L:/redisURL:51687 - R:redisURL/redisURL:6379]
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, chart_settings_v493, redisson__timeout__set:{chart_settings_v493}, redisson__idle__set:{chart_settings_v493}, redisson__map_cache__last_access__set:{chart_settings_v493}, {chart_settings_v493}:redisson_options, 1560190864239, PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256)], channel: [id: 0xeddb5e30, L:/redisURL:51687 - R:redisURL/redisURL:6379]
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:935)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
Steps to reproduce or test case
Unknown
Redis version - 5.0.4 on AWS as a cluster
Redisson version - 3.10.7
Redisson configuration
public static RedissonClient createRedissonClient(Properties o) {
	Config config = new Config()
			.setAddressResolverGroupFactory(new DnsAddressResolverGroupFactory());
	config.useClusterServers()
		.addNodeAddress(o.getProperty("testRedisURL"))
		.setSubscriptionConnectionMinimumIdleSize(10)
		.setSubscriptionConnectionPoolSize(500)
		.setSlaveConnectionMinimumIdleSize(10)
		.setSlaveConnectionPoolSize(640)
		.setMasterConnectionMinimumIdleSize(32)
		.setMasterConnectionPoolSize(640)
		.setRetryAttempts(3);
	RedissonClient client = Redisson.create(config);
	return client;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
问题
@参考教程
第三方框架整合
单机配置
redisson 整合 Spring Session 报错,一直提示RedisTimeoutException:null
netty线程尝试开大32,64
连接超时开启到30000
都不行
不整合spring session没有问题
依赖版本
springboot 2.1.5RELEASE
spring-session-core  2.1.2.RELEASE
redisson-spring-boot-starter 3.11.0RELEASE
报错信息
` Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2019-06-11 11:48:13.566 ERROR 2284 --- [           main] o.s.boot.SpringApplication               : Application run failed
org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:157) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at com.wokeoo.test.TestApplication.main(TestApplication.java:26) [classes/:na]
Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:125) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.(TomcatWebServer.java:86) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:427) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:180) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:181) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:154) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
... 8 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepositoryFilterRegistration' defined in class path resource [org/springframework/boot/autoconfigure/session/SessionRepositoryFilterConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepositoryFilterRegistration' parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springSessionRepositoryFilter' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'springSessionRepositoryFilter' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.spring.session.RedissonSessionRepository]: Factory method 'sessionRepository' threw exception; nested exception is org.redisson.client.RedisTimeoutException
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:204) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:235) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:226) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:101) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.(ServletContextInitializerBeans.java:88) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:261) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.selfInitialize(ServletWebServerApplicationContext.java:234) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatStarter.onStartup(TomcatStarter.java:54) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5139) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1377) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1367) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_144]
at java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_144]
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_144]
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:902) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:831) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1377) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1367) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_144]
at java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_144]
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_144]
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:902) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardService.startInternal(StandardService.java:423) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:932) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.startup.Tomcat.start(Tomcat.java:455) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:106) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
... 13 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springSessionRepositoryFilter' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'springSessionRepositoryFilter' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.spring.session.RedissonSessionRepository]: Factory method 'sessionRepository' threw exception; nested exception is org.redisson.client.RedisTimeoutException
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1168) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 55 common frames omitted
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.spring.session.RedissonSessionRepository]: Factory method 'sessionRepository' threw exception; nested exception is org.redisson.client.RedisTimeoutException
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:607) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1168) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 69 common frames omitted
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.spring.session.RedissonSessionRepository]: Factory method 'sessionRepository' threw exception; nested exception is org.redisson.client.RedisTimeoutException
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 83 common frames omitted
Caused by: org.redisson.client.RedisTimeoutException: null
at org.redisson.pubsub.PublishSubscribeService$3.run(PublishSubscribeService.java:235) ~[redisson-3.11.0.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_144] `
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am thinking of the possibility of separating out the Reddison client from Tomcat container. Is there any way to do that? or do I always have to use RedissonSessionManager with Tomcat? I am using AWS Elasticache Redis. Thanks.
Redisson version - 3.10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Reads to be disctibuted across primary + replica servers for ReadMode.Master_Slave and ReadMode.Slave
Actual behavior
All the reads are going to primary server
Steps to reproduce or test case
We are using Aws elasticCache redis instance ( 1 primary 1 replica )
I have tried both useReplicated and useMaterSlave configs below
config.useReplicatedServers()
// use "rediss://" for SSL connection
.setScanInterval(50)
.addNodeAddress("redis://serverIp")
.addNodeAddress("redis://serverIp")
.setReadMode(ReadMode.SLAVE);
config.useMasterSlaveServers()
// use "rediss://" for SSL connection
.setMasterAddress("redis://primaryIp")
.addSlaveAddress("redis://replicaIp")
.setReadMode(ReadMode.SLAVE);
Also note I have tried both read modes ReadMode.SLAVE and ReadMode.MASTER_SLAVE
Redis version
tried on two redis version same result
4.10
5.0.0
Redisson version
3.9.0
Redisson configuration
config.useReplicatedServers()
// use "rediss://" for SSL connection
.setScanInterval(50)
.addNodeAddress("redis://serverIp")
.addNodeAddress("redis://serverIp")
.setReadMode(ReadMode.SLAVE);
config.useMasterSlaveServers()
// use "rediss://" for SSL connection
.setMasterAddress("redis://primaryIp")
.addSlaveAddress("redis://replicaIp")
.setReadMode(ReadMode.SLAVE);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why bloom filter bit size limit Integer.MAX_VALUE*2？not Integer.MAX_VALUE or other value ？
@mrniko can you tell me the reason？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In method private void changeMaster(URI address, ClientConnectionsEntry oldMaster, RFuture<RedisClient> future), parameter oldMaster is assigned masterEntry, however on complete of the future of setupMasterEntry, masterEntry is already assigned a new value which means oldMaster changes as well. How can this oldMaster get ahold of the "old master" as the code intends? After hours of reading the code my brain is slow, so I must be wrong. Please help me understand this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actual behavior
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [local s = redis.call('hgetall', KEYS[1]); local result = {}; local maxSize = tonumber(redis.call('hg..., 5, onlineUserCache, redisson__timeout__set:{onlineUserCache}, redisson__idle__set:{onlineUserCache}, redisson__map_cache__last_access__set:{onlineUserCache}, {onlineUserCache}:redisson_options, 1560498015304], channel: [id: 0xa205d196, ...............
at org.redisson.command.CommandAsyncService$13.run(CommandAsyncService.java:960)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
question:
when i get allvalue of a key, occured RedisResponseTimeoutException,why? the numbers of the values is 10000 or more .
Steps to reproduce or test case
###Redis version
3.2.11
Redisson version
2.15.2
Redisson configuration
redisson:sentinel-address
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko ^
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi everybody
I'm trying to configure hibernate (5.4.3 final) with redisson (3.11.0). I use RedissonRegionFactory by default but i want that expiration.time_to_live be 10 seconds.
How should the correct configuration be?
hibernate.cache.redisson.RedissonRegionFactory.expiration.time_to_live = 10000 ???
Thanks in advanced.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We noticed recently there are a lot of org.nustaq.serialization.FSTConfiguration instances around in our jvm service(with redisson 3.6 installed and FstCodec enabled).But according to the comment in the javadoc, construction of org.nustaq.serialization.FSTConfiguration is very expensive, which should be cached and reused.
After some digging in redisson's code, I get some clue, it may be caused by the implementation type of org.redisson.command.CommandAsyncService#CODECS . By design, codec construction should be limited, mostly old ones from the ConcurrentHashMap stored in the ReferenceCacheMap should get returned. But since CODECS is a weak reference cache map, the ConcurrentHashMap is possible to get removed by GC. And since there is only one possible strong reference to the ConcurrentHashMap, which is a local variable in org.redisson.command.CommandAsyncService#getCodec,  the possibility of CODECS getting cleared during a GC event is very large.
the declaration and usage of org.redisson.command.CommandAsyncService#CODECS  is included in the following snippet.

    private static final Map<ClassLoader, Map<Codec, Codec>> CODECS = ReferenceCacheMap.weak(0, 0);

    protected Codec getCodec(Codec codec) {
        if (codec == null) {
            return codec;
        }

        for (Class<?> clazz : BaseCodec.SKIPPED_CODECS) {
            if (clazz.isAssignableFrom(codec.getClass())) {
                return codec;
            }
        }

        Codec codecToUse = codec;
        ClassLoader threadClassLoader = Thread.currentThread().getContextClassLoader();
        if (threadClassLoader != null) {
            Map<Codec, Codec> map = CODECS.get(threadClassLoader); // this is the only possible strong reference to the ConcurrentHashMap stored in CODECS
            if (map == null) {
                synchronized (CODECS) {
                    map = CODECS.get(threadClassLoader);
                    if (map == null) {
                        map = new ConcurrentHashMap<Codec, Codec>();
                        CODECS.put(threadClassLoader, map);
                    }
                }
            }
            codecToUse = map.get(codec);
            if (codecToUse == null) {
                try {
                    codecToUse = codec.getClass().getConstructor(ClassLoader.class, codec.getClass()).newInstance(threadClassLoader, codec);
                } catch (NoSuchMethodException e) {
                    codecToUse = codec;
                    // skip
                } catch (Exception e) {
                    throw new IllegalStateException(e);
                }
                map.put(codec, codecToUse);
            }
        }
        return codecToUse;
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
UpdateValve valve should be installed only once for tomcat pipeline but if there are multiple web application each one will instantiate a new RedissonSessionManager and each startInternal() will install it's own copy of the UpdateValve, more over the UpdateValve  have back reference to RedissonSessionManager, so remove this reference in order to have only one UpdateValve installed for the tomcat pipeline and allow proper RedissonSessionManager garbage collection.
When we have Redisson client set in JNDI which is shared between web applications we need to remove MessageListener from the topic when web application is deinstalled during stopInternal method of RedissonSessionManager
Actual behavior
Each web app will create it's own RedissonSessionManager instance which will result in multiple UpdateValve instances installed into tomcat pipeline
MessageListener is not removed from redisson topic which will cause web application class loader memory leak as MessageListener have reference to codecToUse which in turn have reference to application class loader
Steps to reproduce or test case
Redis version
Redisson version
3.11.1-SNAPSHOT
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Are you sure pipeline is a singleton object?
The getEngine().getPipeline() will get Engine pipeline that is shared between web apps

If we use getEngine().getPipeline() then the valves will be like this:
[org.redisson.tomcat.UpdateValve[Catalina], org.apache.catalina.core.StandardEngineValve[Catalina]]
If we do not check if the valve is added into getEngine().getPipeline() other instances of the valve per web app will be added into the same pipeline (having as many UpdateValve as we have web apps)
if we use getContext().getPipeline() the valves are like this:
[org.apache.catalina.authenticator.BasicAuthenticator[/XXXWEBAPP], org.redisson.tomcat.UpdateValve[/XXXWEBAPP], org.apache.catalina.core.StandardContextValve[/XXXWEBAPP]]
as you could see the getContext().getPipeline() is per web app pipeline but the UpdateValve is added in the middle of the pipeline valves instead as the first valve like in case of getEngine().getPipeline() - so we want redisson valve to be the wrapper valve so it is not like other valves could be added before the redisson session manager valve
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please delete this issue, needs more work before filing. I cant delete myself.
see #2181
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behaviour
None, or fewer Exceptions (just during failover period)
Actual behaviour
After a master re-election (and not otherwise) a constant percentage (about 1%) of the requests fail with this exception until the Redisson client is re-initialised manually with a pod bounce.
org.redisson.client.RedisTimeoutException: Subscribe timeout: (60000ms). Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters. at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:167) ~[redisson-3.10.7.jar!/:na] at org.redisson.RedissonLock.lock(RedissonLock.java:183) ~[redisson-3.10.7.jar!/:na] at org.redisson.RedissonLock.lock(RedissonLock.java:157) ~[redisson-3.10.7.jar!/:na] at com.ajw.quondam.redis.RedisConnector.removeKey(RedisConnector.java:53) ~[classes!/:1.0-SNAPSHOT]
Steps to reproduce or test case
I'm running 3 redis (master, slave, slave) alongside 3 sentinels.
 I'm running a constant load of requests through a redisson client which can run indefinitely without any issue. 
When I introduce a chaos script to trigger a failure of the master and thus a master re-election I start to see the errors, yet only for a very small percentage of the requests (but that percentage remains constant indefinitely until a manual restart of the redisson client happens)
Each request acquires and releases an RLock with a chance of collision with another request being 1 in 100.
If I lower the collision probability to be 1 in 10000 this problem almost completely disappears to the point where I lose only perhaps a single request, during the failover period (which is the expected behaviour for the higher collision case also)
Redis version
redis_version:4.0.11
Redisson version
3.10.7
Redisson configuration
.setSubscriptionsPerConnection(20) 
.setSubscriptionConnectionPoolSize(200) 
.setRetryAttempts(15) 
.setRetryInterval(3000) 
.setSubscriptionConnectionMinimumIdleSize(50) 
.setSlaveConnectionPoolSize(200)
 .setMasterConnectionPoolSize(200)
 .setTimeout(15000)
.setNettyThreads(128)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
期待tryLock返回成功
Actual behavior
实际每次加锁都会返回false
Steps to reproduce or test case
每次加锁都会失败
Redis version
Redisson version
3.8到3.11都尝试了
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
reconnectionTimeout: 3000
failedAttempts: 3
password: null
subscriptionsPerConnection: 5
clientName: null
address: "redis://127.0.0.1:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 32
connectionPoolSize: 64
database: 0
dnsMonitoring: false
dnsMonitoringInterval: 5000
threads: 10
nettyThreads: 10
codec: !<org.redisson.codec.JsonJacksonCodec> {}
transportMode :NIO
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
addListEx 这个操作不是原子的 所以高并发下会出现问题，并没有实现ex的原子性操作
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently there is no way to tell when a jar file has been build - This feature request is to add Build-Time manifest entry so that we could tell when it was build/rebuild as often if release version is not changed (e.g. providing patches via rebuild of the master code) once the modified version of the jar file is created we can't tell if it contains the fixes or not by simply having a file inside the jar to tell us when it has been build. Also some of the jars that are created do not have the default implementation entries and/or specification entries
Expected behavior
Each jar to have default implementation/specification entries and have a build time - optionally if we have git branch / commit into MANIFEST.MF would be beneficial as well
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
3.11.1-SNAPSHOT
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
If we want to serialize object with codec other than SerializationCodec as the values are not Serializable for example and if the web app xml have the distributable tag when we try to set attribute into the session that is not Serializable an exception will be thrown that the object is not serializable
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
3.11.1-SNAPSHOT
Redisson configuration
Redisson codec other than SerializationCodec and web application that have web.xml tag distributable
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonSession setAttribute do not check if the value is null before removing the attribute name from removedAttributes collection
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
3.11.1-SNAPSHOT
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context
We are in the process of migrating to Microsoft Azure and are planning to make use of the Azure Redis Cache. Because of this, I am in the process of investigating Redisson and have been for the most part impressed by the performance and feature set.
However, I have been running into this intermittent issue for a few days now. Every now and again, when the application starts up, Redisson will throw an error, telling me that it's only able to initialise 31 of 32 connections. My experiments with Lettuce didn't seem to run into anything similar to this.
Anyone have any thoughts or suggestions on things to look into to resolve this? Is there something particular about Azure Redis Cache that might need to be configured? Does Redisson need all 32 connections or would reducing the required number potentially resolve this?
Expected behavior
Successfully connects to Redis every time.
Actual behavior
Infrequently throws the following error on application start-up:
<21-Jun-2019 09:14:07,916 o'clock BST> <Error> <HTTP> <BEA-101216> <Servlet: "InitSWCTest" failed to preload on startup in Web application: "test/app".
java.lang.ExceptionInInitializerError
	at com.demo.test.ejb.permissions.engine.cache.PermissionCacheManager.createManager(PermissionCacheManager.java:27)
	at com.demo.test.ejb.permissions.engine.cache.PermissionCacheManager.<clinit>(PermissionCacheManager.java:9)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:348)
	at com.demo.test.common.ClassUtil.initialise(ClassUtil.java:30)
	Truncated. see log file for complete stacktrace
Caused By: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 31 from 32 were initialized. Redis server: test.redis.cache.windows.net/XX.XXX.XX.XXX:YYYY
	at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:160)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:476)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415)
	Truncated. see log file for complete stacktrace
Caused By: io.netty.channel.ConnectTimeoutException: connection timed out: test.redis.cache.windows.net/XX.XXX.XX.XXX:YYYY
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)

Redis version
3.2.7
Redisson version
5.10.7
Redisson configuration
Config config = new Config();
config.useSingleServer()
    .setAddress(redisConnectionString)
    .setPassword(redisPassword);

RedissonClient redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I reverted all whitespace changes (first I need to disable "remove trailing whitespaces" in IntelliJ 😂) and updated the PR.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在阿里云Redis环境下
采用SingleServerConfig配置
使用RLock锁时,会出一定机率的解锁问题:
多线程模式下, 对同一个key进行加锁, A线程加锁成功, B线程等待, A线程解锁, B线程继续等待直到30秒默认时间才能加锁成功.
public class RLockTest extends BaseTest {
    @Autowired
    private RedissonClient redissonClient;

    private List<String> lockKeys = new ArrayList<>();
    private Logger log= LoggerFactory.getLogger(getClass());

    @Before
    public void init() {
        for (int i = 0; i < 10; i++) {
            lockKeys.add("lock_key_" + i);
        }
    }

    @Test
    public void test() {
        List<Thread> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            list.add(new Thread(() -> {
                for (int j = 0; j < 10; j++) {
                    LogRequestIdPlugin.setRequestId(LogRequestIdPlugin.newRequestId());
                    doLock(finalI);
                    LogRequestIdPlugin.setRequestId(null);
                }
            }));
        }
        for (Thread t : list) {
            t.start();
        }
        for (Thread t : list) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void doLock(int i) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        RLock lock = redissonClient.getLock(lockKeys.get(((int) (Math.random() * 10000) % lockKeys.size())));
        try {
            log.info("thread:" + i + " start locking");
            long s = System.currentTimeMillis();
            lock.lock();
            if (System.currentTimeMillis() - s > 10000) {
                log.error("加锁异常!!!");
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("thread:" + i + " locked");
        } finally {
            lock.unlock();
        }
    }
}


15:15:27.923 [B5oYGRb11f8524b] [Thread-29] INFO  cn.com.sjfx.account.RLockTest - thread:3 start locking
15:15:27.926 [B5oYGRb11f8524b] [Thread-29] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (EVAL) and params [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, lock_key_5, 30000, 30e213ca-fbb8-49b7-a6a2-45fe94e15ec7:292] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=4, freeConnectionsCounter=value:58:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.1.26:6379], nodeType=MASTER, firstFail=0]]] using node 192.168.1.26/192.168.1.26:6379... RedisConnection@154358690 [redisClient=[addr=redis://192.168.1.26:6379], channel=[id: 0xcaa97c72, L:/192.168.1.26:37308 - R:192.168.1.26/192.168.1.26:6379], command=null]
15:15:28.014 [B5oYGRb11f8524b] [Thread-29] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (EVAL) and params [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, lock_key_5, 30000, 30e213ca-fbb8-49b7-a6a2-45fe94e15ec7:292] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=8, freeConnectionsCounter=value:62:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.1.26:6379], nodeType=MASTER, firstFail=0]]] using node 192.168.1.26/192.168.1.26:6379... RedisConnection@792711111 [redisClient=[addr=redis://192.168.1.26:6379], channel=[id: 0x00f6d3b9, L:/192.168.1.26:37324 - R:192.168.1.26/192.168.1.26:6379], command=null]
15:15:57.966 [B5oYGRb11f8524b] [Thread-29] DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (EVAL) and params [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, lock_key_5, 30000, 30e213ca-fbb8-49b7-a6a2-45fe94e15ec7:292] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=9, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.1.26:6379], nodeType=MASTER, firstFail=0]]] using node 192.168.1.26/192.168.1.26:6379... RedisConnection@792711111 [redisClient=[addr=redis://192.168.1.26:6379], channel=[id: 0x00f6d3b9, L:/192.168.1.26:37324 - R:192.168.1.26/192.168.1.26:6379], command=null]
15:15:58.008 [B5oYGRb11f8524b] [Thread-29] ERROR cn.com.sjfx.account.RLockTest - 加锁异常!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Jdk1.7 is still used a lot, what is the corresponding version?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fixed in #2476
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Should be able to run the tests using mvn or intellij on OSX
Actual behavior
After uncommenting line 245 in RedisRunner, I see these output lines repeating forever instead of a test being run:
[INFO] Running org.redisson.RedissonCountDownLatchConcurrentTest
REDIS RUNNER: Starting up default instance...
REDIS RUNNER: Making directory /var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b
REDIS LAUNCH OPTIONS: [/usr/local/bin/redis-server, --dir, "/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b", --port, 48062]
REDIS PROCESS: [87419] 24 Jun 17:20:14.179 # Can't chdir to '"/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b"': No such file or directory
REDIS LAUNCH OPTIONS: [/usr/local/bin/redis-server, --dir, "/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b", --port, 48079]
REDIS PROCESS: [87421] 24 Jun 17:20:15.688 # Can't chdir to '"/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b"': No such file or directory
REDIS LAUNCH OPTIONS: [/usr/local/bin/redis-server, --dir, "/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b", --port, 48108]
REDIS PROCESS: [87424] 24 Jun 17:20:17.194 # Can't chdir to '"/var/folders/m9/tq46v60j4yg6trcl57d6rvh40000gn/T/b85dae5b-d273-441f-80cd-e91cf791806b"': No such file or directory

Steps to reproduce or test case
git clone https://github.com/redisson/redisson
git checkout redisson-3.11.0
cd redisson
mvn -DargLine="-Xmx2g -DredisBinary=which redis-server" -Punit-test clean test -e -X
Redis version
Redis 2.8.17 (00000000/0) 64 bit
Redisson version
3.11.0
Redisson configuration
n/a
I've tested the redis-server commands as expected to be run via Redis Runner manually on the same environment and see no issues starting the redis process, it seems like there is some issue when the tests are running the same commands though, via ProcessBuilder.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am experiencing a lot of command execution timeout exceptions mainly for PING as well as other operations intermittently.
I have been back and forth with AWS customer support and I can conclusively say that there exist no CPU, memory and N/W constraints that were faced during any of the timeouts seen.
Further, we have captured and analyzed the TCP dump on the client side to reveal nothing on the network side.
Server Setup:
Redis version: AWS elasticache redis 3.2.4.
Redis node count: 1 Primary and 2 Replicas
Redis instance type: cache.r4.large
Client Setup:
Services connecting to the redis servers are running in docker containers on ec2 instances.
Redisson version: 3.10.6
Redisson configuration:
connectTimeout = 5000
command exection timeout  = 3000
master min connection pool size = 50
slave min connection pool size = 50
Exception seen on the client:
"org.redisson.client.RedisTimeoutException: Command execution timeout for command: PING, Redis client: [addr=redis://<aws-redis-endpoint>:6379]
\tat org.redisson.connection.RedisClientEntry.lambda$pingAsync$1(RedisClientEntry.java:85) ~[redisson-3.10.6.jar!/:?]
\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668) ~[netty-common-4.1.24.Final.jar!/:4.1.24.Final]
\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743) ~[netty-common-4.1.24.Final.jar!/:4.1.24.Final]
\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471) ~[netty-common-4.1.24.Final.jar!/:4.1.24.Final]
\tat java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]

Any help in this regard is much appreciated.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
getKeys should return even with an empty redis
getKeys block and never return

    int sizeIter = 1000
    Config config = new Config();
    ClusterServersConfig tmp = config.useClusterServers().setScanInterval(2000);
    redisNodes.forEach(node -> tmp.addNodeAddress("redis://" + node.toString()));
    RedissonClient redisClient = Redisson.create(config);
    RKeys redisKeys = redisClient.getKeys();
    for (String key : redisKeys.getKeys(sizeIter)) {
      System.out.println(key);
    }


5.0.5
3.11.0
Cluster mode
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (10000 ms) occured after 3 retry attempts. Command: (EXISTS), params: [claim_task_concurrent_lock_7b34232d-9721-11e9-a8da-680715517318], channel: [id: 0x59bfd9e4, L:/192.168.10.241:53028 - R:10.65.255.121/10.65.255.121:6379]
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:934)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
config:
redission:3.11.0
{"addressResolverGroupFactory":{},"clusterConfig":false,"codec":{"mapKeyDecoder":{},"mapKeyEncoder":{},"mapValueDecoder":{"$ref":"$.codec.mapKeyDecoder"},"mapValueEncoder":{"$ref":"$.codec.mapKeyEncoder"},"valueDecoder":{"$ref":"$.codec.mapKeyDecoder"},"valueEncoder":{"$ref":"$.codec.mapKeyEncoder"}},"decodeInExecutor":false,"keepPubSubOrder":true,"lockWatchdogTimeout":30000,"maxCleanUpDelay":1800,"minCleanUpDelay":5,"nettyThreads":32,"referenceEnabled":true,"sentinelConfig":false,"threads":16,"transportMode":"NIO","useScriptCache":false}
不懂为啥过段时间就会出现问题 不稳定 求指导
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Apologies if this is something simple that I've missed out
Have been trying to figure this out for a while but can't.
Trying to simply get the value associated with field in the hash stored at key as described in the documentation for HGET
The code used is
RedissonClient redisson = Redisson.create();
RMap<String, String> map =  redisson.getMap("myhash");
System.out.println(map.get("a"));

However, it seems like this implementation fetches all values stored in all fields in 'myHash' instead of just the value stored in field 'a'. Unsure if this fetching of values happens during redisson.getMap ( More likely ) or map.get()
Expected behavior
Redisson issues only one HGET and retrieves only the value of field 'a' in hash 'myhash'
Actual behavior
Redisson seems to be fetching values of all fields in 'myhash'
Steps to reproduce or test case
redis-cli
HSET myhash a valueofa
HSET myhash b valueofb
HSET myhash c valueofc

java
RedissonClient redisson = Redisson.create();
RMap<String, String> map =  redisson.getMap("myhash");
System.out.println(map.get("a"));

Redis version
4.0.9
Redisson version
3.10.7
Redisson configuration
Default ( Testing on localhost )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm using Redis with 1 master and 2 slaves, watched over by 3 sentinels on 3 ports 8359, 8360 and 8361 from a single node. When executing through redisson the program works perfectly fine except that every now and then it spews out this error:
[redisson-netty-4-5] ERROR org.redisson.connection.SentinelConnectionManager - Can't execute SENTINEL commands on 10.60.xxx.xxx/10.60.xxxx.xxxx:8361
org.redisson.client.RedisTimeoutException: Command execution timeout for  10.60.xxx.xxx/10.60.xxxx.xxxx:8361
	at org.redisson.client.RedisConnection$2.run(RedisConnection.java:212)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:125)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)

This doesn't really affect anything so far, the sentinels still send data properly to the clients but I have ever wondered what might be the cause of this? It only happens to the last port 8361, the two other ports are unaffected albeit on the same node.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson/redisson/src/main/java/org/redisson/RedissonLock.java
    
    
         Line 553
      in
      da7874d
    
  
  
    

        
          
           "redis.call('pexpire', KEYS[1], ARGV[2]); " +
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson/redisson/src/main/java/org/redisson/RedissonLock.java
    
    
         Line 553
      in
      da7874d
    
  
  
    

        
          
           "redis.call('pexpire', KEYS[1], ARGV[2]); " +
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2019-07-01 10:11:19.710  INFO 26104 --- [  restartedMain] org.redisson.Version                     : Redisson 3.10.6
2019-07-01 10:11:29.508  INFO 26104 --- [isson-netty-1-4] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for 192.168.0.250/192.168.0.250:6379
2019-07-01 10:11:32.473 ERROR 26104 --- [  restartedMain] o.s.b.web.embedded.tomcat.TomcatStarter  : Error starting Tomcat context. Exception: org.springframework.beans.factory.UnsatisfiedDependencyException. Message: Error creating bean with name 'sessionRepositoryFilterRegistration' defined in class path resource [org/springframework/boot/autoconfigure/session/SessionRepositoryFilterConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepositoryFilterRegistration' parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springSessionRepositoryFilter' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'springSessionRepositoryFilter' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepository' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redissonClient' defined in class path resource [com/sflows/configuration/redis/RedisClient.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
2019-07-01 10:11:32.507  INFO 26104 --- [  restartedMain] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]
2019-07-01 10:11:32.519  WARN 26104 --- [  restartedMain] o.a.c.loader.WebappClassLoaderBase       : The web application [ROOT] appears to have started a thread named [Thread-14] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
sun.net.dns.ResolverConfigurationImpl.notifyAddrChange0(Native Method)
sun.net.dns.ResolverConfigurationImpl$AddressChangeListener.run(ResolverConfigurationImpl.java:144)
2019-07-01 10:11:32.521  WARN 26104 --- [  restartedMain] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
2019-07-01 10:11:32.534  INFO 26104 --- [  restartedMain] ConditionEvaluationReportLoggingListener :
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2019-07-01 10:11:32.546 ERROR 26104 --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed
org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:157) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at com.sflows.SalesflowApplication.main(SalesflowApplication.java:9) [classes/:na]
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_181]
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_181]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_181]
at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_181]
at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) [spring-boot-devtools-2.1.5.RELEASE.jar:2.1.5.RELEASE]
Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:125) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.(TomcatWebServer.java:86) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:427) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:180) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:181) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:154) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
... 13 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepositoryFilterRegistration' defined in class path resource [org/springframework/boot/autoconfigure/session/SessionRepositoryFilterConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepositoryFilterRegistration' parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springSessionRepositoryFilter' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'springSessionRepositoryFilter' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepository' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redissonClient' defined in class path resource [com/sflows/configuration/redis/RedisClient.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:204) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:235) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:226) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:101) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.ServletContextInitializerBeans.(ServletContextInitializerBeans.java:88) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:261) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.selfInitialize(ServletWebServerApplicationContext.java:234) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.springframework.boot.web.embedded.tomcat.TomcatStarter.onStartup(TomcatStarter.java:54) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5139) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1377) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1367) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_181]
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_181]
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:902) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:831) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1377) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1367) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_181]
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_181]
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:902) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardService.startInternal(StandardService.java:423) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:932) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.apache.catalina.startup.Tomcat.start(Tomcat.java:455) ~[tomcat-embed-core-9.0.19.jar:9.0.19]
at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:106) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE]
... 18 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'springSessionRepositoryFilter' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'springSessionRepositoryFilter' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepository' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redissonClient' defined in class path resource [com/sflows/configuration/redis/RedisClient.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1168) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 58 common frames omitted
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'sessionRepository' defined in class path resource [org/redisson/spring/session/config/RedissonHttpSessionConfiguration.class]: Unsatisfied dependency expressed through method 'sessionRepository' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redissonClient' defined in class path resource [com/sflows/configuration/redis/RedisClient.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:509) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1168) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 72 common frames omitted
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redissonClient' defined in class path resource [com/sflows/configuration/redis/RedisClient.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1168) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 86 common frames omitted
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE]
... 100 common frames omitted
Caused by: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 from 10 were initialized. Redis server: 192.168.0.250/192.168.0.250:6379
at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:160) ~[redisson-3.10.6.jar:na]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.10.6.jar:na]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:476) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.10.6.jar:na]
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:330) ~[redisson-3.10.6.jar:na]
at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:296) ~[redisson-3.10.6.jar:na]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.10.6.jar:na]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:495) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:474) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.10.6.jar:na]
at org.redisson.client.RedisClient$2$2.run(RedisClient.java:245) ~[redisson-3.10.6.jar:na]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:405) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_181]
Caused by: io.netty.channel.ConnectTimeoutException: connection timed out: 192.168.0.250/192.168.0.250:6379
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:267) ~[netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
... 7 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1208139997 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0x0eaaac69, L:/192.168.0.8:53949 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3f5f6794(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3f5f6794(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd], command: (HGETALL), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
2019-07-01 15:59:46.919  WARN 24032 --- [nio-8099-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1208139997 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0x0eaaac69, L:/192.168.0.8:53949 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3f5f6794(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3f5f6794(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd], command: (HGETALL), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8] after 3 retry attempts]
2019-07-01 15:59:46.975 ERROR 24032 --- [nio-8099-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1734246104 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0xc32936dc, L:/192.168.0.8:53945 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3217bd72(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3217bd72(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts] with root cause
org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1734246104 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0xc32936dc, L:/192.168.0.8:53945 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3217bd72(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3217bd72(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@750413cd], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715) ~[redisson-3.10.6.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]
/error
2019-07-01 15:59:47.044 ERROR 24032 --- [nio-8099-exec-8] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=7, freeConnectionsCounter=value:61:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1015602425 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0xc72413df, L:/192.168.0.8:53943 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@34c86c4d(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@34c86c4d(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts] with root cause
org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=7, freeConnectionsCounter=value:61:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1015602425 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0xc72413df, L:/192.168.0.8:53943 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@34c86c4d(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@34c86c4d(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715) ~[redisson-3.10.6.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]
/error
2019-07-01 15:59:49.488 ERROR 24032 --- [nio-8099-exec-6] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1540626475 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0x8cc95170, L:/192.168.0.8:53948 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3b3e743e(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3b3e743e(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts] with root cause
org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:19:queue:0, freeConnectionsAmount=6, freeConnectionsCounter=value:60:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.0.250:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1540626475 [redisClient=[addr=redis://192.168.0.250:6379], channel=[id: 0x8cc95170, L:/192.168.0.8:53948 - R:192.168.0.250/192.168.0.250:6379], command=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3b3e743e(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7]], current command in queue: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3b3e743e(failure: java.util.concurrent.CancellationException)], command=(HGETALL), params=[spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8], codec=org.redisson.codec.CompositeCodec@b330f7e7], command: (PEXPIRE), params: [spring:session:5a1e8cc5-a7eb-47ba-9b29-e73e8d4f36c8, 1800000] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715) ~[redisson-3.10.6.jar:na]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]
/error
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2019-07-02 10:39:33.670 ERROR 16368 --- [isson-netty-1-2] o.redisson.client.handler.CommandsQueue  : Exception occured. Channel: [id: 0x83f2c596, L:/192.168.0.8:59407 - R:192.168.0.250/192.168.0.250:6379]
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
at sun.nio.ch.SocketDispatcher.read0(Native Method) ~[na:1.8.0_181]
at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43) ~[na:1.8.0_181]
at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) ~[na:1.8.0_181]
at sun.nio.ch.IOUtil.read(IOUtil.java:192) ~[na:1.8.0_181]
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) ~[na:1.8.0_181]
at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288) ~[netty-buffer-4.1.36.Final.jar:4.1.36.Final]
at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1125) ~[netty-buffer-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:347) ~[netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148) ~[netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:682) [netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:617) [netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:534) [netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) [netty-transport-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) [netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.36.Final.jar:4.1.36.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.36.Final.jar:4.1.36.Final]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Tomcat 9.0.20 the setting in logging.properties is respected, but in 9.0.21, it is ignored.
Expected behavior
Don't log INFO. Only Warning, Error, Severe.
Actual behavior
INFO is logged.
02-Jul-2019 11:42:10.381 INFORMAÇÕES [http-nio-8080-exec-19] org.redisson.tomcat.RedissonSessionManager.findSession Session 1814A7D885CC689F6E5734E967E18B3D can't be found

Steps to reproduce or test case
Deploy .war to tomcat with redisson installed and org.redisson.tomcat.RedissonSessionManager.findSession.level = WARNING added to logging.properties
Redis version
Tested in 5.0.5 and 5.0.3
Redisson version
Tested in 3.10.7 and 3.11.1
Redisson configuration
{
   "singleServerConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "address": "redis://redis:6379",
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "connectionMinimumIdleSize":32,
      "connectionPoolSize":64,
      "database":0,
      "dnsMonitoringInterval":5000
   },
   "threads":0,
   "nettyThreads":0,
   "codec":{
      "class":"org.redisson.codec.FstCodec"
   },
   "transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The order of tasks is not preserved, which is pretty critical if the same key was both added/updated and deleted. Looks like tasks are accumulated in two separate batches, each one is flushed once full. If there are no more incoming tasks, then "deletes" are always executed first.
Check sample code in "steps to reproduce".
Expected behavior
In the sample code below I'd expect it to print:
1) writing [key1]:=B
2) deleting key [key1]

E.g. "write" and then "delete"
Actual behavior
1) deleting key [key1]
2) writing [key1]:=B

Btw, setting batch size to "1" fixes the issue, which makes sense - all tasks are carried out with delay but exactly when received, so the order is preserved.
But without batching "write-behind" feature isn't really that useful.
Steps to reproduce or test case

Configure write-behind with batch size =2
put  X = A
put  X = B
remove X

RedissonClient rclient = Redisson.create();
MapOptions<String, String> mapOptions = MapOptions.<String, String>defaults()
	.writeMode(WriteMode.WRITE_BEHIND)
	.writeBehindDelay(1000)
	.writeBehindBatchSize(2)
	.writer(new MapWriter<String,String>() {
		private final AtomicInteger opsCounter = new AtomicInteger(0);
		@Override
		public void write(Map<String, String> map) {
			for (Map.Entry<String, String> e : map.entrySet()) {
				System.out.println("" + opsCounter.incrementAndGet() 
				+ ") writing [" + e.getKey() + "]:=" + e.getValue());
			}
		}
		@Override
		public void delete(Collection<String> keys) {
			for (String key : keys) {
				System.out.println("" + opsCounter.incrementAndGet() 
				+ ") deleting key [" + key + "]");
			}
		}
	});
RMap<String, String> map = rclient.getMap("testBugMap", mapOptions);
map.fastPut("key1", "A");
map.fastPut("key1", "B");
map.fastRemove("key1");

Redis version
5.0.3
Redisson version
3.11.1
Redisson configuration
(see code above)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
3.11. 0 版本:
16:42:01.132 [main] DEBUG org.redisson.connection.DNSMonitor - DNS monitoring enabled; Current masters: {redis://:sa@192.168.1.175:6381/9=192.168.1.175/192.168.1.175:6381}, slaves: {}

Actual behavior
3.11.1 版本:
16:43:44.537 [redisson-netty-2-2] DEBUG io.netty.buffer.PoolThreadCache - Freed 3 thread-local buffer(s) from thread: redisson-netty-2-2
Exception in thread "main" java.net.UnknownHostException: failed to resolve '192.168.1.175]' after 6 queries 
	at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:901)
	at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:860)
	at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:328)
	at io.netty.resolver.dns.DnsResolveContext.onResponse(DnsResolveContext.java:515)
	at io.netty.resolver.dns.DnsResolveContext.access$400(DnsResolveContext.java:63)
	at io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:372)


Steps to reproduce or test case
Redis version
Redisson version
3.11.1
Redisson configuration
    val url = "redis://:sa@192.168.1.175:6381/9"
    val config = Config()
    config.useSingleServer().setAddress(url)
    val redisson = Redisson.create(config)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Caused by: org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:400) ~[redisson-3.10.6.jar!/:?]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:204) ~[redisson-3.10.6.jar!/:?]
at org.redisson.command.CommandBatchService.execute(CommandBatchService.java:360) ~[redisson-3.10.6.jar!/:?]
at org.redisson.spring.data.connection.RedissonConnection.exec(RedissonConnection.java:1597) ~[redisson-spring-data-21-3.10.6.jar!/:?]
... 143 more
Caused by: java.util.NoSuchElementException
at java.util.ArrayList$Itr.next(ArrayList.java:854) ~[?:1.8.0_65]
at org.redisson.command.CommandBatchService$1.lambda$run$2(CommandBatchService.java:471) ~[redisson-3.10.6.jar!/:?]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.10.6.jar!/:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:476) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:529) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:101) ~[netty-all-4.1.34.Final.jar!/:4.1.34.Final]
Steps to reproduce or test case
Test code(Under the multithread test):
List txResults = redisTemplate.execute(new SessionCallback<List>() {
@OverRide
public List execute(RedisOperations operations) throws DataAccessException {
try {
operations.watch(key);
SeqInfo seqInfo = SeqInfo.fromString(String.valueOf(operations.opsForValue().get(key)));
if (oldSeq.equals(seqInfo)) {
operations.multi();
operations.opsForValue().get(key);
operations.opsForValue().set(key, newSeq.toString());
return operations.exec();
} else {
return null;
}
} catch (Exception e) {
log.error(e.getMessage(), e);
return null;
} finally {
operations.unwatch();
}
}
});
redis version:3.2.0
redisson version:3.10.6

singleServerConfig
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if a semaphore release failed (shutdown or net not available)，it's there any way to let the server recover the permits? just like expired in Lock
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
  获取锁，等待自己释放，或者已释放都会出现‘远程主机关闭一个连接’

Redis version
redis-starter   2.1.5.RELEASE
Redisson version
   redisson  3.11.1   

Redisson configuration
eg：1
#Redisson配置
singleServerConfig:
address: "redis://127.0.0.1:6379"
password: null
clientName: null
database: 7 #选择使用哪个数据库0~15
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
reconnectionTimeout: 3000
failedAttempts: 3
subscriptionsPerConnection: 5
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 32
connectionPoolSize: 64
dnsMonitoringInterval: 5000
#dnsMonitoring: false
threads: 0
nettyThreads: 0
codec:
class: "org.redisson.codec.KryoCodec"
transportMode: "NIO"
创建方式
@bean
public RedissonClient redisson() throws IOException {
// 本例子使用的是yaml格式的配置文件，读取使用Config.fromYAML，如果是Json文件，则使用Config.fromJSON
Config config = Config.fromYAML(RedissonManager.class.getClassLoader().getResource("redisson/redisson-dev.yml"));
return Redisson.create(config);
}
eg :2
@bean
//    public RedissonClient getRedisson(){
//        List cluster = redissonProperties.getNodes();
//        String[] nodes = new String[cluster.size()];
//        //redisson版本是3.5，集群的ip前面要加上“redis://”，不然会报错，3.2版本可不加
//    	for(int i=0;i<cluster.size();i++){
//            nodes[i] = "redis://"+cluster.get(i);
//    	}
//        Config config = new Config();
//    	//TODO 集群模式下需要改成如下模式
////        config.useClusterServers() //这是用的集群server
////        .setScanInterval(2000) //设置集群状态扫描时间
////        .addNodeAddress(nodes);
//        //.setPassword(password);
//        config.useSingleServer().setAddress(nodes[0]);
//        RedissonClient redisson = Redisson.create(config);
//
//        //可通过打印redisson.getConfig().toJSON().toString()来检测是否配置成功
//        return redisson;
//    }
直接使用这个方式创建，，同样都报了同样的错误
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am new in Redisson, so probably it is a dumb question.
Please give it a look.
My code:
`   Config config = new Config();
config.useSingleServer().setAddress("redis://" + redis.getContainerIpAddress() + ":" + redis.getMappedPort(6379));
RedissonClient redisson = Redisson.create(config);
//Random data
RBucket<Object> bucket = redisson.getBucket("obj.0.a");
bucket.set("a");
bucket = redisson.getBucket("obj.0.b");
bucket.set("b");
bucket = redisson.getBucket("obj.0.c");
bucket.set("c");
bucket = redisson.getBucket("obj.0.d");
bucket.set("d");

//Batch delete by patern
RBatch createBatch = redisson.createBatch();
RFuture<Long> deleteByPatternAsync = createBatch.getKeys().deleteByPatternAsync("obj.0.*");
createBatch.execute();
Thread.sleep(10 * 1000);

//Test batch delete
Iterator<String> iterator = redisson.getKeys().getKeysByPattern("obj.0.*").iterator();
if (iterator.hasNext()) {
  System.out.println("deleteByPatternAsync did not work");
} else {
  System.out.println("deleteByPatternAsync worked");
}

//Syn Delete
redisson.getKeys().deleteByPattern("obj.0.*");
iterator = redisson.getKeys().getKeysByPattern("obj.0.*").iterator();

//Test syn detelete
if (iterator.hasNext()) {
  System.out.println("deleteByPattern did not work");
} else {
  System.out.println("deleteByPattern worked");
}`

Expected behavior
Output:
deleteByPatternAsync worked
deleteByPattern worked
Actual behavior
Output:
deleteByPatternAsync did not work
deleteByPattern worked
Steps to reproduce or test case
I used testcontainers with the docker image 'redis:3.0.6'
Redis version
3.0.6
Redisson version
3.11.1
Redisson configuration
SingleServer
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
class：org.redisson.spring.data.connection.RedissonConnection.java
code line：882
code segment：
 T write(byte[] key, Codec codec, RedisCommand<?> command, Object... params) {
RFuture f = executorService.writeAsync(key, codec, command, params);
indexCommand(command);
return sync(f);
}
bug：return null when not used in pipeline / transaction.
Expected behavior
not return null when not used in pipeline / transaction.
Actual behavior
return null when not used in pipeline / transaction.
Steps to reproduce or test case
public Boolean setNx(String key, String value, long expireMillis) {
return stringRedisTemplate.execute(new RedisCallback() {
@OverRide
public Boolean doInRedis(RedisConnection connection) throws DataAccessException {
return connection.set(key.getBytes(), value.getBytes(), Expiration.milliseconds(expireMillis),
SetOption.SET_IF_ABSENT);
}
}, true);
}
Redis version
Redis-x64-3.0.500
Redisson version
3.11.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
update rateConfig
Actual behavior
not update
Steps to reproduce or test case
  @Test
  public void trySetRate() {
    RRateLimiter limiter = RedissonManager.getRedissonClient().getRateLimiter("test:RateLimit");
    limiter.trySetRate(RateType.OVERALL, 1, 1, RateIntervalUnit.SECONDS);
    RateLimiterConfig config = limiter.getConfig();
    logger.info("rate:{}RateInterval{}RateType:{}", config.getRate(), config.getRateInterval(),
        config.getRateType());

    limiter.trySetRate(RateType.OVERALL, 2, 2, RateIntervalUnit.HOURS);
    RateLimiterConfig config1 = limiter.getConfig();
    logger.info("rate:{}RateInterval{}RateType:{}", config1.getRate(), config1.getRateInterval(),
        config1.getRateType());
  }
11:34:27.390 TRSID[main] INFO  - rate:1RateInterval1000RateType:OVERALL
11:34:27.396 TRSID[main] INFO  - rate:1RateInterval1000RateType:OVERALL

Redis version 4.0.2
Redisson version 3.11.0
I hope there is a way to force  update RateConfig. for example add a method ? forceSetRate
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I should not see any warnings in my logs.
Actual behavior
after I had updated Redisson from 3.3.1 to 3.11.3, it started constantly repeating logs, never ending:
[2019-09-05 14:13:20,402] INFO  [redisson-netty-8-12] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:20,982] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:25,410] INFO  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:25,998] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:30,422] INFO  [redisson-netty-8-7] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:32,022] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:35,429] INFO  [redisson-netty-8-31] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:41,063] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:45,443] INFO  [redisson-netty-8-25] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:46,082] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:50,451] INFO  [redisson-netty-8-22] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:53,109] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:13:55,459] INFO  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:13:58,130] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:00,463] INFO  [redisson-netty-8-5] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:01,143] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:05,470] INFO  [redisson-netty-8-31] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:07,172] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:10,476] INFO  [redisson-netty-8-19] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:11,188] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:15,486] INFO  [redisson-netty-8-16] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:18,216] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:20,495] INFO  [redisson-netty-8-26] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:21,233] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:25,503] INFO  [redisson-netty-8-23] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:26,250] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:30,511] INFO  [redisson-netty-8-21] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:32,280] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:35,514] INFO  [redisson-netty-8-4] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:36,306] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:40,524] INFO  [redisson-netty-8-20] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:41,329] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:45,528] INFO  [redisson-netty-8-17] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:47,354] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:50,532] INFO  [redisson-netty-8-32] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:53,376] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down
[2019-09-05 14:14:55,537] INFO  [redisson-netty-8-14] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 added
[2019-09-05 14:14:57,397] WARN  [redisson-netty-8-8] o.redisson.connection.SentinelConnectionManager - sentinel: redis://10.76.155.139:26379 has down

Steps to reproduce or test case
we have 9 sentinels. One of these sentinels, the special one, redis://10.76.155.139:26379  is deployed on the same machine as the application itself. I think this is the key to understand the problem. We use docker for redis, sentinels and application.
Redis version
5.0.3
Redisson version
3.11.3
Redisson configuration
JsonJacksonCodec codec = new JsonJacksonCodec();
codec.getObjectMapper()
        .registerModule(new JavaTimeModule())
        .registerModule(new Jdk8Module());
config.setCodec(codec);

if (StringUtil.isNotNullOrEmpty(sentinelHosts) && StringUtil.isNotNullOrEmpty(sentinelMaster)) {
    String[] sentinelAddress = Arrays.stream(sentinelHosts.split(",")).map(h -> {
        if (!h.startsWith("redis")) {
            return "redis://" + h;
        } else {
            return h;
        }
    }).toArray(String[]::new);
    config.useSentinelServers()
            .addSentinelAddress(sentinelAddress)
            .setMasterName(sentinelMaster)
            .setDatabase(db);
} else {
    config.useSingleServer()
            .setAddress(host + ":" + port)
            .setDatabase(db);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Reading properties from a config file and mapping them with com.fasterxml.jackson.databind.ObjectMapper.convertValue() to a Redisson Config to be working fine.
Actual behavior
It seems like with Java 9 module system using reflection is not as safe as before. We are running Java 11 and the following exception is raised when using com.fasterxml.jackson.databind.ObjectMapper.convertValue() to create a Redisson Config from a Map (properties loaded from a config file).
Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make field private final boolean java.lang.module.ModuleDescriptor.open accessible: module java.base does not "opens java.lang.module" to unnamed module @5c83ae01
at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:340)
at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:280)
at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:176)
at java.base/java.lang.reflect.Field.setAccessible(Field.java:170)
at com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(ClassUtil.java:891)
at com.fasterxml.jackson.databind.deser.impl.FieldProperty.fixAccess(FieldProperty.java:102)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder._fixAccess(BeanDeserializerBuilder.java:484)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder.build(BeanDeserializerBuilder.java:350)
at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:245)
at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:137)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:411)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)
at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)
at com.fasterxml.jackson.databind.DeserializationContext.findNonContextualValueDeserializer(DeserializationContext.java:467)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:473)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)
at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)
at com.fasterxml.jackson.databind.DeserializationContext.findNonContextualValueDeserializer(DeserializationContext.java:467)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:473)
at com.fasterxml.jackson.module.afterburner.deser.SuperSonicBeanDeserializer.resolve(SuperSonicBeanDeserializer.java:79)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)
at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)
at com.fasterxml.jackson.databind.DeserializationContext.findNonContextualValueDeserializer(DeserializationContext.java:467)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:473)
at com.fasterxml.jackson.module.afterburner.deser.SuperSonicBeanDeserializer.resolve(SuperSonicBeanDeserializer.java:79)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)
at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)
at com.fasterxml.jackson.databind.DeserializationContext.findNonContextualValueDeserializer(DeserializationContext.java:467)
at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:473)
at com.fasterxml.jackson.module.afterburner.deser.SuperSonicBeanDeserializer.resolve(SuperSonicBeanDeserializer.java:79)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)
at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)
at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)
at com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)
at com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4190)
at com.fasterxml.jackson.databind.ObjectMapper._convert(ObjectMapper.java:3743)
at com.fasterxml.jackson.databind.ObjectMapper.convertValue(ObjectMapper.java:3668)

The exception is raised when trying to create a ClassLoader (which is needed in the Redisson Codec) via reflection.
I would like to know if there's any other way to easily create a Redisson Config based on a config file without having to hardcode every property.
If you have something in mind which can be implemented here to avoid this kind of issues we are more than happy to contribute a PR.
Steps to reproduce or test case
We still can't reproduce this with a clear example, in some of our Java 11 apps we can convert to a Redisson Config, but in other ones the above exception is raised. So we are still trying to figure out how we can reproduce this consistently.
That said, the piece of code is something like this:
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

Map<String, Object> config = loadConfigFile();
Config redissonCfg = objectMapper.convertValue(config, Config.class);

Redis version
N/A
Redisson version
3.11.0
Jackson version
com.fasterxml.jackson.core : jackson-databind : 2.9.9
Redisson configuration
N/A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
The call to closeNodeConnection waits indefinitely on call to MasterSlaveConnectionManager.closeNodeConnections.
Section from thread dump:
/service/soap
Transaction type: Web
Transaction name: /service/soap
Duration: 818,433.1 milliseconds
CPU time: 34.0 milliseconds
"qtp1957530885-64062" #64062
   java.lang.Thread.State: WAITING
        at java.lang.Object.wait(Native Method)
        - waiting on io.netty.util.concurrent.ImmediateEventExecutor$ImmediatePromise@5dd96fe
        at java.lang.Object.wait(Object.java:328)
        at io.netty.util.concurrent.DefaultPromise.awaitUninterruptibly(DefaultPromise.java:254)
        at io.netty.util.concurrent.DefaultPromise.syncUninterruptibly(DefaultPromise.java:340)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:128)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:35)
        at org.redisson.connection.MasterSlaveConnectionManager.closeNodeConnections(MasterSlaveConnectionManager.java:234)
        at org.redisson.cluster.ClusterConnectionManager.shutdown(ClusterConnectionManager.java:780)
        at org.redisson.Redisson.shutdown(Redisson.java:670)
        at com.zimbra.cs.mailbox.redis.RedissonRetryClient.restart(RedissonRetryClient.java:117)
        - locked on com.zimbra.cs.mailbox.redis.RedissonRetryClient@58a8ea4c
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.reconnect(RedissonRetryDecorator.java:64)
        - locked on com.zimbra.cs.mailbox.redis.RedissonRetryScript@67d62c10
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.access$000(RedissonRetryDecorator.java:15)
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator$1.run(RedissonRetryDecorator.java:35)
        at com.zimbra.cs.util.RetryUtil$RequestWithRetry.execute(RetryUtil.java:26)
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.runCommand(RedissonRetryDecorator.java:82)
        at com.zimbra.cs.mailbox.redis.RedissonRetryScript.eval(RedissonRetryScript.java:171)
        at com.zimbra.cs.mailbox.redis.RedisBackedLRUItemCache$LRUCacheTrimScript.trimCache(RedisBackedLRUItemCache.java:68)
        at com.zimbra.cs.mailbox.TransactionAwareLRUItemCache$LRUCacheCachedObject.trimCache(TransactionAwareLRUItemCache.java:134)
        at com.zimbra.cs.mailbox.TransactionAwareLRUItemCache.trimCache(TransactionAwareLRUItemCache.java:43)
        at com.zimbra.cs.mailbox.cache.RedisItemCache.trim(RedisItemCache.java:132)
        at com.zimbra.cs.mailbox.Mailbox.trimItemCache(Mailbox.java:9211)
        at com.zimbra.cs.mailbox.Mailbox.commitCache(Mailbox.java:9095)
        at com.zimbra.cs.mailbox.Mailbox.access$1900(Mailbox.java:295)
        at com.zimbra.cs.mailbox.Mailbox$MailboxTransaction.close(Mailbox.java:10168)
        at com.zimbra.cs.mailbox.MailboxIndex.search(MailboxIndex.java:604)
        at com.zimbra.cs.index.DBQueryOperation.dbSearch(DBQueryOperation.java:669)
        at com.zimbra.cs.index.DBQueryOperation.luceneFirstGetNextChunk(DBQueryOperation.java:798)
        at com.zimbra.cs.index.DBQueryOperation.getNextChunk(DBQueryOperation.java:844)
        at com.zimbra.cs.index.DBQueryOperation.peekNext(DBQueryOperation.java:526)
        at com.zimbra.cs.index.QueryOperation.hasNext(QueryOperation.java:169)
        at com.zimbra.cs.index.ItemPreloadingGrouper.bufferHits(ItemPreloadingGrouper.java:54)
        at com.zimbra.cs.index.BufferingResultsGrouper.hasNext(BufferingResultsGrouper.java:68)
        at com.zimbra.cs.index.ConvQueryResults.internalGetNextHit(ConvQueryResults.java:59)
        at com.zimbra.cs.index.ConvQueryResults.bufferNextHit(ConvQueryResults.java:117)
        at com.zimbra.cs.index.ConvQueryResults.peekNext(ConvQueryResults.java:124)
        at com.zimbra.cs.index.ZimbraQueryResultsImpl.hasNext(ZimbraQueryResultsImpl.java:93)
        at com.zimbra.cs.index.ItemPreloadingGrouper.bufferHits(ItemPreloadingGrouper.java:54)
        at com.zimbra.cs.index.BufferingResultsGrouper.peekNext(BufferingResultsGrouper.java:73)
        at com.zimbra.cs.index.FilteredQueryResults.peekNext(FilteredQueryResults.java:195)
        at com.zimbra.cs.index.FilteredQueryResults.hasNext(FilteredQueryResults.java:145)
        at com.zimbra.cs.index.ResultsPager.hasNext(ResultsPager.java:139)
        at com.zimbra.cs.service.mail.Search.putHits(Search.java:202)
        at com.zimbra.cs.service.mail.Search.handle(Search.java:127)
        at com.zimbra.soap.SoapEngine.dispatchRequest(SoapEngine.java:664)
        at com.zimbra.soap.SoapEngine.dispatch(SoapEngine.java:509)
        at com.zimbra.soap.SoapEngine.dispatch(SoapEngine.java:296)
        at com.zimbra.soap.SoapServlet.doWork(SoapServlet.java:308)
        at com.zimbra.soap.SoapServlet.doPost(SoapServlet.java:217)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
        at com.zimbra.cs.servlet.ZimbraServlet.service(ZimbraServlet.java:214)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:873)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1623)
        at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:214)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.CsrfFilter.doFilter(CsrfFilter.java:175)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.RequestStringFilter.doFilter(RequestStringFilter.java:54)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.SetHeaderFilter.doFilter(SetHeaderFilter.java:59)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ETagHeaderFilter.doFilter(ETagHeaderFilter.java:47)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ContextPathBasedThreadPoolBalancerFilter.doFilter(ContextPathBasedThreadPoolBalancerFilter.java:107)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ZimbraQoSFilter.doFilter(ZimbraQoSFilter.java:116)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ZimbraInvalidLoginFilter.doFilter(ZimbraInvalidLoginFilter.java:117)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at org.eclipse.jetty.servlets.DoSFilter.doFilterChain(DoSFilter.java:482)
        at org.eclipse.jetty.servlets.DoSFilter.doFilter(DoSFilter.java:327)
        at org.eclipse.jetty.servlets.DoSFilter.doFilter(DoSFilter.java:297)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:540)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:146)
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:524)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:257)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1700)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:255)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1345)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:203)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:480)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1667)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:201)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1247)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:144)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:220)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:152)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:335)
        at org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:753)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.server.Server.handle(Server.java:505)
        at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:370)
        at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:267)
        at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:305)
        at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
        at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:427)
        at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:321)
        at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:159)
        at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
        at org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:698)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:804)
        at java.lang.Thread.run(Thread.java:834)

Expected behavior
MasterSlaveConnectionManager.closeNodeConnections should throw an timeout exception if the same is not able to complete within a configured timeout.
Actual behavior
Thread hangs indefinitely at the request.
Redis version
5.0.5
Redisson version
3.10.7
Redisson configuration
nettyThreads=16
masterConnectionPoolSize=200
masterConnectionMinimumIdleSize=100
subscriptionConnectionPoolSize=200
subscriptionConnectionMinimumIdleSize=100
subscriptionsPerConnection=10
connectionTimeout=10000
retryInterval=3000
retryAttempts=10
keepAlive=true
tcpNoDelay=true
clusterScanInterval=2000
pingConnectionInterval=10000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
3.2
Redisson version
3.10.6
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When submitting task with taskRetryInterval option set, the task should run on the next available Redisson executor node when the original executor node was killed.
Actual behavior
The task is not retried on the next available worker. Also when the worker node is started again it will run duplicate task on all the available worker nodes.
Steps to reproduce or test case
Submit JobA and then start 2 instance of the Worker lets say Worker1 and Worker2. When Worker1 is running JobA kill that worker, now the Worker2 should try to run the JobA after the taskRetryInterval, but it does not. Now start Worker1 again, Redisson will duplicate the task run on both Worker1 and Worker2.
public class Schedule {

	public static void main(String[] args) {
		RedissonClient client = Redisson.create();
                ExecutorOptions option = ExecutorOptions.defaults();
                option.taskRetryInterval(3000, TimeUnit.MILLISECONDS);
		RScheduledExecutorService executorService = client.getExecutorService("JobA",option);
                // submit JobA
		RExecutorFuture<?> future = executorService
                .submit(new JobA());
	}

}


JobA:
public class JobA implements Runnable {

	@Override
	public void run() {
                System.out.println("JOB A started!!!!!!!!!!");
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("JOB A finished!!!!!!!!!!");
	}

}

Worker:
public class Worker{
	public static void main(String[] args) {
		Config config = new Config();
		config.useSingleServer().setAddress("redis://127.0.0.1:6379");
		RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
		nodeConfig.getExecutorServiceWorkers().put("JobA", 1);
		RedissonNode node = RedissonNode.create(nodeConfig);
		node.start();
	}

}

Redis version
Redis 3.0.503
Redisson version
3.9.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
长时间运行，不会导致内存泄露
Actual behavior
长时间运行，导致内存泄露
Steps to reproduce or test case
1.从spring官网上生成spring boot的demo项目。
2.在pom.xml中增加对redisson的依赖。
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson</artifactId>
	<version>3.11.3</version>
</dependency>
3.debug方式启动spring boot。
4.通过断点观察

可以看到redisson所依赖的netty里，这个数组的的大小会不断增大，最终导致oom。
Redis version
redis_version:5.0.4
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:913214bd6b0ee4ea
redis_mode:cluster
os:Linux 3.10.0-957.1.3.el7.x86_64 x86_64
arch_bits:64
multiplexing_api:epoll
atomicvar_api:atomic-builtin
Redisson version
3.11.3
Redisson configuration
我是在spring boot里通过代码的方式配置的。
@SpringBootApplication
public class Test3Application {

    public static void main(String[] args) {
        SpringApplication.run(Test3Application.class, args);
    }

    @Bean
    public RedissonClient getRedisson() {
        Config config = new Config();
        config.useClusterServers()
                .setScanInterval(2000) // cluster state scan interval in milliseconds
                .addNodeAddress("redis://10.193.xxx.xxx:8303");
        RedissonClient redisson = Redisson.create(config);
        return redisson;
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Get saved session
Actual behavior
Errror on get saved session
[http-nio-8080-exec-3] org.redisson.tomcat.RedissonSessionManager.findSession Session 220E103487E92F790688E64E864CE089 can't be found 09/09/19 17:31:22 ERROR hamburgsud.schedule.report.sign.in.controller.SignInController:44 Unable to sign in. java.lang.IllegalArgumentException: The user cannot be null.
Steps to reproduce or test case
Tomcat configuration Steps
Redis version
lastest
Redisson version
3-11-2
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: null
subscriptionsPerConnection: 5
clientName: null
address: "redis://10.121.224.137:7000"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 24
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
threads: 16
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson and redis are used ONLY as cache by spring @Cacheable(value="xy", key="ab") annotations.  TTL is set to 10min. no manual access or manual redisson commands are written in code.
Expected behavior
after catch RedisOutOfMemoryException redisson evicts old keys to make more space, because redis cannot handle outOfMemory due to redisson creates key "xy" that represents whole cache name and ttl is not set for this key. Value of this key is "map" that contains cache our keys "ab" and cached values. There exists also other redis key with prefix redisson__timeout__set:{xy} that holds TTL.
Actual behavior
after RedisOutOfMemoryException there is inconsistency that stored records are alive and is returned from cache after 5 days even we have TTL only 10min. Maybe because redisson first put value to xy cache and next put TTL value to redisson__timeout__set:{xy} cache. if write to redisson__timeout__set:{xy} caused OOM exception then record in xy cache will stay alive forever.
Steps to reproduce or test case
set redis max memory to low value and store bigger data to cache.
Redis version
v5.0.4
Redisson version
v3.10.7
Redisson configuration
private static final int CONNECTION_POOL_SIZE = 256;
private static final int SUBSCRIPTION_CONNECTION_MINIMUM_IDLE_SIZE = 2;
private static final int SUBSCRIPTION_POOL_SIZE = 100;
private static final int SUBSCRIPTIONS_PER_CONNECTION_SIZE = 20;
private static final int RETRY_INTERVAL = 100;
private static final int RETRY_ATTEMPTS = 1;
config.useMasterSlaveServers()
.setMasterAddress(halCacheProperties.getRedisMaster())
.addSlaveAddress(halCacheProperties.getRedisSlaves())
.setRetryInterval(RETRY_INTERVAL)
.setRetryAttempts(RETRY_ATTEMPTS)
.setReadMode(ReadMode.MASTER_SLAVE)
.setMasterConnectionPoolSize(CONNECTION_POOL_SIZE)
.setSlaveConnectionPoolSize(CONNECTION_POOL_SIZE)
.setSubscriptionConnectionMinimumIdleSize(SUBSCRIPTION_CONNECTION_MINIMUM_IDLE_SIZE)
.setSubscriptionConnectionPoolSize(SUBSCRIPTION_POOL_SIZE)
.setSubscriptionsPerConnection(SUBSCRIPTIONS_PER_CONNECTION_SIZE);
config.setCodec(new SerializationCodec());   //codec, to fix concurrency problem with fstCodec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis server response timeout (1000 ms) occured for command: (EVAL) with params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then redis.call('hincrby', KEYS[1], ARGV[2], 1); redis.call('pexpire', KEYS[1], ARGV[1]); return nil; end; return redis.call('pttl', KEYS[1]);, 1, _dtlocks/OrderVerificProcessor_WelfareVerific#O20190825000042, 600000, 30f2dd72-90c5-4863-b712-aff5fd06c828:351]
redisson.2.2.13
when occouring this problem,the redis has not much qps
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In https://github.com/redisson/redisson/wiki/6.-Distributed-objects#612-ratelimiter, the example is:
// 5 permits per 2 seconds
limiter.trySetRate(RateType.OVERALL, 1, 2, RateIntervalUnit.SECONDS);

Should it be the following?
limiter.trySetRate(RateType.OVERALL, 5, 2, RateIntervalUnit.SECONDS);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using Redisson's Tomcat9 session manager going against Azure Redis Cache
with readMode=MEMORY and updateMode=DEFAULT .
This is mainly for session failover in case a server fails. Sessions are sticky, and so during normal operation, all session reads should be local within Tomcat.
Occasionally all of our Tomcat instances experience Netty timeout errors and requests to Redis fail.  This causes a complete failure of the application, as sessions are unavailable. This failure seems unnecessary, since the session data is available in local Tomcat memory and is not dependent on Redis (except in the case of failover)
Is there any way to get Redisson session manager to circuit break if calls to Redis fail or time out, and fall back to using session data from local memory ? The exception is below. Any help would be appreciated. Thanks!
Sep 05, 2019 1:09:58 AM org.redisson.tomcat.RedissonSessionManager findSession
SEVERE: Can't read session object by id: 36D02EC9371A380BBA8A8A6C7BAC6C37
org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=9, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=rediss://sessions-redis.redis.cache.windows.net:6380], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@310983480 [redisClient=[addr=rediss://sessions-redis.redis.cache.windows.net:6380], channel=[id: 0x51576dba, L:/10.23.152.48:49800 - R:sessions-redis.redis.cache.windows.net/137.116.35.20:6380], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@3f0a0e71(failure: java.util.concurrent.CancellationException)], command=(PUBLISH), params=[p-bs:redisson:tomcat_session_updates:/auth, PooledUnsafeDirectByteBuf(freed)], codec=org.redisson.client.codec.StringCodec]], command: (HMGET), params: [p-bs:redisson:tomcat_session:36D02EC9371A380BBA8A8A6C7BAC6C37, PooledUnsafeDirectByteBuf(ridx: 0, widx: 24, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 13, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 24, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 27, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 15, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 256)] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:714)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
Expected behavior
Redisson Session Manager should fail gracefully and fall back to local memory if Redis calls fail, and Tomcat requests should succeed
Actual behavior
All Tomcat requests that use the http session data fail
Steps to reproduce or test case
Issue is intermittent, but occurs when calls to Netty time out
Redis version
Azure Cache for Redis
Redisson version
3.11.0
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
subscriptionsPerConnection: 5
clientName: null
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 10
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 35000
threads: 16
nettyThreads: 32
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
We are running in to DNS resolution failures sometimes.
`DatagramDnsResponse(from: /10.0.0.2:53, to: /0:0:0:0:0:0:0:0:53018, 52723, QUERY(0), NoError(0), RD RA)
DefaultDnsQuestion(useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com. IN A)
DefaultDnsRawRecord(useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com. 15 IN A 4B)
DefaultDnsRawRecord(OPT flags:0 udp:4096 0B)
2019-09-11 06:50:21,154-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] DEBUG - [id: 0x9099eb92] WRITE: [58273: /10.0.0.2:53], DefaultDnsQuestion(useast101-rd01-0002.j2b5o9.0001.use1.cache.amazonaws.com. IN A)
2019-09-11 06:50:21,155-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] DEBUG - [id: 0x9099eb92] WRITE: [31257: /10.0.0.2:53], DefaultDnsQuestion(useast101-rd01-0002.j2b5o9.0001.use1.cache.amazonaws.com. IN AAAA)
2019-09-11 06:50:21,155-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] DEBUG - [id: 0x9099eb92] WRITE: [54664: /10.0.0.2:53], DefaultDnsQuestion(useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com. IN A)
2019-09-11 06:50:22,881-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] DEBUG - [id: 0x9099eb92] WRITE: [32392: /10.0.0.2:53], DefaultDnsQuestion(useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com. IN AAAA)
2019-09-11 06:50:40,212-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-35] ERROR - Command execution timeout for command: (INFO REPLICATION), params: [], Redis client: [addr=redis://useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com:6379] org.redisson.client.RedisTimeoutException: Command execution timeout for command: (INFO REPLICATION), params: [], Redis client: [addr=redis://useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com:6379]
at org.redisson.client.RedisConnection$1.run(RedisConnection.java:209) [redisson-3.10.7.jar:?]
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:405) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) [netty-transport-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
2019-09-11 06:50:37,598-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] ERROR - Unable to resolve useast101-rd01-0002.j2b5o9.0001.use1.cache.amazonaws.com io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'useast101-rd01-0002.j2b5o9.0001.use1.cache.amazonaws.com' failed to resolve 'useast101-rd01-0002.j2b5o9.0001.use1.cache.amazonaws.com' after 2 queries
at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:877) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:838) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:333) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.access$600(DnsResolveContext.java:63) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:382) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:495) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:474) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:220) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsQueryContext.access$300(DnsQueryContext.java:43) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:170) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:405) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) [netty-transport-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/10.0.0.2:53] query timed out after 5000 milliseconds (no stack trace available)
2019-09-11 06:51:13,388-0700 [toe=00p4dqty02gn9h] [redisson-netty-2-24] ERROR - Unable to resolve useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com' failed to resolve 'useast101-rd01-0001.j2b5o9.0001.use1.cache.amazonaws.com' after 2 queries
at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:877) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:838) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:333) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext.access$600(DnsResolveContext.java:63) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:382) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:502) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:495) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:474) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:415) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:540) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:533) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:114) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:220) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsQueryContext.access$300(DnsQueryContext.java:43) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:170) [netty-resolver-dns-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:405) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) [netty-transport-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:906) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.35.Final.jar:4.1.35.Final]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/10.0.0.2:53] query timed out after 5000 milliseconds (no stack trace available)`
The redisson configuration details are as below
Redisson Version : 3.10.7
Redis Server : Elasticache
Redisson Configuration
Server Mode: Replication
Threads: 32
Netty Threads : 64
decodeInExecutor:false
timeout : 10 seconds
pingInterval : 60 seconds
Can you please look in to this. This is happening intermittently(nearly 50% of times)
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2317
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis version
V 2.2 Provided by PCF.
Redisson version
3.9.0
Redisson configuration
	Config config = new Config();
	String url = String.format("%s%s%s%s", "redis://", 127.0.0.1, COLON, 6379);
	config.useSingleServer().setAddress(url).setPassword(password);
	return Redisson.create(config);

The exception I see is:
Caused by: org.redisson.client.RedisException: ERR unknown command EVAL, with args beginning with: local value =
  redis.call('hget', KEYS[1], ARGV[2]); if value == false then return
  nil; end;
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I've tried running tasks Runnable/Callable that have autowired dependencies from SpringBoot and I get serialization errors on scheduling tasks or null pointer exceptions when tasks are about to execute.
I've crawled through documentation very carefully and I've even noticed there is some invalid documentation examples.
Please check out in your documentation Section 9. , 9.4.3. Distributed scheduled executor service. Scheduling a task with Spring beans.
Example code is invalid and it doesn't work.
To summarize:
Is there a way to create Callable/Runnable tasks that have SpringBoot beans as dependencies autowired - Important: that they dont have to implement Serializable interface.
Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Code
public void addRoutePath(String rxpkData, Rxpk rxpk, RouteMap routeMap, int seconds) {
    RxpkPathContext lockContext = new RxpkPathContext();
    lockContext.setRxpk(rxpk);
    lockContext.setRouteMap(routeMap);
    String name = ROUTE_KEY.replace("{rxpkData}", rxpkData);
    RSet<String> set = redisson.getSet(name);
    set.add(JSONObject.toJSONString(lockContext));
    set.expire(seconds, TimeUnit.SECONDS);
}

public List<RxpkPathContext> getRoutePaths(String rxpkData) {
    String name = ROUTE_KEY.replace("{rxpkData}", rxpkData);
    return redisson.<String>getSet(name).readAll().stream()
        .map(path -> JSONObject.parseObject(path, RxpkPathContext.class))
        .collect(Collectors.toList());;
}
Redisson configuration
public RedissonClient redisson() {
    Config config = new Config();
    config.setNettyThreads(32)
        .setCodec(new JsonJacksonCodec())
        .useSingleServer()
        .setConnectionMinimumIdleSize(16)
        .setConnectionPoolSize(64)
        .setAddress(address)
        .setPassword(password);
    return Redisson.create(config);
}
Exception
2019-09-12 17:31:22.729 ERROR --- [] o.r.client.handler.CommandDecoder        : Unable to decode data. channel: [id: 0x7a8d9c11, L:/11.193.49.163:44086 - R:r-uf6c6b15f63a9214.redis.rds.aliyuncs.com/100.118.18.139:6379], reply: ReplayingDecoderByteBuf(ridx=850, widx=9495), command: (SMEMBERS), params: [lora_route_ea7b6661]
com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing typeid property '@class'
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 837]
  at com.fasterxml.jackson.databind.exc.InvalidTypeIdException.from(InvalidTypeIdException.java:43)
  at com.fasterxml.jackson.databind.DeserializationContext.missingTypeIdException(DeserializationContext.java:1645)
  at com.fasterxml.jackson.databind.DeserializationContext.handleMissingTypeId(DeserializationContext.java:1218)
  at com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._handleMissingTypeId(TypeDeserializerBase.java:300)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:164)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:105)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:193)
  at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712)
  at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)
  at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)
  at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070)
  at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)
  at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:428)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393)
  at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
  at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
  at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
  at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
  at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
  at java.lang.Thread.run(Thread.java:766)
2019-09-12 17:31:22.730 WARN  --- [] io.netty.channel.DefaultChannelPipeline  : An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 837]
  at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
  at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
  at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
  at java.lang.Thread.run(Thread.java:766)
Caused by: com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 837]
  at com.fasterxml.jackson.databind.exc.InvalidTypeIdException.from(InvalidTypeIdException.java:43)
  at com.fasterxml.jackson.databind.DeserializationContext.missingTypeIdException(DeserializationContext.java:1645)
  at com.fasterxml.jackson.databind.DeserializationContext.handleMissingTypeId(DeserializationContext.java:1218)
  at com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._handleMissingTypeId(TypeDeserializerBase.java:300)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:164)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:105)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:193)
  at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712)
  at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)
  at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)
  at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070)
  at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)
  at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:428)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393)
  at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
  at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
  at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
  ... 28 common frames omitted
org.redisson.client.RedisException: Unexpected exception while processing command
  at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:354)
  at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:158)
  at org.redisson.RedissonObject.get(RedissonObject.java:94)
  at org.redisson.RedissonSet.readAll(RedissonSet.java:140)
  at com.aliyun.iotx.loraserver.major.dal.CacheServiceImpl.getRoutePaths(CacheServiceImpl.java:134)
  at java.lang.Thread.run(Thread.java:766)
Caused by: com.fasterxml.jackson.databind.exc.InvalidTypeIdException: Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: missing type id property '@class'
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 837]
  at com.fasterxml.jackson.databind.exc.InvalidTypeIdException.from(InvalidTypeIdException.java:43)
  at com.fasterxml.jackson.databind.DeserializationContext.missingTypeIdException(DeserializationContext.java:1645)
  at com.fasterxml.jackson.databind.DeserializationContext.handleMissingTypeId(DeserializationContext.java:1218)
  at com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase._handleMissingTypeId(TypeDeserializerBase.java:300)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:164)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:105)
  at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:193)
  at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:712)
  at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)
  at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)
  at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070)
  at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)
  at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:428)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393)
  at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153)
  at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
  at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
  at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
  at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
  at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
  ... 1 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson add all sentinels
Actual behavior
Add only the first one, ignoring the other two.
[main] INFO org.redisson.connection.SentinelConnectionManager - master: redis://172.31.30.1:6379 added
[main] INFO org.redisson.connection.SentinelConnectionManager - slave: redis://172.31.41.2:6379 added
[redisson-netty-2-12] INFO org.redisson.connection.SentinelConnectionManager - sentinel: redis://172.31.30.1:26379 added
[redisson-netty-2-20] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for 172.31.41.2/172.31.41.2:6379
[redisson-netty-2-27] INFO org.redisson.connection.pool.SlaveConnectionPool - 24 connections initialized for 172.31.41.2/172.31.41.2:6379
[redisson-netty-2-32] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for 172.31.30.1/172.31.30.1:6379

When the added sentinel and the master fail, even if fail over happens normally with the other 2 sentinels, redisson dont reconnect.
Steps to reproduce or test case
Configure de redisson with Tomcat 9
Redis version
5.0.5
Redisson version
3.11.1
Redisson configuration
{
   "sentinelServersConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "failedSlaveReconnectionInterval":3000,
      "failedSlaveCheckInterval":60000,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "loadBalancer":{
         "class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
      },
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "slaveConnectionMinimumIdleSize":24,
      "slaveConnectionPoolSize":64,
      "masterConnectionMinimumIdleSize":24,
      "masterConnectionPoolSize":64,
      "readMode":"SLAVE",
      "subscriptionMode":"SLAVE",
      "sentinelAddresses":[
         "redis://172.31.30.1:26379",
         "redis://172.31.41.2:26379",
         "redis://172.31.4.2:26379"
      ],
      "masterName":"mymaster",
      "database":0
   },
   "threads":16,
   "nettyThreads":32,
   "codec":{
      "class":"org.redisson.codec.FstCodec"
   },
   "transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RRateLimiter does not have a setRate/setRateAsync method.
It only has trySetRate/trySetRateAsync methods, so once a rate-limiter's config is persisted to Redis, it cannot be overwritten.
Actual behavior
Invoking RRateLimiter.trySetRate twice with different rate-limiter configuration values does not overwrite, since it uses HSETNX instead of HSET operation.
Steps to reproduce or test case
RRateLimiter rateLimiter = redisson.getRateLimiter("myRateLimiter");
boolean success;
success = rateLimiter.trySetRate(RateType.OVERALL, 1, 1, RateIntervalUnit.SECONDS);
System.out.println(success); // "true"
success = rateLimiter.trySetRate(RateType.OVERALL, 2, 2, RateIntervalUnit.SECONDS);
System.out.println(success); // "false"

There is no way to overwrite the existing "myRateLimiter" with a different rate, besides modifying the rate limiter name
Redis version
4.0.11
Redisson version
3.11.2
Redisson configuration
N/A
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko I am aware you have proposed some workarounds in #2322, but I am curious what the opposition to this change is.  Would you be willing to elaborate further on why this change is not acceptable?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
<dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-redis</artifactId> </dependency> <dependency> <groupId>org.redisson</groupId> <artifactId>redisson-spring-data-18</artifactId> <version>3.11.3</version> <exclusions> <exclusion> <groupId>net.bytebuddy</groupId> <artifactId>byte-buddy</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>net.bytebuddy</groupId> <artifactId>byte-buddy</artifactId> <version>1.8.17</version> </dependency>
org.redisson.spring.session.RedissonSessionRepository

Actual behavior

Steps to reproduce or test case
Redis version
4.0.1
Redisson version
3.11.3
Redisson configuration
 <contenxt:property-placeholder location="classpath*:application.properties"/> <bean id="stringCodec" class="org.redisson.client.codec.StringCodec"/> <redisson:client id="sentinelRedisClient" codec-ref="stringCodec" > <redisson:sentinel-servers master-name="${redisson.master_name}"  database="0" password="${redisson.pwd}" connect-timeout="60000" master-connection-pool-size="30" master-connection-minimum-idle-size="10"> <redisson:sentinel-address value="${redisson.node1}" /> <redisson:sentinel-address value="${redisson.node2}" /> <redisson:sentinel-address value="${redisson.node3}" /> </redisson:sentinel-servers> </redisson:client>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:14.374 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:14.375 o.r.c.ClusterConnectionManager redisson-netty-2-7 [INFO] 24576 slots found to add
2019-09-19 08:58:19.387 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:19.388 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:19.388 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:19.388 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:19.388 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:19.388 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:19.389 o.r.c.ClusterConnectionManager redisson-netty-2-30 [INFO] 24576 slots found to add
2019-09-19 08:58:24.402 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:24.402 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:24.403 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:24.403 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:24.403 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:24.403 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:24.404 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 24576 slots found to add
2019-09-19 08:58:29.416 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:29.416 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:29.417 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:29.417 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:29.417 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:29.417 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:29.418 o.r.c.ClusterConnectionManager redisson-netty-2-5 [INFO] 20480 slots found to add
2019-09-19 08:58:34.430 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:34.431 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:34.431 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:34.431 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:34.432 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:34.432 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:34.433 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots found to add
2019-09-19 08:58:39.446 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots added to redis://10.1.135.28:6379
2019-09-19 08:58:39.446 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots removed from redis://10.1.135.28:6379
2019-09-19 08:58:39.447 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots added to redis://10.1.135.70:6379
2019-09-19 08:58:39.447 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 10944 slots removed from redis://10.1.135.70:6379
2019-09-19 08:58:39.447 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots added to redis://10.1.135.127:6379
2019-09-19 08:58:39.447 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 5504 slots removed from redis://10.1.135.127:6379
2019-09-19 08:58:39.448 o.r.c.ClusterConnectionManager redisson-netty-2-17 [INFO] 16384 slots found to add
Steps to reproduce or test case
Redis version
3.2.10
Redisson version
3.11.2
Redisson configuration
Config config = new Config();
config.useClusterServers().setTimeout(timeout);
for(String host : hosts.split(",")) {
    config.useClusterServers().addNodeAddress("redis://" + host);
}

this.redisson = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi  ,
I am using following code :
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
client = Redisson.create(config);
RMapCache<String,String >map = client.getMapCache("TestMap1");
RFuture result =mapCache.putAsync("5","6");
I can get the same value back using redisson , But when i see all values using redis-cli , i see following:
:~$ redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379> hgetall  TestMap1

"\xf7\x01"
"\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\xfc\x03abc"
"\x00\x01\x1eorg.redisson.RedissonReference\xfc(org.redisson.client.codec.ByteArrayCodec\xfc\x011\xfc\x1eorg.redisson.api.RBinaryStream\x00"
"\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\xfb$\x03abc"

How could i avoid this serialization or encoding of data so that i can access the data using some other redisson client ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Session xxxxxxxxxxxxxx can't be found
Expected behavior
get session from redission
Actual behavior
Sep 20, 2019 2:31:33 PM org.redisson.tomcat.RedissonSessionManager findSession INFO: Session 2905FF64FAF76CCF89DC2FF4CDE7BFB9 can't be found Sep 20, 2019 2:31:33 PM org.redisson.tomcat.RedissonSessionManager findSession INFO: Session 2905FF64FAF76CCF89DC2FF4CDE7BFB9 can't be found Sep 20, 2019 2:31:33 PM org.redisson.tomcat.RedissonSessionManager findSession INFO: Session 2905FF64FAF76CCF89DC2FF4CDE7BFB9 can't be found Sep 20, 2019 2:31:33 PM org.redisson.tomcat.RedissonSessionManager findSession INFO: Session 2905FF64FAF76CCF89DC2FF4CDE7BFB9 can't be found {"valid":false,"currentSessionId":"0F7CC0D1A51C285102F4BD3A68B7F858","sessionIdFromCookie":"2905FF64FAF76CCF89DC2FF4CDE7BFB9","fromCookie":true,"url":"http://xxx.xxx.xxx/back/"} {"valid":true,"currentSessionId":"0F7CC0D1A51C285102F4BD3A68B7F858","sessionIdFromCookie":"0F7CC0D1A51C285102F4BD3A68B7F858","fromCookie":true,"url":"http://xxx.xxx.xxx/goh5.min.css"}
But i found key 'redission:tomcat_session:2905FF64FAF76CCF89DC2FF4CDE7BFB9' in redis client
Steps to reproduce or test case
1、restart tomcat
2、access other tomcat
Redis version
3.0.5
Redisson version
2.15.2
Redisson configuration
{ "singleServerConfig":{ "idleConnectionTimeout":10000, "pingTimeout":1000, "connectTimeout":10000, "timeout":3000, "retryAttempts":3, "retryInterval":1500, "password":"exam", "subscriptionsPerConnection":5, "clientName":"cloud-search-session", "address": "redis://10.31.145.19:6380", "subscriptionConnectionMinimumIdleSize":1, "subscriptionConnectionPoolSize":50, "connectionMinimumIdleSize":10, "connectionPoolSize":64, "database":8, "dnsMonitoringInterval":5000, "keepAlive":true, "pingConnectionInterval":60000 }, "threads":0, "nettyThreads":0, "codec":{ "class":"org.redisson.codec.JsonJacksonCodec" }, "transportMode":"NIO" }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Dear all,
I tried to test with redisson lib but I saw lack of basic example.
In redis I set String value, for example SET testkey testvalue.
How can I use redisson to get  the String value of testkey?
Here are my code:
public static void main(String[] args) {
Config config = new Config();
// use single Redis server
config.useSingleServer().setAddress("redis://IP:6379");
RedissonClient redisson = Redisson.create(config);
	// perform operations
	RBucket<String> bucket = redisson.getBucket("testkey");
	System.out.println("Value of testkey: " + bucket.get());
    
	//shutdown 
	redisson.shutdown();
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
The redisson should reconnect and query without exceptions, after the slave restarted.
Actual behavior
After the slave node restarted successfully, the server using redisson v2.13.1 printed logs like ClusterConnectionManager.java:245 | - slaves: [redis://x.x.x.x:x] added for slot ranges:[[x-x]] , and I took it as redisson had reconnected to the slave node. However, when the server queried data in this node, there were expections:
org.redisson.client.RedisConnectionException: RedisConnection@xxxx [redisClient=[addr=redis://x.x.x.x:x], channel=[id: xxxx, L:x.x.x.x/x.x.x.x:xxxx]] is not active!
	at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:323)
	at org.redisson.connection.pool.ConnectionPool.connectTo(ConnectionPool.java:253)
	at org.redisson.connection.pool.ConnectionPool.access$300(ConnectionPool.java:53)
	at org.redisson.connection.pool.ConnectionPool$3.run(ConnectionPool.java:214)
	at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:142)
	at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:125)
	at org.redisson.connection.ClientConnectionsEntry.acquireConnection(ClientConnectionsEntry.java:134)
	at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:161)
	at org.redisson.connection.pool.ConnectionPool.acquireConnection(ConnectionPool.java:224)
	at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:172)
	at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
	at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:244)
	at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:457)
	at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:576)
	at org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:679)
	at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:536)
	at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:625)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473)
	at java.lang.Thread.run(Thread.java:748)

By contrast, the servers using redisson v3.7.3 recovered as expected.
Steps to reproduce or test case
The redis cluster are composed of 3 masters with 3 slaves.
I did cluster failover on the slave, after the master and slave switched successfully, i did shutdown and restarted the server. After the operations, the redisson threw exceptions when queried the restarted redis node, and could not recovered automatically in half an hour.
Redis version
3.2.9
Redisson version
Exception version：2.13.1
Right version：3.7.3
Redisson configuration
We are using recommend parameters in redisson wiki, here are 2 key parameters：
{
  "clusterServerConfig": {
    "idleConnectionTimeout": 10000,
    ...,
    "readMode": "SLAVE",
    ...
  }
}

Other problems
After master-slave switch and restart slave node, I found all redisson(v2.13.1 and v3.7.3) connections increased significantly(almost twice as normal connections), and config timeout set xxx was useless. When i restarted the servers, the redisson connections were back to normal. So is there a reason that redisson do no release idle connections for a long time?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In RedissionSessionManager.findSession()
source code：
RedissonSession session = (RedissonSession) createEmptySession();
session.setId(id);
session.setManager(this);
session.load(attrs);

Session.setId() will sync data to redis, but before session.setId() , the isValid is not initialized. Maybe execute session.load(atttr) before session.setId() can fix this BUG.

RedissonSession session = (RedissonSession) createEmptySession();
session.load(attrs);
session.setId(id);
session.setManager(this);

Expected behavior
Session is valid
Actual behavior
Session is invalid
Steps to reproduce or test case
1、access tomcat A, createSession
2、access tomcat B, findSession
Redis version
ignore
Redisson version
ignore
Redisson configuration
ignore
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Call RSet.getSize() returns set size of N, and a subsequent call to RSet.iterator(batchSize) allows you to iterate through all N items.
Actual behavior
Call RSet.getSize() returns set size of N, and a subsequent call to RSet.iterator(batchSize) returns an iterator that has no items to iterate through.  Without (first) getting the size, the iterator will iterate through the set of N elements.  For some reason, getting the size (first) makes the set appear to be empty, and there seems to be no method to "reset" to the head of the set, if this is, indeed, what is happening.  Another detail that may also be notable is that, each time I restart my application, RSet.size() returns the expected size, so the data is not being removed with a call to get the cardinality of the set.
Steps to reproduce or test case
Get a set by calling RSet testSet = RedissonClient.getSet("testSet");
Add items to the set with testSet.addAll(Arrays.asList("1", "2", "3", "4", "5"));
Get the set size with int testSetSize = RSet.size();
The size of testSetSize == 5.
Get an iterator with testSet.iterator(5);
Attempt to iterate over the set, but there will be no items to iterate over.
Redis version
4.0.8
Redisson version
3.11.3
Redisson configuration
Config config = new Config();
config.setCodec(new KryoCodec)
.useMasterSlaveServers()
.setMasterAddress("redis://192.168.0.2")
.addSlaveAddress("redis://192.168.0.3")
.addSlaveAddress("redis://192.168.0.4")
.setReadMode(ReadMode.MASTER_SLAVE)
.setDatabase(1)
.setTimeout(FIVE_MINUTES)
return Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In my Kubernetes setup, REDIS pods get created as following..
`
crdb-crdb-redisio-sentinel-0                    1/1     Running                 0          39d    12.18.1.222   samt-worker-02   
crdb-crdb-redisio-sentinel-1                    1/1     Running                 0          54d    12.18.1.147   samt-worker-03   
crdb-crdb-redisio-sentinel-2                    1/1     Running                 0          39d    12.18.1.191   samt-worker-01   
crdb-crdb-redisio-server-0                      3/3     Running                 0          54d    12.18.1.156   samt-worker-03   
crdb-crdb-redisio-server-1                      3/3     Running                 0          39d    12.18.1.187   samt-worker-01   
crdb-crdb-redisio-server-2                      3/3     Running                 0          39d    12.18.1.215
samt-worker-02   
`
So 1 master and few slaves
Output of "kubectl get svc" is like:
`
crdb-crdb-redisio                      ClusterIP   10.254.111.38            6379/TCP                                                                                    54d    app=crdb-crdb-redisio,crdb-dbtype=redisio,csf-component=crdb,csf-subcomponent=redisio,heritage=Tiller,redisio_role=master,release=crdb,type=server
crdb-crdb-redisio-readonly             ClusterIP   10.254.211.116           6379/TCP                                                                                    54d    app=crdb-crdb-redisio,crdb-dbtype=redisio,csf-component=crdb,csf-subcomponent=redisio,heritage=Tiller,redisio_role=slave,release=crdb,type=server
`
Expected behavior
I want to connect to both master-slave via Raddison client
Actual behavior
I'm not sure how though because there are like following ways!
config.useClusterServers().
config.useSingleServer().
config.useMasterSlaveServers()
Steps to reproduce or test case
Redis version
not sure
Redisson version
3.3.0
Redisson configuration
This is what i am confused with
Could you please provide a sample code on how best to connect to Redis with master slave configuration?
master could become slave and vice versa so how dynamically Raddision would take care of this switch?
IPs of service needs to be configured or IPs of pods?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson session key is keeps increasing rapidly, now there are 300,000 key in redis, but HttpSessionListener can't get any sessionCreated even.
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
4
Redisson version
2.15.2
Redisson configuration
ignore
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I found that redisson-lock can not run well on aliyun-redis which cluster by proxy like code or twemproxy. Does anyone occour this problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You can use it via Redisson.createBatch method. It accumulates all invoked commands in one batch command.
Originally posted by @mrniko in #263 (comment)
How can we exactly do that?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
需要整合zipkin做链路跟踪，发现Redisson没有提供对应的扩展点
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Here is an example https://github.com/redisson/redisson/wiki/10.-additional-features#103-execution-batches-of-commands
Originally posted by @mrniko in #2339 (comment)
I tried using RedissonClient.createBatch(), its returning null. Whereas,      RBucket getBucket(String name) is working fine.
Can't figure out the issue behind this. I am extending RedissonClient and initialised its constructor.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While trying to track down an issue we had with AWS Elasticache redis + Redisson and a botched failover, this question came up -- "What is the difference between config.useReplicatedServers() and config.useMasterSlaveServers()?
The documentation suggests that ReplicatedServers is the right choice for Elasticache but doesn't go into more details. Thoughts?
Thanks
Tony
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
我现在的业务是数据入库成功后更新redis，之前mysql事务是没开启的。我的想法是mysql事务和redis事务都开启，当db入库成功后存redis缓存，否则一起回滚。
刚才试了下，貌似RedissonTransactionManager无法和DataSourceTransactionManager共存，不知大家有没有解决方案
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@component
public class RedisMessageListenerConfig {
@Bean
RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                        @Autowired @Qualifier("cacheHandlerAdapter") MessageListenerAdapter cacheHandlerAdapter,
                                        @Autowired @Qualifier("cacheHandlerAdapter1") MessageListenerAdapter cacheHandlerAdapter1) {
    RedisMessageListenerContainer container = new RedisMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    container.addMessageListener(cacheHandlerAdapter, topic());
    container.addMessageListener(cacheHandlerAdapter1, topic1());

    return container;
}

@Bean
MessageListenerAdapter cacheHandlerAdapter(CachePurgeHandler cachePurgeHandler) {
    return new MessageListenerAdapter(cachePurgeHandler);
}

@Bean
MessageListenerAdapter cacheHandlerAdapter1(CachePurgeHandler1 cachePurgeHandler1) {
    return new MessageListenerAdapter(cachePurgeHandler1);
}

@Bean
ChannelTopic topic() {
    return new ChannelTopic("CACHE_PURGE");
}

@Bean
ChannelTopic topic1() {
    return new ChannelTopic("messageQueue");
}

}
Expected behavior
the listener execute multi times as the topics` size
Actual behavior
execute one time
Steps to reproduce or test case
redis-cli> PUBLISH messageQueue "{"id": 4, "name": "xxoo"}"
Redis version
newest version
Redisson version
3.11.4
Redisson configuration
redis-spring-boot
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While looking through the server logs of our application running on Microsoft Azure, I came across the UnknownHostException below. It seems to occur on average once or twice a day.
<04:58:48> [ERROR] [DNSMonitor] Unable to resolve app.redis.cache.windows.net
java.net.UnknownHostException: failed to resolve 'app.redis.cache.windows.net'
	at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:925) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:884) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:356) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsResolveContext.access$600(DnsResolveContext.java:64) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:405) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:228) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsQueryContext.access$300(DnsQueryContext.java:42) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:177) [netty-resolver-dns-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:134) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:510) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:518) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_212]
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/127.0.0.11:53] query via UDP timed out after 5000 milliseconds (no stack trace available)

I found this issue which discusses a similar problem, but I am still seeing the error after upgrading to the latest version of Redisson.
Redis version
3.2.7
Redisson version
3.11.4
Redisson configuration
config.useSingleServer()
    .setAddress(PROTOCOL + HOST_PORT)
    .setPassword(PASSWORD)
    .setConnectTimeout(15000)
    .setConnectionMinimumIdleSize(32)
    .setConnectionPoolSize(32)
    .setRetryAttempts(3)
    .setRetryInterval(1500);
Any assistance would be much appreciated.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For the Redisson executor and scheduled executor service, is there a way to get the count of pending tasks in the queue?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
DC's . in LN and US
Want primaries + slaves in US, just replicas in LN
Want Sentinel HA
Want to hit the primaries+slaves in US when runnng service on US, LN would only be used with reconfigure/failover.

But it looks like the connection pool will try to spread over all slaves?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using RedissonTopic，subscribe sucess and when publish message, can subscribe message success. Bug after a few days,publish message success, but cannot subscribe message.
I found some errors in redis log:
[22387] 07 Oct 00:00:30.521 - Reading from client: Connection reset by peer
[22387] 07 Oct 00:00:30.521 - Reading from client: Connection reset by peer
[22387] 07 Oct 00:00:30.521 - Reading from client: Connection reset by peer
[22387] 07 Oct 00:00:30.521 - Reading from client: Connection reset by peer
There no error in my application.
redisson version is 3.10.0
RTopic topic = redissonClient.getTopic(CacheKeyUtil.getMyTopic());
listenerId = topic.addListener(RedisTopicModel.class, (channel, topicModel) -> {
LoggerUtil.info(getClass(), "redis topic listener,channel:{0},msg:{1}", channel, topicModel);
// do something
});
Is connection reset but no reconnect?How can I resolved ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
3.11.0
Redisson configuration
AtomicDouble这个方法去计算浮点是不精确的是不是考虑BigDecimal借鉴一下？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting following exception sometimes in my tomcat app which uses redisson client to connect to AWS Redis. it says java.lang.ClassNotFoundException: com.sun.proxy.$Proxy222 but I have all the jar files in the classpath. Could someone shed some light on this. Thanks
org.redisson.client.RedisException: Unexpected exception while processing command
	org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:403)
	org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:200)
	org.redisson.RedissonObject.get(RedissonObject.java:87)
	org.redisson.RedissonMap.readAllMap(RedissonMap.java:528)
	org.redisson.tomcat.RedissonSessionManager.findSession(RedissonSessionManager.java:149)
	org.apache.catalina.connector.Request.doGetSession(Request.java:2913)
	org.apache.catalina.connector.Request.getSession(Request.java:2310)
	org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:897)
	javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
	javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
	javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:229)
	org.apache.struts2.dispatcher.SessionMap.<init>(SessionMap.java:62)
	org.apache.struts2.dispatcher.Dispatcher.createContextMap(Dispatcher.java:645)
	org.apache.struts2.dispatcher.ng.PrepareOperations.createActionContext(PrepareOperations.java:82)
	org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:89)
	com.org.tester.web.filters.TesterSecurityWrapperFilter.doFilter(testerSecurityWrapperFilter.java:51)
	com.org.tester.web.filters.CSRFFilter.doFilter(CSRFFilter.java:59)
	org.apache.logging.log4j.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:64)
	com.org.tester.web.filters.ServiceBoundryInitFilter.doFilter(ServiceBoundryInitFilter.java:109)
	com.org.tester.web.filters.TesterSecurityWrapperFilter.doFilter(testerSecurityWrapperFilter.java:51)
	com.org.tester.web.filters.CSRFFilter.doFilter(CSRFFilter.java:59)
	org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)
	org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	org.apache.logging.log4j.web.Log4jServletFilter.doFilter(Log4jServletFilter.java:71)
root cause

java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME:com.sun.proxy.$Proxy222 loader:WebappClassLoader
  context: /orgv5
  delegate: false
  repositories:
    /WEB-INF/classes/
----------> Parent Classloader:
java.net.URLClassLoader@5e8f9e2d

	org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
	org.redisson.codec.FstCodec$1.decode(FstCodec.java:70)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330)
	org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:380)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)
	org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
	io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:656)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:591)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:508)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:470)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:909)
	io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	java.lang.Thread.run(Thread.java:748)
root cause

java.lang.RuntimeException: class not found CLASSNAME:com.sun.proxy.$Proxy222 loader:WebappClassLoader
  context: /orgv5
  delegate: false
  repositories:
    /WEB-INF/classes/
----------> Parent Classloader:
java.net.URLClassLoader@5e8f9e2d

	org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:235)
	org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190)
	org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173)
	org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478)
	org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(FSTObjectInput.java:635)
	org.nustaq.serialization.FSTObjectInput.readObjectCompatible(FSTObjectInput.java:574)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:559)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
	org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
	org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
	org.redisson.codec.FstCodec$1.decode(FstCodec.java:70)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330)
	org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:380)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)
	org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
	io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:656)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:591)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:508)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:470)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:909)
	io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	java.lang.Thread.run(Thread.java:748)
root cause

java.lang.ClassNotFoundException: com.sun.proxy.$Proxy222
	org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1720)
	org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1571)
	java.lang.Class.forName0(Native Method)
	java.lang.Class.forName(Class.java:348)
	org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:197)
	org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190)
	org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173)
	org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478)
	org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(FSTObjectInput.java:635)
	org.nustaq.serialization.FSTObjectInput.readObjectCompatible(FSTObjectInput.java:574)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:559)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713)
	org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566)
	org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374)
	org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
	org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
	org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
	org.redisson.codec.FstCodec$1.decode(FstCodec.java:70)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:330)
	org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:380)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343)
	org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:130)
	org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:110)
	io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
	io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:656)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:591)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:508)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:470)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:909)
	io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	java.lang.Thread.run(Thread.java:748)
note The full stack trace of the root cause is available in the Apache Tomcat logs.```
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have the next example https://github.com/kaa-ghub/redisson-sheduler.
Expected behavior
I assume there should be an API with which I could find out if there are running tasks for a given executor manager.
RScheduledExecutorService executor = redissonClient.getExecutorService("defaultExecutor");
Map<?> tasks = executor.getTasks();

Actual behavior
Each time when start the application, a new task is added and the running jobs are duplicated.
Steps to reproduce or test case
Run a example two or more times.
Redis version
5.0.3
Redisson version
3.11.2
Redisson configuration
https://github.com/kaa-ghub/redisson-sheduler/blob/master/config/application.yml
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
can use a different codec rather than the codec defined in config to encode and decode the object.
Actual behavior
it works when encoding, but doesn't work when decoding
Steps to reproduce or test case
        RBuckets buckets = client.getBuckets(StringCodec.INSTANCE);
        Map<String, String> items = buckets.get("buckets:A", "buckets:B", "buckets:C");

        items.put("buckets:A", "XYZ");
        items.put("buckets:B", "OPM");
        items.put("buckets:C", "123");

        buckets.set(items);
        items = buckets.get("buckets:A", "buckets:B", "buckets:C");
        Assert.assertEquals(3, items.size());
        Assert.assertEquals("XYZ", items.get("buckets:A")); // this line will be fail. because the value of this key is a byte array.
the issue should be in the CommandAsyncService.executeBatchedAsync function. when the Redis is not in cluster mode, the parameter codec is useless.
    private <T, R> RFuture<R> executeBatchedAsync(boolean readOnly, Codec codec, RedisCommand<T> command, SlotCallback<T, R> callback, String... keys) {
        if (!this.connectionManager.isClusterMode()) {
            return readOnly ? this.readAsync((String)null, command, keys) : this.writeAsync((String)null, command, keys); 
        } else {
            Map<MasterSlaveEntry, List<String>> range2key = new HashMap();
            String[] var7 = keys;
            int var8 = keys.length;

            ...
Redis version
5
Redisson version
3.11.4
Redisson configuration
        config = new Config();
        config.setCodec(ByteArrayCodec.INSTANCE)
              .useMasterSlaveServers()
              .setMasterAddress("redis://xxx.aws.com:6379")
              .addSlaveAddress("redis://xxx.aws.com:6379")
              .setConnectTimeout(5000)
              .setTimeout(2000)
              .setClientName("Tester")
              .setRetryInterval(500);


        client = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
不会存在非常多的RedisConnection，堆内存、cpu正常
Actual behavior
存在非常多的RedisConnection，新生代，年老代都接近100%，cpu达到300%
Steps to reproduce or test case
Redis version
4.0.8
Redisson version
3.10.1
Redisson configuration
Config config = new Config();
config.setNettyThreads(0).setThreads(0).setCodec(new JsonJacksonCodec()).setReferenceEnabled(true);
config.useSingleServer()
.setAddress("redis://"+"ip".concat(":").concat(String.valueOf(port)))
.setDatabase(1)
.setPassword("password")
.setIdleConnectionTimeout(10000)
.setPingConnectionInterval(30000)
.setPingTimeout(1000)
.setConnectTimeout(10000)
.setTimeout(3000)
.setRetryAttempts(3)
.setRetryInterval(1500)
.setSubscriptionsPerConnection(5)
.setClientName("none")
.setSubscriptionConnectionMinimumIdleSize(1)
.setSubscriptionConnectionPoolSize(50)
.setConnectionPoolSize(64)
.setConnectionMinimumIdleSize(10)
.setDnsMonitoringInterval(5000);
RedissonClient redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<dependency> <groupId>org.redisson</groupId> <artifactId>redisson-spring-data-18</artifactId> <version>3.11.3</version> <exclusions> <exclusion> <groupId>net.bytebuddy</groupId> <artifactId>byte-buddy</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>net.bytebuddy</groupId> <artifactId>byte-buddy</artifactId> <version>1.8.17</version> </dependency>
Steps to reproduce or test case
2019-10-15 10:15:26.640 | [redisson-netty-2-20] | [ERROR] | org.redisson.connection.SentinelConnectionManager - Can't execute SENTINEL commands on 10.145.0.227/10.145.0.227:26379 org.redisson.client.RedisTimeoutException: Command execution timeout for command: (SENTINEL GET-MASTER-ADDR-BY-NAME), params: [mymaster], Redis client: [addr=redis://10.145.0.227:26379] at org.redisson.client.RedisConnection$1.run(RedisConnection.java:209) at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127) at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Long.toUnsignedString0(Long.java:356) at java.lang.Long.toHexString(Long.java:272) at io.netty.buffer.ByteBufUtil$HexUtil.<clinit>(ByteBufUtil.java:1023) at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:139) at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:210) at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:380) at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:299) at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:271) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:233) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:173) at ch.qos.logback.classic.spi.LoggingEvent.getFormattedMessage(LoggingEvent.java:293) at ch.qos.logback.classic.spi.LoggingEvent.prepareForDeferredProcessing(LoggingEvent.java:206) at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:205) at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100) at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84) at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51) at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270) at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257) at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421) at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414) at ch.qos.logback.classic.Logger.warn(Logger.java:700) at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:461) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:455) at org.redisson.client.handler.CommandDecoder.decodeResult(CommandDecoder.java:444) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:438) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) 2019-10-15 10:15:26.646 | [redisson-netty-2-15] | [WARN ] | org.redisson.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [FAILED toString()], command: (SENTINEL SENTINELS), params: [mymaster] SLF4J: Failed toString() invocation on an object of type [io.netty.channel.socket.nio.NioSocketChannel] Reported exception: java.lang.NoClassDefFoundError: Could not initialize class io.netty.buffer.ByteBufUtil$HexUtil at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:139) at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:210) at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:380) at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:299) at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:271) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:233) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:173) at ch.qos.logback.classic.spi.LoggingEvent.getFormattedMessage(LoggingEvent.java:293) at ch.qos.logback.classic.spi.LoggingEvent.prepareForDeferredProcessing(LoggingEvent.java:206) at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:205) at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100) at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84) at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51) at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270) at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257) at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421) at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414) at ch.qos.logback.classic.Logger.warn(Logger.java:700) at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:461) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:455) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:340) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) 2019-10-15 10:15:31.600 | [redisson-netty-2-15] | [WARN ] | org.redisson.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [FAILED toString()], command: (QUIT), params: [] SLF4J: Failed toString() invocation on an object of type [io.netty.channel.socket.nio.NioSocketChannel] Reported exception: java.lang.NoClassDefFoundError: Could not initialize class io.netty.buffer.ByteBufUtil$HexUtil at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:139) at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:210) at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:380) at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:299) at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:271) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:233) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:173) at ch.qos.logback.classic.spi.LoggingEvent.getFormattedMessage(LoggingEvent.java:293) at ch.qos.logback.classic.spi.LoggingEvent.prepareForDeferredProcessing(LoggingEvent.java:206) at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:205) at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100) at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84) at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51) at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270) at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257) at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421) at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414) at ch.qos.logback.classic.Logger.warn(Logger.java:700) at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:461) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:455) at org.redisson.client.handler.CommandDecoder.decodeResult(CommandDecoder.java:444) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:438) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) 2019-10-15 10:15:31.602 | [redisson-netty-2-15] | [WARN ] | org.redisson.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [FAILED toString()], command: (SENTINEL GET-MASTER-ADDR-BY-NAME), params: [mymaster] SLF4J: Failed toString() invocation on an object of type [io.netty.channel.socket.nio.NioSocketChannel] Reported exception: java.lang.NoClassDefFoundError: Could not initialize class io.netty.buffer.ByteBufUtil$HexUtil at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:139) at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:210) at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:380) at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:299) at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:271) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:233) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:173) at ch.qos.logback.classic.spi.LoggingEvent.getFormattedMessage(LoggingEvent.java:293) at ch.qos.logback.classic.spi.LoggingEvent.prepareForDeferredProcessing(LoggingEvent.java:206) at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:205) at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100) at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84) at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51) at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270) at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257) at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421) at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414) at ch.qos.logback.classic.Logger.warn(Logger.java:700) at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:461) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:455) at org.redisson.client.handler.CommandDecoder.decodeResult(CommandDecoder.java:444) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:438) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) 2019-10-15 10:15:31.604 | [redisson-netty-2-15] | [WARN ] | org.redisson.client.handler.CommandDecoder - response has been skipped due to timeout! channel: [FAILED toString()], command: (SENTINEL SLAVES), params: [mymaster] 2019-10-15 10:15:31.606 | [[ACTIVE] ExecuteThread: '4' for queue: 'weblogic.kernel.Default (10.145.0.225:2181)] | [INFO ] | org.apache.zookeeper.ClientCnxn - Socket connection established to 10.145.0.225/10.145.0.225:2181, initiating session SLF4J: Failed toString() invocation on an object of type [io.netty.channel.socket.nio.NioSocketChannel] Reported exception: java.lang.NoClassDefFoundError: Could not initialize class io.netty.buffer.ByteBufUtil$HexUtil at io.netty.buffer.ByteBufUtil.hexDump(ByteBufUtil.java:139) at io.netty.channel.DefaultChannelId.asShortText(DefaultChannelId.java:210) at io.netty.channel.AbstractChannel.toString(AbstractChannel.java:380) at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:299) at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:271) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:233) at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:173) at ch.qos.logback.classic.spi.LoggingEvent.getFormattedMessage(LoggingEvent.java:293) at ch.qos.logback.classic.spi.LoggingEvent.prepareForDeferredProcessing(LoggingEvent.java:206) at ch.qos.logback.core.OutputStreamAppender.subAppend(OutputStreamAppender.java:205) at ch.qos.logback.core.OutputStreamAppender.append(OutputStreamAppender.java:100) at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84) at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51) at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270) at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257) at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421) at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414) at ch.qos.logback.classic.Logger.warn(Logger.java:700) at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:461) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:455) at org.redisson.client.handler.CommandDecoder.decodeResult(CommandDecoder.java:444) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:438) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745)
Redis version
4.0
Redisson version
3.11.3
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Trying to remove multiple records through transaction , when executing case after 4,5 successful iteration,  transaction commitAsync doesnt return at all. test generator keeps waiting indefinitely.
around 2k size of testSet
Steps to reproduce or test case
`	try {
		for (String test : testSet) {
			transaction.getSetCache(DETAILS+ test.toString())
					.remove(testId);
		}
        
		tHandle.future = transaction.commitAsync();

	} catch (Exception exp) {
		transaction.rollbackAsync();

	}`

Redis version
5.0.4
Redisson version
3.11.4
Redisson configuration
defaults clustered server, nettyThread 64
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using following function code to insert data in redis :
public List<Map<JioNSSFSnssai, HashSet>> getAmfIdForTaiListSnssaiPair(List taiList) {
List<Map<JioNSSFSnssai, HashSet>> resMap = new ArrayList<>();
RBatch batch = redissonClient.createBatch(BatchOptions.defaults());
for(JioNSSFTai tai :taiList) {
batch.getMapCache("mapName").getAsync(tai);
}
    BatchResult<?> res = batch.execute();

    for(int i=0 ;i<res.getResponses().size();i++) {
        Map<JioNSSFSnssai, HashSet<String>>mapData =(Map<JioNSSFSnssai, HashSet<String>>)res.getResponses().get(i);
        resMap.add(mapData);
        
    }
    return resMap;
}

Value is a Map whose key is : JioNSSFSnssai
and Have defined this class as following with over-riding equals and hashcode :
public class JioNSSFSnssai {
@SerializedName("sst")
private Integer sst = null;

@SerializedName("sd")
private String sd = null;

public Integer getSst() {
	return sst;
}

public void setSst(Integer sst) {
	this.sst = sst;
}

public String getSd() {
	return sd;
}

public void setSd(String sd) {
	this.sd = sd;
}

@Override
public String toString() {
	return "JioNSSFSnssai [sst=" + sst + ", sd=" + sd + "]";
}

@Override
public boolean equals(Object o) {
	if (this == o) return true;
	if (o == null || getClass() != o.getClass()) return false;
	JioNSSFSnssai snssai = (JioNSSFSnssai) o;
	return com.google.common.base.Objects.equal(sst, snssai.sst) &&
			com.google.common.base.Objects.equal(sd, snssai.sd);
}

@Override
public int hashCode() {
	int resp=com.google.common.base.Objects.hashCode(sst, sd);
	return resp;
}

}
I see that HashCode of values key(JIONSSFSNSSAI) obtained from redis has changes , not sure whats the reason for it ?
As a result I can't perform operations on the obtained Map since equals and hashcode don't match to the same key.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello @mrniko
We are facing an issue when using redisson with Elasticache with replication.
We are writing some 100K key value pairs to a map and then renaming it. Then we immediately attempt to read the same. It fails and redisson reports that the key does not exist.
Note that we have default values of read mode (SLAVE) and scan interval (1000ms) . Can you please suggest if changing to MASTER_SLAVE read mode can help in this. Also are there any configurations on redisson that we can try with.
Thanks,
Yash

Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I want to migrate data from an old Redis cluster to a new one programmatically, so I did this :
            legacyRedisClient.getKeys()
                .getKeys()
                .forEach(key -> {
                    LOGGER.info("Redis Migration : Migrating key {}", key);
                    Optional.of(legacyRedisClient.getBucket(key))
                            .filter(RObject::isExists)
                            .map(RBucket::get)
                            .ifPresent(value -> {
                                LOGGER.info("Redis Migration : Storing element with key {}", key);
                                RBucket<Object> bucket = encryptedRedisClient.getBucket(key);
                                bucket.set(value);
                                bucket.expire(48L, DAYS);
                            });
                });

The problem with this, is that I when I do RBucket::get, Redisson try to decode the value with a class that is not necessarily in the classpath (because that was set by an other microservice).
Is there a way to disable decoding in Redisson ? Or a better way to do this ?
Redis version
3.2.6
Redisson version
3.11.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Connects to Redis on AWS
Actual behavior
Netty throws an exception trying to resolve the hostname:
Caused by: io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'ec2-54-234-206-155.compute-1.amazonaws.com]' failed to resolve 'ec2-54-234-206-155.compute-1.amazonaws.com].ec2.internal' after 3 queries

Somehow, there is a ] added to the hostname (ec2-54-234-206-155.compute-1.amazonaws.com]), even though my redisson.json does not contain one.
Steps to reproduce or test case
Click this button to deploy the repro example for free on Heroku:

Then view the logs (you may need to restart the app if you want to view the logs in the browser because it crashes).
Or you may run this sample app with a command like:
$ java -jar webapp-runner.jar --session-store redis --session-store-pool-size 5 target/heroku-redisson-test.war

Redis version
5.0
Redisson version
3.11.4 (appeared in 3.11.01 and possibly earlier but not before 3.10.0)
Redisson configuration
{"singleServerConfig":{"idleConnectionTimeout":10000,"pingTimeout":1000,"connectTimeout":10000,"timeout":5000,"retryAttempts":3,"retryInterval":1500,"password":"pb9e2626905755078bb5c0fa4d482a19e5871b66645aac0c8650794d3c6e742f2","subscriptionsPerConnection":5,"sslEnableEndpointIdentification":true,"sslProvider":"JDK","
pingConnectionInterval":0,"keepAlive":false,"tcpNoDelay":false,"address":"redis://<redacted>:<redacted>@ec2-54-234-206-155.compute-1.amazonaws.com:15319","subscriptionConnectionMinimumIdleSize":1,"subscriptionConnectionPoolSize":50,"connectionMinimumIdleSize":5,"connectionPoolSize":5,"database":0,"dnsMonitoringInterval
":5000},"threads":16,"nettyThreads":32,"codec":{"class":"org.redisson.codec.FstCodec"},"referenceEnabled":true,"transportMode":"NIO","lockWatchdogTimeout":30000,"keepPubSubOrder":true,"decodeInExecutor":false,"useScriptCache":false,"minCleanUpDelay":5,"maxCleanUpDelay":1800,"addressResolverGroupFactory":{"class":"org.redisson.connection.DnsAddressResolverGroupFa
ctory"}}
Other information
Tomcat 8.5.47
The source code for the webapp-runner code that sets up Redisson can be found on Github.
Full error:
SEVERE: The session manager failed to start
org.apache.catalina.LifecycleException: io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'ec2-34-226-17-251.compute-1.amazonaws.com]' failed to resolve 'ec2-34-226-17-251.compute-1.amazonaws.com].ec2.internal' after 3 queries
	at org.redisson.tomcat.RedissonSessionManager.buildClient(RedissonSessionManager.java:354)
	at org.redisson.tomcat.RedissonSessionManager.startInternal(RedissonSessionManager.java:237)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5182)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1412)
	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1402)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'ec2-34-226-17-251.compute-1.amazonaws.com]' failed to resolve 'ec2-34-226-17-251.compute-1.amazonaws.com].ec2.internal' after 3 queries
	at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:925)
	at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:884)
	at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:356)
	at io.netty.resolver.dns.DnsResolveContext.onResponse(DnsResolveContext.java:543)
	at io.netty.resolver.dns.DnsResolveContext.access$400(DnsResolveContext.java:64)
	at io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:400)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at io.netty.resolver.dns.DnsQueryContext.setSuccess(DnsQueryContext.java:204)
	at io.netty.resolver.dns.DnsQueryContext.finish(DnsQueryContext.java:196)
	at io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:1320)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931)
	at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:700)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514)
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Amazon ElastiCache Redis cluster mode, Redis version:  3.2.4
Redisson version: 3.11.x Community version.
Java version: Oracle 1.8
App: Spring boot 1.5.22 with spring-data-redis 1.8.23
Hi,
When I deploy my app to Amazon dev server, after about 24 to 28 hours, I got the following log:
2019-10-20 03:50:26.532  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots added to redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:26.532  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots removed from redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:26.533  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 18432 slots found to add --- MDC: {, , , , }
2019-10-20 03:50:31.543  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots added to redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:31.543  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots removed from redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:31.547  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 28672 slots found to add --- MDC: {, , , , }
2019-10-20 03:50:36.557  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots added to redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:36.557  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots removed from redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:36.558  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 28672 slots found to add --- MDC: {, , , , }
2019-10-20 03:50:41.575  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots added to redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:41.576  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 16384 slots removed from redis://10.5.3.207:6379 --- MDC: {, , , , }
2019-10-20 03:50:41.581  INFO 10880 --- [redisson-netty-2-5] o.r.c.ClusterConnectionManager           : 28672 slots found to add --- MDC: {, , , , }
And my app sometimes throws exception when it gets data from redis.
I have such issue in redisson 3.11.0.to 3.11.4
If I switch back to redisson 3.10.7, then it is ok. Please help to fix it. Thank you very much.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Session object is stored in Redis
Actual behavior
Getting the following error trying to enable session replication via Redisson:
21-Oct-2019 14:15:42.488 SEVERE [http-nio2-8086-exec-9] org.apache.coyote.http11.Http11Processor.service Error processing request
java.lang.ClassCastException: org.apache.catalina.session.StandardManager cannot be cast to org.redisson.tomcat.RedissonSessionManager
at org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:55)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:798)
at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806)
at org.apache.tomcat.util.net.Nio2Endpoint$SocketProcessor.doRun(Nio2Endpoint.java:1735)
at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
at org.apache.tomcat.util.net.AbstractEndpoint.processSocket(AbstractEndpoint.java:1069)
at org.apache.tomcat.util.net.Nio2Endpoint$Nio2SocketWrapper$3.completed(Nio2Endpoint.java:575)
at org.apache.tomcat.util.net.Nio2Endpoint$Nio2SocketWrapper$3.completed(Nio2Endpoint.java:553)
at sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:126)
at sun.nio.ch.Invoker$2.run(Invoker.java:218)
at sun.nio.ch.AsynchronousChannelGroupImpl$1.run(AsynchronousChannelGroupImpl.java:112)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
at java.lang.Thread.run(Thread.java:748)
Steps to reproduce or test case
Tomcat Version 8.0.14
Redis version
Redisson version
redisson-tomcat-8-3.11.5
Redisson configuration
singleServerConfig:
address: "redis://${REDIS_HOST}:${REDIS_PORT}"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /
at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:744)
at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:353)
at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:340)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:633)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
集合比对，求差集
Actual behavior
Caused by: java.io.IOException: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:364)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:408)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:373)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:199)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:139)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
Steps to reproduce or test case
public Set sdiffSet(String setSourceKey, String setDestKey) {
RSet sourceSet = redissonClient.getSet(setSourceKey);
	return sourceSet.readDiff(setDestKey);
}

Redis version
3.10.5
Redisson version
Redisson configuration
redis.pool.lock.waitTime=30000
redis.pool.lock.leaseTime=10000
redis.pool.cache.hostPrefix=redis://
redis.pool.cache.servers=redis1:7000,redis2:7000,redis3:7000,redis1:7001,redis2:7001,redis3:7001
redis.pool.cache.password=xxxxxx
redis.pool.cache.lockWatchTime=20
redis.pool.cache.cluserMaxAttempts=20
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
redis里的key显示为 limit:api:test=123
Actual behavior
redis里的key显示为： limit:api:limit:api:test=123
Steps to reproduce or test case
public static String wrap(String key){
return "limit:api": + key
}
bucket = redisson.getBucket(wrap(“test”), codec)
bucket.set(“123”);
Redis version
3.2.9
Redisson version

			org.redisson
			redisson-spring-boot-starter
			${redisson-spring-boot-starter.version.version}
			
				
					org.redisson
					redisson-spring-data-21
				
				
					spring-boot-actuator-autoconfigure
					org.springframework.boot
				
			
		
		
			org.redisson
			redisson-spring-data-20
			${redisson-spring-boot-starter.version.version}
		
### Redisson configuration
clusterServersConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
reconnectionTimeout: 3000
failedAttempts: 3
subscriptionsPerConnection: 5
clientName: null
slaveSubscriptionConnectionMinimumIdleSize: 1
slaveSubscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
nodeAddresses:
- "redis://risk-redis1:7000"
- "redis://risk-redis1:7001"
- "redis://risk-redis2:7002"
- "redis://risk-redis2:7003"
- "redis://risk-redis3:7004"
- "redis://risk-redis3:7005"
scanInterval: 1000
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
transportMode: NIO
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2440
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
I just submitted two questions that didn't work. The reason is that I pressed the wrong key(ctrl + enter on windows). I'm sorry to be embarrassed. My problem is that I use springboot version 2.1.11.RELEASE and the redisson-spring-boot-starter version is 3.11.  .6, the error is the same as the title. I checked issue 2478 and suggested that he downgrade to redisson-spring-data-21. If it is redisson-spring-boot-starter, what version should he downgrade to?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RSet<String> set = client.getSet(msg.getSlot()); set.expireAsync(2, TimeUnit.HOURS); set.add(msg.getUserId());
我如何判断已经设置过过期时间了
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 版本：2.15.2
jdk: 1.7
redis: 3.0.504
执行环境就是在main函数里面测试了一下。不是分布式环境
Config config = new Config();
		config.useSentinelServers()
		    .setMasterName("redis-master")
		    .addSentinelAddress("redis://127.0.0.1:27000","redis://127.0.0.1:27001","redis://127.0.0.1:27002");
		RedissonClient redissonClient = Redisson.create(config);
		RSet<String> set = redissonClient.getSet("test_reduce");
	    set.add("gdxxw_123");
	    set.add("gdxxw_1234");
	    set.add("gdxxw_1235");
	    set.add("guizhou_123");
	    set.add("guizhou_124");

	    RCollectionMapReduce<String, String, Integer> mapReduce
        = set.<String, Integer>mapReduce()
              .mapper(new OnlineSiteRCollectionMapper())
            .reducer(new OnlineSiteRReducer());

		
		Map<String, Integer> mapToNumber = mapReduce.execute();
		System.out.println(mapToNumber.toString());

public class OnlineSiteRCollectionMapper implements
		RCollectionMapper<String, String, Integer> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	@Override
	public void map(String value, RCollector<String, Integer> collector) {
		if(value!=null){
			String[] s = value.split("_");
			collector.emit(s[0], 1);
		}
	}

}

public class OnlineSiteRReducer implements RReducer<String, Integer> {
	private static final long serialVersionUID = 1L;
	@Override
	public Integer reduce(String reducedKey, Iterator<Integer> iter) {
		System.out.println(reducedKey);
		int sum=0;
		while(iter.hasNext()){
			sum++;
		}
		return sum;
	}
}

卡在mapReduce.execute();那没有任何反应，阻塞在那里也不报错！
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 3.11.4 版本 RedissonBuckets类 第86行，mget获取的返回值不应该用ConcurrentHashMap接收，会报空指针异常，希望LZ能改成HashMap
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Actual behavior
Caused By: java.lang.NullPointerException ·
CommandEncoder.java:131org.redisson.client.handler.CommandEncoder.encode
CommandEncoder.java:100org.redisson.client.handler.CommandEncoder.encode
CommandBatchEncoder.java:52org.redisson.client.handler.CommandBatchEncoder.encode
CommandBatchEncoder.java:32org.redisson.client.handler.CommandBatchEncoder.encode
MessageToByteEncoder.java:107io.netty.handler.codec.MessageToByteEncoder.write
CommandBatchEncoder.java:45org.redisson.client.handler.CommandBatchEncoder.write
AbstractChannelHandlerContext.java:706io.netty.channel.AbstractChannelHandlerContext.invokeWrite0
AbstractChannelHandlerContext.java:698io.netty.channel.AbstractChannelHandlerContext.invokeWrite
AbstractChannelHandlerContext.java:780io.netty.channel.AbstractChannelHandlerContext.write
AbstractChannelHandlerContext.java:691io.netty.channel.AbstractChannelHandlerContext.write
ChannelDuplexHandler.java:106io.netty.channel.ChannelDuplexHandler.write
CommandsQueue.java:97org.redisson.client.handler.CommandsQueue.write
AbstractChannelHandlerContext.java:706io.netty.channel.AbstractChannelHandlerContext.invokeWrite0
AbstractChannelHandlerContext.java:753io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush
AbstractChannelHandlerContext.java:778io.netty.channel.AbstractChannelHandlerContext.write
AbstractChannelHandlerContext.java:747io.netty.channel.AbstractChannelHandlerContext.writeAndFlush
DefaultChannelPipeline.java:1031io.netty.channel.DefaultChannelPipeline.writeAndFlush
AbstractChannel.java:310io.netty.channel.AbstractChannel.writeAndFlush
CommandsQueue.java:123org.redisson.client.handler.CommandsQueue.sendData
CommandsQueue.java:100org.redisson.client.handler.CommandsQueue.write
Redis version
Seen on versions 3 and 4
Redisson version
3.11.7-SNAPSHOT (latest as of a couple weeks ago)
Redisson configuration
Master-Slave Cluster configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#2477
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
最近使用RedissonSpringCacheManager，缓存清理延迟，看wiki有了说明，但是不明白为什么一次最多清理100条，而且时间有递增，这是出于什么考虑呢？望解惑！
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在使用如上方式配置，构造codec实例时，报初始化方法不存在，如下是异常栈：
Caused by: java.lang.NoSuchMethodException: org.redisson.codec.TypedJsonJacksonCodec.()
at java.lang.Class.getConstructor0(Class.java:3082)
at java.lang.Class.getDeclaredConstructor(Class.java:2178)
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:80)
... 82 common frames omitted
redisson版本3.11.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Calling RBlockingQueue.takeLastAndOfferFirstTo(otherQueue)  should block until an element is available.
Actual behavior
When the queue is empty RBlockingQueue.takeLastAndOfferFirstTo(otherQueue) returns null immediately.
Steps to reproduce or test case
// running from a Runnable submitted to redisson.getExecutorService()
RBlockingQueue q = redisson.getBlockingQueue("qName");
Object item = q.takeLastAndOffsetFirstTo("otherQueue");
assert item == null;
Redis version
5.0.3
Redisson version
3.11.6
Redisson configuration
single server configuration - all defaults
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When submitting a task to a Redisson executor service the task is run in the state at the time of submit().
Meaning: when i submit at task at some time X the code in the body of that task must execute exactly as it was at time X. If in the meantime the task code is modified and a new task is submitted at time Y, the code as it was submitted at time Y must be executed.
Actual behavior
Both code-at-time-X and code-at-time-Y are executed, randomly. This leads to unpredictable behaviour.
Actually it seems more than one version of the code is cached and one is randomly picked for execution. This was proved by adding log statements.
When restarting the app one of the versions would be executed.
It's not documented how to clear this cache.
Steps to reproduce or test case
BASIC:
Create a Runnable that delegates part of the execution to a spring bean. (using the bean factory obtained from the spring context)
Submit the Runnable in different versions, making sure it "prints" some different debugging output during execution, so it's possible to know which version is running.
CASE 1: in one of the versions i changed the type of data i write to a redis list from string to a json object. BOTH versions were running! That means RANDOMLY some tasks would write a json and some others a string. The service somehow caches the code to run.
CASE 2: the code caching became even more evident when the code was refactored (and one method eliminated). AFTER RESTART the executor service was expecting (for NEWLY submitted tasks) the deleted class to be present, and failed with a no-such-method-error
Redis version
5.0.3
Redisson version
3.11.6
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
CommandReactiveService.java
always return value, so i can check is exists
Expected behavior
future.onComplete((v, e) -> {
if (e != null) {
emitter.error(e);
return;
}
                emitter.next(v);
                emitter.complete();
            });

Actual behavior
future.onComplete((v, e) -> {
if (e != null) {
emitter.error(e);
return;
}
                if (v != null) {
                    emitter.next(v);
                }
                emitter.complete();
            });

Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is observed only when a key is already put in the map. When key is not available it is working as expected. put operation was successful but after that when we try to get the value of the key, following exception is taken. Using redis elastic cache 5.0.6 with redisson 3.11.3
aused by: org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:354) ~[redisson-3.11.3.jar:?]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:158) ~[redisson-3.11.3.jar:?]
at org.redisson.RedissonObject.get(RedissonObject.java:94) ~[redisson-3.11.3.jar:?]
at org.redisson.RedissonMap.get(RedissonMap.java:266) ~[redisson-3.11.3.jar:?]
at com.pega.platform.datagridredis.internal.cache.redisson.RedissonCache.get(RedissonCache.java:59) ~[datagrid-redis.jar:?]
... 10 more
Caused by: java.io.IOException: java.lang.reflect.InvocationTargetException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) ~[redisson-3.11.3.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.13.Final.jar:?]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) ~[netty-common-4.1.13.Final.jar:?]
... 1 more
Caused by: java.lang.reflect.InvocationTargetException
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_171]
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_171]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_171]
at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_171]
at org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(FSTObjectInput.java:609) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectCompatible(FSTObjectInput.java:574) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:559) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) ~[redisson-3.11.3.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.13.Final.jar:?]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) ~[netty-common-4.1.13.Final.jar:?]
... 1 more
Caused by: java.lang.NullPointerException
at java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:1250) ~[?:1.8.0_171]
at java.io.ObjectInputStream.checkArray(ObjectInputStream.java:1292) ~[?:1.8.0_171]
at java.io.ObjectInputStream.access$200(ObjectInputStream.java:214) ~[?:1.8.0_171]
at java.io.ObjectInputStream$1.checkArray(ObjectInputStream.java:262) ~[?:1.8.0_171]
at java.util.concurrent.CopyOnWriteArrayList.readObject(CopyOnWriteArrayList.java:993) ~[?:1.8.0_171]
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_171]
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_171]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_171]
at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_171]
at org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(FSTObjectInput.java:609) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectCompatible(FSTObjectInput.java:574) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:559) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectFields(FSTObjectInput.java:713) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadNoSer(FSTObjectInput.java:566) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:374) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:215) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:153) ~[redisson-3.11.3.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) ~[redisson-3.11.3.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:367) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265) ~[netty-codec-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458) ~[netty-transport-4.1.13.Final.jar:?]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) ~[netty-common-4.1.13.Final.jar:?]
at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138) ~[netty-common-4.1.13.Final.jar:?]
... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Background: The use Redis do session sharing. Session is currently shared by three projects
Problem: After logining in to a service, the service does not operate for a long time. When the timeout time set by the service tomcat is reached, even if other services are still in operation, there will be a forced exit. However, as long as one service is still in use, we do not want it to exit because one of the services has reached the timeout period.
Is there a good solution?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a convenience method for FLUSHALL? Would be super helpful during development.
https://redis.io/commands/flushall
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Env: Tomcat/8.5.35
Deploying spring boot as web application :
Spring Boot v2.1.6.RELEASE
Spring v5.1.8.RELEASE
the web app contains
@EnableCaching spring annotation
in tomcat lib I have following jars:
redisson-all-3.11.1-SNAPSHOT.jar
redisson-tomcat-8-3.11.1-SNAPSHOT.jar
During web app boot from tomcat here is the exception:
java.lang.IllegalStateException: Error processing condition on org.springframework.boot.actuate.autoconfigure.audit.AuditAutoConfiguration$AuditEventRepositoryConfiguration
        at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:59)
        at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:108)
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator.shouldSkip(ConfigurationClassBeanDefinitionReader.java:447)
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:128)
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:117)
        at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:327)
        at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:232)
        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275)
        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95)
        at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:705)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:531)
        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742)
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:311)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:151)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:131)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:91)
        at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:171)
        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5245)
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)
        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:985)
        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:522)
        at java.util.concurrent.FutureTask.run(FutureTask.java:277)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1160)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:811)
Caused by: java.lang.IllegalStateException: Failed to introspect Class [org.redisson.spring.cache.RedissonCacheStatisticsAutoConfiguration] from ClassLoader [java.net.URLClassLoader@ccf6af1b]
        at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:507)
        at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:404)
        at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:389)
        at org.springframework.util.ReflectionUtils.getUniqueDeclaredMethods(ReflectionUtils.java:447)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$$Lambda$299.00000000147FF510.apply(Unknown Source)
        at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1671)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(AbstractAutowireCapableBeanFactory.java:738)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:679)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:647)
        at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1518)
        at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1023)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanTypeForNonAliasDefinition(BeanTypeRegistry.java:190)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanTypeForNonAliasDefinition(BeanTypeRegistry.java:157)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanType(BeanTypeRegistry.java:150)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.updateTypesIfNecessary(BeanTypeRegistry.java:138)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry$$Lambda$297.0000000013A73830.accept(Unknown Source)
        at java.util.Iterator.forEachRemaining(Iterator.java:127)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.updateTypesIfNecessary(BeanTypeRegistry.java:133)
        at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getNamesForType(BeanTypeRegistry.java:97)
        at org.springframework.boot.autoconfigure.condition.OnBeanCondition.collectBeanNamesForType(OnBeanCondition.java:268)
        at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getBeanNamesForType(OnBeanCondition.java:261)
        at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getBeanNamesForType(OnBeanCondition.java:250)
        at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchingBeans(OnBeanCondition.java:170)
        at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchOutcome(OnBeanCondition.java:145)
        at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:46)
        ... 30 common frames omitted
Caused by: java.lang.NoClassDefFoundError: org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider
        at java.lang.ClassLoader.defineClassImpl(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:377)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:154)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:729)
        at java.net.URLClassLoader.access$400(URLClassLoader.java:95)
        at java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:1184)
        at java.security.AccessController.doPrivileged(AccessController.java:730)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:604)
        at java.lang.ClassLoader.loadClassHelper(ClassLoader.java:924)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:869)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:852)
        at java.lang.Class.getDeclaredMethodsImpl(Native Method)
        at java.lang.Class.getDeclaredMethods(Class.java:929)
        at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:489)
        ... 54 common frames omitted
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider
        at java.net.URLClassLoader.findClass(URLClassLoader.java:609)
        at java.lang.ClassLoader.loadClassHelper(ClassLoader.java:924)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:869)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:852)
        ... 68 common frames omitted

The missing class 'org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider' is in spring-boot-actuator-2.1.6.RELEASE.jar that is inside the web application inside WEB-INF/lib folder
I guess the issue is because the redisson library is inside tomcat system lib and the introspection happens from the web application -  e.g. different classloaders - I guess redisson tomcat lib can't load classes from war file where the CacheMeterBinderProvider class is located - If I remove redisson lib from tomcat the web application deploys and functions as intended
If I put a break point into org.springframework.util.ReflectionUtils method's getDeclaredMethods
where the exception occur here is the exception stack trace from this method and exception that occur:
The getDeclaredMethods is invoked with parameter "org.redisson.spring.cache.RedissonCacheStatisticsAutoConfiguration" for bean redissonCacheMeterBinderProvider
here is the exception :
java.lang.NoClassDefFoundError: org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider
	at java.lang.ClassLoader.defineClassImpl(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:377)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:154)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:729)
	at java.net.URLClassLoader.access$400(URLClassLoader.java:95)
	at java.net.URLClassLoader$ClassFinder.run(URLClassLoader.java:1184)
	at java.security.AccessController.doPrivileged(AccessController.java:730)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:604)
	at java.lang.ClassLoader.loadClassHelper(ClassLoader.java:924)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:869)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:852)
	at java.lang.Class.getDeclaredMethodsImpl(Native Method)
	at java.lang.Class.getDeclaredMethods(Class.java:929)
	at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:489)
	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:404)
	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:389)
	at org.springframework.util.ReflectionUtils.getAllDeclaredMethods(ReflectionUtils.java:434)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getCandidateFactoryMethods(BeanTypeRegistry.java:257)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getFactoryMethod(BeanTypeRegistry.java:243)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getFactoryMethod(BeanTypeRegistry.java:238)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getFactoryMethodReturnType(BeanTypeRegistry.java:217)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanTypeForNonAliasDefinition(BeanTypeRegistry.java:188)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanTypeForNonAliasDefinition(BeanTypeRegistry.java:157)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.addBeanType(BeanTypeRegistry.java:150)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.updateTypesIfNecessary(BeanTypeRegistry.java:138)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry$$Lambda$292.0000000018682530.accept(Unknown Source)
	at java.util.Iterator.forEachRemaining(Iterator.java:127)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.updateTypesIfNecessary(BeanTypeRegistry.java:133)
	at org.springframework.boot.autoconfigure.condition.BeanTypeRegistry.getNamesForType(BeanTypeRegistry.java:97)
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.collectBeanNamesForType(OnBeanCondition.java:268)
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getBeanNamesForType(OnBeanCondition.java:261)
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getBeanNamesForType(OnBeanCondition.java:250)
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchingBeans(OnBeanCondition.java:170)
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchOutcome(OnBeanCondition.java:145)
	at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:46)
	at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:108)
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator.shouldSkip(ConfigurationClassBeanDefinitionReader.java:447)
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:128)
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:117)
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:327)
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:232)
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:275)
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:95)
	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:705)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:531)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:311)
	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:151)
	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:131)
	at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:91)
	at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:171)
	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5245)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)
	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)
	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:985)
	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:522)
	at java.util.concurrent.FutureTask.run(FutureTask.java:277)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1160)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:811)
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider
	at java.net.URLClassLoader.findClass(URLClassLoader.java:609)
	at java.lang.ClassLoader.loadClassHelper(ClassLoader.java:924)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:869)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:852)
	... 65 more

Note there are no "org.springframework" libs in Tomcat lib directory (only inside war lib directory).
The class "org.springframework.boot.actuate.metrics.cache.CacheMeterBinderProvider" is defined only inside /WEB-INF/lib/spring-boot-actuator-2.1.6.RELEASE.jar of the war file (no such class inside tomcat lib or another jar file inside the war file)
If I define this inside spring boot web app in the @configuration:
@EnableAutoConfiguration(excludeName = {"org.redisson.spring.cache.RedissonCacheStatisticsAutoConfiguration"})

Then I get this exception:
org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'servletEndpointRegistrar' defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method 'servletEndpointRegistrar' threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cachesEndpoint' defined in class path resource [org/springframework/boot/actuate/autoconfigure/cache/CachesEndpointAutoConfiguration.class]: Unsatisfied dependency expressed through method 'cachesEndpoint' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cacheManager' defined in class path resource [org/springframework/boot/autoconfigure/cache/JCacheCacheConfiguration.class]: Unsatisfied dependency expressed through method 'cacheManager' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jCacheCacheManager' defined in class path resource [org/springframework/boot/autoconfigure/cache/JCacheCacheConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.cache.CacheManager]: Factory method 'jCacheCacheManager' threw exception; nested exception is java.lang.IllegalStateException: Default configuration hasn't been specified!
        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:155)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)
        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742)
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:311)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:151)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:131)
        at org.springframework.boot.web.servlet.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:91)
        at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:171)
        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5245)
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)
        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:985)
        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:522)
        at java.util.concurrent.FutureTask.run(FutureTask.java:277)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1160)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:811)

So I can't exclude redisson auto configuration. The javax.cache package is only defined inside redisson;s lib redisson-all-3.11.1-SNAPSHOT.jar - there are no javax.cache packages bundled with the war file
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using Redisson PRO 3.11.6.
The destroy() method on RedissonConnectionFactory is empty. When the RedissonConnectionFactory creates its own RedissonClient using the default constructor or the constructor that takes a Config as an argument, it should be responsible for calling shutdown() on the created RedissonClient. The RedissonClient is internal to the class and cannot be shutdown otherwise.
To safely manage resources, we must use the constructor that takes a RedissonClient argument so that the client has an external reference that we can shutdown.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@Value("${spring.redis.addresses}")
private String addresses;

@Bean
public RedissonClient redissonClient() {
            Config config = new Config();
            String[] addressList = addresses.split(",");
            config.useClusterServers().addNodeAddress(addressList);
            return Redisson.create(config);
}

addresses地址发生变化,redisson如何感知到?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
read from redis cluster  properly

Actual behavior
read nothing from redis clsuter

Steps to reproduce or test case
1. redis cluster(5.*) with password 
2 run the following code. When we use the following code to set an value(CC) for key(cc),when these codes runs on redis version of 4.*,  CC will be printed, But when it runs on redis cluster of version 5.*, null will be printed. But when we use command (get cc) in redis-cli console, we could get the value 'CC' of key 'cc' 

    RBucket rBucket = redisson.getBucket("cc");

    rBucket.set("CC");

    String v = ( String) rBucket.get();

    System.out.println(v);

Redis version
I test on redis 5.0.7 and redis4.0.11

Redisson version
 3.12.0

Redisson configuration
no special configuration.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
public static RedissonClient getRedis() {
RedissonClient rediss = ApplicationContextKeeper.getAppCtx().getBean(RedissonClient.class);
rediss.getConfig().setCodec(new FstCodec()); // 会一直撑爆内存
return rediss;
}
Actual behavior
Steps to reproduce or test case
Redis version
4.0.1
Redisson version
3.11.4
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException,ERR Error running script (call to f_762bfafa6be221431a0b668685dd15c926483619): @user_script:1: user_script:1: attempt to compare nil with number . channel: [id: 0xc180c731, L:/172.31.0.110:52122 - R:xx-api.tflohd.0001.cnn1.cache.amazonaws.com.cn/172.31.25.58:6379] command: (EVAL), params: [while true do local firstThreadId2 = redis.call('lindex', KEYS[2], 0);if firstThreadId2 == false the..., 3, lock:charge:pre:5de9b5bd1b92990740f5114d, redisson_lock_queue:{lock:charge:pre:5de9b5bd1b92990740f5114d}, redisson_lock_timeout:{lock:charge:pre:5de9b5bd1b92990740f5114d}, 500, 371bc7b9-7504-4614-a4e5-747c37fb9580:14401, 5000, 1578030638778]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
有一个工具类可能多条线程都要同时调用的，大概这么写的
private static RedissonClient client;

@Autowired
public 构造方法(RedissonClient redissonClient){
client=redissonClient;
}

public static put(String key,String value){
    client.getMap("固定的name").put(key,value);
}
而我看里面每一次getMap都是一次new RedissonMap()。
由于name固定的，那我能不能将静态redissonClient直接换成静态RMap，就不用每次调用时都实例化一次RedissonMap：
//private static RedissonClient client;
private static RMap<String,String> map;

@Autowired
public 构造方法(RedissonClient redissonClient){
    //client=redissonClient;
    map=redissonClient.getMap("固定的name");
}

public static put(String key,String value){
    //client.getMap("固定的name").put(key,value);
    map.put(key,value);
}
这样修改的话有没有问题，效率上会变快吗，有没有线程安全之类的问题可能会出现？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am creating tiny redis cache library for all running java based microservices using redisson. This library will be used by all spring boot and and non spring boot microservices.
I am using below maven dependency for redission:
<dependency>
 	   <groupId>org.redisson</groupId>
 	   <artifactId>redisson</artifactId>
 	   <version>3.12.0</version>
 </dependency>

And using below implementation for redisson bean creation
@Configuration
public class RedissionClient {

	@Bean
	public RedissonClient init(@Value("${redishostname}") String host, @Value("${redisport}") String port) {
		Config config = new Config();
		String url = "redis://"+ host + ":" + port;
        config.useSingleServer().setAddress(url);
        return Redisson.create(config);
	}
}

Above configuration works well when I use this library with non spring boot based application.
But it fails with spring boot based application. I saw that redissonClient try to connect to local redis instance instead of configuration provided by me in application.properties.
It works when I used below configration in application.properties
spring.redis.host=${redis_host:172.28.221.76}
spring.redis.port=${redis_port:6379}
But being a common library I can not use above configuration for non spring boot based application.
Is there a way where I can force redissonClient to be created with custom configuration instead of default configuration ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@aaabramov
No.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, i just want to change the codec from org.redisson.codec.FstCodec to org.redisson.codec.JsonJacksonCodec,so i write the redisson.yml:
codec: !<org.redisson.codec.JsonJacksonCodec> {}
but when i run the application, it calls exception:
Caused by: java.lang.IllegalArgumentException: server(s) address(es) not defined!
...

my spring-application.yml is
spring:
  redis:
    database: 0
    port: 6379
    host: 127.0.0.1
    redisson:
      config: 'classpath:/redisson.yml'
in org.redisson.spring.starter.RedissonAutoConfiguration#redisson,i find code
if (redissonProperties.getConfig() != null) {
	// read config from redisson.yml
	...
} else if (redisProperties.getSentinel() != null) {
	// read config from spring-application.yml
	...
} else if (clusterMethod != null && ReflectionUtils.invokeMethod(clusterMethod, redisProperties) != null) {
	// read config from redisProperties using cluster server
	...
} else {
	// read config from redisProperties using single server
	...
}
so, i must write server config in redisson.yml again.
singleServerConfig:
  address: 'redis://127.0.0.1:6379'
  database: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
Is there anyway to merge  redisson.yml and  spring-application.yml?
redisson version is:
redissonVersion = '3.11.6'
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How is redisson meant to be used with AWS Elasticache? Would love to see a full example with multiple shards, dynamically fetching node addresses, failover handling, node health monitoring etc.
This link gives a very minimal example, I think a production ready example would be super helpful to anyone using redisson with AWS elasticache.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps to reproduce or test case

Establish a connection to a single-server Redis
Subscribe to a topic using Redisson
Kill the network or restart Redis

Expected behavior

Existing subscriptions should be closed when connection to Redis is lost
(and/or) subscriptions should re-subscribe when connection becomes possible again

Actual behavior
The subscriptions are left in a zombie state where they're not connected and will never receive any data. Even if a new connection from the same JVM is established to Redis once it's available again, and it publishes data on the topic, the zombie subscription never receives it.
Redis version
5.0.5
Redisson version
3.11.6
Redisson configuration
new Config().useSingleServer().setAddress(url)
Notes
It's ok that Redisson doesn't resubscribe when connection becomes available, but at the bare minimum it'd be super helpful if it closes the subscription or gave me an event to listen to or something so that I could handle it myself. I've tried all the options like keep-alive etc and there doesn't seem to be any workaround.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Deserialization the object from redis to RList throws InvocationTargetException
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Deserialization the object from redis to RList throws InvocationTargetException
redisson:3.12.0
fst:2.56
1.8.0_152
stacktrace:
Caused by: java.lang.reflect.InvocationTargetException: null at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at org.redisson.command.RedisExecutor.getCodec(RedisExecutor.java:681) ... 109 common frames omitted Caused by: java.lang.NoSuchMethodError: org.nustaq.serialization.FSTConfiguration.getJsonFieldNames()Lorg/nustaq/serialization/coders/FSTJsonFieldNames; at org.redisson.codec.FstCodec.copy(FstCodec.java:201) at org.redisson.codec.FstCodec.<init>(FstCodec.java:190) ... 114 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
配置文件中的地址全是阿里云的外网地址  不过通过 cluster nodes命令获取到的myself节点的地址是内网地址
导致在连接myself节点的时候使用的地址变成内网

这里既然知道myself节点的外网地址是否可以选择使用外网还是内网 而不是通过 cluster nodes的方式获取
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
Redission collection is used in my application (single jar) and want to package needed classes without all optional dependencies to reduce app size.
Describe the solution you'd like
Split feature (optional dependencies are used) as sub module.
Describe alternatives you've considered
Remove all optional dependencies java classes from my jar (Follow dependency document in wiki). But I don't think it is right approach and whether have potential problems.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Given both redis sentinel and redis master/slave are protected by passwords, Redisson should be able to establish a connection through sentinel.
Actual behavior
Scheme ( redis or rediss) is not being forwarding from the Redis Sentinel URI to the URI created in order to connect the Redis node.
Following exception is returned:

Caused by: java.lang.IllegalArgumentException: Redis url should start with redis:// or rediss:// (for SSL connection)
at org.redisson.misc.RedisURI.(RedisURI.java:36) ~[redisson-3.12.0.jar:3.12.0]
at org.redisson.connection.SentinelConnectionManager.convert(SentinelConnectionManager.java:595) ~[redisson-3.12.0.jar:3.12.0]
at org.redisson.connection.SentinelConnectionManager.(SentinelConnectionManager.java:172) ~[redisson-3.12.0.jar:3.12.0]
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:197) ~[redisson-3.12.0.jar:3.12.0]
at org.redisson.Redisson.(Redisson.java:120) ~[redisson-3.12.0.jar:3.12.0]
at org.redisson.Redisson.create(Redisson.java:160) ~[redisson-3.12.0.jar:3.12.0]
at com.phoenixnap.poc.redis.configuration.RedisConfiguration.redissonClient(RedisConfiguration.java:84) ~[classes/:na]
at com.phoenixnap.poc.redis.configuration.RedisConfiguration$$EnhancerBySpringCGLIB$$54482668.CGLIB$redissonClient$0() ~[classes/:na]
at com.phoenixnap.poc.redis.configuration.RedisConfiguration$$EnhancerBySpringCGLIB$$54482668$$FastClassBySpringCGLIB$$d929cc1f.invoke() ~[classes/:na]
at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.2.2.RELEASE.jar:5.2.2.RELEASE]
at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.2.2.RELEASE.jar:5.2.2.RELEASE]
at com.phoenixnap.poc.redis.configuration.RedisConfiguration$$EnhancerBySpringCGLIB$$54482668.redissonClient() ~[classes/:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.2.2.RELEASE.jar:5.2.2.RELEASE]
... 47 common frames omitted

Steps to reproduce or test case
Setup a password protected Redis Sentinel/Redis nodes and try to connect using useSentinelServers config.
I replicated this using docker:
Docker compose:

version: '2'
networks:
app-tier:
driver: bridge
services:
redis:
image: 'bitnami/redis:latest'
environment:
- REDIS_PASSWORD=some_pass
networks:
- app-tier
redis-sentinel:
image: 'bitnami/redis-sentinel:latest'
environment:
- REDIS_MASTER_HOST=redis
- REDIS_SENTINEL_PASSWORD=some_pass
- REDIS_SENTINEL_QUORUM=1
ports:
- '26379:26379'
networks:
- app-tier

Using the following configuration:

    final Config config = new Config();
    config.useSentinelServers()
            .setTimeout(1000000)
            .setPassword("some_pass")
            .addSentinelAddress("redis://127.0.0.1:26379")
            .setMasterName("mymaster");
    final RedissonClient redissonClient = Redisson.create(config);


Redis version
Using latest bitnami redis docker image as shown above.
Redisson version
3.12.0
Redisson configuration

    final Config config = new Config();
    config.useSentinelServers()
            .setTimeout(1000000)
            .setPassword("some_pass")
            .addSentinelAddress("redis://127.0.0.1:26379")
            .setMasterName("mymaster");
    final RedissonClient redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Spring Boot RedissonAutoConfiguration there is the need for post customizing the autoconfigured RedissonClient.
Would you consider a pull request with this functionality?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use RDelayedQueue hit an bug.
The code is as below:
RBlockingQueue blockingFairQueue = redissonClient.getBlockingQueue(topicName);
RDelayedQueue delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);
delayedQueue.offer(delayJob, 5, TimeUnit.SECONDS);
Expected behavior
I expect the job can be executed after 5 second.
Actual behavior
In my prod environment, I found almost all job is executed after 5 second, but only a few jobs were executed immediately(do not delay 5 seconds)
Steps to reproduce or test case
It is hard to reproducde, only a few jobs were executed immediately in each day
Redis version
redis_version:3.2.12
Redisson version
3.11.6
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Float
Actual behavior
No exception is thrown
Steps to reproduce or test case
@test
public void testBucketFloat(){
String key = dcsConfigProperties.getRedisPrefix() + ":test:" + "test-bucket-string";
RBucket asset = redissonClient.getBucket(key);
asset.set(42.00F);
Float a = asset.get();
Assert.assertEquals(42.00F,a,0.001);
}
Redis version
3.2.11
Redisson version
3.11.6
Redisson configuration
codec: org.redisson.codec.TypedJsonJacksonCodec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
最近将redisson版本升到了3.11.5，然后测试了一下redisson的重连机制，然后出现了一个奇怪的现象。在Linux上部署redis集群，然后在本地Windows上进行连接测试。如果使用在Linux上使用iptables切断连接，在连接恢复后不可用连接会重连；但如果在Windows上使用IP安全策略来切断连接，在连接恢复后，不可用连接没有重连。请问一下，这两种方式之间有什么不一样的地方吗？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
We are using Redisson with AWS elasticache redisson cluster. Redisson client throws exception from some of the hosts. Only way to recover is to reboot the EC2 instances/restart the application. Slaves are reachable from the EC2.
Actual behavior
Redisson client fails with the following exception eventhough slaves are reachable from EC2.
Caused by: org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries.  Disconnected hosts: [10.0.129.98/10.0.129.98:6379]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:219) ~[Redisson-3.11.x.jar:?]
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30) ~[Redisson-3.11.x.jar:?]
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:248) ~[Redisson-3.11.x.jar:?]
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:464) ~[Redisson-3.11.x.jar:?]
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:607) ~[Redisson-3.11.x.jar:?]
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:645) ~[Redisson-3.11.x.jar:?]
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116) ~[Redisson-3.11.x.jar:?]
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:245) ~[Redisson-3.11.x.jar:?]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:663) ~[netty-common-4.1.21.Final.jar:?]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:738) ~[netty-common-4.1.21.Final.jar:?]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:466) ~[netty-common-4.1.21.Final.jar:?]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.21.Final.jar:?]
Steps to reproduce or test case
Exception happens very randomly in production.
Redis version
5.0.6
Redisson version
3.11.6
Redisson configuration
config.setNettyThreads(256)
.useClusterServers()
.addNodeAddress(redisUrl)
.setTimeout(200)
.setRetryInterval(50)
.setMasterConnectionPoolSize(128)
.setMasterConnectionMinimumIdleSize(32)
.setSlaveConnectionPoolSize(128)
.setSlaveConnectionMinimumIdleSize(32)
.setPingConnectionInterval(5000)
.setKeepAlive(true);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I try to upgrade redisson from 3.8.2 to the version after 3.11.2. The following code breaks.
public class Demo {
	
	private SingleServerConfig singleServerConfig;
	
	public void test() throws URISyntaxException {
		
		singleServerConfig.setSslKeystore(new URI("test"));
		
	}
}

The code should pass, but it throws an error:
Demo.java:[15,51] incompatible types: java.net.URI cannot be converted to java.net.URL
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RRateLimiter don't allow query the remain permits for now . so i can not get the permits . i think add a method like :
int remain()


may be well .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
我用spring中的@Cacheable时，从数据库中取出来准备序列化存到redis中的数据是Byte类型，但是再从redis中查出来返回的却是Integer，这个是需要修改redisson的数据序列化方式吗？我试了一下包装类Short、Byte都会变成Integer，Character会变成String，Float会变成Double。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Might be connected to #2120, but I wasn't too sure about that, so I decided to create a new issue instead.
Expected behavior
No memory leak?
Actual behavior
SentinelConnectionManager is leaking memory because it stores too many connections to the sentinels in the nodeConnections map.
We are using a singleton Redisson instance for connecting to our replicated Redis instance (3 nodes, 3 sentinels). After running for some days, we are experiencing high GC times and OOM errors. Upon investigating the heap dump, we noticed that the SentinelConnectionManager stores nearly 50,000 connection to the same 3 sentinels in its nodeConnections map. However, the sentinels map itself only contains the expected 3 entries.

I tried analyzing and reproducing the leak myself, but I wasn't too successful since I am not familiar with your code. Would be great if you could have a look what could cause such a behavior :)
Unfortunately can't provide the heap dump since it might contain sensitive data.
Steps to reproduce or test case
N/A
Redis version
4.0.2
Redisson version
3.11.3
Redisson configuration
config.useSentinelServers().setMasterName("mymaster")
    .addSentinelAddress(redisSentinelAddress)
    .setPassword("")
    .setReadMode(ReadMode.MASTER)
    .setSubscriptionMode(SubscriptionMode.MASTER)
    .setMasterConnectionPoolSize(64)
    .setRetryInterval(2000)
    .setRetryAttempts(3)
    .setConnectTimeout(1000)
    .setTimeout(5000);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko Can you please take a look at the checks. I can't figure out why the linter is failing.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
服务在运行时,打印的错误日志,在工程中只用到了下面代码,但不确定是不是在执行下面的代码报出来的error日志
...
RLock rLock = redissonClient.getLock(LOCK);
...
rLock.tryLock(1, 3, TimeUnit.SECONDS);
...
rLock.unlock();
error日志如下:
[2020-01-09 10:39:45 ERROR] [nioEventLoopGroup-2-9] [CommandDecoder.java:316] - Error message from Redis: ERR handle request, command 'SUBSCRIBE' is not allowed channel: [id: 0x67a5ab14, L:/serverIp: serverPort - R:redis-serverIp/redis-serverIp:redis-serverPort]
[2020-01-09 10:39:46 ERROR] [nioEventLoopGroup-2-9] [CommandDecoder.java:316] - Error message from Redis: ERR handle request, command 'UNSUBSCRIBE' is not allowed channel: [id: 0x67a5ab14, L:/serverIp: serverPort - R:redis-serverIp/redis-serverIp:redis-serverPort]
Redis version
3.2.11
Redisson version
3.10.0
Redisson configuration
@bean
public RedissonClient redissonClient() {
Config config = new Config();
config.useSingleServer().setAddress("redis://" + redis-serverIp + ":" + redis-serverPort);
config.setEventLoopGroup(new NioEventLoopGroup());
config.setCodec(JsonJacksonCodec.INSTANCE);
return Redisson.create(config);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does the Redisson（BLPOP） support multily key？
Just like BLPOP key [key …]，When multiple key parameters are given, check each list in order of parameter key, and the first non empty list header element will pop up
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RLock
lock.isHeldByCurrentThread() verification  before unlocking
but sometimes exception
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:400)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:204)
at org.redisson.RedissonObject.get(RedissonObject.java:94)
at org.redisson.RedissonLock.isHeldByThread(RedissonLock.java:521)
at org.redisson.RedissonLock.isHeldByCurrentThread(RedissonLock.java:515)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are interested in running Sentinel behind a L4 proxy terminating TLS.  This sentinel will report a master at IP:master_port.  This master is behind a second L4 proxy terminating TLS on a port we plan to infer from the reported master_port.   Ideally, Redisson would offer Sentinel + Master over TLS, with the ability to configure a port mapping function to take master_port and translate it to the L4 proxy port terminating TLS in front of the master.   As an aside, our model does not require us to translate either the sentinel or master IP, but the Lettuce example below fully allows that.
Here is the equivalent Lettuce 5.2.2 (due out 2/11/2020) code:
package com.example;

import io.lettuce.core.RedisClient;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.sync.RedisCommands;
import io.lettuce.core.internal.HostAndPort;
import io.lettuce.core.resource.ClientResources;
import io.lettuce.core.resource.DnsResolvers;
import io.lettuce.core.resource.MappingSocketAddressResolver;
import org.junit.Test;

public class TestApp {

    @Test
    public void testLettuceSentinel() {
        final MappingSocketAddressResolver portMapper = MappingSocketAddressResolver.create(DnsResolvers.UNRESOLVED,
                                                                                            hostAndPort -> {
                                                                                                int port = hostAndPort.port;
                                                                                                switch (port) {
                                                                                                    case 6380:
                                                                                                        port = port + 1;  
                                                                                                        break;
                                                                                                }
                                                                                                System.out.printf("mapping: %s to %s:%d\n", hostAndPort.toString(), hostAndPort.hostText, port);
                                                                                                return HostAndPort.of(hostAndPort.hostText, port);
                                                                                            });

        final ClientResources clientResources = ClientResources.builder().socketAddressResolver(portMapper).build();

        final RedisClient redisClient = RedisClient.create(clientResources, "rediss-sentinel://192.168.99.1:26381/0#mymaster");

        try (final StatefulRedisConnection<String, String> connection = redisClient.connect()) {
            System.out.println("connected");

            final RedisCommands<String, String> redisCommands = connection.sync();
            redisCommands.clientSetname("blah");

            final String result = redisCommands.set("foo", "bar");
            System.out.printf("set foo result=%s\n", result);

            final String foo = redisCommands.get("foo");
            System.out.printf("get foo=%s\n", foo);
        }
        redisClient.shutdown();
    }
}

Describe alternatives you've considered
Many.  Including putting the sentinel / master cluster behind an F5 load balancer terminating TLS and let the F5 choose the master.  Clients program to the F5 over plain Redis API over TLS.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 6e3d30b7-83b1-433a-9335-5e8b9916d3ac thread-id: 731
at org.redisson.RedissonLock.lambda$unlockAsync$3(RedissonLock.java:580)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
at org.redisson.command.RedisExecutor.handleReference(RedisExecutor.java:483)
at org.redisson.command.RedisExecutor.handleSuccess(RedisExecutor.java:476)
at org.redisson.command.RedisExecutor.handleResult(RedisExecutor.java:461)
at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:447)
at org.redisson.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:169)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:444)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:439)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:370)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:493)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:271)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson version: 3.12.0
When using ipv6, we get the following error:
java.lang.IllegalArgumentException: java.net.MalformedURLException: Invalid host: [[22be:ffee:0:f101::328]
at org.redisson.misc.RedisURI.(RedisURI.java:54)
at org.redisson.connection.SentinelConnectionManager.convert(SentinelConnectionManager.java:595)
at org.redisson.connection.SentinelConnectionManager.(SentinelConnectionManager.java:167)
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:197)
at org.redisson.Redisson.(Redisson.java:120)
at org.redisson.Redisson.create(Redisson.java:160)
...
Caused by: java.net.MalformedURLException: Invalid host: [[22be:ffee:0:f101::328]
at java.net.URL.(URL.java:627)
at java.net.URL.(URL.java:490)
at java.net.URL.(URL.java:439)
at org.redisson.misc.RedisURI.(RedisURI.java:49)
... 82 common frames omitted
Caused by: java.lang.IllegalArgumentException: Invalid host: [[22be:ffee:0:f101::328]
at java.net.URLStreamHandler.parseURL(URLStreamHandler.java:195)
at java.net.URL.(URL.java:622)
... 85 common frames omitted
It seems that in org.redisson.connection.SentinelConnectionManager#createAddress, the square bracket is added to the address; then in new RedisURI(), the square bracket was added AGAIN.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
**We use redis distributed delay queues for queuing data for future process and connecting to redis using node from each shard in cluster. Around 10% of the data is lost due to these errors.
Redis client version -3.9.1
We see RedisConnectionException and RedisResponseTimeoutException**
org.redisson.client.RedisConnectionException:
SlaveConnectionPool no available Redis entries.  Disconnected hosts: [1.2.4.3/1.1.1.1:6379]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:217)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:244)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:471)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:580)
at org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:814)
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:671)
at org.redisson.command.CommandAsyncService$10.run(CommandAsyncService.java:760)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
RedisResponseTimeoutException: Redis server response timeout (3000 ms) occurred for command:".
Here is the complete error.
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured for command: (EVAL) with params: [local result = {}; local items = redis.call('lrange', KEYS[1], 0, -1); for i, v in ipairs(items) do ..., 1, redisson_delay_queue:{delayEventQueue-e-prod}] channel: [id: 0x0f2e4a10, L:/ - R:]
at org.redisson.command.CommandAsyncService$13.run(CommandAsyncService.java:882)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at java.lang.Thread.run(Thread.java:748)
Redis configuration is below.  We have configured single node from each shard, what is the recommended approach for node configuration, cluster endpoint or nodes from each shard?
{
"clusterServersConfig": {
"idleConnectionTimeout": 10000,
"pingTimeout": 1000,
"connectTimeout": 10000,
"timeout": 3000,
"retryAttempts": 3,
"retryInterval": 1500,
"reconnectionTimeout": 3000,
"failedAttempts": 3,
"password": null,
"subscriptionsPerConnection": 5,
"clientName": "realTimeEventScheduler",
"loadBalancer": {
"class": "org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"slaveSubscriptionConnectionMinimumIdleSize": 1,
"slaveSubscriptionConnectionPoolSize": 50,
"slaveConnectionMinimumIdleSize": 10,
"slaveConnectionPoolSize": 64,
"masterConnectionMinimumIdleSize": 10,
"masterConnectionPoolSize": 64,
"readMode": "SLAVE",
"nodeAddresses": [
"redis://node:6379",
"redis://node:6379",
"redis://node:6379",
"redis://node:6379"
],
"scanInterval": 1000
},
"threads": 0,
"nettyThreads": 0,
"codec": null,
"useLinuxNativeEpoll": false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello
I have a bug in redisson
i have many server who need to be connected on redis
when the first one start all work fine it is connected
but when the second one start the server freeze and there is no error log
it freeze when i call Redisson.create(config)
it's the same program than the first server so i don't understand why it don't work
someone as any idea ?
EDIT!
the only error i've found is this summon when i try to login to the server, it will crash and restart and print me this:
Current Thread: Server thread [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 	PID: 17 | Suspended: false | Native: false | State: WAITING [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 	Stack: [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		sun.misc.Unsafe.park(Native Method) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.util.concurrent.CompletableFuture$Signaller.block(CompletableFuture.java:1707) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3323) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.util.concurrent.CompletableFuture.waitingGet(CompletableFuture.java:1742) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1947) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:172) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:39) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.connection.MasterSlaveConnectionManager.initEntry(MasterSlaveConnectionManager.java:286) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.connection.MasterSlaveConnectionManager.init(MasterSlaveConnectionManager.java:246) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:164) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:49) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:231) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.Redisson.<init>(Redisson.java:115) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.redisson.Redisson.create(Redisson.java:154) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		fr.akame.core.database.redis.RedisAccess.initRedisson(RedisAccess.java:45) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		fr.akame.core.database.redis.RedisAccess.<init>(RedisAccess.java:23) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		fr.akame.core.database.redis.RedisAccess.init(RedisAccess.java:28) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		fr.akame.core.Main$1.run(Main.java:54) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.bukkit.craftbukkit.v1_8_R3.scheduler.CraftTask.run(CraftTask.java:59) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		org.bukkit.craftbukkit.v1_8_R3.scheduler.CraftScheduler.mainThreadHeartbeat(CraftScheduler.java:352) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		net.minecraft.server.v1_8_R3.MinecraftServer.B(MinecraftServer.java:783) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		net.minecraft.server.v1_8_R3.DedicatedServer.B(DedicatedServer.java:378) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		net.minecraft.server.v1_8_R3.MinecraftServer.A(MinecraftServer.java:713) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		net.minecraft.server.v1_8_R3.MinecraftServer.run(MinecraftServer.java:616) [14:01:05] [PaperSpigot Watchdog Thread/ERROR]: 		java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis: 5.0.12
Redisson: 3.12.0
The following code snippet will successfully create and lock RLock and will throw RedisException unlocking the lock.
   RLock lock = client.getLock("lock-test");
   lock.lock();
   lock.unlock();

org.redisson.client.RedisException: ERR Error running script (call to f_3ffe249c16dee540ac8ab32e39bd408626b9aff7): @user_script:1: ERR hash value is not an integer . channel: [id: 0x7c579845, L:/my-ip:port - R:host/my-ip:port] command: (EVAL), params: [if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call('h..., 2, lock-test, redisson_lock__channel:{lock-test}, 0, 30000, 62ad3063-9ff4-4a24-bfe1-bd08254b2968:1]

	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:351)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:199)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:139)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I tried Master Slave configuration for redission-mybatis. I want to set 'master' only for writer and 'slave' for read only. But when is set master slave configuration i can see master is also used for reading purpose.
Can i set configuration in which 'master' work only as writer not reader?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
delay queue still work
Actual behavior
delay queue doesn't work
Steps to reproduce or test case
Redis version
3.2.12
Redisson version
3.12.0
Configration:
slaveConnectionMinimumIdleSize: 8
slaveConnectionPoolSize: 50
masterConnectionMinimumIdleSize: 8
masterConnectionPoolSize: 50
throw follow exception continuous, but the the APP host acctualy has ony 7 connection
Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=11834, addr=redis://10.10.14.61:6382, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local expiredValues = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #exp..., 3, transfer_ttl_queue, redisson_delay_queue_timeout:{transfer_ttl_queue}, redisson_delay_queue:{transfer_ttl_queue}, 1579602478857, 100] after 0 retry attempts
org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=11834, addr=redis://10.10.14.61:6382, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local expiredValues = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #exp..., 3, transfer_ttl_queue, redisson_delay_queue_timeout:{transfer_ttl_queue}, redisson_delay_queue:{transfer_ttl_queue}, 1579602478857, 100] after 0 retry attempts
thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our application uses UUIDs for keys and stores them in a RMapCache<String, Boolean>. Clearing 3MB of expired keys currently takes about 10 minutes though even a trivial service load can generate 5-7MB/min. Is there a way to increase the frequency of the eviction task, or increase the batch size of objects that are expired ?
Currently using a default configuration, connecting to a 3-node Redis cluster in Sentinel mode.
Dependencies:
redisson:redisson-spring-boot-starter:3.11.1
org.springframework.boot:spring-boot-starter-parent:2.1.2.RELEASE
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
I have about 100,000 redis object should be persist into Redis.
And they are of several data types. each data type will associate with others.
In other word, they form a cycle.
If I use RCascadeType.PERSIST, the program will stuck. Because it is gone into an infinite loop.
Describe the solution you'd like

regisiter rlo class method should record all the classes that user need to persist
add a new method to calculate the class's adjacencyArrays.
persist vertex classes
construct relationships according to adjacencyArrays.

Describe alternatives you've considered
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Working with replicaof server.
Returning data when using RedisDesktopManager. But when I tried to create client following exception occurs with RedissonPromise
01-23 19:52:03.408 20281-20281/com.example.uhf E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.uhf, PID: 20281 java.lang.NoClassDefFoundError: org.redisson.misc.RedissonPromise at org.redisson.connection.MasterSlaveConnectionManager.shutdown(MasterSlaveConnectionManager.java:663) at org.redisson.connection.MasterSlaveConnectionManager.shutdown(MasterSlaveConnectionManager.java:643) at org.redisson.connection.MasterSlaveConnectionManager.stopThreads(MasterSlaveConnectionManager.java:727) at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:363) at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:167) at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:191) at org.redisson.Redisson.<init>(Redisson.java:120) at org.redisson.Redisson.create(Redisson.java:160) 
I am using
 implementation 'org.redisson:redisson:3.12.6'
using config
config.useMasterSlaveServers() .setMasterAddress("redis://<master ip> <master port>") .setReadMode(ReadMode.SLAVE) .addSlaveAddress("redis://<replica ip> <replica port>"); config.setCodec(JsonJacksonCodec.INSTANCE);
same exception occurs using config.useSingleServer()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There was almost no load on the system and it has almost no activity with only one idle connection  (we keep two connections in reserve - connectionMinimumIdleSize: 2) and the freeConnectionsCounter=63  (out of  connectionPoolSize: 64).
How come we received the “Command still hasn't been written into connection” error message? It seems like something was preventing Redisson from sending commands to Redis, resulting in a timeout exception...
org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=1, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=rediss://example8872.redis.cache.windows.net:6380], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@491802721 [redisClient=[addr=rediss:// example8872.redis.cache.windows.net:6380], channel=[id: 0xdfc88972, L:/10.23.209.100:55594 - R: example8872.redis.cache.windows.net/52.111.71.236:6380], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@52cca638(failure: java.util.concurrent.CancellationException)], command=(HMSET), params=[p-bb:redisson:tomcat_session:EFE72C79B569DA602D9867772D1BA0D3, PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), PooledUnsafeDirectByteBuf(freed), ...], codec=org.redisson.codec.CompositeCodec@2ae5abfe]], command: (HGETALL), params: [p-bb:redisson:tomcat_session:EFE72C79B969DA602D9865372D1BA0D3] after 5 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:202) ~[redisson-all.jar:3.11.6]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:680) ~[netty-common-4.1.32.Final.jar:3.11.6]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:755) ~[netty-common-4.1.32.Final.jar:3.11.6]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:483) ~[netty-common-4.1.32.Final.jar:3.11.6
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.32.Final.jar:3.11.6]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_212]

singleServerConfig:
idleConnectionTimeout: 30000
connectTimeout: 30000
timeout: 5000
retryAttempts: 5
retryInterval: 5000
subscriptionsPerConnection: 5
clientName: null
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 2
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 10000
threads: 32
nettyThreads: 64
codec: !<org.redisson.codec.FstCodec> {}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello there.
I try to use Redisson for schedule tasks in my Spring Boot application. And I have the next issue: after application restart with graceful shutdown - Redison scheduled executor service is in shutdown state, and all my tasks are rejected with exception
java.util.concurrent.RejectedExecutionException: Task rejected. ExecutorService is in shutdown state
Here is my code:
I use Distributed scheduled executor service like a bean
@Configuration
public class RedissonScheduledExecutorConfig {

    private static final String EXECUTOR_SERVICE_NAME = "rScheduledExecutor";

    @Bean
    public RScheduledExecutorService rScheduledExecutorService(
            final RedissonClient redissonClient,
            final BeanFactory beanFactory
    ) {
        final WorkerOptions workerOptions = WorkerOptions.defaults().workers(1).beanFactory(beanFactory);
        final ExecutorOptions executorOptions = ExecutorOptions.defaults()
                .taskRetryInterval(0, TimeUnit.SECONDS);
        final RScheduledExecutorService executorService = redissonClient
                .getExecutorService(EXECUTOR_SERVICE_NAME, executorOptions);
        executorService.registerWorkers(workerOptions);
        return executorService;
    }

}

Send the task to executor:
@RestController
@RequiredArgsConstructor
public final class TestController {

    private final RScheduledExecutorService rScheduledExecutorService;

    @GetMapping("/test")
    public String test() {
        final RScheduledFuture<?> rScheduledFuture = this.rScheduledExecutorService.schedule(
                new RunnableTask(),
                60,
                TimeUnit.SECONDS
        );
    }

}

Task implementation:
public final class RunnableTask implements Runnable, Serializable {

    private static final long serialVersionUID = 1L;

    @Autowired
    private transient MyService myService;

    @Override
    public void run() {
        this.myService.sendEmail();
    }

}

I use spring boot version - 2.1.7.RELEASE, and redisson-spring-boot-starter with version 3.11.5
Thank you for any help!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonReactiveZSetCommands.zCount behaves incorrectly if one of range bounds is unbounded.
if lower bound is unbounded:
actual value: 0
expected value: -inf
if upper bound is unbounded:
actual value: -1
expected value: +inf
btw this is how RedissonReactiveZSetCommands.zRangeByScore implemented.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we set TTL into CacheConfig when the cache is initially created. Is there a way to change that AFTER creation?
we are caching an api endpoint and would like to return stale objects even after expiry.
one way to achieve this is to check the downstream api and if not responding then extend ttl to use the existing stale object.

@bean("xxCacheManager")
CacheManager getCM(RedissonClient redissonClient) {
CacheConfig cacheConf = new CacheConfig();
cacheConf.setTTL(...);
Map<String, CacheConfig> configs = new HashMap<String, CacheConfig>() {{ put("xxCacheManager", cacheConf); }};
return new RedissonSpringCacheManager(redissonClient,configs);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for your contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello guys,
I've setup Redission, Redission-Hibernate and Spring Data Cache to work with Spring Boot.
Pom definition:
	<properties>
		<redisson-spring-boot-starter.version>3.11.6</redisson-spring-boot-starter.version>
	</properties>

		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
		</dependency>

		<!-- redisson configuration begin -->
		<!-- For more information refer to documentation: https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter#spring-boot-starter -->
		<dependency>
			<!-- for Spring Data Redis v.2.1.x -->
			<groupId>org.redisson</groupId>
			<artifactId>redisson-spring-data-21</artifactId>
			<version>${redisson-spring-boot-starter.version}</version>
		</dependency>
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson-spring-boot-starter</artifactId>
			<version>${redisson-spring-boot-starter.version}</version>
		</dependency>
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson-hibernate-53</artifactId>
			<version>${redisson-spring-boot-starter.version}</version>
		</dependency>
		<!-- redisson configuration end -->


When I start the application I'm getting the following warning:
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.nustaq.serialization.FSTClazzInfo (file:/XXX/.m2/repository/de/ruedigermoeller/fst/2.57/fst-2.57.jar) to field java.lang.String.value
WARNING: Please consider reporting this to the maintainers of org.nustaq.serialization.FSTClazzInfo
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release


When I start the application through eclipse application lunch, everything works fine. But when I create my application jar (mvn package), and run it by prompt command and issue a request for a cached resource, I'm getting the following error:
ERROR 2020-01-27 16:46:41,393 [redisson-netty-5-11] org.redisson.client.handler.CommandDecoder:decodeCommand(212): Unable to decode data. channel: [id: 0x2137d2ce, L:/127.0.0.1:22780 - R:localhost/127.0.0.1:9000], reply: ReplayingDecoderByteBuf(ridx=122, widx=122), command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, Location, redisson__timeout__set:{Location}, redisson__idle__set:{Location}, redisson__map_cache__last_access__set:{Location}, {Location}:redisson_options, 1580150801152, PooledUnsafeDirectByteBuf(ridx: 0, widx: 470, cap: 512)]
java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME:org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl loader:jdk.internal.loader.ClassLoaders$AppClassLoader@c387f44
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar!/:?]
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) [redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) [redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-3.11.6.jar!/:3.11.6]
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) [netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at java.lang.Thread.run(Thread.java:835) [?:?]
Caused by: java.lang.RuntimeException: class not found CLASSNAME:org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl loader:jdk.internal.loader.ClassLoaders$AppClassLoader@c387f44
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:235) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]
        ... 24 more
Caused by: java.lang.ClassNotFoundException: org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl
        at jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) ~[?:?]
        at jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[?:?]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[?:?]
        at java.lang.Class.forName0(Native Method) ~[?:?]
        at java.lang.Class.forName(Class.java:415) ~[?:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:197) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]
        ... 24 more
WARN  2020-01-27 16:46:41,401 [redisson-netty-5-11] io.netty.channel.DefaultChannelPipeline:onUnhandledInboundException(1152): An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME:org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl loader:jdk.internal.loader.ClassLoaders$AppClassLoader@c387f44
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [netty-transport-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.45.Final.jar!/:4.1.45.Final]
        at java.lang.Thread.run(Thread.java:835) [?:?]
Caused by: java.io.IOException: java.lang.RuntimeException: class not found CLASSNAME:org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl loader:jdk.internal.loader.ClassLoaders$AppClassLoader@c387f44
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar!/:?]
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.11.6.jar!/:3.11.6]
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        ... 17 more
Caused by: java.lang.RuntimeException: class not found CLASSNAME:org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl loader:jdk.internal.loader.ClassLoaders$AppClassLoader@c387f44
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:235) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.11.6.jar!/:3.11.6]
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        ... 17 more
Caused by: java.lang.ClassNotFoundException: org.hibernate.cache.spi.support.AbstractReadWriteAccess$SoftLockImpl
        at jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) ~[?:?]
        at jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[?:?]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[?:?]
        at java.lang.Class.forName0(Native Method) ~[?:?]
        at java.lang.Class.forName(Class.java:415) ~[?:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:197) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.classForName(FSTClazzNameRegistry.java:190) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:173) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar!/:?]
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar!/:?]
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) ~[redisson-3.11.6.jar!/:3.11.6]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.11.6.jar!/:3.11.6]
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.45.Final.jar!/:4.1.45.Final]
        ... 17 more

I have checked the dependencies inside the jar and I could find a nested dependency in the lib folder "./BOOT-INF/lib/hibernate-core-5.4.10.Final.jar".
I found the issue 2430, but in my case, all dependencies belongs to the same module.
What I'm missing?
Thanks in advance, Alan
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Probably this is a RLEC bug - RENAME shouldn't throw such errors since it executed behind cluster proxy. Did you contact their support?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2636
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2644
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson: 3.12.1
Java: 1.8
In production we saw below error few times. As per some closed issues if we set pingConnectionInterval, will the excess idle connections be closed after idleConnectionTimeout ?
And also enabling KeepAlive solved the issue for any?
org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=0, freeConnectionsCounter=value:230:queue:0, freezed=false, freezeReason=null, client=[addr=redis://<removed>:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1929783894 [redisClient=[addr=redis://<removed>:6379], channel=[id: 0x3a9bcda0, L:/<<removed>>:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@63c1de5f(success)], command=(BLPOP), params=[userqueue2, 60], codec=org.redisson.client.codec.StringCodec]], command: (BLPOP), params: [userqueue2, 60] after 3 retry attempts
    at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:280)
    at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:60)
    at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:162)
    at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:159)
    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
    at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)
    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
    at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
    at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
    at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
    at org.redisson.client.handler.CommandsQueue.channelInactive(CommandsQueue.java:83)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)

Config config = new Config();
		config.setCodec(StringCodec.INSTANCE);
		
		ReplicatedServersConfig replicatedServersConfig = config.useReplicatedServers()
				.setScanInterval(2000) 
				.setReadMode(READ_MODE) 
				.setTimeout(CacheConstants.TIMEOUT) 
				.setMasterConnectionPoolSize(CacheConstants.MAX_TOTAL_CONNECTIONS)
				.setSlaveConnectionPoolSize(CacheConstants.SLAVE_MAX_TOTAL_CONNECTIONS);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
报错信息：
Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.data.redis.connection.RedisPipelineException: Pipeline contained one or more invalid commands; nested exception is org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redis-m.xxx.com:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1628911 [redisClient=[addr=redis://redis-m.xxx.com:6379], channel=[id: 0xed6e09bd, L:/1xx.sss.xxx.xxx:sss - R:redis-m.xxx.com/xxx.xx.x6.2s02:sss], currentCommand=null], command: null, params: null after 3 retry attempts] with root cause
java.lang.NullPointerException: null
配置：
masterSlaveServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 60000
password: null
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "SLAVE"
slaveAddresses:
- "redis://127.0.0.1:6381"
- "redis://redis-s.xxxx.com:6379"

masterAddress: "redis://redis-m.xxxx.com:6379"
database: 0
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
调用场景：
用户退出登录时，删除缓存中的token和用户信息
consumerTokenServices.revokeToken(logoutDto.getToken());
tokenCacheService.removeCellphoneTokenKey();
tokenCacheService.removeCellphoneToken(tokenCacheKey);
报错信息里面提示了currentCommand=null，但是没有了更细的日志了
不知是什么原因导致command=null呢
谢谢！
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm working on a legacy project and trying to integrate Redisson Tomcat. The project uses the session object to store lots of data, and doesn't use setAttribute to do it. Because of this I'm forced to use the AFTER_REQUEST update mode. Since every page needs multiple calls to the server to render the whole process is very slow as Redisson will load and then save the session on every request.
Is it possible to restrict session loading/saving to specific requests? I couldn't see a mechanism which enables it so I thought of injecting a valve before the UpdateValve which will skip it in specific cases. Is there a better way?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RedissonBoundedBlockingQueue drainTo method will return result.
Actual behavior
RedissonBoundedBlockingQueue drainTo method got infinite hung.
"ne3sws-ping-consumer" Id=368 WAITING on io.netty.util.concurrent.ImmediateEventExecutor$ImmediatePromise@72e4e41f
CPU time=14.375 secs, USER time=9.47 secs, MEMORY allocation=397318568 bytes
Java callstack:
at java.lang.Object.wait(Native Method)
-  waiting on io.netty.util.concurrent.ImmediateEventExecutor$ImmediatePromise@72e4e41f
at java.lang.Object.wait(Object.java:502)
at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:252)
at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)
at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:142)
at org.redisson.RedissonObject.get(RedissonObject.java:90)
at org.redisson.RedissonBoundedBlockingQueue.drainTo(RedissonBoundedBlockingQueue.java:298)
at com.nsn.oss.mf.mediation.ne3sws.ping.consumer.PingTaskConsumer.consume(PingTaskConsumer.java:69)
at com.nsn.oss.mf.mediation.ne3sws.ping.consumer.PingTaskConsumer.lambda$start$1(PingTaskConsumer.java:53)
at com.nsn.oss.mf.mediation.ne3sws.ping.consumer.PingTaskConsumer$$Lambda$88/1358833464.call(Unknown Source)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
    Number of locked synchronizers = 1
    - java.util.concurrent.ThreadPoolExecutor$Worker@4d8bb13b

Steps to reproduce or test case Unknown/..
Redis version any
Redisson version 3.12.2
Redisson configuration 3 Sentinels + 1M+1S
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissonClient.getNodesGroup and RedissonClient.getClusterNodesGroup methods are deprecated
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to use Redission with spring boot. I followed https://github.com/redisson/redisson/wiki/3.-operations-execution#32-reactive-way but when I check my Redis data is not saved. What am I doing wrong? I am new to Reactive Programming.
These are setting I am using
POM
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.5.RELEASE</version>
        <relativePath />
        <!-- lookup parent from repository -->
    </parent>
    <groupId>org.inventum</groupId>
    <artifactId>inventumaaa</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>war</packaging>
    <name>xyz</name>
    <description>XYZ desc</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.12.3</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

Config
@Bean(destroyMethod = "shutdown")
public RedissonReactiveClient reactiveRedissonClient(){
   Config config = new Config();
   config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("myPass");
   return  Redisson.createReactive(config);
}

Service
@GetMapping(value="/set")
public ResponseEntity<Void> set()
{
   RMapReactive<String,String> bucket = reactiveClient.getMap("anyObject");
   bucket.put("Hello", "Sweety");		
   return new ResponseEntity<Void>(HttpStatus.OK);
}

After that when I do keys * in Redis  I get (empty list or set) , however when I use normal RedissonClient everything works.
Clearly I am doing something wrong there, I would appreciate if someone can point that out
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
tomcat8
codec: org.redisson.codec.JsonJacksonCodec
readMode: MEMORY
updateMode: AFTER_REQUEST
redisson-tomcat-8-3.12.2.jar
redisson-all-3.12.2.jar

error stack :
[redisson-netty-2-28] ERROR org.redisson.client.handler.CommandPubSubDecoder - Unable to decode data. channel: [id: 0x3c021770, L:/10.0.0.85:52584 - R:r-8vbjwkx5e2lpm7j5ws.redis.zhangbei.rds.aliyuncs.com/10.0.0.126:6379], reply: ReplayingDecoderByteBuf(ridx=271, widx=271)
com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `java.util.Collections$SetFromMap` (no Creators, like default construct, exist): no default no-arguments constructor found
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 100] (through reference chain: org.redisson.tomcat.AttributeRemoveMessage["names"])
	at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)
	...

	... 
	at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
	at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:76)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:91)

So i saw the source of

RedissonSession.java

:


The class SetFromMap of Collections don't have no args construct method....
how can i fixed this .
Thx
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using a master/slave configuration using Sentinel and ReadMode of SLAVE, all Redis reads should go to the slave nodes.
Actual behavior
Reads of type multiGet (MGET) get sent to the master node.
Steps to reproduce or test case
NOTE: To reproduce, use the Spring Data Redisson connector.

Set up a master/slave Redis configuration using Sentinel and run the Redis MONITOR command on master and slave nodes.
Do a SET on a key. You should see the command on the master node first. The master will send the command to its slaves.
Do a GET on the key. You should see the command on the slave node
Do an MGET on an array of keys including the key you just set. You will see the command on the master node instead of the slave node.

Redis version
5.0.7
Redisson version
3.12.3
Redisson configuration
Master/Slave using a Sentinel. Connect to Redis using Spring Data Redisson connector.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for the contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have the following code:
final Config config = new Config();
config.setCodec(new FstCodec(FSTConfiguration.createJsonConfiguration()));
final RedissonClient client = Redisson.create(config);
When a copy of the codec is created by RedisExecutor, the ConfType of the FstConfiguration is always DEFAULT.
This can be fixed by using FSTConfiguration#deriveConfiguration.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We’re currently switching from Lettuce to Redisson to handle our Spring Sessions. We’re using FstCodec, because JacksonJsonCodec doesn’t support all of the objects we need to serialize.
We’re getting an exception processing the response from Redis when reading the old map (stack trace at end).
It looks like the issue is that the map’s codec isn’t being passed to the batch command, so FstCodec is being used for both keys and values, rather than the map’s CompositeCodec(StringCodec, FstCodec).
org.redisson.client.RedisException: Unexpected exception while processing command
        at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:353)
        at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:150)
        at org.redisson.command.CommandBatchService.execute(CommandBatchService.java:160)
        at org.redisson.RedissonBatch.execute(RedissonBatch.java:209)
        at org.redisson.spring.session.RedissonSessionRepository$RedissonSession.changeSessionId(RedissonSessionRepository.java:211)
        at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.changeSessionId(SessionRepositoryFilter.java:274)
        at javax.servlet.http.HttpServletRequestWrapper.changeSessionId(HttpServletRequestWrapper.java:262)
…
Caused by: java.io.IOException: java.lang.NullPointerException
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
…
Caused by: java.lang.NullPointerException
        at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357)
        at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311)
        at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245)
        at org.redisson.codec.FstCodec$1.decode(FstCodec.java:250)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368)
        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
        at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:266)
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:207)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for the contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, when I create a client I have an error with netty...
java.lang.NoSuchMethodError: io.netty.util.NetUtil.isIpV4StackPreferred()Z at io.netty.resolver.dns.DnsNameResolver.<clinit>(DnsNameResolver.java:119) ~[?:?] at io.netty.resolver.dns.DnsNameResolverBuilder.<init>(DnsNameResolverBuilder.java:52) ~[?:?] at io.netty.resolver.dns.DnsAddressResolverGroup.<init>(DnsAddressResolverGroup.java:56) ~[?:?] at org.redisson.connection.DnsAddressResolverGroupFactory.create(DnsAddressResolverGroupFactory.java:33) ~[?:?] at org.redisson.connection.DnsAddressResolverGroupFactory.create(DnsAddressResolverGroupFactory.java:28) ~[?:?] at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:211) ~[?:?] at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:163) ~[?:?] at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:34) ~[?:?] at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:195) ~[?:?] at org.redisson.Redisson.<init>(Redisson.java:59) ~[?:?] at org.redisson.Redisson.create(Redisson.java:99) ~[?:?]
The code:
private void redis(){ Config config = new Config(); config.useSingleServer().setAddress("redis://127.0.0.1:6379"); RedissonClient redisson = Redisson.create(config); }
I use the last version of redisson
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
In a sentinel environment with 1 master(write only), 2 slaves (Read only), Redisson Stream's readGroup and Claim method should execute commands on redis master node.
Actual behavior
The XREADGROUP and XCLAIM redis commands are actually write commands in redis but Redisson consider these as read only commands and executes on slave nodes resulting in the following error
from redis:
org.redisson.client.RedisException: READONLY You can't write against a read only replica.. channel: [id: 0x6de344ad, L:/10.1.60.141:59425 - R:10.1.60.147/10.1.60.147:8223] command: (XREADGROUP), params: [GROUP, TASK_CONSUMER_GROUP, lms_node, COUNT, 10, BLOCK, 15000, STREAMS, TASK_STORE_STREAM, >]
Steps to reproduce or test case
Use readGroups and claim  method in a  master-slave redis environment with master being write only and slaves being read only
Redis version
5.0.5
Redisson version*
3.11.5
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson-spring-boot-starter</artifactId>
	<version>2.15.2</version>
</dependency>

In a spring boot 1.5.6 application, We have below operations on merchant account ,
PayServiceImpl.java
private R balanceFreeze() {
org.redisson.api.RLock lock = redisson.getLock(lockName);
// try the merchant account lock (A)
boolean res = lock.tryLock();
if (res) {
try {
return payHandlerService.balanceFreeze();
} finally {
// It seems here throw the exception (B)
lock.unlock();
}
} else {
LockUtils.logLockError(lockName, order.getOrderNo(), null, "freeze balance");
msg = String.format("获取商户账户锁(%s)失败", lockName);
}
}
PayHandlerServiceImpl.java
public balanceFreeze() {
...
return balanceAndEntryBooking();
...
}
public R balanceAndEntryBooking() {
org.redisson.api.RLock lock = redisson.getLock(lockName);
// try the same merchant account lock with (A)
boolean res = lock.tryLock();
if (res) {
try {
...
} finally {
if (lock.isHeldByCurrentThread())
lock.unlock();
}
} else {
LockUtils.logLockError(lockName, entries, null, "book entry");
msg = String.format("获取商户账户锁(%s)失败", lockName);
}
   }

In PayServiceImpl class , using spring proxy (IOC) to call payHandlerService.balanceFreeze.
It seems (B) throws the exception as below
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: 6c80d703-714c-4f01-b8c6-0ae59686d2e2 thread-id: 8605
at org.redisson.RedissonLock$5.operationComplete(RedissonLock.java:526)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103)
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:73)
at org.redisson.command.CommandAsyncService.handleReference(CommandAsyncService.java:1131)
at org.redisson.command.CommandAsyncService.handleSuccess(CommandAsyncService.java:1124)
at org.redisson.command.CommandAsyncService.checkAttemptFuture(CommandAsyncService.java:1106)
at org.redisson.command.CommandAsyncService$12.operationComplete(CommandAsyncService.java:825)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:103)
at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:73)
at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:448)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:439)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:366)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:188)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does mybatis-redisson keep on sending query to DB in background? I changed in project from local mybatis cache in distributed env. to redis cache using mybatis but load on DB is still same. I expected load on DB lesser after using redisson-mybatis.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Configuring only few maps for strong consistency:
Can i configure that few maps are read from the replicas and for others where i need strong consistency are read from the master only?
In this way i get strong consistency and also performance for other maps.
If not, can i have  to have two redisson instances with different configurations (one with read from replicas and other w/o )  for doing this?
Preventing data loss for map.

have a copy of map and write to it every time when the primary map changes
name the map in such way that slot# is on different redis master
when there is a node crash, start using other map as primary map
( we are planning to use elastic cache ,hopefully there is a way to get notified which master failed)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
redisson use without problem
Actual behavior
old generation overflow, stack exception is
"redisson-netty-160-64" #21377 prio=5 os_prio=0 tid=0x00007fc192b01000 nid=0x490b6 runnable [0x00007fbd44645000]
Steps to reproduce or test case
set redisson config connectionMinimumIdleSize =256 connectionPoolSize =512
Redis version
4.0
Redisson version
3.10.7
Redisson configuration
{"singleServerConfig":{"idleConnectionTimeout":10000,"pingTimeout":1000,"connectTimeout":10000,"timeout":6000,"retryAttempts":3,"retryInterval":1500,"reconnectionTimeout":3000,"failedAttempts":3,"password":"","subscriptionsPerConnection":5,"clientName":null,"address":"","subscriptionConnectionMinimumIdleSize":1,"subscriptionConnectionPoolSize":50,"connectionMinimumIdleSize":256,"connectionPoolSize":512,"database":0},"threads":0,"nettyThreads":0,"codec":{"class":"org.redisson.codec.JsonJacksonCodec"},"transportMode":"NIO"}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The main idea behind RedLock algorithm is to overcome losing of lock acquisition during failover since Redis replication is asynchronous. Moreover its effectiveness still subject of dispute https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html
To overcome this every Redis command execution made by RLock object is synchronized through WAIT command introduced in Redis 3.0.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson version:3.11.6
RRateLimiter rateLimiter = redissonClient.getRateLimiter("key");
rateLimiter.trySetRate(RateType.OVERALL, 3, 10, RateIntervalUnit.MINUTES);
//Delete the invalid
rateLimiter.delete();
Delete the invalid
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Note:this ticket is different from ticket2471 and ticket2303
I found the following bugs in the SentinelConnectionManager class，my test environment is as follows，three sentinels(node10, node14, noe15)，one master(node14)， one slave(node15), the network environment of each node is IPv6 dual stack, and the IP of each node is as follows：
[root@clab508node14 ~]# hostname -i
2a00:8a00:4000:20c::8b:e74 10.32.222.115
[root@clab508node15 ~]# hostname -i
2a00:8a00:4000:20c::8b:e75 10.32.222.116
[root@clab508node10 ~]# hostname -i
2a00:8a00:4000:20c::8b:e70 10.32.222.111
The application program runs in node14 and node15 respectively. The following logs are captured in node14 and printed frequently in the log:
sentinel: redis://2a00:8a00:4000:20c::8b:e74:26379 has down
sentinel: redis://2a00:8a00:4000:20c::8b:e70:26379 has down
sentinel: redis://2a00:8a00:4000:20c:0:0:8b:e74:26379 has down
sentinel: redis://2a00:8a00:4000:20c:0:0:8b:e70:26379 has down
sentinel: redis://10.32.222.111:26379 has down
sentinel: redis://2a00:8a00:4000:20c::8b:e75:26379 has down
sentinel: redis://2a00:8a00:4000:20c:0:0:8b:e75:26379 has down
When the application is initialized, we will get all sentinels in the constructor of SentinelConnectionManager by synchronously call (140 lines)：connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName())，debug log as below：
ip: 2a00:8a00:4000:20c::8b:e74
ip: 2a00:8a00:4000:20c::8b:e75
client currentAddr: redis://10.32.222.111:26379        // Note that the log is printed through the code: client. Getaddr(). Getaddress(). Gethostaddress(), which is an IPv4 address
sentinel: redis://2a00:8a00:4000:20c::8b:e74:26379 added
sentinel: redis://10.32.222.111:26379 added
sentinel: redis://2a00:8a00:4000:20c::8b:e75:26379 added
In the function scheduleChangeCheck, we will asynchronously call(446 lines)：sentinelsFuture = connection.async(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName()). Get the sentinel of the current time point, and the debug print is as follows:
ip: 2a00:8a00:4000:20c::8b:e75
ip: 2a00:8a00:4000:20c::8b:e70
client currentAddr: redis://2a00:8a00:4000:20c:0:0:8b:e74:26379           // This log is based on the code: connection. Getredisclient(). Getaddr(). Getaddress(). Gethostaddress(), which is IPv6 address
Through the above log, you can see that for IPv6 address，in SentinelConnectionManager, some codes get IPv6 addresses without 0(2a00:8a00:4000:20c::8b:e74), and some code get IPv6 addresses with 0(2a00:8a00:4000:20c:0:0:8b:e74)，and some of the code gets the IPv4 address, this will cause the IP address string is not equal in the updateSentinels function**("2a00:8a00:4000:20c::8b:e74" != "2a00:8a00:4000:20c:0:0:8b:e74") ("10.32.222.111" != "2a00:8a00:4000:20c::8b:e70") ("10.32.222.111" != "2a00:8a00:4000:20c:0:0:8b:e70")**, and then call the two functions disconnectNode and shutdownAsync in error. The code is as follows：
for (RedisURI uri : currentUris) {
RedisClient sentinel = SentinelConnectionManager.this.sentinels.remove(uri);
if (sentinel != null) {
disconnectNode(sentinel);
sentinel.shutdownAsync();
log.warn("sentinel: {} has down", uri);
}
}
Redisson version
org.redisson.Version | Redisson 3.12.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In cluster mode, when I called cluster failover in redis-cli, the redis-cli client list showed that connection number increased than masterConnectionMinimumIdleSize/ slaveConnectionMinimumIdleSize  while those connections idle time is larger than idleConnectionTimeout. I have tried both redisson verion 3.7.2 and 3.12.4, redis verion 3.2.9 and 5.0.8. So i wander why the idle connection does not be released after redis cluster failover? It's a feature or the problem of setting or just a bug? Thanks for reply.
Here is my setting of redisson:

Here is my redisson connection count and details, and you can see there are many connection idle time is larger than 10s, cmd is NULL, and connection number is larger than masterConnectionMinimumIdleSize, but is does not release the idle connection.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Earlier i was using redisson 3.11.6, application was working fine.
after upgrading to redisson 3.12.4 , during application startup i am getting this exception
java.lang.NoSuchMethodError: io.netty.buffer.ByteBuf.isContiguous()Z at io.netty.handler.codec.ByteToMessageDecoder$1.cumulate(ByteToMessageDecoder.java:83) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:274) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Say I have a page which requires two requests to render. In my session I hold a variable A=1. I use Redisson with readMode="MEMORY" updateMode="AFTER_REQUEST" broadcastSessionEvents="false".
Now I load the page. Both requests fire concurrently, the first completes before the second. The first request goes to Redis, gets A=1, changes it to A=2 and persists the session to Redis. The second request goes to Redis, gets A=1, does nothing and persists the session to Redis. Now in Redis I have A=1, even though I expected A=2.
Does Redisson do anything clever to handle this scenario or is it up to me?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LiveobjectService find method not working as expected, I am trying to search an object based on its  properties values, something like this

find all objects where attribute = value1 and value = value2 and someId = value3

Collection<AccountNetIDCache> dc = liveObjectService.find(
         AccountNetIDCache.class,Conditions.and(
                Conditions.eq("attribute", value1), 
                Conditions.eq("value", value2),
                Conditions.eq("someId", value3))
);

Expected behavior

It should not return any values is condition is not satisfied

Actual behavior

It's returning all the values

Steps to reproduce or test case


Create an object with at least 3 properties


Populate it with random values and store it as live objects


Use something line below-mentioned code to replicate.


liveObjectService.find(
         SomeClass.class,Conditions.and(
                Conditions.eq("key1", value3), 
                Conditions.eq("key2", value3),
                Conditions.eq("key3", value3))

Here if
Lets say we have following entries
{uid:1, key1:A1 ,key2:common,key3:1 }
{uid:2, key1:B1 ,key2:common,key3:1 }
{uid:3, key1:C1 ,key2:common,key3:1 }
{uid:4, key1:D1 ,key2:common,key3:1 }
{uid:5, key1:E1 ,key2:common,key3:1 }
For Conditions:

key1=A1 && key2=common && key3=1

Response
{uid:1, key1:A1 ,key2:common,key3:1 }  (Which is expected)


key1=X1 && key2=common && key3=1

Response
{uid:1, key1:A1 ,key2:common,key3:1 } 
{uid:2, key1:B1 ,key2:common,key3:1 } 
{uid:3, key1:C1 ,key2:common,key3:1 } 
{uid:4, key1:D1 ,key2:common,key3:1 } 
{uid:5, key1:E1 ,key2:common,key3:1 } 


key1=A1 && key2=common && key3=2

Response
No Result (Which is expected) 

Redis version
redis_version:3.2.12
Redisson version
redission:3.12.3
Redisson configuration
public RedissonClient redissonClient() {
  Config config = new Config();
  switch (redisProperties.getMode()) {
  case "sentinal":
  	SentinelServersConfig sconfig = config.useSentinelServers().setMasterName("mymaster");
  	for(int i = 0;i<redisProperties.getSentinalUrl().length;i++) {
  		sconfig.addSentinelAddress(redisProperties.getSentinalUrl()[i].toString());
  	}
  	break;
  }
  return Redisson.create(config);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Consider the following code:
final RTopic topic1 = redisson.getTopic("topic1");  
topic1.addListener(String.class, new MessageListener<String>() { @Override public void onMessage(final CharSequence channel, final String msg) { System.out.println("topic1: " + msg); }});
System.out.println("Listeners: " + topic1.countListeners()); // Prints 1

final RTopic topic2 = redisson.getTopic("topic2");
topic2.addListener(String.class, new MessageListener<String>() { @Override public void onMessage(final CharSequence channel, final String msg) { System.out.println("topic2: " + msg); }});
System.out.println("Listeners: " + topic2.countListeners()); // Prints 2 (should be 1)

Expected behavior
The countListeners should return 1 per topic.
Actual behavior
It looks like the countListeners returns the total of listeners registred for all topics (2 in this case).
Redisson version
3.12.4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior : Redisson should be able to talk to redis without any hiccups while failover is in progress or completed.
Actual behavior  : After failover is completed, redisson is throwing exceptions for a slot which is 1684. It also mentions that it is unable to connect to master in logs.
Why we think redisson is causing issue and not redis:
When the application was restarted which means the redisson was disconnected and reconnected to same configuration URL. Redisson worked fine, which tell us the issue was with redisson and not redis. We could see that all slots were covered via redis console and also via redis-cli. We were able to connect and retrieve data from 1684 slot from redis-cli. Cluster nodes and Cluster info command also shows everything is fine.
Below is the logs of interest:
2020-04-03 05:35:07,946 [ redisson-netty-2-6] [ ] [ ] [ ] (uster.ClusterConnectionManager) ERROR - Can't connect to master: rediss://pega-XXXXXXX-0001-002.pega-XXXXXXX.XXXXX.use1.cache.amazonaws.com:6379 with slot ranges: [[0-5461]]
2020-04-03 05:35:12,698 [ Agent queue Thread] [ ] [ ] [ ] (RedisDistributedMapDiagnostics) ERROR - DMAP [default#com.pega.pegarules.session.internal.async.AgentInfo] Operation [get] failed on key [PZPROCESSREBASE:PEGA-RULEREFACTORING:UTIL-I-0351C91AF120DC92B] with message [Node for slot: 1684 hasn't been discovered yet. Check cluster slots coverage
org.redisson.client.RedisNodeNotFoundException: Node for slot: 1684 hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command
at org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:610) ~[redisson-3.11.3.jar:?]
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:594) ~[redisson-3.11.3.jar:?]
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:669) ~[redisson-3.11.3.jar:?]
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:134) ~[redisson-3.11.3.jar:?]
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:273) ~[redisson-3.11.3.jar:?]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-all-4.1.37.Final.jar:?]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-all-4.1.37.Final.jar:?]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-all-4.1.37.Final.jar:?]
at java.lang.Thread.run(Thread.java:748) [?:1.8.0_171]
Steps to reproduce or test case:
While the application was running. We have triggered a manual failover from AWS elasticache console. Which resulted in this exception. It is consistently reproducible.
Redis version :  Elasticache Redis 5.0.6, cluster mode, ssl enabled, password enabled. Redisson connects using configuration URL provided for redis.
Redisson version: 3.11.3
Redisson configuration
clusterServersConfig:
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: XXXX
nodeAddresses: []
clientName: "PEGA_REDISSON_NODE"
threads: 8
nettyThreads: 16
codec: !<org.redisson.codec.LZ4Codec> {}
useScriptCache: TRUE
keepPubSubOrder: FALSE
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I had use the version:
compile group: 'org.redisson', name: 'redisson-spring-boot-starter', version: '3.12.4',.
The Questions :
2020-04-07 22:27:34.275 [parallel-4] ERROR reactor.core.scheduler.Schedulers:319 : Scheduler worker in group main failed with an uncaught exception
java.lang.NoClassDefFoundError: org/springframework/data/redis/connection/ReactiveStreamCommands
at org.redisson.spring.data.connection.RedissonConnectionFactory.getReactiveConnection(RedissonConnectionFactory.java:149)
at reactor.core.publisher.MonoSupplier.subscribe(MonoSupplier.java:56)
at reactor.core.publisher.MonoLiftFuseable.subscribe(MonoLiftFuseable.java:55)
at reactor.core.publisher.Mono.subscribe(Mono.java:3882)
at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:123)
at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)
at reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)
at org.springframework.cloud.sleuth.instrument.async.TraceCallable.call(TraceCallable.java:70)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.ClassNotFoundException: org.springframework.data.redis.connection.ReactiveStreamCommands
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:93)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
... 14 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We use load balancing to achieve high redis availability,So we're using a domain name to connect to redisson.But now this error occurs:
org.redisson.client.RedisTimeoutException: Unable to get connection! Try to increase 'nettyThreads' and/or connection pool size settingsNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:0:queue:1, freeConnectionsAmount=0, freeConnectionsCounter=value:0:queue:322, freezed=false, freezeReason=null, client=[addr=redis://local.db.xxx.xxx.com:6379], nodeType=MASTER, firstFail=0]]], command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, redisson_lock_sync2slave_documents_slave_p1, 30000, a9178bf5-e2c9-4a9e-be75-8a8c1481419d:231] after 0 retry attempts
2020-03-31 00:43:41,196 INFO [org.redisson.connection.DNSMonitor] - Detected DNS change. Master redis://local.db.xxx.xxxx.com:6379 has changed ip from 10.80.xxx.x1 to 10.80.xxx.x2
2020-03-31 00:43:41,196 ERROR [org.redisson.connection.DNSMonitor] - Unable to find master entry for local.db.xxx.xxx.com/10.80.xxx.x1:6379. Multiple IP bindings for single hostname supported only in Redisson PRO!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I really want to start migrating to JDK14.
So my question is about JDK14 support estimates?
Since bloomfilter doesn't work right now (which is pretty logical):
java.lang.ClassCastException: class org.redisson.api.BatchResult cannot be cast to class java.util.List (org.redisson.api.BatchResult is in unnamed module of loader 'app'; java.util.List is in module java.base of loader 'bootstrap')
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a example of how to correctly connect to a Redis Cluster using Configuration Endpoint? It seems like you must add all the nodes to Redisson configuration?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
No exception
Actual behavior
Caused by: java.lang.ClassCastException: class org.redisson.api.BatchResult cannot be cast to class java.util.List (org.redisson.api.BatchResult is in unnamed module of loader 'app'; java.util.List is in module java.base of loader 'bootstrap')
Steps to reproduce or test case
private void init() {
	var value = UUID.randomUUID().toString();
    RBloomFilter<String> bf = redissonCli.getBloomFilter(BLOOM_NAME);
    bf.tryInit(40_000_000L, 0.03);
    if (!bf.contains(value)) {
    	bf.add(value);
    }
}

Redis version
5.0.8
Redisson version
3.12.4
Redisson configuration
@SpringBootConfiguration
public class RedissonConfiguration {

    @Bean(destroyMethod = "shutdown")
    RedissonClient redissonClient() {
        var cfg = new Config();
        cfg.useSingleServer()
                .setTimeout(1000000)
                .setAddress("redis://127.0.0.1:36379");
        return Redisson.create(cfg);
    }

    @Bean
    RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
        return new RedissonConnectionFactory(redisson);
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
In case of using through org.springframework.data.redis.core.ReactiveStringRedisTemplate, I expect to handle messages from the channel I subscribed to via reactiveRedisTemplate.listenTo(channel)
Actual behavior
The subscription via reactiveRedisTemplate.listenTo(channel) is happening and redis-cli PUBLISH channel hello returns (integer) 1, but NO messages are handled.
Spent some time debugging, I noticed that anonymous subclass of BaseRedisPubSubListener  is created in RedissonReactiveSubscription.receive() with overridden onMessage(CharSequence channel, Object msg) method which as I understand should handle all the messages from redis channel (by the way, perhaps you could explain why BaseRedisPubSubListener overrides onMessage with empty implementation? ).
In fact the listener handles all messages and swallows it somewhere, debugging the message hits onMessage breakpoint, but nothing happened then.
By the way, in some unexplainable cases (I really don't know how to explain it) somewhere in the code the SubscribeListener is initialized and message that is handled by that listener is handled downstream (happens only in debug mode with some combination of breakpoints placed:)).
But event in that base, a single message first handled by BaseRedisPubSubListener empty implementation of onMessage and only then by SubscribeListener which translates the message downstream.
I tried a lot of times but didn't understand what is really needed to achieve this.
Steps to reproduce or test case

Initialize ReactiveStringRedisTemplate with regular spring config (example attached).
Call reactiveRedisTemplate.listenTo(channel) and subscribe to it.

Redis version
5.0.5
Redisson version
org.redisson:redisson-spring-data-22:3.12.4
Redisson configuration
@Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
                .setDnsMonitoringInterval(-1)
                .setTimeout(commandTimeoutMillis)
                .setAddress("redis://" + host + ":" + port);
        return Redisson.create(config);
    }
@Bean
public ReactiveRedisConnectionFactory redisConnectionFactory(RedissonClient redissonClient) {
    return new RedissonConnectionFactory(redissonClient);
}
 @Bean
ReactiveStringRedisTemplate reactiveRedisTemplate(ReactiveRedisConnectionFactory redisConnectionFactory) {
    return new ReactiveStringRedisTemplate(redisConnectionFactory);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
rtopic  can  receive message,  but throw exception on publish message  every time.
spring-boot: 2.1.2.RELEASE
redisson-spring-boot-starter: 3.11.5
 RTopic rTopic = redissonClient.getTopic("xxx");
        rTopic.addListener(Long.class, (channel, msg) -> {
            log.info("收到消息: {}", msg);
        });


-------------------

 RTopic rTopic = redissonClient.getTopic("xxx");
rTopic.publishAsync(System.currentTimeMillis());

Exception in thread "redisson-3-11" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@71f5bc7c has been closed already
        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)
        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)
        at group.xxxx.SpringUtil.getBean(SpringUtil.java:51)
        at group.xxxx.handleMsg(RedissonMq.java:73)
        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)
        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)
        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
Exception in thread "redisson-3-17" Exception in thread "redisson-3-3" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@1c08adcb has been closed already
        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)
        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)
        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)
        at group.xxx.handleMsg(RedissonMq.java:73)
        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)
        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)
        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
java.lang.NoClassDefFoundError: io/netty/buffer/PoolArena$1
        at io.netty.buffer.PoolArena.freeChunk(PoolArena.java:293)
Exception in thread "redisson-3-7"      at io.netty.buffer.PoolThreadCache$MemoryRegionCache.freeEntry(PoolThreadCache.java:460)
        at io.netty.buffer.PoolThreadCache$MemoryRegionCache.free(PoolThreadCache.java:430)
        at io.netty.buffer.PoolThreadCache$MemoryRegionCache.free(PoolThreadCache.java:422)
        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:279)
        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:270)
        at io.netty.buffer.PoolThreadCache.free(PoolThreadCache.java:241)
        at io.netty.buffer.PooledByteBufAllocator$PoolThreadLocalCache.onRemoval(PooledByteBufAllocator.java:450)
        at io.netty.buffer.PooledByteBufAllocator$PoolThreadLocalCache.onRemoval(PooledByteBufAllocator.java:426)
        at io.netty.util.concurrent.FastThreadLocal.remove(FastThreadLocal.java:271)
        at io.netty.util.concurrent.FastThreadLocal.removeAll(FastThreadLocal.java:67)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:32)
        at java.lang.Thread.run(Thread.java:748)
java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@55d9ff04 has been closed already
        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)
        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)
        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)
        at group.xxxx.handleMsg(RedissonMq.java:73)
        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)
        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)
        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
Exception in thread "redisson-3-1" java.lang.IllegalStateException: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@1dc92408 has been closed already
        at org.springframework.context.support.AbstractApplicationContext.assertBeanFactoryActive(AbstractApplicationContext.java:1067)
        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1100)
        at group.xxx.SpringUtil.getBean(SpringUtil.java:51)
        at group.xxx.handleMsg(xxx.java:73)
        at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)
        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)
        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm wondering what the best approach would be using Redisson to zero-out (remove all entries) residing in the bloomfilter entry generated by Redisson's RedissonBloomFilter.tryInit() and .add commands?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We’ve successfully migrated to using RedissonSessionRepository for our Spring sessions, but we get intermittent NPEs right after startup. It looks like the issue is that the first listener is added before all of the topics are initialized, and the conditional matching in onMessage doesn’t go in the same order as initialization.
java.lang.NullPointerException
        at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:303)
        at org.redisson.spring.session.RedissonSessionRepository.onMessage(RedissonSessionRepository.java:58)
        at org.redisson.PubSubPatternMessageListener.onPatternMessage(PubSubPatternMessageListener.java:83)
        at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84)
        at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:181)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When RedissonSession#changeSessionId is called, state is copied to the new key in Redis, but the field remains a reference to the old RMap. Any subsequent session updates in that request will get persisted to the wrong key.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The spring session documentation has two spring boot ways of configuring session timeout (spring.session.timeout, server.servlet.session.timeout) Redisson does not make use of either of these, instead you have to set it on the EnableRedissonHttpSession annotation which is not configurable.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Inside RedissonSessionRepository is code for publishing session expired, session destroyed, and session created events. Of these, i have only been able to get the session created event to fire. What circumstances trigger the destroyed and expired events?
Have attempted deleting by session id from the repository, deleting directly in redis, and trying to load an expired session from the repository, waiting for the entry to expire on its own. Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected: RPUSH should work without any exception
Actual: WriteRedisConnectionException/ClosedChannelException occured
Steps to reproduce: Intermittent error in production
Redis version: 2.8.19
Redisson version: 3.12.4
Redisson configuration
config.useReplicatedServers()
				.setScanInterval(2000) 
				.setReadMode(MASTER)
				.setTimeout(20000) 
				.setMasterConnectionPoolSize(CacheConstants.MAX_TOTAL_CONNECTIONS)
				.setSlaveConnectionPoolSize(CacheConstants.SLAVE_MAX_TOTAL_CONNECTIONS)
				.setKeepAlive(true)
				.setPingConnectionInterval(CacheConstants.PING_INTERVAL);

When doing RPUSH, it's trying on the connection which is busy with BLPOP on entirely on different queue. Can you let me know how to avoid this issues. I have also added ping interval.
This issue is also happening on connections waiting with command BLPOP.
org.redisson.client.WriteRedisConnectionException@/kibana-highlighted-field@: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=1, freeConnectionsCounter=value:230:queue:0, freezed=false, freezeReason=null, client=[addr=redis://<host>:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1606408253 [redisClient=[addr=redis://<host>:6379], channel=[id: 0x10f2380a, L:/:58058 ! R:<host>/:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@53692e5c(success)], command=(BLPOP), params=[usermessage_queue2, 60], codec=org.redisson.client.codec.StringCodec]], command: (RPUSH), params: [botresponse_queue-<host>, PooledUnsafeDirectByteBuf(ridx: 0, widx: 140, cap: 512)] after 3 retry attempts\n\tat org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:270)\n\tat org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:58)\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:155)\n\tat org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:152)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:993)\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:865)\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)\n\tat io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1104)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.nio.channels.ClosedChannelException: null\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.newClosedChannelException(AbstractChannel.java:957)\n\t... 12 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sentinel mode, 3 node
demo code:
@Inject
private RedissonService redissonService;

@PostConstruct
private void init() throws RedissonException {
	redissonService.getRedissonClient().getTopic
			("lip",new StringCodec()).addListener(String.class, (channel, msg) -> logger.info("msg: " + msg + ": " + channel.toString()));

}


result:
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
Yes; it's a problem. It's difficult to debug connection problems when connecting to sentinel servers fails. Example log below. When each sentinel node connection fails, a small warning with no stack trace and real error message is emitted. When finally no connection is made a message with list of servers tried is included. We've no information about the actual underlying problem.
2020-04-15T10:50:49,472Z WARN  org.redisson.connection.SentinelConnectionManager - Can't connect to sentinel server. Unable to connect to: redis://siggydiggy:26379  2020-04-15T10:50:51,495Z] ERROR org.redisson.client.RedisConnectionException: Unable to connect to Redis sentinel servers: redis://siggydiggy:26379, at org.redisson.connection.SentinelConnectionManager.checkAuth(SentinelConnectionManager.java:235) ~[redisson-3.11.6.jar:3.11.6] at org.redisson.connection.SentinelConnectionManager.<init>(SentinelConnectionManager.java:104) ~[redisson-3.11.6.jar:3.11.6] at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:197) ~[redisson-3.11.6.jar:3.11.6] at org.redisson.Redisson.<init>(Redisson.java:120) ~[redisson-3.11.6.jar:3.11.6] at org.redisson.Redisson.create(Redisson.java:160) ~[redisson-3.11.6.jar:3.11.6]
Describe the solution you'd like
Collect the exceptions in a list and output them with stack traces after it's established that no connection was made.
Describe alternatives you've considered
Log stack dumps to INFO or DEBUG.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a redis cluster with 3 master and 6 slave,and I want redisson only connect to the nodes in config file.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Mono<Boolean> set(K key, V value, Duration timeout) in ReactiveValueOperations  from Spring Data Redis Reactive implies the Mono will return an Boolean to indicate success or fail.
However when using Redisson's Spring Data Redis Integration, the response is either onComplete or onError. It's not revealed in documents that this method should not rely on the Boolean value. It would be easier to use the integration if documents offers these important information.

Besides, the Spring Boot Starter includes spring-boot-starter-web module which conflicts with newer spring-boots-starter-webflux module, which is necessary for Spring Webflux applications.
After exclude the spring-boot-starter-web module from Gradle, Redisson Starter works well. So, can the web module be removed from starter dependencies officially, or, change it to other dependencies?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Wrong solution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Environment Info:
redis server machine:
net.ipv4.tcp_keepalive_time:1200
redis-server version:4.0.11
redis.config:
timeout 300
tcp-keepalive 300
redission-version:3.12.0
redission-config:
clusterServersConfig:
idleConnectionTimeout: 10000
pingTimeout: 1000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
subscriptionsPerConnection: 5
sslEnableEndpointIdentification: true
sslProvider: "JDK"
pingConnectionInterval: 0
keepAlive: false
tcpNoDelay: false
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveConnectionMinimumIdleSize: 24
slaveConnectionPoolSize: 64
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 180000
masterConnectionMinimumIdleSize: 24
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "MASTER"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
dnsMonitoringInterval: 5000
natMap: {}
nodeAddresses:

"redis://XXXX"
"redis://XXXX"
"redis://XXXX"
"redis://XXXX"
"redis://XXXX"
"redis://XXXX"
scanInterval: 5000
checkSlotsCoverage: false
slaveSubscriptionConnectionPoolSize: 50
slaveSubscriptionConnectionMinimumIdleSize: 1
threads: 16
nettyThreads: 32
referenceEnabled: true
transportMode: "NIO"
lockWatchdogTimeout: 30000
keepPubSubOrder: true
decodeInExecutor: false
useScriptCache: false
minCleanUpDelay: 5
maxCleanUpDelay: 1800
addressResolverGroupFactory: !<org.redisson.connection.DnsAddressResolverGroupFactory> {}


Sometimes the following error occurs:
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Increase nettyThreads and/or timeout settings. Command: (EVAL), ......
........
problem analysis:
After catching the network packet,we found the reason is the redission client use a closed connection (maybe closed by os tcp or redis-server ) in the ConnectionPool.

question:
Because the connection in the connection pool has not been operated for a long time, it is closed by the server, and the connection pool does not know.
I want to konw whether there is a heartbeat mechanism on the redisson client and redis-server(use the default configuration)?
Is there any problem with this configuration?
Is there any invalid connection detection mechanism?

英文可能表述不准确,汉语说下.
经过抓包分析发现,redission客户端使用的连接是被操作系统层面关闭的,
由于相关配置,tcp连接长时间无操作会被强制关闭,而且redis-server也设置5分钟无操作关闭连接,
这样就会导致在连接池中维护的最小连接数的连接,如果长时间无操作,就会被tcp或者redis-server关闭
客户端如果再使用这个连接就会导致超时,org.redisson.client.RedisResponseTimeoutException
目前redisson有这方面的失效连接检测机制吗?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when I use this method in project：
RedissonBoundedBlockingQueue.offer(V e, long timeout, TimeUnit unit)
I fount some error like this:
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.base/java.lang.Thread.run(Thread.java:834) Exception in thread "redisson-3-3737" java.lang.Error: Maximum permit count exceeded at java.base/java.util.concurrent.Semaphore$Sync.tryReleaseShared(Semaphore.java:198) at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared(AbstractQueuedSynchronizer.java:1382) at java.base/java.util.concurrent.Semaphore.release(Semaphore.java:619) at org.redisson.pubsub.SemaphorePubSub.onMessage(SemaphorePubSub.java:44) at org.redisson.pubsub.SemaphorePubSub.onMessage(SemaphorePubSub.java:26) at org.redisson.pubsub.PublishSubscribe$4.onMessage(PublishSubscribe.java:129) at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78) at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:184) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.base/java.lang.Thread.run(Thread.java:834)
seems like the message's value is too large,bug I'm not sure,and I  can't reproduce the error.
SemaphorePubSub.onMessage(RedissonLockEntry value, Long message)
jdk version
11
Redisson version
3.11.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Elasticache Redis cluster failover on primary should not cause several minutes of failing Redis calls.
Actual behavior
After failover ClosedChannelException caused by WriteRedisConnectionException happen.
Requests timeout and fail with WriteRedisConnectionException.
Note: this looks like the same problem as issue #2678
Steps to reproduce or test case
Run application
Do "failover primary" on a shard from AWS Console
Redis version
5.0.4
Redisson version
3.12.4
Redisson configuration
clusterServersConfig:
  readMode: "MASTER"
  nodeAddresses:
  - "rediss://clustercfg.redis-cluster.aaa.usw2.cache.amazonaws.com:6379"
  tcpNoDelay: "true"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When it's like this:
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
class A {
  @Id Long id;

  @Column(unique = true) String uniqueField;
  
  @ManyToMany
  @JoinTable(
      name = "a_b",
      joinColumns = @JoinColumn(
          name = "unique_field", referenced_column_name = "unique_field"),
      inverseJoinColumns = @JoinColumn(
          name = "b_id", referencedColumnName = "id"))
  @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
  private List<B> bs = new ArrayList<>();
}

@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
class B {
  @Id Long id;
}

Every time I getting bs it calls database.
But when we change joining field to A primary key:
@JoinTable(
      name = "a_b",
      joinColumns = @JoinColumn(
          name = "a_id", referenced_column_name = "id"),
      inverseJoinColumns = @JoinColumn(
          name = "b_id", referencedColumnName = "id"))

It gets bs from cache.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, using redisson for http session, the created, expired, destroyed events for sessions are raised on each client. Are there any strategies to isolating this to the client that created the session? Looking at prefixing an identifier, and filtering based on that. Wondering if there are better ways? Thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis set has element
"131524001193300000012"
RSetReactive.contains("1524001193300000012")
Expected behavior
should returen false, because use   redis  SISMEMBER
Actual behavior
true
Steps to reproduce or test case
Redis version
redis-cli 5.0.4
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We use redisson library pom dependency for an AWS lambda code. The lambda job is to evict a cache entry from the AWS Redis cache. The Lambda has stopped working since we have upgraded the redisson version from 3.3.1 to 3.12.3. Looking at the Lambda cloudwatch logs, we can see the following in logs

DEBUG RedisExecutor:acquired connection for command (HDEL)
DEBUG RedisExecutor:released connection for command (HDEL)

but the entry in the cache is not deleted. There is no exception/error in the logs. Is there any known issue related to it or are we missing any configuration in the latest version to make the deletes happen.
We use the following code
redissonClient.getMap(cacheKey).fastRemove(cacheKeyId)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is it possible to load entry into hash map (e.g. RMapCache) and set TTL for loaded entry? What would be workaround if this feature not exists?
I would like to add entries into cache using read-through strategy but to keep that entries with TTL and evicted after TTL.
Thanks,
Marko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am using the below code:
RBatch batch = redisson.createBatch(BatchOptions.defaults());
RMapCacheAsync<String, String> map = batch.getMapCache(cdrKey);
map.putAllAsync(batchRequest);
config.setCodec(StringCodec.INSTANCE);
Why are my values appending \x00\x00\x00\x00\x00\x00\x00\ before the XYZ string which is my real value?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
请教个问题，tomcat8集成redission后，AAP运行后生成很多FastThreadLocalThread对象，不久OOM。
33 instances of "io.netty.util.concurrent.FastThreadLocalThread", loaded by "java.net.URLClassLoader @ 0x6c1ae3398" occupy 817,977,408 (68.17%) bytes.
Biggest instances:
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2499ac8 redisson-netty-2-23 - 41,760,720 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c26866e0 redisson-netty-2-29 - 41,759,680 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2b846a8 redisson-netty-2-7 - 41,759,552 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2af2778 redisson-netty-2-9 - 41,759,488 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2dde1e0 redisson-netty-2-6 - 41,759,432 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2b11718 redisson-netty-2-1 - 41,759,288 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c268f208 redisson-netty-2-28 - 41,759,240 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2579748 redisson-netty-2-4 - 41,759,144 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2c4d858 redisson-netty-2-22 - 41,758,760 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2ca50c0 redisson-netty-2-18 - 41,758,752 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c25689e0 redisson-netty-2-2 - 41,758,448 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c29213a0 redisson-netty-2-15 - 41,741,384 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2664de8 redisson-netty-2-21 - 41,741,200 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c25de460 redisson-netty-2-24 - 41,740,304 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c267d890 redisson-netty-2-32 - 41,740,200 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2994798 redisson-netty-2-27 - 41,740,024 (3.48%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2a35a90 redisson-netty-2-25 - 17,913,472 (1.49%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2799e98 redisson-netty-2-26 - 17,379,360 (1.45%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2cfa1c0 redisson-netty-2-11 - 17,375,328 (1.45%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2e46c58 redisson-netty-2-19 - 17,360,160 (1.45%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c2498428 redisson-netty-2-3 - 17,356,816 (1.45%) bytes.
•io.netty.util.concurrent.FastThreadLocalThread @ 0x6c27a7df0 redisson-netty-2-20 - 17,355,424 (1.45%) bytes.
Keywords
io.netty.util.concurrent.FastThreadLocalThread
java.net.URLClassLoader @ 0x6c1ae3398
如下是我们的版本及配置信息
redis version 5.0.3
redisson version 3.12.4
tomcat version 8.0.39
-----------server.xml------------



-----------context.xml------------


-----------redisson.yaml-----------
sentinelServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 6000
retryAttempts: 3
retryInterval: 1500
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 60000
password: "xxxx"
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 24
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 24
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "SLAVE"
sentinelAddresses:

"redis://"
"redis://"
"redis://"
masterName: "xxxx"
database: 0
threads: 16
nettyThreads: 32
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey !
Everytime I try to store UUIDs on redis (with a List, a Set, a bucket) and I wish to compare them or use them as a keys to get elements in a hashmap for example, this error occurs, UUID is considered as a string, here is the format in redis :
"\"88a10822-c3e4-47e8-8f53-1069858fedc4\""
Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.util.UUID
Maybe JsonJackson can't serialize correctly uuids, I sadly didn't find anything interesting about that :/
Thanks in advance for your answer, and sorry for disturbing with weird questions ^^
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have 1 primary and 2 replicas in our production AWS ElastiCache Redis cluster (cluster mode disabled). All three nodes given to ReplicatedServersConfig as mentioned in https://github.com/redisson/redisson/wiki/2.-Configuration#25-replicated-mode. We have set scan interval as 2000, and readMode as MASTER. We are using replicas only for failover, when we tested failover to one of the slaves, the Redisson client still sending the write requests to replica (which is old master) and failing with error org.redisson.client.RedisException: READONLY You can't write against a read only replica.
Does it have to anything to do with readMode? Should we use SLAVE or MASTER_SLAVE?
With readMode MASTER redissonClient.getRedisNodes(RedisNodes.MASTER_SLAVE).getSlaves().size() returns 0, so I assume it will not have old slaves info in the context.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
a76949a#r39710042
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
We have a redis server with about 600 commands per seconds sent via redisson. And we have some cronjobs that update information in the db (and cache). We are using redisson 3.12.3 with LocalCachedMap with the following options.
LocalCachedMapOptions.defaults()
        .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.LRU)
        .syncStrategy(LocalCachedMapOptions.SyncStrategy.INVALIDATE)
        .timeToLive(ttlMinutes, TimeUnit.MINUTES);

The synchronization is working great. However, since the cronjob is setting up new connections then disconnects we often during the peak hours receive errors like so
2020-06-08 10:00:07,395 ERROR org.redisson.client.handler.CommandPubSubDecoder - Unable to decode data. channel: [id: 0x62858bf8, L:/10.y.y.y:50724 - R:xxx/10.x.x.x:6379], reply: ReplayingDecoderByteBuf(ridx=49, widx=49)
java.util.concurrent.RejectedExecutionException: Task org.redisson.client.handler.CommandPubSubDecoder$$Lambda$91/1018878170@65cec14d rejected from java.util.concurrent.ThreadPoolExecutor@41eae594[Shutting down, pool size = 10, active threads = 0, queued tasks = 0, completed tasks = 15]

        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
        at org.redisson.client.handler.CommandPubSubDecoder.enqueueMessage(CommandPubSubDecoder.java:171)
        at org.redisson.client.handler.CommandPubSubDecoder.decodeResult(CommandPubSubDecoder.java:127)
        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:422)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:71)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:91)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)

I'm thinking that we can either wait longer for the shutdown or configure the instance not to subscribe to updates? I realize that this might be a weird use case, I tried manually constructing the publish command but got lost somewhere in the command encoding. I'm thinking that ideally a new SyncStrategy that only publish invalidation, and doesn't listen to them, would be the best solution for us.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Periodic scan of cluster nodes runs forever (every scanInterval milliseconds)
Actual behavior
Periodic scan of cluster nodes stops when a single master is added to the cluster and Redisson cannot perform CLUSTER INFO
Steps to reproduce or test case
Failure to perform CLUSTER INFO is probably a side effect from another problem but I expect that Redisson can recover.
I'm using a 6 nodes cluster in a VM (libvirt) environment on 3 virtual machines. Each VM hosts one master and one slave in way that master and slave happens to be on different VMs (master1 is on VM1, but slave1 is on VM2; master2 is on VM2, while slave2 is on VM3 and master3 is on VM3 while slave3 is on VM1). Hard stop VM2 which effectively disconnects master2 and slave1. Then I bring back VM2. Former master2 is no longer master so I promote it to be master again by executing CLUSTER FAILOVER on it. After I do so, Redisson attempts to reconnect to master2 but for unknown reason fails with:
201471 [redisson-timer-4-1] ERROR o.r.c.ClusterConnectionManager - Can't execute CLUSTER_INFO for /10.1.1.12:6379
org.redisson.client.RedisTimeoutException: Command execution timeout for command: (CLUSTER INFO), params: [], Redis client: [addr=redis://10.1.1.12:6379]
	at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:207)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)

Redis version
Redis 6.0.4
Redisson version
3.13.0
Redisson configuration
All defaults, except useClusterServer and one node address.
Notes
I traced back the issue to org.redisson.cluster.ClusterConnectionManager#checkMasterNodesChange:
for (ClusterPartition newPart : addedPartitions.values()) {
    RFuture<Collection<RFuture<Void>>> future = addMasterEntry(newPart, cfg);
    future.onComplete((res, e) -> {
        if (e == null) {
            futures.addAll(res);
        }
        
        if (masters.decrementAndGet() == 0) {
            AtomicInteger nodes = new AtomicInteger(futures.size());
            for (RFuture<Void> nodeFuture : futures) {
                nodeFuture.onComplete((r, ex) -> {
                    if (nodes.decrementAndGet() == 0) {
                        result.trySuccess(null);
                    }
                });
            }
        }
    });
}
addMasterEntry returns failed future (e is not null) and  futures.addAll(res); is never executed. As a result result future is never resolved and the next round of scanning is not performed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I expect to get metrics of RedissonSpringCacheManager
Actual behavior
But RedissonCacheStatisticsAutoConfiguration not matched to condition @ConditionalOnBean({CacheManager.class, RedissonCache.class})
The reason is that there isn't RedissonCache bean registered in context.
If you dive deep into RedissonSpringCacheManager you can see RedissonCache instance created, but not registered in ApplicationContext and it should not.
RedissonCacheStatisticsAutoConfiguration":{"notMatched":[{"condition":"OnBeanCondition","message":"@ConditionalOnBean (types: org.springframework.cache.CacheManager,org.redisson.spring.cache.RedissonCache; SearchStrategy: all) did not find any beans of type org.redisson.spring.cache.RedissonCache"}]
Steps to reproduce or test case
Fail case:

Configure spring boot cache (see below)
Configure spring-boot-starter-data-redis (ip, port, db)
Use spring cache annotations on objects an methods
check /actuator/metrics
You won't see any cache metrics
Success case:
Repeat all from Fail case (steps 1-3)
Register RedissonCacheMeterBinderProvider on your own
check /actuator/metrics
You will see cache.puts, cache.gets, cache.size metrics

Redisson version
redisson-spring-boot-starter - 3.13.0
redisson - 3.13.0
Redisson configuration
@Configuration
@EnableCaching
public class CacheConfiguration {
    @Bean
    public CacheManager cacheManager(RedissonClient redissonClient, AbacCacheProperties properties) {
        CacheConfig cacheConfig = new CacheConfig(properties.getTtl().toMillis(),
                properties.getMaxIdleTime().toMillis());
        cacheConfig.setMaxSize(properties.getMaxSize());

        Map<String, CacheConfig> configMap = Arrays.stream(CacheName.ALL)
                .collect(Collectors.toMap(Function.identity(), s -> cacheConfig));

        return new RedissonSpringCacheManager(redissonClient, configMap);
    }
}

Solution
Change conditions from
@Configuration
@AutoConfigureAfter(CacheAutoConfiguration.class)
@ConditionalOnBean({ CacheManager.class, RedissonCache.class })
@ConditionalOnClass(CacheMeterBinderProvider.class)

to
@Configuration
@AutoConfigureAfter(CacheAutoConfiguration.class)
@ConditionalOnBean(CacheManager.class)
@ConditionalOnClass({ CacheMeterBinderProvider.class, RedissonCache.class })
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have an application in which we are using Redis as a small database.
We are using Redis in a master-slave configuration in docker swarm environment. We have 1 master node and 2 replica nodes.
For persistent storage we have enabled volumes for master/replica nodes in docker swarm environment e.g if container restarts it can pick data from the volumes file on disk.
Few of my doubts are as below -

Is it necessary to enable volumes for replica nodes?
If we have volumes enabled for replica nodes, in a scenario when replica docker container restarts, will it pick its data from its volumes file on disk? or it ignores that file and only get data after syncing with master node?

Please let me know if you need more information.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After upgrading redisson client from 2.2.12 to 3.10.6 there are a lot of org.redisson.client.RedisException errors when performing various queries to Redis via redisson.
It seems there are a couple of issues:

There cannot be two applications using different redisson versions at the same time, e.g. App1 with 2.2.12 and App2 with 3.10.6, otherwise the RedisException occurs.
The keys created by the old version must be flushed, otherwise the RedisException occurs.

Expected behavior
After upgrading redisson client from 2.2.12 to 3.10.6 new keys can be created and old keys can be read/updated without errors.
Actual behavior
After upgrading redisson client from 2.2.12 to 3.10.6 new keys cannot be created and old keys cannot be read/updated without RedisException.
Question
Is there a way to avoid flushing the cache in order to avoid the errors?
Steps to reproduce or test case

Using the old redisson client insert keys to Redis.
Using the new redisson client try to read the old keys or update them.
Result: org.redisson.client.RedisException

Redis version
3.10.6
Redisson version
3.0.7
Redisson configuration
{
"clusterServersConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":1000,
"timeout":1000,
"retryAttempts":3,
"retryInterval":1000,
"reconnectionTimeout":3000,
"failedAttempts":3,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"slaveSubscriptionConnectionMinimumIdleSize":1,
"slaveSubscriptionConnectionPoolSize":25,
"slaveConnectionMinimumIdleSize":50,
"slaveConnectionPoolSize":800,
"masterConnectionMinimumIdleSize":50,
"masterConnectionPoolSize":800,
"readMode":"SLAVE",
"nodeAddresses":[
"//172.0.0.1:7000",
"//172.0.0.1:7001"
],
"scanInterval":1000
},
"threads":0,
"codec":null,
"useLinuxNativeEpoll":false,
"eventLoopGroup":null
}
Stack Trace
Error: Unexpected exception while processing command
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:400) ~[redisson-3.10.6.jar:?]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:204) ~[redisson-3.10.6.jar:?]
at org.redisson.RedissonObject.get(RedissonObject.java:94) ~[redisson-3.10.6.jar:?]
at org.redisson.RedissonMapCache.scanIterator(RedissonMapCache.java:1220) ~[redisson-3.10.6.jar:?]
at org.redisson.RedissonMapIterator.iterator(RedissonMapIterator.java:47) ~[redisson-3.10.6.jar:?]
at org.redisson.BaseIterator.hasNext(BaseIterator.java:54) ~[redisson-3.10.6.jar:?]
at com.vo.services.sessionmanager.service.crm.CrmService.getSessionList(CrmService.java:30) [classes/:5.2]
at com.vo.services.sessionmanager.service.crm.InternalCrmService.getSessionList(InternalCrmService.java:60) [classes/:5.2]
at com.vo.services.sessionmanager.api.Controller.getSessionListCrm(Controller.java:48) [classes/:5.2]
at sun.reflect.GeneratedMethodAccessor172.invoke(Unknown Source) ~[?:?]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) ~[?:1.8.0_92]
at java.lang.reflect.Method.invoke(Unknown Source) ~[?:1.8.0_92]
at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:114) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:622) [servlet-api.jar:?]
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) [servlet-api.jar:?]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-websocket.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) [spring-boot-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:105) [spring-boot-actuator-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at com.orca.authenticator.AuthenticationFilter.doFilter(AuthenticationFilter.java:184) [local-authenticator-1.4.jar:?]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:115) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:169) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:121) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:66) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) [spring-security-web-4.1.3.RELEASE.jar:4.1.3.RELEASE]
at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:89) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:107) [spring-boot-actuator-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:119) [spring-boot-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.boot.web.support.ErrorPageFilter.access$000(ErrorPageFilter.java:61) [spring-boot-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.boot.web.support.ErrorPageFilter$1.doFilterInternal(ErrorPageFilter.java:94) [spring-boot-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.3.RELEASE.jar:4.3.3.RELEASE]
at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:112) [spring-boot-1.4.1.RELEASE.jar:1.4.1.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) [catalina.jar:8.0.32]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) [catalina.jar:8.0.32]
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) [catalina.jar:8.0.32]
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [catalina.jar:8.0.32]
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [catalina.jar:8.0.32]
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) [catalina.jar:8.0.32]
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [catalina.jar:8.0.32]
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [catalina.jar:8.0.32]
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:522) [catalina.jar:8.0.32]
at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1095) [tomcat-coyote.jar:8.0.32]
at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672) [tomcat-coyote.jar:8.0.32]
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1500) [tomcat-coyote.jar:8.0.32]
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1456) [tomcat-coyote.jar:8.0.32]
at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) [?:1.8.0_92]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [?:1.8.0_92]
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-util.jar:8.0.32]
at java.lang.Thread.run(Unknown Source) [?:1.8.0_92]
Caused by: java.io.IOException: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:364) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:199) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:139) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114) ~[redisson-3.10.6.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
... 1 more
Caused by: java.lang.NullPointerException
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:357) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:?]
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:?]
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:364) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:199) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:139) ~[redisson-3.10.6.jar:?]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:114) ~[redisson-3.10.6.jar:?]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) ~[netty-codec-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) ~[netty-transport-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.34.Final.jar:4.1.34.Final]
... 1 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2829
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson support redis 6.0+ ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
Should I use useMasterSlaveServers for an AWS redis (1 master - 2 slaves) with an unique reader endpoint (Amazon ElastiCache launches reader endpoints for Redis)
here is my current configuration
private static RedissonClient getAwsRedisClient(Config config, RedisModel redisModel) {
    DescribeReplicationGroupsRequest describeReplicationGroupsRequest = new DescribeReplicationGroupsRequest()
            .withReplicationGroupId(redisModel.getGroupName());

    NodeGroup nodeGroup = AmazonElastiCacheClientBuilder.defaultClient()
            .describeReplicationGroups(describeReplicationGroupsRequest)
            .getReplicationGroups()
            .stream()
            .map(ReplicationGroup::getNodeGroups)
            .flatMap(List::stream)
            .findFirst()
            .orElseThrow(IllegalArgumentException::new);

    checkArgument(Objects.nonNull(nodeGroup.getPrimaryEndpoint()), "primary endpoint is undefined");
    checkArgument(Objects.nonNull(nodeGroup.getReaderEndpoint()), "reader endpoint is undefined ");

   UnaryOperator<String> ENDPOINT = endpoint -> "redis://" + endpoint + ":" + REDIS_PORT;
    
    config.useMasterSlaveServers()
            .setReadMode(ReadMode.SLAVE)
            .setSlaveConnectionPoolSize(500) // 500
            .setMasterConnectionPoolSize(500)
            .setConnectTimeout(5000)
            .setPingConnectionInterval(1000)
            .setRetryInterval(50)
            .setRetryAttempts(1)
            .setSubscriptionConnectionPoolSize(1)
            .setMasterAddress(ENDPOINT.apply(nodeGroup.getPrimaryEndpoint().getAddress()))
            .setSlaveAddresses(singleton(ENDPOINT.apply(nodeGroup.getReaderEndpoint().getAddress())));

    return Redisson.create(config);
}

Remember we haven't enabled the cluster mode .. We have only 1 master with 2 slaves.
However we got 2 troubles




(redis-2 is the primary, redis-1 and redis-3 are the slaves)
As you can see in the picture, the current connections between the 2 slaves are strange. I know there is load balacing between the 2 slaves. But why the connections fall back to 0 periodically ? Should I increase the maximum idle time of the connections before they are released ?

Then after the failover, 2 services failed to reconnect on the master node. Our other services had no problems with  the same configuration.


2020/06/09 21:58:45.308 ERROR [redisson-netty-5-10] o.r.c.DNSMonitor | Key= period= - Unable to find master entry for ....

It makes no sense to me because the unique primary endpoint and the unique reader endpoint have not changed ... Should I disabled the dns monitoring interval on the redis client ?
let me know if you have answers to these troubles
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson should try to send command later if this error arose.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
所有消息发布之后都能返回正常的消费者数量
Actual behavior
有的频道返回的消费者数量为0
Steps to reproduce or test case
Redis version
6
Redisson version
3.13.1
Redisson configuration
clusterServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: wawa1314
subscriptionsPerConnection: 5
clientName: redis_study
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
nodeAddresses:
- "redis://127.0.0.1:7002"
- "redis://127.0.0.1:7001"
- "redis://127.0.0.1:7000"
scanInterval: 1000
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
"transportMode": "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use case
When I put the content into delayed queue, I manage to add listener on the content transferring to the destination.
Questions
Is there any methods I can get to listen delayed queue callback when transferring entity to destination ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From this documentation: https://github.com/redisson/redisson/wiki/2.-Configuration#24-cluster-mode
It is written for cluster mode "Minimal cluster configuration requires to contain at least three master nodes"
I want to understand why this limitation is there?
So overall if I have a cluster enable AWS elastic cache with single shard(1 master,2 Replicas) then i can't use cluster mode configuration?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a cluster mode enabled AWS Elastic cache with current configuration 1 shard(1 master 2 slaves) and i wan't to know that if i increase the shards count say to 2, would Redisson able to auto discover the newly added shard nodes?
As per this: https://github.com/redisson/redisson/wiki/2.-Configuration#241-cluster-settings  Redisson only take the node addesses but AWS also provides the configuration endpoint but i don't see any option to provide that in Redisson.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a sharded AWS cluster enabled elastic cache with multiple shards.
I want to use the Redisson client to interact with my AWS Elastic Cache .
Can this be possible in OpenSource Redisson or it's possible only in Redisson pro?
Also it would be really helpful if you can share a sample code to connect to a sharded AWS elastic Cache using Redisson Client
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
The client to reconnect to new masters
Actual behavior
Seeing this exception
Caused by: org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=15421, addr=redis://x.x.x.89:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet.
	at org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:615)
	at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:567)
	at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:647)
	at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116)
	at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:245)

Steps to reproduce or test case
Happens in production after the redis cluster is restarted
Redis version
5.0.5
Redisson version
3.11.6
Redisson configuration
x.x.x.81:6379,x.x.x.82:6379,x.x.x.83:6379,x.x.x.84:6379,x.x.x.85:6379,x.x.x.86:6379,x.x.x.87:6379,x.x.x.88:6379,x.x.x.89:6379

redis-json-config=\
{\
   "clusterServersConfig":{\
      "idleConnectionTimeout":10000,\
      "pingTimeout":250,\
      "connectTimeout":5000,\
      "timeout":3000,\
      "retryAttempts":3,\
      "retryInterval":1500,\
      "failedSlaveReconnectionInterval":3000,\
      "failedSlaveCheckInterval":60000,\
      "password":"xxx",\
      "subscriptionsPerConnection":5,\
      "clientName":"CLIENT_NAME",\
      "loadBalancer":{\
         "class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"\
      },\
      "subscriptionConnectionMinimumIdleSize":1,\
      "subscriptionConnectionPoolSize":5,\
      "slaveConnectionMinimumIdleSize":1,\
      "slaveConnectionPoolSize":5,\
      "masterConnectionMinimumIdleSize":5,\
      "masterConnectionPoolSize":10,\
      "readMode":"MASTER",\
      "subscriptionMode":"MASTER",\
      "nodeAddresses":[REDIS_CLUSTER_IPS],\
      "scanInterval":5000,\
      "pingConnectionInterval": 0,\
      "keepAlive": false,\
      "tcpNoDelay": false\
   },\
   "threads":10,\
   "nettyThreads":10\
}

After the redis cluster restart the error is showing up only on a small percentage of instances. The rest were able to reconnect as expected the p95 latency was under 20ms for fetching a single key from a hashset and around 100ms for fetching the entire hashset
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Seems RedisConnection is leaking in a queue?
Expected behavior
No leak.
Actual behavior

Steps to reproduce or test case
Redis version
n/a
Redisson version
3.11.5
Redisson configuration
    private RedissonClientPair createRedissonClient(String redisNodes, int database, int timeout, int retryAttempts, int retryInterval) {
        final Config config = new Config();
        config.setCodec(new SnappyCodec());
        config.setEventLoopGroup(redisEventLoop.getWorkerGroup());
        config.setTransportMode(redisEventLoop.isNativeEpoll() ?
                                        TransportMode.EPOLL : TransportMode.NIO);
        // inject shared dns address resolver to save memory
        config.setAddressResolverGroupFactory((channelType, nameServerProvider) -> dnsAddressResolverGroup);
        config.setReferenceEnabled(false);

        if (redisNodes.indexOf(',') > -1) {
            final ReplicatedServersConfig clusterConfig = new ReplicatedServersConfig();
            clusterConfig.setScanInterval(2500);
            clusterConfig.setDnsMonitoringInterval(2500);
            clusterConfig.setDatabase(database);
            clusterConfig.setTcpNoDelay(true);
            clusterConfig.setKeepAlive(true);
            for (String addr : StringUtils.tokenizeToStringArray(redisNodes, ",", true, true)) {
                clusterConfig.addNodeAddress(addSchema(addr));
            }
            clusterConfig.setTimeout(timeout);
            clusterConfig.setRetryAttempts(retryAttempts);
            clusterConfig.setRetryInterval(retryInterval);
            clusterConfig.setReadMode(ReadMode.SLAVE);
            config.useCustomServers(new ReplicatedConnectionManager(clusterConfig, config, UUID.randomUUID())); // shared connection manager
        } else {
            SingleServerConfig singleServerConfig = config.useSingleServer();
            singleServerConfig.setDatabase(database);
            singleServerConfig.setTimeout(timeout);
            singleServerConfig.setRetryAttempts(retryAttempts);
            singleServerConfig.setRetryInterval(retryInterval);
            singleServerConfig.setTcpNoDelay(true);
            singleServerConfig.setKeepAlive(true);
            singleServerConfig.setAddress(addSchema(redisNodes));
        }

        return new RedissonClientPair(Redisson.create(config), Redisson.createReactive(config));
    }

    static class RedissonClientPair {

        private final RedissonClient redissonClient;
        private final RedissonReactiveClient redissonReactiveClient;

        public RedissonClientPair(@NotNull RedissonClient redissonClient, @NotNull RedissonReactiveClient redissonReactiveClient) {
            this.redissonClient = redissonClient;
            this.redissonReactiveClient = redissonReactiveClient;
        }
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting below error while trying push a message to RDelayedQueue. Using Redission version 3.6.2. Any thoughts?
org.redisson.client.RedisTimeoutException: Redis server response timeout (3000 ms) occured for command: (LPOP) with params: [delayEventQueue-local] channel: [id: 0x1b6f637b, L:/127.0.0.1:50820 - R:/127.0.0.1:6379]
Also, below error pop up sometimes.
org.redisson.client.RedisTimeoutException: Unable to send command! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=org.redisson.connection.SingleEntry@52d9b542], connection: [id: 0xb7d5d47c, L:/127.0.0.1:54223 - R:/127.0.0.1:6379], command: (EVAL), command params: [local result = {}; local items = redis.call('lrange', KEYS[1], 0, -1); for i, v in ipairs(items) do ..., 1, redisson_delay_queue:{delayEventQueue-local}] after 3 retry attempts
Below are my settings.
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingTimeout":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"reconnectionTimeout":3000,
"failedAttempts":3,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":10,
"connectionPoolSize":64,
"database":0,
"dnsMonitoringInterval":5000
},
"threads":16,
"nettyThreads":32,
"codec":null,
"useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Want to understand how to retrieve delayed queue (RDelayedQueue) by name using getDelayedQueue method on org.redisson.api.RedissonClient.
Does it require to call redissonClient.getDelayedQueue(destinationQueue) every time before queuing a message as below or retrieve queue once and use it for every message queuing ?
RDelayedQueue..offer(message, delayInMillisFromCurrent, TimeUnit.MILLISECONDS);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am trying to find the API equivalent to "CONFIG GET"
I found:  getRedisNodes( RedisNodes.CLUSTER ) and cluster info but not config.
Thanks in advance!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I have using Redisson for not a long time, and I realize that I need my old project to access to Redis and retrieve data that is maintained by the current Java code which use Redisson.
But Redisson is not just a redis client but a In-Memory Data Grid, therefore it's quite different and not compatible friendly for nodejs program for it only has pure redis client tools to use.
So the idea I have is:

Write a Java Redisson program as a proxy and serve data for nodejs program.
Figure out how Redisson save data, for sorted set, and Bucket, and write a package for nodejs to decode data from Redis.
Give up Redisson and use pure redis client, like Redis.

Is there any other solutions? Or is there any nodejs middleware for Redisson? Would that be difficult to write one for Redisson(I haven't read much source code of Redisson yet)?
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
IDLE Closed channel should not be used in latter command execution.
Actual behavior
See below log, acquire connection and IDLE connection check happens around at same time, therefore IdleConnectionWatcher closed it. But this connection was taken into use in latter phase and always get "failure: java.nio.channels.ClosedChannelException)], command=(PING),". However, PING cannot recover it.
2020-06-16-T23:30:30.858+0300 | acquired connection for command (EVAL) and params ... RedisConnection@1313171148 [redisClient=[addr=redis://10
.91.79.165:6379], channel=[id: 0x2605961e, L:/10.91.79.164:36617 - R:10.91.79.165/10.91.79.165:6379], currentCommand=null]
2020-06-16-T23:30:30.916+0300 | redisson-netty-2-2 | DEBUG | org.redisson.connection.IdleConnectionWatcher | Connection [id: 0x2605961e, L:/10.91.79.164:36617 ! R:10.91.79.165/10.91.79.165:6379] has been closed due to idle timeout. Not used for 29888 ms
2020-06-16-T23:30:33.227+0300  | redisson-timer-4-1 | DEBUG | org.redisson.command.RedisExecutor | connection released for command (EVAL) and params ... using connection RedisConnection@1313171148 [redisClient=[addr=redis://10.91.79.165:6379], channel=[id: 0x2605961e, L:/10.91.79.164:36617 ! R:10.91.79.165/10.91.79.165:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18c41e41(failure: java.nio.channels.ClosedChannelException)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]]
Steps to reproduce or test case
Redis version
5.0
Redisson version
3.12.2
Redisson configuration
1M+1S+3 sentinels
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 5000
  retryAttempts: 3
  retryInterval: 1500
  pingConnectionInterval: 60000
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using redis delay queue and see below error with around 20k message in queue.
org.redisson.client.RedisException: BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.. channel: [id: 0x6186980c, L:/127.0.0.1:54603 - R:/127.0.0.1:6379] command: CommandData [promise=org.redisson.misc.RedissonPromise@16ae7198[Not completed], command=(LPOP), params=[delayEventQueue-local], codec=org.redisson.codec.JsonJacksonCodec@4631b499]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:266)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:126)
Below is the config.
{
"singleServerConfig":{
"idleConnectionTimeout":10000,
"pingConnectionInterval":1000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"reconnectionTimeout":3000,
"failedAttempts":3,
"password":null,
"subscriptionsPerConnection":5,
"clientName":null,
"address": "redis://127.0.0.1:6379",
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"connectionMinimumIdleSize":10,
"connectionPoolSize":64,
"database":0,
"dnsMonitoringInterval":5000
},
"threads":0,
"nettyThreads":0,
"codec":null,
"useLinuxNativeEpoll":false
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi - I cant find support for redis OBJECT (https://redis.io/commands/object) command in RedisCommands. Is there any plan to add support for the OBJECT command?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/redisson/redisson/4.-data-serialization returning 404
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
multiple RedissonNodes has Different system time，
example CronSchedule.of("0/10 * * * * ?")
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2852
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we are using redisson with en RLEC (https://redislabs.com/blog/introduction-to-redis-labs-enterprise-cluster-rlec/) it does work but not in every case, so the question is does redisson officially support RLEC and when yes how should we configure it? Is there a example somewhere. If there is one and I could not find it, pleas give me a hint :)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2854
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm attempting to the RedissonSessionManager to handle sessions for tomcat.  I have setup the manager like this in my tomcat context.xml file
Manager className="org.redisson.tomcat.RedissonSessionManager" configPath="${catalina.base}/conf/redisson.yaml" readMode="MEMORY" updateMode="DEFAULT" />
and created the following redisson.yaml file
singleServerConfig: idleConnectionTimeout: 10000 connectTimeout: 10000 timeout: 3000 retryAttempts: 3 retryInterval: 1500 password: null subscriptionsPerConnection: 5 clientName: null address: "redis://<removed this>:6379" subscriptionConnectionMinimumIdleSize: 1 subscriptionConnectionPoolSize: 50 connectionMinimumIdleSize: 24 connectionPoolSize: 64 database: 0 dnsMonitoringInterval: 5000 threads: 16 nettyThreads: 32 codec: !<org.redisson.codec.FstCodec> {} transportMode: "NIO"
With it set like this I get this error,......
aused by: java.lang.NoSuchMethodError: org.nustaq.serialization.FSTConfiguration.getJsonFieldNames()Lorg/nustaq/serialization/coders/FSTJsonFieldNames;                at org.redisson.codec.FstCodec.copy(FstCodec.java:201) at org.redisson.codec.FstCodec.<init>(FstCodec.java:190)                ... 46 more
I had to manually add the fst-2.47.jar as well as the objenesis-3.1.jar to get this and I'm kind of stuck now.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We notice with small connection pool sizes under load that some promises seem to be interrupted or time out. This is normal behavior, but the root cause is omitted under the stack trace.
Redisson tries future.await(), catching the InterruptedException. In this case I believe future.isSuccess() is unlikely to return true, and convertException will be called. If InterruptedException is the cause for the future failing, we want to preserve that as part of the cause in the stack trace.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: ERR Error running script (call to f_e26640977179bbd6382a41b36c8190a8dbccc7d1): @user_script:1: WRONGTYPE Operation against a key holding the wrong kind of value . channel: [id: 0x08807cdc, L:/172.31.23.38:40618 - R:/172.31.10.223:17005] command: (EVAL), params: [local res = redis.call('hdel', KEYS[1], unpack(ARGV)); if res > 0 then redis.call('del', unpack(KEYS..., 1, {bcgame:crash:user-bet-logs}:o76cyhOJyzKx+WqXE/JGLg, PooledUnsafeDirectByteBuf(ridx: 0, widx: 6, cap: 256)]
Expected behavior
List<Object> listKeys = Arrays.<Object>asList( BugfixRedissonSetMultimap.this.getName(), setName );
ByteBuf keyState = encodeMapKey(key);
return BugfixRedissonSetMultimap.this.fastRemoveAsync(Arrays.<Object>asList(keyState), listKeys, RedisCommands.EVAL_BOOLEAN_AMOUNT);
Actual behavior
ByteBuf keyState = encodeMapKey(key);
return RedissonSetMultimap.this.fastRemoveAsync(Arrays.<Object>asList(keyState), Arrays.<Object>asList(setName), RedisCommands.EVAL_BOOLEAN_AMOUNT);
Steps to reproduce or test case
RSetMultimap<String, Long> testMap = redisson.getSetMultimap( "test-2" );
RListMultimap<String, Long> testList = redisson.getListMultimap( "test-3" );
try {
	testList.clear();
	testList.put( "t1", 1L );
	testList.put( "t1", 2L );
	testList.put( "t1", 3L );
	RList<Long> list = testList.get( "t1" );
	
	list.delete();
	Assert.isTrue( testList.size() == 0 && testList.get( "t1" ).size() == 0, "List fail" );
			
	testMap.clear();
	testMap.put( "t1", 1L );
	testMap.put( "t1", 2L );
	testMap.put( "t1", 3L );
	RSet<Long> set = testMap.get( "t1" );
			
	set.delete();
	Assert.isTrue( testMap.size() == 0 && testMap.get( "t1" ).size() == 0, "Map fail" );
			
	System.out.println( "success" );
} finally {
	testList.clear();
	testMap.clear();
	redisson.shutdown();
}
Redis version
Redisson version
3.13.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2858
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Merged! Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I see this same issues from #1850 but nothing about how it was fixed or what to do.
My setup is redisson-all.3.13.1 and redisson-tomcat-8-3.13.  I have the RedissonSessionManager configured.
2020-06-19T07:28:51.226 ERROR org.springframework.boot.web.servlet.support.ErrorPageFilter - Forwarding to error page from request [/login] due to exception [org.springframework.security.web.savedrequest.DefaultSavedRequest cannot be cast to org.springframework.security.web.savedrequest.SavedRequest] java.lang.ClassCastException: org.springframework.security.web.savedrequest.DefaultSavedRequest cannot be cast to org.springframework.security.web.savedrequest.SavedRequest at org.springframework.security.web.savedrequest.HttpSessionRequestCache.getRequest(HttpSessionRequestCache.java:74) at org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler.onAuthenticationSuccess(SavedRequestAwareAuthenticationSuccessHandler.java:77) at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.successfulAuthentication(AbstractAuthenticationProcessingFilter.java:326) at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:240) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92)
Is there something I am most likely missing?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
config.setCodec(new StringCodec())
            .useSingleServer()
            .setAddress("redis://" + "******" + ":" + "6379")
            .setConnectionMinimumIdleSize(3)
            .setConnectionPoolSize(3)

using the latest version .
After debugging,I found that when the connection lost,redisson will try to reconnect and it do succeed,but it still throw an Exception.
I have try enlarging the timeout options,But it just idel there .Can somebody tell me how to solve this?
////////////////////////////////////////////
2020-06-20 17:41:58.529 [http-nio-18080-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet].log:175 - USER: NULL_USER Servlet.service() for servlet [dispatcherServlet] in context with path [/api] threw exception
org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 29. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@491672465 [redisClient=[addr=redis://*:6379], channel=[id: 0x1a073aa2, L:/192.168.0.111:60488 - R:/1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@326e8324(failure: java.util.concurrent.CancellationException)], command=(PSETEX), params=[user:token㊙️13560124863, 2592000000, PooledUnsafeDirectByteBuf(ridx: 0, widx: 29, cap: 256)], codec=org.redisson.client.codec.StringCodec]], command: (PSETEX), params: [user:token㊙️13560124863, 2592000000, PooledUnsafeDirectByteBuf(ridx: 0, widx: 29, cap: 256)] after 3 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:680)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:755)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:483)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis version:5.0.8
redisson version: 3.13.1
i have built redis cluster with six instance。and use cluster nodes to view clusters info。
81c9bd0505d0d610f3b059ef5027b8794f96b5bb 192.168.200.150:7004@17004 master - 0 1592836302435 5 connected 13107-16383
e60bd6fbe90da89dad41022a365d4e379b88ce8e 192.168.200.150:7000@17000 myself,master - 0 1592836298000 1 connected 0-3276
336b6c4f860a8a991e64768d4f71bd82e1f8e621 192.168.200.150:7001@17001 master - 0 1592836300420 2 connected 3277-6553
16f3ecdaff94e0bac2b017962107181f7238639b 192.168.200.150:7003@17003 master - 0 1592836301428 4 connected 9830-13106
55c193e6503d06592128a95e33dd422369efd859 192.168.200.150:7002@17002 master - 0 1592836301000 3 connected 6554-9829
but when i try to acquire redissonRedLock, i can not to acquire lock. the IDEA console info:
[redisson-netty-8-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-11-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-14-17] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-2-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-2-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-5-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-5-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-8-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-8-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-11-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-11-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
[redisson-netty-14-18] DEBUG org.redisson.connection.DNSMonitor - Request sent to resolve ip address for master host: 192.168.200.150
[redisson-netty-14-20] DEBUG org.redisson.connection.DNSMonitor - Resolved ip: /192.168.200.150 for master host: 192.168.200.150
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
Redisson in https://github.com/redisson/redisson/blob/master/redisson-all/pom.xml#L96 creates a hard dependency on an SLF4J binding, which if you already have a binding in place in your application, causes logs like:
SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/home/tomcat/apache-tomcat-7.0.90/lib/redisson-all-3.13.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/home/tomcat/apache-tomcat-7.0.90/webapps/some-webapp/WEB-INF/lib/slf4j-nop-1.6.4.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual binding is of type [org.slf4j.helpers.NOPLoggerFactory]

Note the link and warning from SLF4J: http://www.slf4j.org/codes.html#multiple_bindings.  This is a random behavior and could be catastrophic depending on your intended logging config versus what Redisson attempts to do. Also note this paragraph:

Embedded components such as libraries or frameworks should not declare a dependency on any SLF4J binding but only depend on slf4j-api. When a library declares a compile-time dependency on a SLF4J binding, it imposes that binding on the end-user, thus negating SLF4J's purpose. When you come across an embedded component declaring a compile-time dependency on any SLF4J binding, please take the time to contact the authors of said component/library and kindly ask them to mend their ways.

Describe the solution you'd like
Remove the dependency on slf4j-simple and replace it with slf4j-api like is recommended by SLF4J.  This is noted in the SLF4J link above and is concisely:

Embedded components such as libraries or frameworks should not declare a dependency on any SLF4J binding but only depend on slf4j-api.

Describe alternatives you've considered
We have considered rebuilding the Redisson jars to remove this dependency, but it should not be there to begin with.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How could i deserialize a value which put by RedisTemplate of Spring from redis ?
especially when i used RedisTemplate of spring before in my project, and now changed to Redisson.
I get an deserialize failed error.
redisTemplate.opsForValue().set("hello", "world", 5, TimeUnit.MINUTES); String result = (String)client.getBucket("hello").get(); 

exception stack as follows:
, channel: [id: 0x0451a86f, L:/127.0.0.1:60224 - R:127.0.0.1/127.0.0.1:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2875662c(incomplete)], command=(GET), params=[hello], codec=org.redisson.codec.JsonJacksonCodec]
com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'world': was expecting ('true', 'false' or 'null')
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 11]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1804)
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:703)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._reportInvalidToken(UTF8StreamJsonParser.java:3532)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._handleUnexpectedValue(UTF8StreamJsonParser.java:2627)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:832)
at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:729)
at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4141)
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4000)
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3070)
at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:352)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:128)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:108)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does Redisson maintains a map of all the slots available in each master node. Uses this map to figure out the relevant master for read and write and then queries that master?
Or
Does it queries a random master it gives the answer where the slot lies and then queries again the new master.
what is the hashing algorithm being used in Redisson?Just for confirmation it should be CRC16(Key)?
Does it hash the whole key or partial?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在多台机器上部署应用，并发的情况下 threadId 相同，导致Redis中的Key一样，这个时候两台机器都可以获得这个锁，导出出现重入锁，锁失效的问题，还希望能改善解决
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
print error message
Actual behavior
java.lang.NullPointerException
Steps to reproduce or test case
/org/redisson/RedissonBloomFilter.java:185
try {
List result = (List) executorService.execute();
            for (Boolean val : result.subList(1, result.size()-1)) {
                if (!val) {
                    return false;
                }
            }

            return true;
        } catch (RedisException e) {
            if (!e.getMessage().contains("Bloom filter config has been changed")) {
                throw e;
            }
        }

ex:
org.redisson.client.RedisMovedException AND message is null
Redis version
3.0.7
Redisson version
3.11.3
Redisson configuration
ClusterServersConfig clusterServersConfig = config.useClusterServers();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RTopic topic = redissonClient.getTopic("testExceptionTopic");

        topic.addListener(String.class, new MessageListener<String>() {
            @Override
            public void onMessage(CharSequence charSequence, String calc) {
                if (!lockUtils.acquireLock(calc)){
                    return;
                }
                System.out.println("2onMessage:{}" + charSequence+",calc:{}"+ calc);
            }
        });

集群形式下，多个订阅会重复消费吗
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Either no Exception (just create the value, getAndSet shoudl be able to create the value as well) or documented behaviour
Actual behavior
Null Pointer Exception, but only during first execution. Reproducible if I manually delete the value in Redis again
Steps to reproduce or test case
My code looked like that:
        RAtomicLong counterInDb = redissonClient.getAtomicLong(COUNTER);
        if (counterInDb != null)
            return counterInDb.getAndSet(0);
        else {
            return 0;
        }
When the value does not exist yet, counterInDb is not null but calling getAndSet on it without checking isExists as well in the if gives me a NullPointerException at RedissonAtomicLong.java:122. This is quite confusing as

The Null Pointer Exception is from the implicit cast from Long to long, which makes it really hard to spot
There is no JavaDoc warning that this might happen

Redis version
docker.io/bitnami/redis:6.0.5-debian-10-r10
Redisson version
3.13.1
Redisson configuration
        Config config = new Config();
        config.useSingleServer()
                .setAddress("redis://redis-kube-master.default.svc.cluster.local:6379")
                .setPassword(getRedisPassword());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am running tomcat with Equinox and want to use redisson for session storage. The shared session storage works fine but I have this error in my localhost.xxx.log.
java.util.ServiceConfigurationError: javax.cache.spi.CachingProvider: Provider org.redisson.jcache.JCachingProvider not a subtype
	java.util.ServiceLoader.fail(ServiceLoader.java:239)
	java.util.ServiceLoader.access$300(ServiceLoader.java:185)
	java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:376)
	java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404)
	java.util.ServiceLoader$1.next(ServiceLoader.java:480)
	javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:438)
	javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:432)
	java.security.AccessController.doPrivileged(Native Method)
	javax.cache.Caching$CachingProviderRegistry.getCachingProviders(Caching.java:432)
	javax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:370)
	javax.cache.Caching$CachingProviderRegistry.getCachingProvider(Caching.java:351)
	javax.cache.Caching.getCachingProvider(Caching.java:142)

Here is my redisson.config.yaml
useThreadClassLoader: false

singleServerConfig:
  address: "redis://redis:6379"

I am not actually interested in replacing the caching provider. I'd like to use redisson only for shared session storage.
Appreciate your ideas.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I wanted to run Redis Native commands using redisson provided low-level client, However.  Some of the commands i see not exposed from RedisCommands.java are:
HASH COMMANDS Not supported
HINCRBY
HINCRBYFLOAT
HMGET
STRING COMMANDS NOT SUPPORTED
BITFIELD
BITOPS
DECRBY
SETEX
STRALGO
I just explored String and Hash commands, however list of commands not supported might be more.
Usage:
RedisClient redisClient = RedisClient.create(new RedisClientConfig().setAddress("redis://localhost:6379"));
RedisConnection conn = redisClient.connect();
conn.async(StringCodec.INSTANCE, RedisCommands.MSET, "keys1","values1","keys2","values2");
a) Is there are way i can actually run the redis native commands via some interfaces ?
b) Any reason why redisson is not exposing complete set of redis native commands ?  Does Redisson make any effort on a regular basis to support new commands that are offered by Redis   ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, to configure redisson for hibernate only using code (like env variables) i subclass the RedissonRegionFactory and override method createRedissonClient. This works great until i want to take advantage of the property hibernate.cache.redisson.fallback. This property has private access so i cant alter it in the same way as the base class do. My only way forward is via reflections which is hackish...
Could you provide a protected setter or refactor code for fallback-setting to a protected method? Also allow for inheritance in the future. Thanks!
My code as follow (CacheManager is configured elsewhere)
public class CodeConfigRedissonRegionFactory extends org.redisson.hibernate.RedissonRegionFactory {

    @Override
    protected RedissonClient createRedissonClient(Map properties) {
        String host = System.getenv(……..);
        String password = System.getenv(………..);
        Config config = RedisCacheConfig.buildConfig(host, password);
        String fallbackValue = (String) properties.getOrDefault(FALLBACK, "false");

        // Base class has private attributes... Hack until fixed!
        try {
            java.lang.reflect.Field privateField = this.getClass().getSuperclass().getDeclaredField("fallback");
            privateField.setAccessible(true);
            privateField.set(this, Boolean.valueOf(fallbackValue));
        } catch (Exception e) {...}
        return Redisson.create(config);
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi everybody,
I am experiencing unexpected behaviour(at least from my perspective) when I try to use RedissonRegionFactory.
what I am trying to do is:

I have a clustered application and all of my nodes are using same database, and I was configured ehcache for second level cache on each node, and when something happened on one entity, I was sending an event to other nodes for evict their 2LC to keep data consitenct over the cluster.  Now I try to replace that eh_cache + event system with one central 2lc provider.

for that surpose,  first node is connecting and configuring redis on its startup.
how I am configuring redis:

providing redisson.yaml
putting entity and query configurations as follows.;
-- for instance my entity is com.fatih.example.A : max-size 100, TTL: 600sec, TTIO: 600sec. I am adding configurations like this:
hibernatePropMap.put(hibernate.cache.redisson.com.fatih.example.A.eviction.max_entries, 100) 
hibernatePropMap.put(hibernate.cache.redisson.com.fatih.example.A.expiration.time_to_live, 600)
hibernatePropMap.put(hibernate.cache.redisson.com.fatih.example.A.expiration.max_idle_time, 600)
-- for some custom queries,
hibernatePropMap.put(hibernate.cache.redisson.query.customField.eviction.max_entries, 100)
hibernatePropMap.put(hibernate.cache.redisson.query.customField.expiration.time_to_live, 1800)
hibernatePropMap.put(hibernate.cache.redisson.query.customField.expiration.max_idle_time, 1800)

after first node startup is completed I put a flag on redis to avoid second configuration from other nodes. like 2lc-applied=true
I am able to see redis keys/values like this:
redis-cli > hgetall "com.fatih.example.A"
1) some hex key
2) some hex value
redis-cli > zrange "redisson__idle__set:{com.fatih.example.A}" 0 1
1) "\x04\x04\t>3org.hibernate.cache.internal.CacheKeyImplementation . . ."
redis-cli > zrange "redisson__map_cache__last_access__set:{com.fatih.example.A}" 0 1
1)  "\x04\x04\t>3org.hibernate.cache.internal.CacheKeyImplementation . . ."

after started to second node (which is not doing any configuraiton on redis, it is just connecting it via provided rdisson.yaml), when I check keys/values, they are gone as follows;
redis-cli > hgetall "com.fatih.example.A"
(empty array)
redis-cli > zrange "redisson__idle__set:{com.fatih.example.A}" 0 1
(empty array)
redis-cli > zrange "redisson__map_cache__last_access__set:{com.fatih.example.A}" 0 1
(empty array)

I would be appreciated for any idea advice whatever to help to understand why this behave like this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
情况是这样：我们有6个一样的springboot 服务，其中1个服务报出了这种错误，看源码好像有点像 主节点被当成从节点时，会报这种错误
the situation ：We have six of the same springboot app，One of them reported a mistake，This mistake is a bit like the master node is treated as a slave node by Read the source code
2020-07-01 14:41:33,226 [http-nio-22206-exec-7] ERROR c.s.c.w.e.GlobalExceptionHandler.defaultErrorHandler(GlobalExceptionHandler.java:122) - Unexpected error msg:SlaveConnectionPool no available Redis entries. Master entry host: /172.28.50.76:9001 Disconnected hosts: [/172.28.50.76:9001]
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: /172.28.50.76:9001 Disconnected hosts: [/172.28.50.76:9001]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:254)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:480)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:641)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:643)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:115)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:243)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Redis version
4.0.14
Redisson version
3.13.1
Redisson configuration
spring.redis.master.connectionPoolSize = 200
spring.redis.slave.connectionPoolSize = 400
spring.redis.slave.connectionMinimumIdleSize = 100
spring.redis.connectTimeout = 5000
spring.redis.timeout = 5000
spring.redis.slaveFailsInterval = 180000
spring.redis.pingConnectionInterval = 30000
clusterServersConfig.setMasterConnectionPoolSize(this.masterConnectionPoolSize);
clusterServersConfig.setSlaveConnectionPoolSize(this.slaveConnectionPoolSize);
clusterServersConfig.setSlaveConnectionMinimumIdleSize(this.slaveConnectionMinimumIdleSize);
clusterServersConfig.setConnectTimeout(this.connectTimeout);
clusterServersConfig.setTimeout(this.timeout);
Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry, but you can't use different objects under the same name.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version:
spring-boot : 2.2.2
redisson-spring-boot-starter: 3.12.1
redis: 4.0.10
test case
    @GetMapping("/testRedisson")
    public void testRedisson() {
        String s = UUID.randomUUID().toString();
        ExecutorService executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                1000L, TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>());
        log.info("startLock ");
        IntStream.rangeClosed(0, 500).boxed().forEach(new Consumer<Integer>() {
            @Override
            public void accept(Integer integer) {
                executorService.submit(new Runnable() {
                    @Override
                    public void run() {

                        RLock test = redissonClient.getFairLock(s);
                        test.lock(5, TimeUnit.SECONDS);
                        ThreadUtil.sleep(200); // 200ms
                        log.info("endLok {}", integer);
                        test.unlock();
                    }
                });
            }
        });
        executorService.shutdown();

    }

RedissonFairLock result
Only more than 100 "endLok" were printed。if use RedissonLock，it can be print all。
redis has key "redisson_lock_queue:{4e6cbfe2-1dc0-4956-bec3-ba9aaf16f63e}" and  "redisson_lock_timeout:{4e6cbfe2-1dc0-4956-bec3-ba9aaf16f63e}" Blocking program running
127.0.0.1:6379> LRANGE redisson_lock_queue:{4e6cbfe2-1dc0-4956-bec3-ba9aaf16f63e} 0 10
 1) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1123"
 2) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1124"
 3) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1125"
 4) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1126"
 5) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1127"
 6) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1128"
 7) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1129"
 8) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1130"
 9) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1131"
10) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1132"
11) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1134"

127.0.0.1:6379> ZRANGE redisson_lock_timeout:{4e6cbfe2-1dc0-4956-bec3-ba9aaf16f63e} 0 258 WITHSCORES
  1) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1186"
  2) "1593669091698"
  3) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1188"
  4) "1593669096698"
  5) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1191"
  6) "1593669101698"
  7) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1187"
  8) "1593669106698"
  9) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1189"
 10) "1593669111698"
 11) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1190"
 12) "1593669116698"
 13) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1192"
 14) "1593669121698"
 15) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1193"
 16) "1593669126698"
 17) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1194"
 18) "1593669131698"
 19) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1195"
 20) "1593669136698"
 21) "19df2c25-acc0-42c1-b1a3-9f6f2f41e401:1196"
 22) "1593669141698"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson client config
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://" + redisHost + ":" + redisPort)
            .setPassword(redisPass);
        return Redisson.create(config);
    }

use the redisson lock
RLock lock = redissonClient.getLock("lock_key");
if (lock.tryLock()) {
  try{
      // do business logic
  }finally {
    lock.unlock();
  }
}


Expected behavior
get lock and continue to do business logic
Actual behavior
after first time fail and three times retry fail, I got RedisResponseTimeoutException
Caused by: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, settlement_platform:importPaymentList, 30000, 91e0ee36-9066-482f-a10f-80a80a921772:58], channel: [id: 0xc05adfb7, L:/192.168.1.102:54095 - R:172.20.10.104/172.20.10.104:6379]
    at org.redisson.command.CommandAsyncService$8.run (CommandAsyncService.java:934)
    at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire (HashedWheelTimer.java:682)
    at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts (HashedWheelTimer.java:757)
    at io.netty.util.HashedWheelTimer$Worker.run (HashedWheelTimer.java:485)
    at java.lang.Thread.run (Thread.java:748)

Steps to reproduce or test case
the prerequisite is

your redis server require a password auth
your redisson client in a NAT

your redis server config have this:
tcp-keepalive 300

after 5 minute you will get this RedisResponseTimeoutException problem, however the redis server did not receive the request at all.
Redis version
5.0.4
Redisson version
3.11.1
Redisson configuration
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://" + redisHost + ":" + redisPort)
            .setPassword(redisPass);
        return Redisson.create(config);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
如题
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey there!
What is the proper way to configure Redisson when you have a AWS ElastiCache Redis running as Clustered Mode? I have tried to set using it as follows:
    val nodeAddress = "redis://test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com:6379" 
    val config = Config()
    val configCluster = config.useClusterServers().addNodeAddress(nodeAddress)
    val client = Redisson.create(config)

Node endpoint: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com
Configuration endpoint: test-rest-encryption.p0vefj.clustercfg.use1.cache.amazonaws.com
For nodeAddress, I have tried to use configuration endpoint and node endpoint but fails in both case (connection timed out):
21:04:39.542 [main] WARN  o.r.cluster.ClusterConnectionManager - connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379
Exception in thread "main" org.redisson.client.RedisConnectionException: Can't connect to servers!
	at org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:144)
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:237)
	at org.redisson.Redisson.<init>(Redisson.java:117)
	at org.redisson.Redisson.create(Redisson.java:156)
	at aus.web.SessionManagerApplicationKt.main(SessionManagerApplication.kt:23)
Caused by: io.netty.channel.ConnectTimeoutException: connection timed out: test-rest-encryption-0001-001.p0vefj.0001.use1.cache.amazonaws.com/172.31.19.41:6379
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261)
	at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)

Am I missing something?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
use redisson sentinel mode
sentinel
Expected behavior
work fine
Actual behavior
org.redisson.client.RedisException: READONLY You can't write against a read only replica.. channel: [id: 0xa1a322cd L:/.:** - R:********] command: (EVAL), params: [if (redis.call('exists',KEYS[1])==0 then redis.call('hset',KEYS[1],ARGV[2],1)];redis.call('pr... ,1,
Steps to reproduce or test case
Config config = new Config();
config.useSentinelServers();
....
config file:
redisson:
sentinel:
addresses:
- redis://:26379
- redis://:26379
- redis://**:26379
password: ********
master-name: mymaster
ping-connection-interval: 5000
keep-alive: true
timeout: 10000
master-connection-minimum-idle-size: 10
slave-connection-minimum-idle-size: 10
Redis version
Redis version=5.0.5, bits=64,
Redisson version
3.9.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2984
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I am facing error while connecting to cluster.
It is giving following error::
java.lang.IllegalArgumentException: port out of range:-1
at java.net.InetSocketAddress.checkPort(InetSocketAddress.java:143)
at java.net.InetSocketAddress.(InetSocketAddress.java:224)
at org.redisson.client.RedisClient.(RedisClient.java:93)
at org.redisson.connection.MasterSlaveConnectionManager.createClient(MasterSlaveConnectionManager.java:310)
at org.redisson.cluster.ClusterConnectionManager.connect(ClusterConnectionManager.java:150)
at org.redisson.cluster.ClusterConnectionManager.(ClusterConnectionManager.java:81)
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:172)
at org.redisson.Redisson.(Redisson.java:103)
at org.redisson.Redisson.create(Redisson.java:133)
Actually it not generating ClientPartition.getMasterAddress() properly.
Address is //127.0.0.1:8001@18001 as recorded by CLUSTER_NODES, but it reads it as host: 18001 and port=-1.
Cluster config from CLUSTER_NODES::
[ClusterNodeInfo [nodeId=4317f285b359ddc3ac08bb85239924509146e475, address=//127.0.0.1:8003@18003, flags=[SLAVE], slaveOf=4118a348827e6107d7e35522a251fd39c5a8f82b, slotRanges=[]], ClusterNodeInfo [nodeId=2f7b93c80d3721b3fb26fe87bc28ed04a63fe0ec, address=//127.0.0.1:8005@18005, flags=[SLAVE], slaveOf=8b81c3e1acb4e1959a83267540058d1a6bffa12f, slotRanges=[]], ClusterNodeInfo [nodeId=4118a348827e6107d7e35522a251fd39c5a8f82b, address=//127.0.0.1:8001@18001, flags=[MASTER], slaveOf=null, slotRanges=[[5461-10922]]], ClusterNodeInfo [nodeId=a0770863d893a5b8106a83e247cea2544f99ef36, address=//127.0.0.1:8004@18004, flags=[SLAVE], slaveOf=6b9da1bbe38b978a3017406e5c1e310f4706cfc8, slotRanges=[]], ClusterNodeInfo [nodeId=8b81c3e1acb4e1959a83267540058d1a6bffa12f, address=//127.0.0.1:8000@18000, flags=[MYSELF, MASTER], slaveOf=null, slotRanges=[[0-5460]]], ClusterNodeInfo [nodeId=6b9da1bbe38b978a3017406e5c1e310f4706cfc8, address=//127.0.0.1:8002@18002, flags=[MASTER], slaveOf=null, slotRanges=[[10923-16383]]]]
My code is ::
Config config = new Config();
config.useClusterServers()
.addNodeAddress("redis://127.0.0.1:8000");
RedissonClient redisson = Redisson.create(config);
RMap<String, String> map = redisson.getMap("simpleMap");
map.put("mapKey", "This is a map value");
String mapValue = map.get("mapKey");
System.out.println("stored map value: " + mapValue);
redisson.shutdown();
Also, tried with
.addNodeAddress("127.0.0.1:8000");
Dependencies::
 
     org.redisson
     redisson
     2.3.0
 
Let me know if any other detail is required.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redis 4
Tomcat 9
Redisson 3.13.3
The session details are maintained in a  Vector class which doesn't have a default constructor
Sample class below:
public class Test1 extends Vector implements Serializable
{
private String cName;
            public Test1(String sName)      # This is the only constructor
            {
                            c = sName;
            }

}
While deserialising session data , we are getting following error
[redisson-netty-2-12] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x62b212db, L:/192.168.15.3:51412 - R:redis-svc/[ip:port], reply: ReplayingDecoderByteBuf(ridx=187, widx=416), command: (HGETALL), params: [redisson:tomcat_session:8F92D92D6DFCA04B858558540BB52535]
java.io.IOException: java.lang.InstantiationException: Test1
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:228)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:428)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393)
…
Caused by: java.lang.InstantiationException: Test1
at java.lang.Class.newInstance(Class.java:427)
at org.nustaq.serialization.serializers.FSTCollectionSerializer.instantiate(FSTCollectionSerializer.java:83)
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadWithSer(FSTObjectInput.java:501)
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370)
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
We are using RedissonSessionManager to store tomcat sessions to Redis. When session object contains object of type Java Vector  without default constructor, it  throws a deserialisation exception
[redisson-netty-2-12] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0x62b212db, L:/192.168.15.3:51412 - R:redis-svc/[ip:port], reply: ReplayingDecoderByteBuf(ridx=187, widx=416), command: (HGETALL), params: [redisson:tomcat_session:8F92D92D6DFCA04B858558540BB52535]
java.io.IOException: java.lang.InstantiationException: Test1
at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247)
at org.redisson.codec.FstCodec$1.decode(FstCodec.java:228)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:384)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:428)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:393)
…
Caused by: java.lang.InstantiationException: Test1
at java.lang.Class.newInstance(Class.java:427)
at org.nustaq.serialization.serializers.FSTCollectionSerializer.instantiate(FSTCollectionSerializer.java:83)
at org.nustaq.serialization.FSTObjectInput.instantiateAndReadWithSer(FSTObjectInput.java:501)
at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:370)
at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331)
Actual behavior
Session should get stored and retrieved from redis
Steps to reproduce or test case
The session details are maintained in a Vector class which doesn't have a default constructor. When we try to add this to redis session it fails
Sample class below:
public class Test1 extends Vector implements Serializable
{
private String cName;
        public Test1(String sName)      # This is the only constructor
        {
                        cName = sName;
        }

}
Redis version
Redisson version
Redis 4
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: null
subscriptionsPerConnection: 5
clientName: null
address: "redis://IP:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 24
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
threads: 16
nettyThreads: 32
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
anotherValue
Actual behavior
null
Steps to reproduce or test case

  @Test
  public void test() {
    RMapCache<String, String> testRMapCache = redissonClient.getMapCache(RedissonTest.testRMapCache);
    testRMapCache.fastPut("key", "value", 20, TimeUnit.SECONDS);
    try {
      //wait for key timeout
      Thread.sleep(21 * 1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    //try to put "key-anotherValue", then get the "key", but the "result" is null
    testRMapCache.put("key", "anotherValue");
    String result = testRMapCache.get("key");
    System.out.println("result: " + result);// null
  }

Redis version
docker redis 5.0.5
Redisson version
redisson-spring-boot-starter
3.13.1
Redisson configuration
redisson-spring-boot-starter default config and localhost redis
spring.redis.host=192.168.85.253
spring.redis.port=6379
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Delayed Queue 在 CLUSTER 模式下无法准时将数据存放到目标队列中，在下一次offer时才会将超时的数据放入目标队列中
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2994
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Facing the following issue during HA testing the application wtih Redisson Client:::
Redisson Version: 3.11.6
Redis Cluster: 3M + 2S
Steps:

Kill one of the masters, the slave becomes the master.
Make the master up after a minute, it then becomes the slave.
Kill the master node(which was slave), the slave becomes the master.
Sometimes its not reproducible in one shot, need to do this 3-4 times.

At this point, redisson is not able to read/write anything to that redis partition  because the client is still taking the previous master(which was killed) and not the promoted slave node.
As per below logs, port 8000 was the master node, which was killed, and the slave node 9000 was promoted to master. But still Redisson is sending the command to the previous master node. We need to restart the application to make it working or make the previous master up.
Redis Cluster Nodes Command:::
10.32.xxx.xx:8000 master,fail - 1597924494641 1597924493739 29 connected
10.32.xxx.xx:8002 master - 0 1597924565415 3 connected 10923-16383
10.32.xxx.xx:9001 slave e0633f21c6a79ad10c9a8696a45991867aabc879 0 1597924566919 2 connected
10.32.xxx.xx:9000 master - 0 1597924566417 30 connected 0-5460
10.32.xxx.xx:8001 myself,master - 0 0 2 connected 5461-10922
Logs:::::
org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=5048, addr=null, redi
sClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:qu
eue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:64:queue:0, freezed=false, freezeReason=null, client=[addr=redis://10.32.xxx.xx:8000], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@427802830 [redisClient=[addr=redis://10.32.xxx.xx:8000], channel=[id: 0xda6d
e1f2, L:0.0.0.0/0.0.0.0:35504], currentCommand=null]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We had an issue where the IP address of the Redis server changed. We saw logs like these from the DNSMonitor:
Detected DNS change. Master rediss://{host}:{port} has changed ip from IP1 to IP2
Unable to find master entry for host/{IP1}:port. Multiple IP bindings for single hostname supported only in Redisson PRO!
I saw in response to a similar issue the recommendation to disable DNS monitoring. I tried to prototype (with 3.13.3) on a local PC using the hosts file to simulator a DNS change. But Redisson continues to use the earlier resolved IP address instead of resolving the hostname again. I confirmed with InetAddress.getByName() that I can retrieve the updated IP address, but Redisson is still trying to use the old one.
I also tried to detect the connection drop when the IP changes (using ConnectionListener) and then completely recreate the Config and RedissonClient objects with the hostname, but still the older IP is used, and shown in the exception after failure to connect. I guess it remains cached somewhere?
Exception in thread "Thread-0" org.redisson.client.RedisConnectionException: Unable to connect to Redis server: host/{IP1}:6379
Is there any way to force a new attempt to resolve the IP?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In cluster mode, delayed queue can't put the data to the target queue on time. The timeout data will be put into the target queue when the next offer is made
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
i use the RedissonQueue 'pollAsync(int limit)' method,
after i poll some elements, the capacity of the queue did not recovery,
at last, the capacity becomes 0, wow , i can not offer element any more!!!!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/2999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko ptal before releasing 3.13.4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko sorry, didn't see this until we deployed to staging redis cluster with read slaves.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
UP
Actual behavior
DOWN because of the exception
`2020-08-21 15:02:50.698  WARN 1 --- [oundedElastic-1] o.s.b.a.r.RedisReactiveHealthIndicator   : Redis health check failed
java.lang.ClassCastException: class com.sun.proxy.$Proxy122 cannot be cast to class org.redisson.Redisson (com.sun.proxy.$Proxy122 and org.redisson.Redisson are in unnamed module of loader org.springframework.boot.loader.LaunchedURLClassLoader @1d56ce6a)
at org.redisson.spring.data.connection.RedissonConnectionFactory.getReactiveConnection(RedissonConnectionFactory.java:149) ~[redisson-spring-data-23-3.13.2.jar!/:3.13.2]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
at java.base/java.lang.reflect.Method.invoke(Method.java:567) ~[na:na]
at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
at org.springframework.cloud.context.scope.GenericScope$LockedScopedProxyFactoryBean.invoke(GenericScope.java:499) ~[spring-cloud-context-2.2.4.RELEASE.jar!/:2.2.4.RELEASE]
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
at org.redisson.spring.data.connection.RedissonConnectionFactory$$EnhancerBySpringCGLIB$$503ddcc5.getReactiveConnection() ~[redisson-spring-data-23-3.13.2.jar!/:3.13.2]
at reactor.core.publisher.MonoSupplier.call(MonoSupplier.java:85) ~[reactor-core-3.3.9.RELEASE.jar!/:3.3.9.RELEASE]
at reactor.core.publisher.FluxSubscribeOnCallable$CallableSubscribeOnSubscription.run(FluxSubscribeOnCallable.java:225) ~[reactor-core-3.3.9.RELEASE.jar!/:3.3.9.RELEASE]
at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:68) ~[reactor-core-3.3.9.RELEASE.jar!/:3.3.9.RELEASE]
at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:28) ~[reactor-core-3.3.9.RELEASE.jar!/:3.3.9.RELEASE]
at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]
at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na]
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]
at java.base/java.lang.Thread.run(Thread.java:830) ~[na:na]`
Steps to reproduce or test case
Create a project that use org.springframework.cloud.context.config
`@Configuration
public class RedisConfig {
@Autowired
private BeanFactory factory;

@Bean
@RefreshScope
public RedisConfigurationProperties properties() {
    return new RedisConfigurationProperties();
}

@Bean
@RefreshScope
public RedissonClient redissonClient(RedisConfigurationProperties props) {
    Config config = new Config();
    config.useSingleServer().setAddress(String.format("redis://%s:%s", props.getHost(), props.getPort()));

    RedissonClient redissonClient = Redisson.create(config);

    return redissonClient;
}

@Bean
@RefreshScope
public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
    return new RedissonConnectionFactory(redisson);
}

}`
Do a get on /actuator/health
Redisson version
3.13.3, with redisson-spring-boot-starter (3.13.3) and redisson-spring-data-23 (3.13.3)
Redisson configuration
Single server
host: localhost
port: 6379
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there an interface I can use to do get, set and del operations with byte[] keys?
public byte[] get(byte[] key) {
      if (key == null) {
         return new byte[0];
      }
      return redissonClient.getBucket(key);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/3005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Regarding #2932, when we confirmed the effect using 3.12.3, the phenomenon was not resolved.
After the failover is complete, access to the new master keeps failing.
Could you please provide the conditions and details of the bugs that have been corrected?
f220d92
I don't know if it is related to this case,
I'm currently using it in a non-cluster mode configuration where Redisson's addNodeAddress specifies the primary endpoint of the node group.
According to the issue below, you are asked to specify the endpoint of each node.
#2644　[Redisson Configuration For AWS ElastiCache]
Is it related to this phenomenon?
※ As a test, I fixed it so that the endpoint of each node was specified, and the phenomenon that it continued to fail after failover did not occur.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
one GET command results in one tcp request and done
Actual behavior
one GET command results in tens of tcp request
Steps to reproduce or test case
very hard to reproduce, don't know what caused this
Redis version
4.0
Redisson version
3.11.2
Redisson configuration
redisson-spring-boot-starter 3.11.2 default config
tcpdump below is from a container without error log now(used to have 2 days ago), the application execute scheduled task every 30 seconds so more easy to analyze
some code samples:
@scheduled(fixedDelay = 30000L)
public void refresh() {
long currentVersion = 0L;
try {
currentVersion = redissonClient.getAtomicLong(RedisConstant.DIALOG_CONFIG_VERSION).get();
} catch (Exception e) {
}
if (currentVersion > oldVersion) {
doBusiness();
}
}
in some application, this causes to much request and finally command timeout:
Caused by: org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://**********:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@461031069 [redisClient=[addr=redis://***:6379], channel=[id: 0xf6f78dd7, L:/172.18.7.150:41846 - R:/10.210.0.239:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@15bd3b82(failure: java.util.concurrent.CancellationException)], command=(INFO DEFAULT), params=[], codec=org.redisson.client.codec.StringCodec]], command: (EVAL), params: [if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call('h..., 2, blacklist-write-81581, redisson_lock__channel:{blacklist-write-81581}, 0, 30000, a5d12374-6c70-4851-96f0-9278a25e428e:69] after 3 retry attempts
application-redis-tcpdump.log
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
I wan't to use redis scan operation via redisson (like in Jedis).
I'm checked next solution.
For example, i have 3 objects inside Redis and want to retrieve only 2
 val keysIterator = redissonClient.keys.getKeysByPattern("some-pattern", 2).iterator()
 while (keysIterator.hasNext()) {
        println(keysIterator.next())
}

But instead of retriving 2 objects, getKeysByPattern("some-pattern", 2) returns all keys from redis.
This behaviour is correct?
Anyway, i'am trying to use SCAN operator via Lua scripts.
val lua = "return {redis.call('SCAN',ARGV[1],'MATCH',ARGV[2],'COUNT',ARGV[3])}"
redissonClient
                .getScript(StringCodec.INSTANCE)
                .eval<List<List<String>>>(RScript.Mode.READ_ONLY,
                        lua,
                        RScript.ReturnType.MAPVALUELIST,
                        listOf(),
                        0,
                        "some-pattern",
                        2)

And this aproach is working one.
But why keys.getKeysByPattern(pattern, count) returns all keys instead of count?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
If we have configured the org.apache.catalina.authenticator.SingleSignOn valve in our application, does Redisson push the ssoId also to Redis? Do we have to make any other configuration changes other than what's mentioned in redisson-tomcat Readme for this to work?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
We are using Redisson to connect to ElastiCache to get RBucket in the AWS lambda. The trigger of the AWS lambda is a SQS(with batch size 10). The logic for this lambda is to get the RBucket for each message from SQS.(Redisson.get(BUCKET_KEY))
When traffic is low, no exception happens(TPS is around 50), but when traffic becomes higher(Max TPS is around 900), the invocation and concerencent number for lambda function is getting higher, and then some RedisTimeoutExceptions are thrown by Redisson. Therefore, the backlog of the SQS is increasing.
Here is the detailed Exception log when executing Redisson.get():
2020-08-20 00:11:57 ##redisson-netty-1-3 ERROR ReplicatedConnectionManager:193 - Command execution timeout for default-replication-group.no4.ng.0001.euw1.cache.amazonaws.com/10.0.14.79:6379
org.redisson.client.RedisTimeoutException: Command execution timeout for default-replication-group.no2m94.ng.0001.euw1.cache.amazonaws.com/10.0.14.79:6379
	at org.redisson.client.RedisConnection$2.run(RedisConnection.java:193) [Redisson-3.x.jar:?]
	at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-all-4.1.jar:4.1.48.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-all-4.1.jar:4.1.48.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_201]

Here is the current Redisson Config, the other
final Config config = new Config();
config.setCodec(new JsonJacksonCodec(new ObjectMapper()));
config.setNettyThreads(64);
config.useReplicatedServers()
    .setReadMode(ReadMode.SLAVE)
    .setTimeout(60000)
    .addNodeAddress(redisUrl);
return Redisson.create(config);

Here are some question I want to get cleared:


I'm wondering what the detailed root cause for org.redisson.client.RedisTimeoutException: Command execution timeout for . Is that means the Redisson configtimout is shorter than expected? But I think purely increasing the timeout seems cannot scale up the capacity to handle the high TPS.


To resolve this issue, how can I modify the Redisson Config to handle such a high traffic? I followed the Redisson FAQ to scale up the config, but not sure how to come up with a suitable config.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
An error occurred when setting the expiration time ：
java.lang.ClassCastException: com.model.test.JobRecordRedisEntity cannot be cast to org.redisson.api.RMap
JobRecordRedisEntity entity = new JobRecordRedisEntity();
entity.setFireInstanceId("q"+i);
entity.setJobId("111111");
entity.setFailcount(4);
entity.setCreatetime(3333333333333l);
entity.setScheduleFireTime("q");
entity.setNextFireTime("w");
entity.setExecutedTime("w"+i);
entity.setRunningResult("seccess");
entity.setMisfired("3");
entity.setRecordId("123456qaz");
        boolean exists = service.isExists(service.get(JobRecordRedisEntity.class, entity.getRecordId()));
        if (exists){
            service.merge(entity);
        }else {
            service.persist(entity);
        }

        **service.asRMap(entity).expire(3, TimeUnit.SECONDS);**
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I see that there is the 'touch' operation on the RObject class but I don't see any method to retrieve the value for last access time.
Maybe is missing the command 'OBJECT IDLETIME'
If yes I can try to add that command.
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After successfully setting up Redisson as Tomcat session manager I get the following exception when trying to access the application:
java.io.NotSerializableException: de.schlund.pfixxml.serverutil.SessionAdmin
I also received another exception pointing to jboss-Marschalling also in regards to NotSerializableException.
As far as I understood the documentation, it would not be required to fix application code to move tomcat sessions to Redis via redisson. Am I wrong with my assumption?
Trying to solve this issue with different codecs did not work either.
Tomcat Version: 9.0.22
Redisson Version: all: 3.13.3, tomcat 9-3.10.6
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Is it possible to find an example where a Redisson Map<String,SomeObject> is serialized to the Redis DB by a process P1. This Map is then accessed in another process  P2, also P2 should get notified about the updates made to this map by Process P1.
Any pointers to get started with this?
I see MapWriter example on Wiki. Does that example assume Oracle DB beneath?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi There,
I am using Redis library in my application.
Now I am planning to use RLiveObjectService  for search page (instead of DB will read from Redis Cache).
I do see that there are methods available  in RLiveObjectService for find , get , detele and instert to update Cache
I am looking for method like mergeAll or persistAll using which I can initialize cache during application startup.
Is there any way to achieve this.?
Thanks in Advance.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi guys,
I stumble upon a weird issue for my project. I am trying to delete RMap key by a pattern. I follow the documentation and it seems I could do that by getting the keyset and passing the pattern, and delete the found keys via the fastRemove method.
However It does not work for me.
I am using redisson library version 3.12.3 for Java, and the cache is deployed through elastic cache AWS.
The setup is like the following:
the RMap name is jsonCollectionV3 and the item key inside the map I tried to delete is  100011176limit5offset2 the pattern I am using is 100011176*
Please find below the code I am trying to use to fetch the key pattern from the map and using the fastRemove to delete the key retrieved.

However as per log below and entry in Redis desktop manager, the key is not removed from the map, the size still one.


If you guys can help me point out where did I do wrong, that will be great! thanks a lot. I have tried changing the key format for storing the records and it is not working as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I'm trying to setup redisson for tomcat 8, and i'm getting this exception at the start:
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'UNKNOWN-UNKNOWN' with class 'eu.bitwalker.useragentutils.UserAgent' to class 'eu.bitwalker.useragentutils.UserAgent'
I think it may be related to incorrect dependencies? In order to get the tomcat to start withouth errors, i had to manually add some libraries to the tomcat instance because redisson was failing with multiple exceptions related to classNotFound, these are the dependecies i had to add:

fst-2.57.jar
objenesis-3.1.jar
UserAgentUtils-1.21.jar

This is the redisson.conf i'm using
{ "singleServerConfig": { "idleConnectionTimeout": 10000, "connectTimeout": 10000, "timeout": 3000, "retryAttempts": 3, "retryInterval": 1500, "password": null, "subscriptionsPerConnection": 5, "clientName": null, "address": "redis://xxxxx.0001.use1.cache.amazonaws.com:6379", "subscriptionConnectionMinimumIdleSize": 1, "subscriptionConnectionPoolSize": 50, "connectionMinimumIdleSize": 24, "connectionPoolSize": 64, "database": 0, "dnsMonitoringInterval": 5000 }, "threads": 16, "nettyThreads": 32, "codec": null, "transportMode": "NIO" }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Faced a problem while using redisson client after random period of time. the generated stack trace is:
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: /10.183.127.25:6379 Disconnected hosts: [k-dtce-rb-prd42/10.183.127. 25:6379] at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218) at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30) at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:254) at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:499) at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:641) at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:640) at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:115) at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:243) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748) $$$
the problem that the client does not recover until the application is restarted while another instances using that client is working normally.
Config:
redis.bulk_size=10000
redis.timeout=3000
redis.connection.timeout=10000
redis.idle.connection.timeout=10000
redis.retry.attempts=3
redis.retry.interval=1500
redis.batch.retry.attempts=3
redis.batch.retry.interval=1500
redis.batch.response.timeout=3000
redis.lock.wait.time.milliseconds=1000
redis.lock.lease.time.milliseconds=1000
redis.netty.threads=32
Redis Cluster Configs
redis.cluster.master.pool.size=64
redis.cluster.slave.pool.size=64
redis.cluster.master.minimum.idle.size=24
redis.cluster.slave.minimum.idle.size=24
redis.ping.connection.interval=2000
redis.keep.alive=true
redis.tcp.no.delay=true
CLient: redisson 3.13.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As far as I know, when I put a value to the queue,it will check the size of queue,the value is maintained at the key named redisson_bqs:... ,if the redisson_bqs's value <=0,it won't put any more.
This is the command for method poll():
org.redisson.RedissonBoundedBlockingQueue#pollAsync()
local res = redis.call('lpop', KEYS[1]);if res ~= false then local value = redis.call('incrby', KEYS[2], ARGV[1]); redis.call('publish', KEYS[3], value); end;return res;
If it gets the value,  it will increment the value of redisson_bqs by 1.
The following is the command for method poll(int limit)
org.redisson.RedissonQueue#pollAsync(int)
local result = {};for i = 1, ARGV[1], 1 do local value = redis.call('lpop', KEYS[1]);if value ~= false then table.insert(result, value);else return result;end;end; return result;
It doesn't increment the value of redisson_bqs. When The number of times I put reaches the initial capacity, it won't put any more.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
调用代码：
List resultList = redisTemplate.executePipelined((RedisCallback)connection -> {
for (Long id: idList) {
connection.get(key.getBytes());
}
return null;
}, redisTemplate.getValueSerializer());
Expected behavior
Actual behavior
Caused by: java.lang.UnsupportedOperationException
at java.util.AbstractList.remove(AbstractList.java:161)
at org.redisson.spring.data.connection.RedissonConnection.filterResults(RedissonConnection.java:1534)
at org.redisson.spring.data.connection.RedissonConnection.closePipeline(RedissonConnection.java:162)
Steps to reproduce or test case
Redis version
5.0
Redisson version
3.13.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Regarding the execution of "API: org.redisson.api.RBucket#set(V value, long timeToLive, TimeUnit timeUnit)", is there a way to call multiple using a netty thread?
I tried the following, but it did not run in multi.
Map<K, V> values = new new HashMap<K, V>();
for (Entry<K, V> entry : values.entrySet()) {
    bucket.set(ObjectMapper.writeValueAsString(entry.getValue()), 10, TimeUnit.SECONDS);
}
redisson.json
{
  "clusterServersConfig": {
    "subscriptionConnectionMinimumIdleSize": 1,
    "subscriptionConnectionPoolSize": 150,
    "slaveConnectionMinimumIdleSize": 1,
    "slaveConnectionPoolSize": 150,
    "masterConnectionMinimumIdleSize": 1,
    "masterConnectionPoolSize": 150,
    "readMode": "MASTER_SLAVE",
    "nodeAddresses": [
      "redis://[redis endpoint]:6379"
    ],
    "scanInterval": 600000,
    "retryAttempts": 5,
    "retryInterval": 15000
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3025
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My Code
private RRateLimiter rt;

@PostConstruct
 public void init(){
     rt = redissonClient.getRateLimiter("rt2");
     rt.trySetRate(RateType.OVERALL, 100, 5, RateIntervalUnit.SECONDS);
 }

@GetMapping("")
    public void test(){

        System.out.println(rt.availablePermits());

        rt.acquire(1);

        System.out.println(rt.availablePermits());
    }

Expected behavior
Actual behavior
first call test() function， works fine， but after 5 SECONDS（after one period）， will throw exception
org.redisson.client.RedisException: ERR Error running script (call to f_a953e1748e38137c3168a683556aa561bd05b340): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0x36f2cda8, L:/10.2.47.198:60323 - R:fenbi-notify-push-redis-dev.redis.rds.aliyuncs.com/10.13.160.82:6379] command: (EVAL), params: [local rate = redis.call('hget', KEYS[1], 'rate');local interval = redis.call('hget', KEYS[1], 'inter..., 5, rt2, {rt2}:value, {rt2}:value:f45a9de8-95b9-47f1-aef2-759c37d9f60a, {rt2}:permits, {rt2}:permits:f45a9de8-95b9-47f1-aef2-759c37d9f60a, 1599018405084]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) ~[redisson-3.13.3.jar:3.13.3]
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196) ~[redisson-3.13.3.jar:3.13.3]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134) ~[redisson-3.13.3.jar:3.13.3]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104) ~[redisson-3.13.3.jar:3.13.3]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_202]

Steps to reproduce or test case
Redis version
Redisson version
     <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-data-18</artifactId>
        <version>3.13.3</version>
    </dependency>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.13.3</version>
    </dependency>

Only 3.13.3 have this problem
There is no problem on 3.13.2
Redisson configuration
config.setCodec(JsonJacksonCodec.INSTANCE);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The amount of data is very large, I want to put it in a parent folder，help me
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
After the network between redisson and redis server recoveried from disconnection, Redisson is able to open a healthy connection pool to each of the nodes
Actual behavior
Connection never recover until we restart the service. This situation  Occasionally happens.
Redisson version
3.11.4
Redisson spring-data version
3.13.1
Config
Config config = new Config();
config.setCodec(new org.redisson.client.codec.ByteArrayCodec());
config.useSingleServer().setAddress("redis://xxxx");
config.useSingleServer().setConnectionPoolSize(500);
config.useSingleServer().setRetryAttempts(5);
config.useSingleServer().setPingConnectionInterval(10000);
config.useSingleServer().setKeepAlive(true);
config.setNettyThreads(512);

Error Log
We only log the exception message like this
2020-09-01 00:56:22 [ERROR] [RedissonTool] Unable to get connection! Try to increase 'nettyThreads' and/or connection pool size settingsNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=0, freeConnectionsCounter=value:0:queue:106, freezed=false, freezeReason=null, client=[addr=redis://xxxxxx], nodeType=MASTER, firstFail=0]]], command: (SET), params: [[50, 57, 50, ...], [31, -117, 8, 0, 0, 0, 0, 0, 0, 0, ...]] after 0 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to get connection! Try to increase 'nettyThreads' and/or connection pool size settingsNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=0, freeConnectionsCounter=value:0:queue:106, freezed=false, freezeReason=null, client=[addr=redis://xxxxxx], nodeType=MASTER, firstFail=0]]], command: (SET), params: [[50, 57, 50, 51, 49, 48, 51, 52, 53, 50, ...], [31, -117, 8, 0, 0, 0, 0, 0, 0, 0, ...]] after 0 retry attempts


2020-09-01 00:56:06 [ERROR] [RedissonTool][get]redisson happened error!Unable to get connection! Try to increase 'nettyThreads' and/or connection pool size settingsNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:1100:queue:0, freezed=false, freezeReason=null, client=[addr=redis://xxxxxx], nodeType=MASTER, firstFail=0]]], command: (GET), params: [[50, 53, 48, 53, 57, 55, 52, 50, 53, 49, ...]] after 5 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to get connection! Try to increase 'nettyThreads' and/or connection pool size settingsNode source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:1100:queue:0, freezed=false, freezeReason=null, client=[addr=redis://xxxxxx], nodeType=MASTER, firstFail=0]]], command: (GET), params: [[50, 53, 48, 53, 57, 55, 52, 50, 53, 49, ...]] after 5 retry attempts


I am curious about some question:

why some log shows "after 0retry attempts"? Does the retryAttempt not work?
What's the meaning of the freeConnectionsCounter and freeConnectionsAmount in the log? The value of  freeConnectionsCounter in the log is 1100 and even bigger than the connectionPoolSize, is that ok?
why the connection never recover?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version: 3.11.6


config:


	<Manager className="org.redisson.tomcat.RedissonSessionManager" configPath="${catalina.base}/src/test/webapp/WEB-INF/redisson.yaml" readMode="REDIS" updateMode="DEFAULT" broadcastSessionEvents="true"/>

question:

we have two server: A, B


when session.setAttribute(key, value); on A server


session.invalidate(); on B server.


session.setAttribute(key, value); on A server,


now session.getAttribute(key); on B server will return null


why this happened?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exception in thread "redisson-3-22" java.lang.ClassCastException: java.lang.String cannot be cast to [B
at org.redisson.spring.data.connection.RedissonSubscription$2.onPatternMessage(RedissonSubscription.java:85)
at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:84)
at org.redisson.client.handler.CommandPubSubDecoder.lambda$enqueueMessage$0(CommandPubSubDecoder.java:181)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is no configuration for sentinel password, you are using the same password flag to be used for sentinel and redis, and by that way I am obliged to set the same password for redis and sentinel, so can't we have a different yml property special for sentinel password?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3031
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RBloomFilter<String> bloomFilter = DrpRedissonClusterPool.get().getBloomFilter("getBloomFilter", new FstCodec());
    bloomFilter.delete();
    bloomFilter.tryInit(40000, 0.01);
    System.out.println(bloomFilter.getSize() / 8 / 1024 / 1024);
    System.out.println(bloomFilter.count());
    bloomFilter.add("111");
    bloomFilter.add("111");
    bloomFilter.add("111");
    System.out.println(bloomFilter.getSize());
    System.out.println(bloomFilter.count());
    System.out.println(bloomFilter);
    System.out.println(bloomFilter.contains("111"));


run bloomFilter.contains("111")
Exception in thread "main" org.redisson.client.RedisMovedException
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:339)
at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:266)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:207)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With a regular RMap the size() is very quick and efficient but it doesn't seem that there is a way to get the total size of a multimap in the same way. What I mean by total size is the sum of sizes of all of the values (collections) of a multimap.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3033
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm wondering what exactly is reported by sizeInMemory() method. The doc says it is "Returns bytes amount used by object in Redis memory".
I'm looking at the numbers this method reports say for the RSet of strings and it is much smaller than byte count of the strings stored in the RSet. Does it mean that the data is stored compressed in REDIS?
Also is my understanding correct that for RSetMultimap to find the total size of it in memory one needs to add value returned by sizeInMemory() for the map itself and then the value returned by sizeInMemory() for all of the RSets stored in that map?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
您好：
Hello:
在使用Redisson作为分布式锁时，不定期会出现RedisResponseTimeoutException(具体错误信息如下)，已经按照之前的issue的回答中进行设置，包括设置pingConnectionInterval，以及nettyThreads，但是还是出现了该问题，目前不知道该怎么处理，非常希望能得到您的帮助，非常感谢。
When using Redisson as a distributed lock, RedisResponseTimeoutException will appear from time to time (the specific error message is as follows), which has been set in accordance with the answer to the previous issue, including setting pingConnectionInterval and nettyThreads, but this problem still occurs. I don’t know the How to deal with it, I really hope to get your help, thank you very much.
Expected behavior
[2020-09-07 10:49:47.411] [http-nio-9023-exec-7] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] [] [] [] - Servlet.service() for servlet [dispatcherServlet] in context with path [/activity/provider] threw exception [Request processing failed; nested exception is org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, PrizeActivityServiceImpl:getActivityPrize, 10000, fab0e7c0-940c-423b-af4e-dd86dac6d31f:71], channel: [id: 0x7df78ed5, L:/172.20.2.62:51408 - R:172.18.215.46/172.18.215.46:6389]] with root cause
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Command: (EVAL), params: [if (redis.call('exists', KEYS[1]) == 0) then redis.call('hset', KEYS[1], ARGV[2], 1); redis.call('pe..., 1, PrizeActivityServiceImpl:getActivityPrize, 10000, fab0e7c0-940c-423b-af4e-dd86dac6d31f:71], channel: [id: 0x7df78ed5, L:/172.20.2.62:51408 - R:172.18.215.46/172.18.215.46:6389]
at org.redisson.command.RedisExecutor$3.run(RedisExecutor.java:338)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Redis version
5.0.5
Redisson version
3.11.5
Redisson configuration
@configuration
public class RedissonManager {
@Autowired
private RedissonProperties redissonProperties;
@bean
public RedissonClient getRedissonSingle() {
String address = "redis://"+redissonProperties.getHost() + ":" + redissonProperties.getPort();
Config config = new Config();
SingleServerConfig serverConfig = config.useSingleServer()
.setPingConnectionInterval(1000)
.setRetryInterval(1000)
.setRetryAttempts(3)
.setAddress(address);
if(StringUtils.isNotBlank(redissonProperties.getPassword())) {
serverConfig.setPassword(redissonProperties.getPassword());
}
config.setCodec(new StringCodec());
config.setLockWatchdogTimeout(30*1000);
config.setNettyThreads(64);
return Redisson.create(config);
}
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have multiple instance of web app and all pointing to same AWS Elasticache (redis). When new version deployed some of them will use old Redisson lib (with previous default codec, FST).
Any suggestion appreciate to deploy new version with new codec smoothly without downtime?
Thanks in advance
Marko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
订阅会无故的丢失，而且是查看 redis-server 端 client list 命令，发现订阅的连接的确不存在了。然后我进行了模拟，发现如果网络一段时间连接不上，当重新连接上网络时，redis的订阅连接就消失了。
Steps to reproduce or test case
准备两台机器，redis-server 机器，和 java 客户端的机器。
并设置 redis-server 的 tcp-keepalive 配置项，先设置为 10 。
java 客户端代码如下
        Config config = new Config();
       config.useSingleServer()
               .setAddress("redis://192.168.0.23:6379");
       SingleServerConfig singleServerConfig = config.useSingleServer();
       singleServerConfig.setConnectionMinimumIdleSize(1);
       singleServerConfig.setConnectionPoolSize(1);
       singleServerConfig.setSubscriptionConnectionMinimumIdleSize(1);
       singleServerConfig.setSubscriptionConnectionPoolSize(1);
       RedissonClient redisClient = Redisson.create(config);

       MessageListener messageListener = new MessageListener<String>() {
           @Override
           public void onMessage(CharSequence channel, String msg) {
               logger.warn("channel: {}  receive:{}", channel, msg);
           }
       };

       RTopic zhangTopic = redisClient.getTopic("zhang");
       zhangTopic.addListener(String.class, messageListener);

       AtomicInteger zhangCount = new AtomicInteger();

       long start = System.currentTimeMillis();
       new Thread(new Runnable() {
           @Override
           public void run() {
               while (true) {
                   try {
                       int count  = zhangCount.getAndIncrement();
                       logger.error("publish   count:"+count+"    time："+(System.currentTimeMillis() - start)/1000);
                       zhangTopic.publishAsync("" + count);
                       Thread.sleep(10000);
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }
           }
       }, "----push----").start();

步骤如下：

先运行 java 端程序，查看 redis-server 的 client List 发现有三个连接。
然后断开网络，大概十几秒，然后再连接上网络，就会发现只有两个连接了， 订阅的连接消失不见了， 发送数据的 push 连接也是新创建的，通过 ConnectionWatchdog 来重建的，但是订阅的连接却没有触发这个过程

Redis version
4.0.6
Redisson version
3.11.3
Redisson configuration
就是使用单机版的redis
        Config config = new Config();
        config.useSingleServer()
                .setAddress("redis://192.168.0.23:6379");
        SingleServerConfig singleServerConfig = config.useSingleServer();
        singleServerConfig.setConnectionMinimumIdleSize(1);
        singleServerConfig.setConnectionPoolSize(1);
        singleServerConfig.setSubscriptionConnectionMinimumIdleSize(1);
        singleServerConfig.setSubscriptionConnectionPoolSize(1);
        RedissonClient redisClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis.txt
[ERROR] 2020-09-02 07:59:46.207 [redisson-netty-4-4] [,] CommandDecoder - Unable to decode data. reply: $768
���^B{"email":"********.******@*****.COM","firstName":"**** ******","lastName":"******"}
, channel: [id: 0xb9754a6f, L:/*.*.*.*:36479 - R:redis.com/*.*.*.*:6379], command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@46b21510(failure: java.util.concurrent.CancellationException)], command=(EVAL), params=[local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, ********.******@*****.COM, redisson__timeout__set:{********.******@*****.COM}, redisson__idle__set:{********.******@*****.COM}, redisson__map_cache__last_access__set:{********.******@*****.COM}, {********.******@*****.COM}:redisson_options, 1599029983066, PooledUnsafeDirectByteBuf(freed)], codec=org.redisson.codec.FstCodec]
java.util.concurrent.CancellationException: null
        at java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2263) ~[?:1.8.0_141]
        at org.redisson.misc.RedissonPromise.cancel(RedissonPromise.java:239) ~[redisson-3.10.0.jar:?]
        at org.redisson.command.CommandAsyncService$13.run(CommandAsyncService.java:887) ~[redisson-3.10.0.jar:?]
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:668) ~[netty-common-4.1.25.Final.jar:4.1.25.Final]
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:743) ~[netty-common-4.1.25.Final.jar:4.1.25.Final]
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:471) ~[netty-common-4.1.25.Final.jar:4.1.25.Final]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_141]```


Observing Similar Errors in Our Logs since few days
Attached a file with similar errors

Please help me with this

Redisson Version - 
                 <dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson-spring-data-20</artifactId>
			<version>3.10.0</version>
		</dependency>
We have a single server config
Redisson Yaml
```{
   "singleServerConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "password":"*****************",
      "subscriptionsPerConnection":5,
      "clientName":null,
      "address": "redis://redis.com:6379",
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "connectionMinimumIdleSize":32,
      "connectionPoolSize":64,
      "database":0,
      "dnsMonitoringInterval":5000
   },
   "threads":0,
   "nettyThreads":0,
   "codec":{
      "class":"org.redisson.codec.FstCodec"
   },
   "transportMode":"NIO"
}```
Thank You
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
This is for SingleServerConfigs.
Occasionally during deployment the redis instance comes up after our services. When injecting RedissonClients using Spring @bean or CDI @produces, the RedissonClient dependency will fail with an exception upon construction.
Describe the solution you'd like
When your connection pool minimums are set to 0, RedissonClient instances should be able to be constructed without redis being available.
Any operations with no connections in the pool should attempt a connection. Failing that, fail accordingly. It would be nice to have a "target pool size" in addition to an actual minimum- so that I can have a minimum of 0 but aim to have 10 or more, etc.
Describe alternatives you've considered
We'd have to inject some form of Supplier instead, this is not ideal. The client is the owner of the pool, us doing that is taking on those connection pool management concerns.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am getting a failure due to the issue:
stackTrace: java.io.IOException: Unsupported protocol version 252
at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1360)
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:150)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:378)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:834)
This issue is not seen always as there are success scenarios as well.
Version: 3.13.4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3044
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
We currently use Redisson 3.11.5 with AWS Elasticache Cluster mode enabled. Gets using RBuckets works well.
When we tried to upgrade to Redisson 3.13.1, we expected gets should work seemlessly without issue
Actual behavior
But When we tried to upgrade to 3.13.1, started to see ClassCastExceptions.
I have tried to look into scenarios on when this was happening.
Looks like it happens whenever redission client is seeing MOVED response from connected redis node
Issue get resovled immediately when we rollback to 3.11.5
questions:

is there something different in cluster mode handling in 3.13.1?
Looks  like 3.11.5 rightly resolve to right slot and node and is able to cast payload correctly. But  with 3.13.1 something is broken.

Steps to reproduce or test case
Redis version
5.0.6
Redisson version
3.13.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When a bunch of requests hit the web app in short period (e.g. 2000 requests  in 5 min), tomcat-redisson-9 throws NPE attached on the bottom, the issue refers to below line of code.

  
    
      redisson/redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/UpdateValve.java
    
    
         Line 56
      in
      9579ee7
    
  
  
    

        
          
           ClassLoader applicationClassLoader = request.getContext().getLoader().getClassLoader(); 
        
    
  


I've tried with various versions of redisson-tomcat-9(3.12.3, 3.12.4, 3.13.0, 3.13.4), but the issue stick to below line of code.
redisson version: 3.13.4
redisson-tomcat-9 version: 3.13.4
[http-nio-8080-exec-4] ERROR org.apache.coyote.http11.Http11Processor - Error processing request java.lang.NullPointerException: null
  at org.redisson.tomcat.UpdateValve.invoke(UpdateValve.java:56) [redisson-tomcat-9-3.13.0.jar:3.13.0]
  at org.apache.catalina.connector.CoyoteAdapter.service (CoyoteAdapter.java:343) [catalina.jar:9.0.33]
  at org.apache.coyote.http11. Http11Processor.service(Http11Processor.java:373) [tomcat-coyote.jar:9.0.33]
  at org.apache.coyote. AbstractProcessorLight.process(AbstractProcessorLight.java:65) [ tomcat-coyote.jar:9.0.33]
  at org.apache.coyote. AbstractProtocol$connectionHandler.process(AbstractProtocol.java:868) [ tomcat-coyote.jar:9.0.33]
  at org.apache.tomcat.util.net.NioEndpoint SocketProcessor.doRun(NioEndpoint.java:1594) [ tomcat-coyote.jar:9.0.33]
  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [ tomcat-coyote.jar:9.0.33]
  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1128) [?:?]
  at java.util.concurrent.ThreadPoolExecutor $Worker.run(ThreadPoolExecutor.java:628) [?:?]
  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [ tomcat-util.jar:9.0.33]
  at java.lang.Thread.run(Thread.java:834) [?:?]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, is there any suggestions for configuring these 'size' values based on the config of Redis server

threads
nettyThreads
masterConnectionPoolSize
masterConnectionMinimumIdleSize
slaveConnectionPoolSize
slaveConnectionMinimumIdleSize
subscriptionConnectionPoolSize
subscriptionConnectionMinimumIdleSize

For example, my Redis cluster server:

8 vCPU
26 GB memory
4 instances (2 slots)
50 consumers

I know it may depend on the commands I am using, so I just want to know a basic suggestion.
Is there any formula I can follow for configuring?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3050
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RBloomFilter only have
boolean add(T object);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
如上图， 在未加unlock()时， 发送请求第一次lockFlag = true,  第二次到第十次是false，第十一次是true。可以看出每10次时是true，但是没加unclok()，按理来说不管请求多少次都返回false， 这是不是bug？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3052
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Junit should pass
Actual behavior
2020-09-15 16:28:06,812 ERROR org.redisson.client.handler.CommandDecoder [redisson-netty-1-6]: Unable to decode data. channel: [id: 0x2d695109, L:/127.0.0.1:43810 - R:127.0.0.1/127.0.0.1:6399], reply: ReplayingDecoderByteBuf(ridx=252, widx=252), command: (SMEMBERS), params: [bucket-fst] java.io.IOException: java.lang.RuntimeException: unable to find class for code 50 at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:247) ~[fst-2.57.jar:na] at org.redisson.codec.FstCodec$1.decode(FstCodec.java:164) ~[redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:368) [redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:412) [redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377) [redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:201) [redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:143) [redisson-3.10.3.jar:na] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) [redisson-3.10.3.jar:na] at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502) [netty-codec-4.1.33.Final.jar:4.1.33.Final] at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [netty-codec-4.1.33.Final.jar:4.1.33.Final] at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278) [netty-codec-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491) [netty-transport-4.1.33.Final.jar:4.1.33.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) [netty-common-4.1.33.Final.jar:4.1.33.Final] at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.33.Final.jar:4.1.33.Final] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_221] Caused by: java.lang.RuntimeException: unable to find class for code 50 at org.nustaq.serialization.FSTClazzNameRegistry.decodeClass(FSTClazzNameRegistry.java:180) ~[fst-2.57.jar:na] at org.nustaq.serialization.coders.FSTStreamDecoder.readClass(FSTStreamDecoder.java:478) ~[fst-2.57.jar:na] at org.nustaq.serialization.FSTObjectInput.readClass(FSTObjectInput.java:939) ~[fst-2.57.jar:na] at org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(FSTObjectInput.java:347) ~[fst-2.57.jar:na] at org.nustaq.serialization.FSTObjectInput.readObjectInternal(FSTObjectInput.java:331) ~[fst-2.57.jar:na] at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:311) ~[fst-2.57.jar:na] at org.nustaq.serialization.FSTObjectInput.readObject(FSTObjectInput.java:245) ~[fst-2.57.jar:na] ... 37 common frames omitted
Steps to reproduce or test case
`package com.mycomosi.eaa.alarm.propagation.infrastructure.chain
import java.util
import com.mycomosi.eaa.common.domain.topology._
import com.mycomosi.eaa.common.infrastructure.redis.RedisClientPool
import com.mycomosi.eaa.common.infrastructure.redis.v2_1.{NodeInstanceRto, RelationshipInstanceRto, TopologyInstanceRto}
import com.mycomosi.eaa.common.infrastructure.topology.cache.Converter
import org.junit.runner.RunWith
import org.nustaq.serialization.FSTConfiguration
import org.redisson.Redisson
import org.redisson.config.Config
import org.scalatest.junit.JUnitRunner
import org.scalatest.{BeforeAndAfter, BeforeAndAfterAll, FlatSpec, Matchers}
import redis.embedded.RedisServer
import scala.collection.JavaConverters._
@RunWith(classOf[JUnitRunner])
class FstCodecTest extends FlatSpec with Matchers with BeforeAndAfter with BeforeAndAfterAll {
val redisUrl = "redis://127.0.0.1:6399"
val redisServer = RedisServer.builder()
.port(6399)
.setting("bind 127.0.0.1") // secure + prevents popups on Windows
.setting("maxmemory 128M")
.build();
def toRto(o: NodeInstance): NodeInstanceRto = {
new NodeInstanceRto(o.id, o.name,
o.ik,
o.nodeTemplateId,
o.nodeTemplateName)
}
private def toRto(o: RelationshipInstance): RelationshipInstanceRto = {
val attributes = new util.HashMapString, String
o.attributes.foreach(x => attributes.put(x._1, x._2))
new RelationshipInstanceRto(o.srcId, o.dstId, o._relationType, attributes)
}
def toRto(o: TopologyInstance): TopologyInstanceRto = {
//To avoid issue on FST serializer of Class scala.collection.convert.Wrappers$MapWrapper does not implement Serializable or externalizable
val nodeInstances = new java.util.ArrayListNodeInstanceRto
o.nodeInstances.foreach(x => nodeInstances.add(toRto(x)))
val relationShips = new java.util.ArrayList[RelationshipInstanceRto]()
o.relationshipInstances.foreach(x => relationShips.add(toRto(x)))

new TopologyInstanceRto(o.id,
  o.startDate,
  o.endDate,
  o.topologyTemplateId,
  o.version,
  nodeInstances,
  relationShips)

}
def createConfig: Config = {
val conf: FSTConfiguration = FSTConfiguration.createDefaultConfiguration()
conf.registerClass(List(classOf[TopologyInstanceRto]).toArray: _*)
val fstCodec = new org.redisson.codec.FstCodec(conf)
val config = new Config()
config.useSingleServer.setAddress(redisUrl)
config.setCodec(fstCodec)
config
}
override def beforeAll() {
redisServer.start
}
override def afterAll() {
RedisClientPool.shutdown
redisServer.stop
}
"Measure Topology set get with different Codecs" should " correctly serialize and deserialize and provide measurement" in {
val redisClient = Redisson.create(createConfig)
val nodeInstance2_1 = NodeInstance("nodeId4", "nodeName4", "ik", "mocId2", "mocName2")
val rel1 = RelationshipInstance("nodeId1", "nodeId2", 3.shortValue(), Map[String, String]())
val version = "version"
val topo2 = TopologyInstance("Topo2", 0, 10L, "mocId2", version, nodeInstance2_1:: Nil, rel1:: Nil)

var rtos = (topo2 :: Nil).map(Converter.toRto)

val b = redisClient.getSet[TopologyInstanceRto]("bucket-fst")
b.addAll(rtos.toList.asJava)
b.readAll()

}
}`
Redis version
4.0
Redisson version
3.10.3
Redisson configuration
single
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I followed instructions for Tomcat, copied two jars to lib dir, edited context.xml, created conf.yaml, however, keep getting:
15-Sep-2020 11:38:07.402 SEVERE [localhost-startStop-1] org.apache.catalina.core.StandardContext.startInternal The session manager failed to start
 org.apache.catalina.LifecycleException: Failed to start component [org.redisson.tomcat.RedissonSessionManager[/coreweb]]
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167)
	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5253)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754)
	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730)
	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:980)
	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1852)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/JsonFactory
	at org.redisson.config.Config.fromJSON(Config.java:584)
	at org.redisson.tomcat.RedissonSessionManager.buildClient(RedissonSessionManager.java:342)
	at org.redisson.tomcat.RedissonSessionManager.startInternal(RedissonSessionManager.java:234)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
	... 12 more
Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.JsonFactory
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 16 more

Do I need add more libs to classpath?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It would provide for grate portability and at the same time would benefit from smaller stored object size.
We are using memcached in many places at the moment and it utilizes similar approach for the string data.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson: 3.13.0
@mrniko
i see  this issue was fixed in 3.13.3, and there is no problem, after upgraded to 3.13.3. could you please post the cause of the issue ?  and how to reproduce it ?  thank you very much.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using readMode=REDIS and updateMode=AFTER_REQUEST
session.setAttribute("a","b")
session.getAttributeNames() should include "a"
Actual behavior
session.getAttributeNames() does not include values cached in loadedAttributes map, and goes directly to redis, which has not yet received the new information.
Steps to reproduce or test case
see 86ac2aa for work around that solved the issue
Redis version
Redisson version
3.14.4
Redisson configuration
readMode=Redis
updateMode=after request
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When a session is present on multiple tomcat servers, it should not expire and be removed from redis until the last accessed time in redis is old enough to be considered expired
Actual behavior
the last accessed time in memory on each server is checked, and if any of them are old enough, the session is deleted from redis
Steps to reproduce or test case
So we've run into a different issue around expiring sessions.
The scenario where we ran into this problem was with readMode=Redis and broadcast mode off, but it may exist with it on also.
user interacts with server 1
network partition/round robin loadbalancing makes a the next request to server 2 for a short period of time
user interacts with server 1 again (partition over or dynamic load balancing)
user's in memory session on server 2 will expire prior to their actual session expiration since the last access time in memory on server2 is older than server1 or in redis itself.
server 2 expires the session which triggers a delete call, removing the session from redis, even if they were still active on server 1
our tests, which have diverged a little from master looks along the lines of:
// Session starts on server 1
    write(server1, "test", "1");
    // Access session from server 2
    read(server2, "test", "1");
    // Access session from server 1
    read(server1, "test", "1");

    // Local sessions were created on both servers
    Assert.assertEquals(2, TestHttpSessionListener.CREATED_INVOCATION_COUNTER.get());

    // Keep session alive past timeout interval on server 1 only
    for (int i=0; i < 25; i++) {
      Thread.sleep(3_000);
      read(server1, "test", "1");
    }

    // Local sessions were not allowed to expire on any servers since session was still active in redis
    Assert.assertEquals(0, TestHttpSessionListener.DESTROYED_INVOCATION_COUNTER.get());

    // Idle past the timeout so the sessions all actually expire
    Thread.sleep(75_000);

    // Local sessions were expired and were destroyed
    Assert.assertEquals(2, TestHttpSessionListener.DESTROYED_INVOCATION_COUNTER.get());

    // Access session from server 1 after timeout...attribute is gone
    read(server1, "test", "null");

we patched this by overriding
RedissonSession.isValid
@Override
  public boolean isValid() {

    if (!this.isValid) {
      return false;
    }

    if (this.expiring) {
      return true;
    }

    if (ACTIVITY_CHECK && accessCount.get() > 0) {
      return true;
    }

    if (maxInactiveInterval > 0) {
      if (isSessionTimeout()) {
        LOG.log(Level.FINE,"Possible timeout detected for session {0} last access time = {1}", new Object[]{id, lastAccessedTime});
        try {
          // If we timeout with the local lastAccessTime, resynch the local metadata from redis and check again
          reloadSessionMetadata();
          LOG.log(Level.FINE,"Reloaded session metadata from redis for session {0} last access time = {1}", new Object[]{id, lastAccessedTime});
          if (isSessionTimeout()) {
            LOG.log(Level.FINE,"Session {0} has timed out", id);
            expire(true);
          } else {
            LOG.log(Level.FINE,"Session {0} is still active in redis", id);
          }
        } catch (Exception e) {
          LOG.log(Level.FINE,"Unable to reload session metadata from redis for session {0} to validate access time...cancelling timeout", id);
        }
      }
    }

    return this.isValid;
  }

  private void reloadSessionMetadata() {
    load(((RedissonSessionManager)getManager()).getMap(id).getAll(RedissonSession.ATTRS));
  }

so before we expire any session, we make sure that the last accessed time is accurate.
Redis version
Redisson version
3.14.4
Redisson configuration
readMode=REDIS
updateMode=AFTER_REQUEST
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We noticed a large number of keys in our Redis server had no TTL set and traced it back to the RMap that backs the session.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our company have redis cluster for multiple Springboot apps. We use different redis key prefix between every app by a key serializer, like this:
public class RedisKeyPrefixSerializer implements RedisSerializer<String> {

    /**
     * 前缀
     */
    private String prefix;

    /**
     * 实例化
     *
     * @param prefix 前缀
     */
    public RedisKeyPrefixSerializer(String prefix) {
        this.prefix = prefix + ":";
    }

    @Override
    public byte[] serialize(String string) throws SerializationException {
        String key = prefix + string;
        return key.getBytes(StandardCharsets.UTF_8);
    }

    @Override
    public String deserialize(byte[] bytes) throws SerializationException {
        String saveKey = new String(bytes, StandardCharsets.UTF_8);
        if (saveKey.startsWith(prefix)) {
            saveKey = saveKey.substring(prefix.length());
        }
        return saveKey;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix + ":";
    }
Now, when we use RedisTemplate to do everything, the key was added a prefix by serializer. But when we use RedissonClient to do everything, we must set the prefix by self every time.
So, is there any way to help us set a global key prefix for using redisson client?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
where I use delay queue, I catch an exception:
org.redisson.client.RedisException: ERR Error running script (call to f_78d2ea980580b285865f2db54663f281dc326a78): @user_script:1: WRONGTYPE Operation against a key holding the wrong kind of value . channel: [id: 0xa2d7eddf, L:/192.168.199.112:63770 - R:rrds.aliyuncs.com/127.0.0.1:6379] command: (EVAL), params: [local expiredValues = redis.call('zrangebyscore', KEYS[2], 0, ARGV[1], 'limit', 0, ARGV[2]); if #exp..., 3, test:queue:1, redisson_delay_queue_timeout:{test:queue:1}, redisson_delay_queue:{test:queue:1},

I use the queue:
String taskId = "taskId";
String delayQueueKey = "delayqueue";
        RBlockingQueue<String> blockingQueue = redissonClient.getBlockingQueue(delayQueueKey);
        RDelayedQueue<String> delayedQueue = redissonClient.getDelayedQueue(blockingQueue);
        delayedQueue.offer(taskId, 5, TimeUnit.MINUTES);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Return entity or NULL as expecting
Actual behavior
Throw ClassCastException
Steps to reproduce or test case
This only happens when we upgrade Redisson from 3.10.0 to 3.10.7 and in only happens in one of our environments.
The detail of ClassCastException will be shows like 'Cannot cast 'xxx.yyy.zzz.ClassA' to 'xxx.yyy.zzz.ClassA' (The path are totally the same) or 'org.redisson.spring.cache.NullValue' cannot be cast to '....'
It only happen once and I cannot reproduce from my local.
When I clear the whole Redis, this exception will pause for a while, but after some time, it will happen again
Redis version
5.0.0
Redisson version
From 3.10.0 to 3.10.7
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@bean
public RedissonClient redissonClient(){
Config config = new Config();
String redisUrl = String.format("redis://%s:%s",redisProperties.getHost()+"",redisProperties.getPort()+"");
config.useSingleServer().setAddress(redisUrl).setPassword(redisProperties.getPassword());
config.useSingleServer().setDatabase(3);
return Redisson.create(config);
}
请问这是什么问题呢。。。。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In the picture above, I think it is java code. The modifiers in the code are not correct. Should we use double quotes?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Recently we got below error after Redis M/S switchOver at Redisson 3.10.1:
org.redisson.client.RedisTimeoutException: Subscribe timeout: (9500ms). Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.
And i saw it was fixed at 3.11.2 by: #2181
I have one question about the fix: 12e81de
reattachPubSub method was only called in MasterSlaveEntry.slaveDown. What will happen in Redis M/S switchover
in case we configure  "subscriptionMode: "MASTER""? To my understanding:
slaveDown should not impact subscription as we configured Mode to master.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I increase the logging from Redisson when using the Tomcat Session Manager? I'm not running into an issue, but just want to know how to do that if needed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello,
there are numerous connection settings like connectionPoolSize, connectionMinimumIdleSize so forth so on..
for instance, when I put 100 for connectionPool, it use all of them in course of some load (I monitor redis server with redis-exporter). then I increased it to 200, then it started to use 200.
My question is how can I find suitable settings, is there any hint which I can refer?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Context description:
The regular (non-async, non-reactive, non-Rx) API contains cache variants for multimap based collections:

RListMultimapCache for RListMultimap, available by calling RedissonClient.getListMultimapCache();
and RSetMultimapCache for RSetMultimap, available by calling RedissonClient.getSetMultimapCache()

But the Rx-ified version of the API does not have the cache variants:

RedissonRxClient only has getListMultimap() and not getListMultimapCache(), because RListMultimapCacheRx does not exist yet;
and RedissonRxClient only has getSetMultimap() and not getSetMultimapCache(), because RSetMultimapCacheRx does not exist yet

Our problem:
The problem we are facing is that we have a code base that heavily relies on Rx interfaces and that we need the expiration/eviction functionality that Redisson offers for set multimaps, but this combination seems to be missing from the API.
Desired solution
Additions to the Rx-ified API to be able to instantiate multimap caches, so that we can specify expiration for items in the multimap cache using Rx method calls.
Alternatives we've considered
We've considered using the non-Rx-ified APIs, but we'd end up writing our own Rx proxy layer around it since our code base so heavily relies on RxJava. Therefore it seems more logical to add it to Redisson instead, even more so because it looks as though this feature would fill a rather obvious gap in the API (for which there was understandably no time yet, undoubtedly).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
使用最新版的redisson，看了一下autoconfig。。。一言难尽啊
比如我在使用druid连接池的时候，为了防止忘记设置某一个值，可以使用EnvironmentPostProcessor来初始化一份配置文件，然后由项目组来根据实际场景修改某一个值。
但是这里的配置是通过yaml文件字符串进行读取，和使用环境变量做替换，这。。。感觉有点别扭了
有计划在哪个版本来升级一下autoconfig吗？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
阿里云集群版redis限制了使用EVAL命令，以前也测试过确实会报错，但我现在不知道怎么重现那个错误了，想确认下是不是现在redisson底层处理了什么，让它能用阿里云的集群版redis了
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Since timeseries is a sorted collection I'd expect iterator() to respect the ordering. There's a range method which in fact returns the values in order, however it returns Mono<Collection> instead of Flux which means entire set is loaded into the memory, while I'd like to read it reactively in chunks.
Actual behavior
redisson.getTimeSeries("").iterator().next().block() != redisson.first.block()
Steps to reproduce or test case

add multiple elements into the timeseries collection
open a redis desktop manager or use the cli to check the elements are indeed ordered by score
call iterator() method and check the ordering

I've checked also the non-reactive version and seems to work in the same way.
Redis version
5.0.8
Redisson version
3.13.4
Redisson configuration
singleServerConfig:
address: "redis://127.0.0.1:6379"
database: 2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
I'd like to have a possibility to set eviction for a given element while inserting into the collection that keeps the insertion order.
Describe the solution you'd like
Similar to the MapCache and SetCache I think there's a need for a ListCache as neither of the previous ones keep the ordering.
Describe alternatives you've considered
SetCache but it lacks ordering.
TimeSeries but as per issue 3145 the iterator() method does not return the values according to the score.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I'm getting null pointer exception when try to destroy RMapCache in EvictionScheduler line 74 (remove(String name)). Error occuring on tasks object.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
利用Redisson按天做限流，历史生成的限流key不会自动清除，这个如何处理，可以设置缓存过期时间吗？
// rate limit 100 times per day
String date = DateFormatUtils.format(new Date(), BaseConstants.DATE_FORMAT_LEAN);
RRateLimiter timesPerDayRateLimiter = redissonClient.getRateLimiter(String.format(RedisConstants.TOKEN_REFRESH_TIMES_PER_DAY_RATE_LIMIT, date, userId));
timesPerDayRateLimiter.trySetRate(RateType.OVERALL, tokenProperties.getTokenRefreshTimesPerDayRateLimit(), 1, RateIntervalUnit.DAYS);

该历史缓存会清除
{token:refresh:20201021:68155c4000eb4d79a3f9516bfc51f9c5}:value
该历史缓存未清除
token:refresh:20201021:68155c4000eb4d79a3f9516bfc51f9c5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
在低并发时无此现象  当并发达到一定量级后出现如下错误(版本3.0.1)：
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:307) ~[redisson-3.0.1.jar:?]
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:150) ~[redisson-3.0.1.jar:?]
at org.redisson.command.CommandSyncService.evalWrite(CommandSyncService.java:83) ~[redisson-3.0.1.jar:?]
at org.redisson.RedissonLock.unlock(RedissonLock.java:354) ~[redisson-3.0.1.jar:?]
at com.oppo.ocloud.file.common.tool.lock.RedissonLock.unlock(RedissonLock.java:76) ~[ocloud-file-common-tool-1.0.5-SNAPSHOT.jar:?]
at com.oppo.ocloud.file.common.service.ReplaceFileIdService.doReplace(ReplaceFileIdService.java:165) ~[ocloud-file-common-job-1.0-SNAPSHOT.jar:?]
at com.oppo.ocloud.file.common.service.ReplaceFileIdService.lambda$processReplaceFileIdJob$1(ReplaceFileIdService.java:109) ~[ocloud-file-common-job-1.0-SNAPSHOT.jar:?]
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) [?:?]
at java.util.concurrent.FutureTask.run(FutureTask.java:264) [?:?]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
at java.lang.Thread.run(Thread.java:834) [?:?]
Caused by: org.redisson.RedissonShutdownException: Redisson is shutdown
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:463) ~[redisson-3.0.1.jar:?]
at org.redisson.command.CommandAsyncService.evalAsync(CommandAsyncService.java:439) ~[redisson-3.0.1.jar:?]
at org.redisson.command.CommandAsyncService.evalWriteAsync(CommandAsyncService.java:381) ~[redisson-3.0.1.jar:?]
at org.redisson.command.CommandSyncService.evalWrite(CommandSyncService.java:82) ~[redisson-3.0.1.jar:?]
... 9 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version 6.0.5
Redisson version 3.13.1
Redisson configuration
singleServerConfig:
password:
连接空闲超时，单位：毫秒
idleConnectionTimeout: 10000
连接超时，单位：毫秒
connectTimeout: 10000
命令等待超时，单位：毫秒
timeout: 3000
命令失败重试次数,如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。
如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。
retryAttempts: 3
命令重试发送时间间隔，单位：毫秒
retryInterval: 1500
单个连接最大订阅数量
subscriptionsPerConnection: 5
客户端名称
clientName: null
发布和订阅连接的最小空闲连接数
subscriptionConnectionMinimumIdleSize: 1
发布和订阅连接池大小
subscriptionConnectionPoolSize: 50
最小空闲连接数
connectionMinimumIdleSize: 32
连接池大小
connectionPoolSize: 64
sentinelAddresses:

"redis://192.168.101.153:26379"
"redis://192.168.101.153:26380"
"redis://192.168.101.128:26379"
masterName: "mymaster",

数据库编号
database: 0
DNS监测时间间隔，单位：毫秒
dnsMonitoringInterval: 5000
线程池数量,默认值: 当前处理核数量 * 2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
there are three sentinel node, and one master node and on slave node.
redis and sentinel config file in attachment file.
redisson version:3.12.2
Redis server v=4.0.10
config.zip
error/info log as below:
2020-10-22-T18:07:36.018+0800 | lrc3vm16 | | redisson-netty-2-10 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:38.018+0800 | lrc3vm16 | | redisson-netty-2-10 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:07:40.026+0800 | lrc3vm16 | | redisson-netty-2-7 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:41.035+0800 | lrc3vm16 | | redisson-netty-2-12 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:07:42.037+0800 | lrc3vm16 | | redisson-netty-2-8 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:43.135+0800 | lrc3vm16 | | redisson-netty-2-10 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:07:44.052+0800 | lrc3vm16 | | redisson-netty-2-4 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:46.066+0800 | lrc3vm16 | | redisson-netty-2-4 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:07:48.106+0800 | lrc3vm16 | | redisson-netty-2-11 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:50.105+0800 | lrc3vm16 | | redisson-netty-2-6 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:07:51.107+0800 | lrc3vm16 | | redisson-netty-2-4 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:07:59.133+0800 | lrc3vm16 | | redisson-netty-2-3 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
2020-10-22-T18:08:02.334+0800 | lrc3vm16 | | redisson-netty-2-6 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.17/172.18.81.17:6379 has changed to 172.18.81.16/172.18.81.16:6379
2020-10-22-T18:08:04.470+0800 | lrc3vm16 | | redisson-netty-2-10 | INFO  | org.redisson.connection.SingleEntry | master 172.18.81.16/172.18.81.16:6379 has changed to 172.18.81.17/172.18.81.17:6379
There are no other debug logs here. For example, I want to print the following log, How should I configure log4j?
log.debug("Request sent to resolve ip address for master host: {}", entry.getKey().getHost());
log.debug("Resolved ip: {} for master host: {}", future.getNow().getAddress(), entry.getKey().getHost());
log.info("Detected DNS change. Master {} has changed ip from {} to {}",  entry.getKey(),
currentMasterAddr.getAddress().getHostAddress(), newMasterAddr.getAddress().getHostAddress());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Calling RedissonConnection.del() with multiple keys when using a clustered connection should delete the keys without error

public Long del(byte[]... keys)

Actual behavior
"CROSSSLOT" exception is thrown
Steps to reproduce or test case
Should be able to reproduce by simply trying to delete multiple keys that aren't in the same slot using a ReddisonConnection that is clustered.
In my example

Using redis-spring-data with redisson-spring-data
Using clustered connection
Using "@CacheEvict(allEntries = true)" annotation
This calls

RedisCache.clear()
DefaultRedisCacheWriter.clean()
RedissonConnection.del(byte[][] keys)



Redis version
5.0.3 (AWS)
Redisson version
redis-spring-data
3.12.5+  ("redisson-spring-data23:3.13.6" is where I have tested)
Redisson configuration
Clustered
I ran into this when upgrading from Spring 2.2.x to 2.3.x (Redisson 3.12.0 to 3.13.6)
This appears to have been broken when the check for clustered connection was removed as part of this commit: 8be9008
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
阿里云集群版redis限制了EVAL命令，按理来说用redisson会报错用不了，但是我测试了没有报错，想问下要怎么重现
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Rkeys does not contains RLock keys.  Only me?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have this RMapCache<String, String> stored in redis. Each key has a 30s TTL
Everything behaves normally but from time to time I get this class cast exception which causes a lot of issues down the line.
Caused by: java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.util.Map
	at org.redisson.client.protocol.decoder.MapCacheScanResultReplayDecoder.decode(MapCacheScanResultReplayDecoder.java:35)
	at org.redisson.client.protocol.decoder.MapCacheScanResultReplayDecoder.decode(MapCacheScanResultReplayDecoder.java:30)
	at org.redisson.client.protocol.decoder.ListMultiDecoder2.decode(ListMultiDecoder2.java:46)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:421)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)

I can't tell why this is happening , I am using redisson 3.12.5
Any idea what is happening over here ?
We have multiple nodes that are updating the same map inserting and deleting keys , different TTL's for each.
All nodes are time synced
Any help will be greatly apreciated.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
I initially discussed this idea in #3136.
Describe the solution you'd like
I'd like an RQueue implementation that allows to ack() elements to improve reliability and ensure that an object has been processed by one of the queue's consumers. The following example demonstrates the feature request:
RQueue<E> q;
E element = q.poll(); // prevents other clients to poll the same element but does not finally remove from queue
processElement(element); // do something with it
q.ack(element); // acknowledges processing of element and removes element from queue
If the consumer that q.poll()ed the element crashes or shuts down before finishing the processing and calling q.ack(), the element will automatically be "unlocked" for another consumer to poll next (e.g. via a watch dog similar to RLocks).
Describe alternatives you've considered

As shown in #3136 I considered using RStream but decided against doing so because the RStreams are far too complicated for simple use cases with only a small number of consumers.
My current solution involves using q.pollLastAndOfferFirstTo(...) and creating locks for the elements that should be marked as in progress to check whether the consumer working on an element is still alive or not. This also involves a periodic task that performs such a check on all items in the "in-progress-queue". This works but it would be great if this could be a feature of Redisson so I could reduce my code to someting similar as shown in the small example above.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Let me explain why this change is important.
We use a configuration with 200+ application servers and a Redis cluster with 50+ nodes. We have configured the scan cluster value for 1000 milliseconds. When 200+ applications send CLUSTER NODES to the same Redis node, it leads to very high CPU usage on that Redis node. As a workaround, we changed the cluster scan time to 10 seconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Getting following error:
org.redisson.client.RedisException: MOVED redirection loop detected. Node redis://xxxxx-cache-0001-001.xxxxx-cache.yyyyy.usw2.cache.amazonaws.com:6379 has further redirect to redis://xxxxx-cache-0001-001.xxxxx-cache.yyyyy.usw2.cache.amazonaws.com:6379
We are using redisson 3.13.4 ( tried with 3.13.6 also) with AWS Elasticache Redis.
For our internal testing we created AWS Elasticache Redis cluster with following configuration:
Shards: 1
replica: 1
Engine compatibilty: 5.0.6
readMode=MASTER.
Connecting to configuration endpoind.
In the error you see 'redis://' but we are using 'rediss://' , there is another bug in RedisException where 'redis://' ( without extra 's') is hardcoded.
It was working fine till last week.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
wiki的原文
7.6. 字典排序集（LexSortedSet）
它 公式 还保证了字符串元素的唯一性。
正确的词是不是这样
它 同时 还保证了字符串元素的唯一性。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Will RList<>.add(V) return false ever?
It looks like RedisCommands.RPUSH_BOOLEAN command always return true based on below convertor implementation, can you please let's know will it every return false assuming there is no RedisTimeoutException?
public class TrueReplayConvertor implements Convertor<Boolean> {
    @Override
    public Boolean convert(Object obj) {
        return true;
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi!
Is your feature request related to a problem? Please describe.
We use redisson with spring-boot-starter in our project. Unfortunately, sometimes we need to disable caching (f.e. on some environments we don't have redis). When it comes to a spring-data-redis we can just set property:
spring.cache.type: NONE

and caching is disabled, but if we use Redisson then his auto-configuration doesn't let us run the application without a worked Redis connection.
Describe the solution you'd like
Disable the whole auto-configuration when
spring.cache.type: NONE

Describe alternatives you've considered
We can add a new maven profile and exclude the redisson dependency but it doesn't sound well because we get a new profile to maintain.
My current solution

I excluded autoconfigurations:

@EnableAutoConfiguration(exclude = { RedissonAutoConfiguration.class, RedisAutoConfiguration.class })


I made my own auto configuration (based on redisson's autoconfiguration) where I've added @ConditionalOnExpression("'${spring.cache.type}' == 'redis'")

@Configuration
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties({RedisProperties.class, RedissonProperties.class})
@ConditionalOnExpression("'${spring.cache.type}' == 'redis'")
public class RedisConfiguration {

  private static final String REDIS_PROTOCOL_PREFIX = "redis://";
  private static final String REDISS_PROTOCOL_PREFIX = "rediss://";

  @Bean
  public RedisTemplate<Object, Object> redisTemplate(
      RedisConnectionFactory redisConnectionFactory) {
    RedisTemplate<Object, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
  }

  @Bean
  @ConditionalOnMissingBean
  public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
  }

  @Bean
  public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
    return new RedissonConnectionFactory(redisson);
  }


  @Bean(destroyMethod = "shutdown")
  @ConditionalOnMissingBean(RedissonClient.class)
  public RedissonClient redisson(RedissonProperties redissonProperties, ApplicationContext ctx,
      RedisProperties redisProperties) throws IOException {
    Config config = null;
    Method clusterMethod = ReflectionUtils.findMethod(RedisProperties.class, "getCluster");
    Method timeoutMethod = ReflectionUtils.findMethod(RedisProperties.class, "getTimeout");
    Object timeoutValue = ReflectionUtils.invokeMethod(timeoutMethod, redisProperties);
    int timeout;
    if (null == timeoutValue) {
      timeout = 10000;
    } else if (!(timeoutValue instanceof Integer)) {
      Method millisMethod = ReflectionUtils.findMethod(timeoutValue.getClass(), "toMillis");
      timeout = ((Long) ReflectionUtils.invokeMethod(millisMethod, timeoutValue)).intValue();
    } else {
      timeout = (Integer) timeoutValue;
    }

    if (redissonProperties.getFile() != null) {
      InputStream is = getConfigStream(redissonProperties, ctx);
      config = Config.fromYAML(is);

    } else if (redisProperties.getSentinel() != null) {
      Method nodesMethod = ReflectionUtils.findMethod(Sentinel.class, "getNodes");
      Object nodesValue = ReflectionUtils.invokeMethod(nodesMethod, redisProperties.getSentinel());

      String[] nodes;
      if (nodesValue instanceof String) {
        nodes = convert(Arrays.asList(((String) nodesValue).split(",")));
      } else {
        nodes = convert((List<String>) nodesValue);
      }

      config = new Config();
      config.useSentinelServers()
          .setMasterName(redisProperties.getSentinel().getMaster())
          .addSentinelAddress(nodes)
          .setDatabase(redisProperties.getDatabase())
          .setConnectTimeout(timeout)
          .setPassword(redisProperties.getPassword());
    } else if (clusterMethod != null
        && ReflectionUtils.invokeMethod(clusterMethod, redisProperties) != null) {
      Object clusterObject = ReflectionUtils.invokeMethod(clusterMethod, redisProperties);
      Method nodesMethod = ReflectionUtils.findMethod(clusterObject.getClass(), "getNodes");
      List<String> nodesObject = (List) ReflectionUtils.invokeMethod(nodesMethod, clusterObject);

      String[] nodes = convert(nodesObject);

      config = new Config();
      config.useClusterServers()
          .addNodeAddress(nodes)
          .setConnectTimeout(timeout)
          .setPassword(redisProperties.getPassword());
    } else {
      config = new Config();
      String prefix = REDIS_PROTOCOL_PREFIX;
      Method method = ReflectionUtils.findMethod(RedisProperties.class, "isSsl");
      if (method != null && (Boolean) ReflectionUtils.invokeMethod(method, redisProperties)) {
        prefix = REDISS_PROTOCOL_PREFIX;
      }

      config.useSingleServer()
          .setAddress(prefix + redisProperties.getHost() + ":" + redisProperties.getPort())
          .setConnectTimeout(timeout)
          .setDatabase(redisProperties.getDatabase())
          .setPassword(redisProperties.getPassword());
    }

    return Redisson.create(config);
  }

  private String[] convert(List<String> nodesObject) {
    List<String> nodes = new ArrayList<>(nodesObject.size());
    for (String node : nodesObject) {
      if (!node.startsWith(REDIS_PROTOCOL_PREFIX) && !node.startsWith(REDISS_PROTOCOL_PREFIX)) {
        nodes.add(REDIS_PROTOCOL_PREFIX + node);
      } else {
        nodes.add(node);
      }
    }
    return nodes.toArray(new String[nodes.size()]);
  }

  private InputStream getConfigStream(RedissonProperties redissonProperties, ApplicationContext ctx)
      throws IOException {
    Resource resource = ctx.getResource(redissonProperties.getFile());
    return resource.getInputStream();
  }
}
If you agree then I will push a pull request with changes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
add amend
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3167
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
amend
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
reopen with antoher pull request
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
close with another pull request under my corp account
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
close with another pull request under my corp account
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Session attributes modified without calling setAttribute are not stored properly in Redis.
The following snippet sets an empty list as a session attribute ("foo") on the first call. Any subsequent call gets the attribute and appends an item ("bar") to the list without calling setAttribute.
public class RedissonTestServlet extends HttpServlet {
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
    final HttpSession session = req.getSession();
    if (session.getAttribute("foo") == null) {
      session.setAttribute("foo", new ArrayList());
    } else {
      List list = (List) session.getAttribute("foo");
      list.add("bar");
      //session.setAttribute("foo", list);
    }
  }
}

Expected behavior
With updateMode AFTER_REQUEST the changes should be persisted to Redis after each request regardless of the missing setAttribute.
So the list should expand by one item on every call.
Actual behavior
In Redis there is always only an empty list.
Steps to reproduce or test case
test project
Redis version
6.0.8
Redisson version
3.13.6
Redisson configuration
<Context>
  <Manager className="org.redisson.tomcat.RedissonSessionManager"
           configPath="redisson.conf"
           readMode="REDIS"
           updateMode="AFTER_REQUEST"
           broadcastSessionEvents="false"
           keyPrefix=""/>
</Context>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Env setup:
redisson client : 3.13.6
redis-cli
127.0.0.1:6379> hmset "u:id-1" f1 "id-1_f1" f2 "id-1_f2" f3 "id-1_f3"
127.0.0.1:6379> hmset "u:id-2" f1 "id-2_f1" f2 "id-2_f2" f3 "id-2_f3"
127.0.0.1:6379> hmset "u:id-3" f1 "id-3_f1" f2 "id-3_f2" f3 "id-3_f3"
Expected Output
# evalsha 9ad57862683cb52805f941819a65cc502a1bc0de 3 "u:id-1" "u:id-2" "u:id-3" 
1) 1) "id-1_f1"
2) "id-1_f2"
3) "id-1_f3"
2) 1) "id-2_f1"
2) "id-2_f2"
3) "id-2_f3"
3) 1) "id-3_f1"
2) "id-3_f2"
3) "id-3_f3"


Lua Script
final RScript script = redisson.getScript(StringCodec.INSTANCE);
String luaScript = "local data = {} for i=1,#KEYS do local fields = redis.call('hmget', KEYS[i], 'f1', 'f2', 'f3', 'f4') data[i] = fields end return data";
       
String sha = script.scriptLoadAsync(luaScript);
System.out.println(sha)
final ImmutableList<String> immutableList = ImmutableList.of("u:id-1", "u:id-2", "u:id-3");
// tried ReturnType.MAPVALUE , ReturnType. MAPVALUELIST
List<Object> results = redisson.getScript().evalSha(RScript.Mode.READ_ONLY,  sha,  RScript.ReturnType.MULTI,  Collections.singletonList(immutableList))
for (List<String> stringList : (List<List<String>>) result) {
      System.out.println(stringList.size());
      System.out.println(stringList);
 }

Actual output:
9ad57862683cb52805f941819a65cc502a1bc0de
4
[null, null, null, null]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
TTL same as in the settings
Actual behavior
TTL +10x higher
Steps to reproduce or test case
Set session-timeout in minutes, get the TTL in redis after the session creation, its way higher.
  <!-- ==================== Default Session Configuration ================= -->
  <!-- You can set the default session timeout (in minutes) for all newly   -->
  <!-- created sessions by modifying the value below. 

    <session-config>
        <session-timeout>10080</session-timeout>
        <tracking-mode>COOKIE</tracking-mode>
    </session-config>

redis:6379> TTL redisson:tomcat_session:XXXXXX
(integer) 36287980
(TTL reply in seconds)

Redis version
5.0.7
Redisson version
3.12.5
Tomcat 9.0.38
Redisson configuration
{
   "singleServerConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "address": "redis://redis:6379",
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "connectionMinimumIdleSize":32,
      "connectionPoolSize":64,
      "database":0,
      "dnsMonitoringInterval":5000
   },
   "threads":16,
   "nettyThreads":32,
   "codec":{
      "class":"org.redisson.codec.FstCodec"
   },
   "transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I set the sessionIdLength in the context.xml?
<Manager sessionIdLength="64" className="org.redisson.tomcat.RedissonSessionManager" configPath="${catalina.base}/conf/redisson.conf" broadcastSessionEvents="true" readMode="MEMORY" updateMode="DEFAULT"/>

This didn't worked, the default is 16.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am not very clear about the specific role of readmode="MEMORY". If readmode="MEMORY" should be enabled at the same time broadcastSessionEvents="true" this attribute to ensure the consistency of multiple copies of the session? Does readmode="MEMORY" just store an extra session in the tomcat memory? When I simulate redis downtime, redisson will not directly read the cache from tomcat, but continue to connect to redis to get the session.I need help,thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My env: SpringBoot 2.3.3.RELASE, JDK 8, Redis 5.0.6, redisson-spring-boot-starter 3.13.6
Base config demo as follows:
Config config = new Config();
...
config.useSingleServer().setRetryAttempts(10);
config.useSingleServer().setRetryInterval(10000);
...

My test scene:

Firstly shutdown my redis server
Then start my springboot application
Then restart my redis server

What I expect is: Redisson in the app will retry to connect to  the redis server until connect successfully and the app started normal. But actually redisson didn't retry to do this and the following exception is thrown:
Caused by: org.redisson.client.RedisConnectionException: Unable to connect to Redis server: /10.213.120.82:6379
    at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0 (ConnectionPool.java:159)
    ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there anything else I should do or provide?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is difficult to add test. This change is related to network.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
springboot version : 2.3.3.RELEASE
spring data redis dependency
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

Redis version
null
Redisson version
<dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <version>3.13.6</version>
        </dependency>

Redisson configuration
public class RedissonSpringDataConfig {
    @Value("${spring.redis.cluster.nodes}")
    String redisNodes;
    @Value("${spring.redis.password}")
    String redisPass;

    @Bean
    public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
        return new RedissonConnectionFactory(redisson);
    }

    @Bean(destroyMethod = "shutdown")
    public RedissonClient redisson() throws Exception {
        if (StringUtils.isEmpty(redisNodes)) {
            throw new Exception("redis cluster nodes must not be null");
        }
        Config config = new Config();
        config.useClusterServers()
                .addNodeAddress(
                        Arrays.stream(redisNodes.split(",")).map(item -> "redis://" + item).toArray(String[]::new)
                ).setPassword(redisPass);
        return Redisson.create(config);
    }

}

Expected behavior
I want to use redisTemplate and redissonClient at the same time. Based on the above configuration, using redisTemplate can set the value during operation. But the get value is always null
When I remove the RedissonConnectionFactory injected in RedissonSpringDataConfig, redisTemplate will use lettuceConnectionFactory by default. At this time, there is no problem using redisTemplate's get method and set method. The get method can also return normal values.
Actual behavior
redisTemplate's get method always return null
Steps to reproduce or test case
null
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
In highload systems, it may be too expensive to make requests to Redis too often. Using a not reactive approach, it's possible to enable local caching and use RLocalCachedMap to reduce amount of requests to Redis. However, in a reactive system, currenty it's not an option.
Describe the solution you'd like
I think it would be very nice to be able to use RLocalCachedMap reactively.
Describe alternatives you've considered
As an alternative, I have to implement a custom caching logic to reduce amount of requests to Redis.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I am trying to set the TTL on the cache map as shown in the snippet below but I am noticing that the TTL is set to -1 and not the value I am passing. Is this the right way to go about setting the TTL for the cache maps? If not what is the right way?
private RedissonClient client;
.
.
.
public <K, V> RMap<K, V> getCachedMap(String key, long expiry, TimeUnit timeUnit) {
    if (!isConnectionAlive()) {
        return null;
    }
    try {
        RMap<K, V> map = client.getMap(key);
        map.expire(expiry, timeUnit);
        return map;
    } catch (RedisTimeoutException | RedisConnectionException e) {
        setConnectionAlive(false);
        logger.error("RedisTimeoutException | RedisConnectionException occurred.", e);
        return null;
    }
}

This is what I see on enabling the debug logs:
acquired connection for command (PEXPIRE) and params [INTERACTIVE:event.9cf3de43-8c57-4247-a454-78c615cfdf1a.instance.acc38bdd-fdcb-4232-a701-eb7dadda894a..., 86400000] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=50, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=49, freeConnectionsCounter=value:199:queue:0, freezed=false, freezeReason=null, client=[addr=redis://redis:6379], nodeType=MASTER, firstFail=0]]] using node redis/169.254.169.3:6379... RedisConnection@1303942170 [redisClient=[addr=redis://redis:6379], channel=[id: 0x3a5aaba3, L:/169.254.169.30:53094 - R:redis/169.254.169.3:6379], currentCommand=null]
So looks like it is indeed trying to set the TTL.
I am using redisson version 3.13.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3184
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Demo Code
        RLock[] rLockArr = new RLock[needLocks.size()];
        for (int i = 0; i < locks.size(); i++) {
            RReadWriteLock rwlock = redissonService.getReadWriteLock(DistributedLockKeyEnum.D_LOCK_KEY.getKey(needLocks.get(i)));
            rLockArr[i] = rwlock.readLock();
        }
        RedissonMultiLock lock = new RedissonMultiLock(rLockArr);
当运行到org.redisson.RedissonReadLock#tryLockInnerAsync时，会发生异常。
由于Redis Cluster使用lua脚本有限制，不允许有多个Key，对于多个Key的情况需要使用{}包起来，但是如下getName()方法中没有做这方面的处理。
    @Override
    <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
        internalLockLeaseTime = unit.toMillis(leaseTime);

        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                                "local mode = redis.call('hget', KEYS[1], 'mode'); " +
                                "if (mode == false) then " +
                                  "redis.call('hset', KEYS[1], 'mode', 'read'); " +
                                  "redis.call('hset', KEYS[1], ARGV[2], 1); " +
                                  "redis.call('set', KEYS[2] .. ':1', 1); " +
                                  "redis.call('pexpire', KEYS[2] .. ':1', ARGV[1]); " +
                                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                                  "return nil; " +
                                "end; " +
                                "if (mode == 'read') or (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[3]) == 1) then " +
                                  "local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1); " + 
                                  "local key = KEYS[2] .. ':' .. ind;" +
                                  "redis.call('set', key, 1); " +
                                  "redis.call('pexpire', key, ARGV[1]); " +
                                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                                  "return nil; " +
                                "end;" +
                                "return redis.call('pttl', KEYS[1]);",
                        // getName() 方法中，没有对Key进行处理，造成lua脚本执行报错
                        Arrays.<Object>asList(getName(), getReadWriteTimeoutNamePrefix(threadId)), 
                        internalLockLeaseTime, getLockName(threadId), getWriteLockName(threadId));
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In my Spring Boot project, I have one redis container deployed in Docker swarm cluster. I use it as Hibernate 2nd level cache for the application. I use Redisson client to manually clear the cache using the following code
Config config = new Config();
config.useSingleServer().setAddress("redis://" + redisProperties.getHost() + ":" + redisProperties.getPort());
RedissonClient redisson = Redisson.create(config);
redisson.getKeys().flushdb();
logger.info("Successfully cleared the Redis Cache");
redisson.shutdown();

Now I would like to scale it to multiple containers to withstand failover and distribute the load. If I do that, how can I clear the cache in 2 or more containers at the same time?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
This should not throw an error. It should convert the number to long but it is converting to int
Actual behavior
RedisExeption is thrown
message: Unable to decode data. channel: [id: 0x9866744b, L:/172.18.167.145:48328 - R:xxxxx-0001-001.xxxxx.oi7ujc.use1.cache.amazonaws.com/10.75.xxx.xx:6379], reply: ReplayingDecoderByteBuf(ridx=18, widx=18), command: (HINCRBYFLOAT), params: [BucketUpdates_urn:aaid:yyyyyyyyy:xxxxxxxx-6aa7-4a52-xxxx-xxxxxxxxxxxx, PooledUnsafeDirectByteBuf(ridx: 0, widx: 23, cap: 256), -12218]
Stack trace:
stack_trace: java.lang.NumberFormatException: For input string: "-3753018785"
at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.base/java.lang.Integer.parseInt(Integer.java:652)
at java.base/java.lang.Integer.parseInt(Integer.java:770)
at org.redisson.client.protocol.convertor.NumberConvertor.convert(NumberConvertor.java:42)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:441)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:377)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1475)
at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1224)
at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1271)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)
at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:834)
Steps to reproduce or test case
Map<String, Number> nonZeroBucketUpdates;
RMap<String, Number> distributedBucketUpdates =redissonClient.getMap("BucketUpdates_urn:aaid:yyyyyyyyy:xxxxxxxx-6aa7-4a52-xxxx-xxxxxxxxxxxx");
nonZeroBucketUpdates.forEach(distributedBucketUpdates::addAndGet);
Redis version
5.0.6
Redisson version
3.13.1
Redisson configuration
redissonConfig.setCodec(new JsonJacksonCodec())
.setNettyThreads(64)
.setReadMode(ReadMode.MASTER)
.addNodeAddress(redisProperties.getNodes().toArray(new String[] {}))
.setPassword(redisProperties.getAuthToken())
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
HI there,
it seems like the Redisson authentication is broken for the current release 3.13.6 in combination with a Redis 6.0.9 and a Sentinel setup. I provide the password with the config object:
config.useSentinelServers() .setMasterName("sentinel-master") .addSentinelAddress("redis://127.0.0.1:26379") .setPassword("redis");
I suspect the implementation of the checkAuth() and createRedisConfig(...) methods in SentinelConnectionManager.
Since the default of usePassword is false, this results in the provided password being set to null in createRedisConfig(..), which subsequently causes checkAuth() to fail prematurely on line 213 client.connect() with a RedisConnectionException caused by an RedisAuthRequiredException. Therefore, usePassword is never set to true and the Redission Sentinel config is broken for secured Sentinel instances.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello Everyone,
The Local cache map data types for key is CacheKey and for value is CacheValue. The CacheKey contains the hashed value of encoded original key object. Due to this, when ever redisson tries to retrieve from the local cache, it has to encode the key and convert to hash value and get value from the local cache.
Is there any specific reason behind this approach? What if the CacheKey stores the original key directly? Will that improves the local cache performance?
Best Regards
Sai
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
run success
Actual behavior
with exception  Can't parse config
Steps to reproduce or test case
Redis version
Redisson version
redisson-spring-boot-starter:3.13.6
Redisson configuration
singleServerConfig:
  idleConnectionTimeout: 10000
#  pingTimeout: 1000 # not exist in properties
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
#  reconnectionTimeout: 3000 # not exist in properties
#  failedAttempts: 3 # not exist in properties
  password:
  subscriptionsPerConnection: 5
  clientName: yitu
  address: redis://127.0.0.1:6379
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 32
  connectionPoolSize: 64
  database: 0
#  dnsMonitoring: false # not exist in properties
  dnsMonitoringInterval: 5000
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
transportMode: NIO
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
1.使用redisson加锁
redissonClient.getLock("LOCK_NAME").Lock()
2.加锁成功后断开本地与redis服务器的网络，使redisson的watchdog报错
ERROR org.redisson.RedissonLock - Can't update lock LOCK_NAME expiration org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (3000 ms) occured after 3 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null, channel: [id: 0x1e676dd8, L:/192.168.20.49:58477 - R:/192.168.2.21:6379] at org.redisson.command.RedisExecutor$3.run(RedisExecutor.java:333) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:748)
`
3.让网络恢复正常，且"LOCK_NAME"这个锁自动失效后，再使用redissonClient.getLock("LOCK_NAME").Lock()加锁后watchdog就不再生效了
Redis version
3.13.6
Redisson version
4.0.9
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I point RedissonSessionManager at a YAML config file. I don't get a deprecation warning about using JSON config files.
Actual behavior
I point RedissonSessionManager at a YAML config file. I do get a deprecation warning about using JSON config files.
Steps to reproduce or test case
Point RedissonSessionManager at a YAML config file. Get a deprecation warning about using JSON config files.
Redis version
6.0.8
Redisson version
3.13.6
Redisson configuration
singleServerConfig:
  address: "redis://127.0.0.1:${REDIS_PORT:-6379}"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
working normally
Actual behavior
throw exception:bad argument #2 to 'unpack' (string expected, got nil)
Steps to reproduce or test case
    public static void main(String[] args) throws InterruptedException {
        RRateLimiter rateLimiter = createLimiter();
        System.out.println(rateLimiter.tryAcquire(1));
        Thread.sleep(1000 * 6);
        System.out.println(rateLimiter.tryAcquire(6));
    }

    public static RRateLimiter createLimiter() {
        Config config = new Config();
        config.useSingleServer()
                .setTimeout(1000000)
                .setAddress("redis://127.0.0.1:6379");

        RedissonClient redisson = Redisson.create(config);
        RRateLimiter rateLimiter = redisson.getRateLimiter("myRateLimiter");
        rateLimiter.trySetRate(RateType.OVERALL, 1, 1, RateIntervalUnit.SECONDS);
        return rateLimiter;
    }
Redis version
5.0.4
Redisson version
3.13.6
Redisson configuration
such as case
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3200
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
用的阿里云的集群版redis，会偶发这个错误，但是不确定是执行什么出的错
[] [ERROR] 2020-11-11 15:10:13.897 [redisson-netty-2-8] org.redisson.client.handler.CommandPubSubDecoder - Unable to decode data. channel: [id: 0xcbbfbec3, L:/10.11.9.221:33926 - R:r-uf6lps934bbmd03q4e.redis.rds.aliyuncs.com/10.11.9.239:6379], reply: ReplayingDecoderByteBuf(ridx=140, widx=362)
java.lang.NullPointerException: null
[] [WARN ] 2020-11-11 15:10:13.897 [redisson-netty-2-8] io.netty.channel.DefaultChannelPipeline - An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
io.netty.handler.codec.DecoderException: java.lang.NullPointerException
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
要怎么排查是具体什么的错啊，要怎么解决
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While working on memory improvements for Redis, I came across with an issue where I have observed that Redis is using huge memory for RMap compared to normal object.
I have execute below code and I observed below things:

I could see memory occupied in Redis for key abcd-abcd:map is 10728729 bytes(10.72 MB), I have used command MEMORY USAGE abcd-abcd:map.
I could see memory occupied in Redis for key abcd-abcd is 1170360 bytes(1.17 MB), I used command MEMORY USAGE abcd-abcd

My question is if I am saving one object(hashmap) as an RMap and saving the same object(hashmap) as a value in another Map then why the object saved in RMap is occupying huge amount of memory compared to other case?
Please note currently I kept SIZE as 100000, but in my case I need to save 1-2 million(or more than that) objects in RMap and in that case I can see huge memory utilization in Redis.
Can someone please review this and share their thoughts?
public class RedisTest {
  
  private static final int SIZE = 100000;
  private static Codec compositeCodec = new 
      CompositeCodec(new StringCodec(), new LZ4Codec(new SerializationCodec()),  new SerializationCodec());
  private static String initId = "abcd-abcd";

  public static void main(String[] args) {
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    RedissonClient redissonClient = Redisson.create(config);
    RMap<String,String> rmap = redissonClient.getMap(initId + ":map", compositeCodec);
    Map<String, String> hashMap = getMap();
    rmap.putAll(hashMap);
    RMap<Object, Object> rootMap = redissonClient.getMap(initId, compositeCodec);
    rootMap.put("object", hashMap);
    redissonClient.shutdown();
  }
  
  private static Map<String, String> getMap() {
    Map<String, String> hashMap = new HashMap<>();
    for (int i = 0; i < SIZE; i++) {
      hashMap.put("keykeykeykeykeykeykeykeykeykeykeykey"+i, "valuevaluevaluevaluevaluevaluevaluevaluevalue"+i);
    }
    return hashMap;
  }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
We are using redisson-spring-boot-starter. We were hoping that we could configure Redisson with a redisson.yml, but also configure more dynamic properties from our application.yml.
# application.yml
spring:
  redis:
    host: ${REDIS_HOSTNAME}
    redisson: 
      file: classpath:redisson.yaml
When we run in a different environment we can overwrite the Redis hostname by setting an environment variable. With Spring Boot profiles (for example "local"), we could have an application-local.yml that contains the following:
# application-local.yml
spring:
  redis:
    host: localhost
Or set the placeholder itself:
# application-local.yml
REDIS_HOSTNAME: localhost
That way we would be able to have different configurations for our local run configuration compared to what we use in our production systems. Detailed properties for Redisson (described in redisson.yml) are the same for all environment, while things like the host, port or ssl properties can change depending on the environment where the application is running.
Describe the solution you'd like
If the merging of application.yml(or application-local.yml) with redisson.yml is not possible, can we then maybe have some feature where we fill variables with Spring Boot values. That way the redisson.yml would be able to look like:
# redisson.yml
singleServerConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  subscriptionsPerConnection: 5
  address: "redis://${REDIS_HOSTNAME}:6379"
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 10
  connectionPoolSize: 64
  dnsMonitoringInterval: 5000
In such a way, we would be able to create an application-local.yml that looks like this:
# application-local.yml
REDIS_HOSTNAME: localhost
With Spring Boot values I mean the values described by externalized configuration here. That way there are many ways to inject variables into the configuration of Redisson.
Describe alternatives you've considered
We currently are using the following as an application.yml:
# application.yml
spring:
  redis:
    redisson:
      config: |
        singleServerConfig:
          idleConnectionTimeout: 10000
          connectTimeout: 10000
          timeout: 3000
          retryAttempts: 3
          retryInterval: 1500
          subscriptionsPerConnection: 5
          address: "redis://${ELASTICACHE_URL}:6379"
          subscriptionConnectionMinimumIdleSize: 1
          subscriptionConnectionPoolSize: 50
          connectionMinimumIdleSize: 10
          connectionPoolSize: 64
          dnsMonitoringInterval: 5000
This works for us but puts a lot of detail for a specific dependency in the application.yml. These fields are never changed. The values are prone to mistakes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Environment:
spring-boot: 2.3.4.RELEASE
hibernate-core: 5.4.21.Final
redisson-spring-boot-starter: 3.13.6
redisson-hibernate-53: 3.13.6
Expected behavior
Setting CACHE_REGION_PREFIX for hibernate should be used by redisson hibernate and the entities should be stored under the entity key with the defined prefix.
Actual behavior
The prefix is not used and the entities are stored under the default keyspace.
Steps to reproduce or test case
Redis version
6.0.9
Redisson version
3.13.6
Redisson configuration
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean emFactoryBean = new LocalContainerEntityManagerFactoryBean();
        emFactoryBean.setDataSource(dataSource);
        emFactoryBean.setPackagesToScan(new String[]{ENTITY_PACKAGE});

        JpaVendorAdapter vendorAdapter = getJpaVendorAdapter();
        emFactoryBean.setJpaVendorAdapter(vendorAdapter);

        Map<String, Object> properties = emFactoryBean.getJpaPropertyMap();

        String ddlAction = Action.NONE.name().toLowerCase();
        properties.put(AvailableSettings.HBM2DDL_AUTO, ddlAction);
        properties.put(AvailableSettings.USE_SECOND_LEVEL_CACHE, true);
        properties.put(AvailableSettings.USE_QUERY_CACHE, true);
        properties.put(AvailableSettings.JPA_SHARED_CACHE_MODE, SharedCacheMode.ALL);
        properties.put(AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY, CacheConcurrencyStrategy.TRANSACTIONAL);
        properties.put(AvailableSettings.CACHE_REGION_FACTORY, regionFactory);
        properties.put(AvailableSettings.CACHE_KEYS_FACTORY, SecondLevelCacheKeysFactory.class);

        // REGION PREFIX IS IGNORED
        properties.put(AvailableSettings.CACHE_REGION_PREFIX, DomainCachingConfiguration.NAMESPACE);

        return emFactoryBean;
    }
@Configuration
@Conditional(OnRedisCondition.class)
public class RedissonPersistenceCachingConfiguration extends RedissonRegionFactory {
    /**
     * To avoid loading the redisson config file. There's no file existing. Config programmatically.
     * @param properties
     * @return
     */
    @Override
    protected RedissonClient createRedissonClient(Map properties) {
        return RedisCachingConfiguration.REDISSON_CLIENT_PERSISTENCE;
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When a fresh copy of the repository is cloned, the tests of should all pass.
Actual behavior
When running mvn clean install in the redisson-spring-boot-starter module the build failed on failing tests. I got the following error:
com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'ï': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')
 at [Source: (String)"ï»¿singleServerConfig:
  address: "redis://127.0.0.1:6379""; line: 1, column: 2]

When I run the tests with an IntelliJ run configuration the test does pass.
Steps to reproduce or test case
OS: Windows
Edition: Windows 10 Enterprise
Version: 2004
OS build 19041.572
JDK: AdoptOpenJDK 8u275-b01
Maven: 3.6.3
IntelliJ: 2020.2
git clone git@github.com:redisson/redisson.git
mvn clean install

Redis version
I think this is not relevant, but it Redis 6.0.6 running on Docker.
Redisson version
3.13.7-SNAPSHOT
Redisson configuration
None
What is the actual problem?
I think you'll see in the above exception log that there are some (probably) unexpected character in the redisson.yaml that is used by the tests for redisson-spring-boot-starter. I looked at the encoding of the redisson.yaml by using Notepad++. The result is that the encoding for the redisson.yaml file is: "UTF-8-BOM".
How to solve this issue?
Setting the encoding of this file to "UTF-8" results in the maven tests passing. After doing this, and looking into the git diff shows the following:
diff --git a/redisson-spring-boot-starter/src/test/resources/redisson.yaml b/redisson-spring-boot-starter/src/test/resources/redisson.yaml
index 28466f3ba..6d8f6d7f0 100644
--- a/redisson-spring-boot-starter/src/test/resources/redisson.yaml
+++ b/redisson-spring-boot-starter/src/test/resources/redisson.yaml
@@ -1,2 +1,2 @@
-<EF><BB><BF>singleServerConfig:
-  address: "redis://127.0.0.1:6379"
\ No newline at end of file
+singleServerConfig:
+  address: "redis://127.0.0.1:6379"

I am not sure what are the "".
Can I create a PR for this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
no exception when use default config
Actual behavior
have exception, but if i set codec to JsonJacksonCodec, everything works
Steps to reproduce or test case
use defatult config with default MarshallingCodec
Redis version
redis 5, 6
Redisson version
3.13.0 - 3.13.6
Redisson configuration
Config config = new Config();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am currently using AWS Redis Elasticache cluster with a simple setup
Redis Version 5.X
1 shard, 2 replica
final RBatch batch = redissonClient.createBatch();
batch.getKeys().deleteByPatternAsync(keyPattern.toString());
return batch.executeAsync()
                     .exceptionally(t -> LOG.warn("error when deleting"));

I sometimes get an error like below where keyPattern is "test-key*" which is confusing considering that I only have 1 shard.
org.redisson.client.RedisException: ERR Error running script (call to f_101594a3a4c130bec4a4a379cda6d00cb1c5ff1a): @user_script:1: @user_script: 1: Lua script attempted to access a non local key in a cluster node . channel: [id: 0xf885399a, L:/172.25.76.177:60542 - R:/172.18.11.62:6379] command: (EVAL), params: [local keys = redis.call('keys', ARGV[1]) local n = 0 for i=1, #keys,5000 do n = n + redis.call('del'..., 0, test-key*] (Most recent call first)
Any idea what could be going here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3212
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can we share sharing the same Redisson client for both Hibernate L2 cache and Spring Cache Abstraction?
I am configuring redisson as my l2 cache in application.propeties
  region:
    factory_class: org.redisson.hibernate.RedissonRegionFactory
  redisson:
    config: redisson.json

Currently, I am creating a Cache manager bean using the below code, which creates a new connection to redis.
    @Bean
    public RedissonClient redissonClient() throws IOException {
        Resource resource = resourceLoader.getResource("classpath:/" + redissonConfigFile);
        Config config = Config.fromYAML(resource.getInputStream());
        return Redisson.create(config);
    }

    @Bean
    public CacheManager cacheManager(RedissonClient redissonClient) {
        return new RedissonSpringCacheManager(redissonClient);
    }

I want to create a Cache Manager bean use the same connection configured in application properties. Is it possible to do that?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public static void main(String[] args) {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://localhost:6379").setDatabase(15);
        config.setCodec(new JsonJacksonCodec());
        config.setThreads(16);
        config.setNettyThreads(32);
        config.setTransportMode(TransportMode.NIO);
        RedissonClient redissonClient = Redisson.create(config);

        ExecutorOptions options = ExecutorOptions.defaults();
        RExecutorService executor = redissonClient.getExecutorService("myExecutor",options);
        RExecutorFuture<TenantPO> submit = executor.submitAsync(new Task());
    }

    public static class Task implements Callable<Long>{

        @Override
        public Long call() throws Exception {
            System.out.println("task over");
            return 233L;
        }
    }
我用15号库想提交一个任务，但是没有执行，结果发现，任务信息保存在0号库里，想问下为什么
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
` RMap<Integer, Classify> map = redissonClient.getMap(RedisNameSpace.PermanentCache.classify);
    for (Map.Entry<Integer, Classify> integerClassifyEntry : map.entrySet()) {  //here is ok
        System.out.println(integerClassifyEntry); // printData:9241=Classify(id=9241)
    }

    for (Integer integer : map.keySet()) { //here will throw java.lang.ClassCastException: java.lang.String cannot be cast to 
                                                               //java.lang.Integer
        System.out.println(integer); 
    }`

Redis version
Redisson version
3.13.6
Redisson configuration
default config
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class RedisTest extends BaseTest {
@Autowired
private RedisTemplate redisTemplate;

@Test
public void testGeo() {
    String key = "test_geo_key";
    Point point = new Point(116.401001, 40.119499);
    redisTemplate.opsForGeo().add(key, point, "a");

    point = new Point(111.545998, 36.133499);
    redisTemplate.opsForGeo().add(key, point, "b");

    point = new Point(111.483002, 36.030998);
    redisTemplate.opsForGeo().add(key, point, "c");
    Circle within = new Circle(116.401001, 40.119499, 80000);
    RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeCoordinates();
    GeoResults<RedisGeoCommands.GeoLocation<String>> res = redisTemplate.opsForGeo().radius(key, within, args);
    System.out.println(res);
}

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I should be able to serialize any Pojo.
Actual behavior
java.lang.IllegalArgumentException: Class is not registered: com.rakuten.rapid.cache.v2.entity.TopEntity
Note: To register this class use: kryo.register(com.rakuten.rapid.cache.v2.entity.TopEntity.class);
at com.esotericsoftware.kryo.Kryo.getRegistration(Kryo.java:512)
at com.esotericsoftware.kryo.util.DefaultClassResolver.writeClass(DefaultClassResolver.java:119)
at com.esotericsoftware.kryo.Kryo.writeClass(Kryo.java:546)
at com.esotericsoftware.kryo.Kryo.writeClassAndObject(Kryo.java:641)
at org.redisson.codec.KryoCodec$2.encode(KryoCodec.java:87)

Steps to reproduce or test case
With those versions of Redisson and Kryo. Just set up a simple client. The boolean "RegistrationRequired" is true by default now on Kryo and any new serialization will fail.
Redis version
Any
Redisson version
3.13.6
Redisson configuration
Use KryoCodec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3257
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3290
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RedissionMap.isEmpty adopts the default AbstractMap.isEmpty, which checks size()==0. RedissionMap.size() iterates all keys (even with pattern), which is inefficient with large HASH.
Suggest to override RedissonMap.isEmpty() which checks iterator().hasNext() instead.
Not sure whether this optimization applies to other RMap implementation.
Redisson version: 3.13.6
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have the following code.
redisson.getScoredSortedSet(keys.stream().findFirst().get()).pollFirstFromAny(1, TimeUnit.MINUTES, keys.toArray(new String[0]))
The above code results to connections getting acquired and released every second as follows. What can I do so that it reuses connections from the pool rather than creating new ones.
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:22,950","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:22,950","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:22,950","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:22,951","debug_thread":"redisson-netty-2-8","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@137358397 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x1a909b89, L:/10.8.108.98:57594 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33b6766c(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:22,951","debug_thread":"redisson-netty-2-8","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@137358397 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x1a909b89, L:/10.8.108.98:57594 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@33b6766c(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:23,143","debug_thread":"redisson-netty-2-32","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@137358397 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xa51bb60f, L:/10.8.108.98:57616 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@650dc38f(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@650dc38f(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:23,143","debug_thread":"redisson-netty-2-32","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@137358397 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xa51bb60f, L:/10.8.108.98:57616 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@650dc38f(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@650dc38f(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,050","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@780fc07f(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,050","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@780fc07f(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,051","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,051","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,051","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,051","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,052","debug_thread":"redisson-netty-2-9","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@780fc07f(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,052","debug_thread":"redisson-netty-2-9","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x825d4b56, L:/10.8.108.98:57595 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@780fc07f(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,251","debug_thread":"redisson-netty-2-7","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xe627b32e, L:/10.8.108.98:57617 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7eec7d3f(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7eec7d3f(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:24,251","debug_thread":"redisson-netty-2-7","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@119754824 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xe627b32e, L:/10.8.108.98:57617 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7eec7d3f(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7eec7d3f(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@45d6efba(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@45d6efba(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,150","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,151","debug_thread":"redisson-netty-2-10","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@45d6efba(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,151","debug_thread":"redisson-netty-2-10","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x486880a2, L:/10.8.108.98:57596 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@45d6efba(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,339","debug_thread":"redisson-netty-2-8","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x72d6dac8, L:/10.8.108.98:57620 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@37abd12(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@37abd12(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:25,339","debug_thread":"redisson-netty-2-8","debug_file":"ConnectionWatchdog.java", "debug_line":"130","debug_message":"RedisConnection@1901897413 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x72d6dac8, L:/10.8.108.98:57620 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@37abd12(success: PONG)], command=(PING), params=[], codec=null]] connected to /10.114.12.5:6379, command: CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@37abd12(success: PONG)], command=(PING), params=[], codec=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@1da96dea(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"632","debug_message":"connection released for command (BZPOPMIN) and params [{otpnext}-queue-otp_provisionqa_111318compu_83, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 - R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@1da96dea(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"ClusterConnectionManager.java", "debug_line":"749","debug_message":"slot 5048 for otpnext","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@549722594 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x523655de, L:/10.8.108.98:57598 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,251","debug_thread":"redisson-timer-4-1","debug_file":"RedisExecutor.java", "debug_line":"610","debug_message":"acquired connection for command (BZPOPMIN) and params [{otpnext}-queue-otp_devteam_vs20160etrtrish_c0, 1] from slot NodeSource [slot=5048, addr=null, redisClient=null, redirect=null, entry=null] using node /10.114.12.5:6379... RedisConnection@549722594 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0x523655de, L:/10.8.108.98:57598 - R:/10.114.12.5:6379], currentCommand=null]","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,252","debug_thread":"redisson-netty-2-11","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@1da96dea(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,252","debug_thread":"redisson-netty-2-11","debug_file":"ConnectionWatchdog.java", "debug_line":"108","debug_message":"reconnecting RedisConnection@1127088553 [redisClient=[addr=redis://10.114.12.5:6379], channel=[id: 0xbbd79ac3, L:/10.8.108.98:57597 ! R:/10.114.12.5:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@1da96dea(success)], command=(BZPOPMIN), params=[{otpnext}-queue-otp_provisionqa_111318compu_83, 1], codec=org.redisson.codec.MarshallingCodec]] to /10.114.12.5:6379 ","clientId": "","datasetId": "","unitId": "","eventId": "","flow": "","exception":""}
{"debug_level":"DEBUG","debug_timestamp":"2020-12-14 22:17:26,353","debug_thread":"redisson-netty-2-5","debug_file":"ClusterConnectionManager.java", "debug_line":"453","debug_message":"cluster nodes state got from /10.114.12.5:6379:
I am connecting to Elasticcache which is running redis with 2 nodes and cluster mode enabled
clusterServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
subscriptionsPerConnection: 5
sslEnableEndpointIdentification: true
sslProvider: "JDK"
pingConnectionInterval: 30000
keepAlive: true
tcpNoDelay: false
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveConnectionMinimumIdleSize: 24
slaveConnectionPoolSize: 64
failedSlaveReconnectionInterval: 3000
failedSlaveCheckInterval: 180000
masterConnectionMinimumIdleSize: 24
masterConnectionPoolSize: 64
readMode: "SLAVE"
subscriptionMode: "MASTER"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
dnsMonitoringInterval: 5000
natMapper: !<org.redisson.api.DefaultNatMapper> {}
nodeAddresses:

"redis://xyz:6379"
scanInterval: 5000
checkSlotsCoverage: true
threads: 16
nettyThreads: 32
referenceEnabled: true
transportMode: "NIO"
lockWatchdogTimeout: 30000
keepPubSubOrder: true
decodeInExecutor: false
useScriptCache: false
minCleanUpDelay: 5
maxCleanUpDelay: 1800
cleanUpKeysAmount: 100
nettyHook: !<org.redisson.client.DefaultNettyHook> {}
useThreadClassLoader: true
addressResolverGroupFactory: !<org.redisson.connection.DnsAddressResolverGroupFactory> {}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for suggested changes!

Are you able to pass all the tests?

yes
Did you check that null values are not stored in Redis?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RScheduledExecutorService executorService = redissonClient.getExecutorService(CommonConstants.smsSchedule);
        RScheduledFuture<?> future = executorService.scheduleAtFixedRate(new SmsTask(), 10,10, TimeUnit.SECONDS);
        try {
            future.get();
        } catch (Exception e) {

        }

一直没有执行，future.get()也一直阻塞没有返回
       <dependency>
           <groupId>org.redisson</groupId>
           <artifactId>redisson</artifactId>
           <version>3.14.0</version>
       </dependency>

这是我的redisson版本
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
not wait pubSubConnectionPool inited, beacuse i think pubSubConnectionPool minimumIdleSize is alway less than 10
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TEMP1.txt
如文件所示
请问 类似于
20-12-17 14:48:33 DEBUG org.redisson.command.CommandAsyncService - acquired connection for command (EXISTS) and params [APIKEY_sun727_USERNAME_pc_432699d91c614c89bef3f9b193cc3a25_securityLogin] from slot NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=23, freeConnectionsCounter=value:63:queue:0, freezed=false, freezeReason=null, client=[addr=redis://localhost:6379], nodeType=MASTER, firstFail=0]]] using node localhost/127.0.0.1:6379... RedisConnection@639223878 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x5e3b8b34, L:/127.0.0.1:55233 - R:localhost/127.0.0.1:6379], currentCommand=null]
这样的打印能否用配置关掉呢?
我不想影响其他的DEBUG级别的日志输出!
谢谢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Version:3.13.6
Demo:
String name = "{foo}_1";
String newName = "foo";
RBloomFilter<String> bloomFilter = redissonClient.getBloomFilter(name);
bloomFilter.rename(newName);
Exception:
org.redisson.client.RedisException: ERR Error running script (call to xxx): @user_script:1: ERR no such key . channel: [] command: (EVAL), params: [redis.call('rename', KEYS[1], ARGV[1]);  return redis.call('rename', KEYS[2], ARGV[2]); , 2, {foo}, {foo}_1:config, foo, {foo}:config]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:361)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)

possible reason：
Bloom Filter is empty now and key {foo} doesn't exist ,so rename failed
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
`
    RMap myRMap = redisson.getMap("my-map");
    String pattern = "mykey-*";
    int batchHint = 1;
    Set<String> keySet = myRMap.keySet(pattern, batchHint);

    //The implementation of "keySet(pattern).isEmpty()" is very in-effective, which iterates all keys.
    //boolean isEmpty = keySet.isEmpty();

    //A workaround is something like this
    boolean isEmpty = !keySet.iterator().hasNext();

`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for the proposed changes! All initialization logic should be invoked in afterPropertiesSet() not in constructor this is a rule of thumb.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When working with multiple service instances and using RSet as a distributed cache, add() will create a duplicate for a custom serializable pojo even though equals() and hashCode() are implemented correctly. Also the contains() method will return false when checking the same pojo from different instances OR from the same instance with a refetched RSet like
RSet<SerializablePojo> = redissionClient.getSet(key).
Actual behavior
RSet's contains() method returns false. RSet's add() method will add the same object multiple times.
Steps to reproduce or test case
Take any simple serializable pojo, add it to an RSet. Get the RSet again from the redission client and call its contains() or add() method with the same object. contains() will return false, and the same object will be added again.
The size of the RSet will increase with each add(). Using the RSet as a constructor parameter for a native HashSet(), its size will  always be constant, since the duplicates are not added as expected.
Redis version
6.0.9
Redisson version
3.14.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Trying to understand the slow performance of get(). I run a test program:
    RMapCache<String, RedisUserData> userMap = redisson.getMapCache("userMap");

    int NUM_USERS = 10;

    for(int i=0; i<NUM_USERS; i++) {

        Instant start = Instant.now();
        RedisUserData userData = userMap.get("userABC");
        Instant end = Instant.now();

        System.out.println(Duration.between(start, end).toNanos()/1e6 +
            " millis/user");

        Thread.sleep(10000);
    }

The output is:
7.7 millis/user
0.7 millis/user
0.5 millis/user
0.2 millis/user
0.2 millis/user
0.3 millis/user
0.4 millis/user
0.2 millis/user
0.4 millis/user
0.1 millis/user
What is happening on the first call that isn't happening afterwards?
Many thanks for your help.
WHat is happening
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RBlockingQueue entries are sometimes lost.
Expected behavior
All entries added to the queue with put are returned with poll.
Actual behavior
Sometimes a queue entry will be lost when poll returns.
Steps to reproduce or test case
Minimal code sample used to reproduce: https://gist.github.com/marcusspangenberg/8f4e7047dc0e2465002a8408cca46295
The bug reproduces within 100 iterations in included sample. The poll timeout is set to 1 ms to increase likelihood of the error happening. In a live system I have this set to 5 seconds and I get this error several times a day.
Redis version
5.0.10
Redisson version
Reproduces in Redisson 3.7.0 -> 3.14.0. Unable to reproduce with Redisson 3.6.5. Using openjdk 11.
Redisson configuration
final var singleServerConfig = config.useSingleServer();
singleServerConfig.setAddress("redis://127.0.0.1:6379");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is my configration file
spring:
  redis:
    timeout: 10000
    cluster:
      nodes:
        - 120.79.8.153:7000
        - 120.79.8.153:7001
        - 120.79.8.153:7002
        - 120.79.8.153:7003
        - 120.79.8.153:7004
        - 120.79.8.153:7005
This is my log. note that the ip of port 7000 has changed,
a0eb8a93e3ce9a3ac2d15c73a9d8c3bf7064904d 120.79.8.153:7002@17002 master - 0 1608603104000 3 connected 10923-16383
dfc494ff70a7b10af271a8e132899c47e771fecc 120.79.8.153:7004@17004 slave 20e35d1e53f766ae93a7158f5e8ff4ac379ef8a0 0 1608603105000 1 connected
422579dc30a3aa20cc2cc2e119f893691dcfdca7 120.79.8.153:7005@17005 slave 645a4f040a4bb12b91aa52c23373c4b5acc7c84b 0 1608603105945 2 connected
20e35d1e53f766ae93a7158f5e8ff4ac379ef8a0 172.18.40.70:7000@17000 myself,master - 0 1608603106000 1 connected 0-5460
c295c0f4b6bac3cc3b883e73dd53826cb9a48204 120.79.8.153:7003@17003 slave a0eb8a93e3ce9a3ac2d15c73a9d8c3bf7064904d 0 1608603104944 3 connected
645a4f040a4bb12b91aa52c23373c4b5acc7c84b 120.79.8.153:7001@17001 master - 0 1608603106947 2 connected 5461-10922

When I test the code on my computer, I always get an error: Can't connect to master: redis://172.18.40.70:7000 with slot ranges: [[0-5460]]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Curently, redisson library itself is more than 2MB. When added Netty, another 2.5MB, along with RxJava, +2MB, & Project Reactor, 1.5MB, its nearly 10MB in total dependency size, even without Spring etc. I realized that both RxJava &  Project Reactor classes are not necessary for all operations, mostly has their own packages for operations/data structures etc. I believe it'd be extremely useful to move them to their own separate modules so anyone who wishes to use them, either one or both, can add specifically, but the core will be free from those dependencies & be more compact.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There is a probability that it will happen, not every time it will go wrong。


config:
singleServerConfig:
address: "redis://127.0.0.1:6379"
password: "casa"
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
subscriptionsPerConnection: 5
clientName: null
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
connectionMinimumIdleSize: 12
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 5000
threads: 16
nettyThreads: 64
codec: {}
transportMode: "NIO"
version:3.11.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Being confused.
If won't save update changes to redis automatically,  "RPriorityQueue/RPriorityBlockingDeque"  feature is almost no help  personally.
The memory address keep change:
RPriorityQueue queue = redisson.getPriorityQueue("anyQueue"); // step 1
Vo topOne = queue.peek(); // step 2
topOne.setUsing(true); // step 3

step 1:

step 2:

step 3: The head of RPriorityQueue, "using" property still be "false"，no matter get from redis later again .
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
With redisson sentinel mode getting null pointer exception
Expected behavior
Sentinel configuration should work as per expectation in redisson version 3.11.6 and 3.14.0
Actual behavior
Getting below error :
java.lang.NullPointerException
at org.redisson.connection.SentinelConnectionManager.lambda$null$4(SentinelConnectionManager.java:462)
at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:174)
at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)
at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)
at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)
at org.redisson.connection.SentinelConnectionManager.lambda$updateState$6(SentinelConnectionManager.java:470)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
Steps to reproduce or test case
On trying to connect to redis labs with below sentinel configuration we are getting above issue.Connection to redis is successful.But I continuously see above error its like every milliseconds.
where  'redis://127.0.0.1:8001' is address of service discovery in redis lab.
Redis version
5.6.0
Redisson version
3.11.6 and 3.14.0 (both)
Redisson configuration
{
"codec":{
"class":"org.redisson.client.codec.StringCodec"
},
"lockWatchdogTimeout" : 600000,
"threads": 16,
"sentinelServersConfig":{
"idleConnectionTimeout":10000,
"connectTimeout":10000,
"timeout":3000,
"retryAttempts":3,
"retryInterval":1500,
"failedSlaveReconnectionInterval":3000,
"failedSlaveCheckInterval":60000,
"subscriptionsPerConnection":5,
"password" : "mypass",
"loadBalancer":{
"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
},
"subscriptionConnectionMinimumIdleSize":1,
"subscriptionConnectionPoolSize":50,
"slaveConnectionMinimumIdleSize":24,
"slaveConnectionPoolSize":64,
"masterConnectionMinimumIdleSize":24,
"masterConnectionPoolSize":64,
"readMode":"MASTER",
"subscriptionMode":"SLAVE",
"sentinelAddresses": [
"redis://127.0.0.1:8001"
],
"masterName":"mymaster",
"database":0
}
}
Similar error was fixed earlier in redisson version 3.11.5 .reference link : #2355
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version:3.14.0
@Bean(destroyMethod = "shutdown")
@ConditionalOnMissingBean
RedissonClient redissonClient() throws Exception {
    Config config = new Config();
    config.useClusterServers()
            .setScanInterval(2000)
            .setPassword(redissonConfig.getPassword())
            .addNodeAddress(redissonConfig.getCluster().getNodes())
    ;
    Codec codec=(Codec) ClassUtils.forName(redissonConfig.getCodec(),ClassUtils.getDefaultClassLoader()).newInstance();
    config.setCodec(codec);
    config.setEventLoopGroup(new NioEventLoopGroup());
    return Redisson.create(config);
}

Cluster
2020-12-23 15:01:25.787 ERROR 84897 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x4f80e738, L:/10.8.0.218:53174 ! R:/10.10.48.62:6385]

java.nio.channels.ClosedChannelException: null
	at io.netty.channel.AbstractChannel$AbstractUnsafe.newClosedChannelException(AbstractChannel.java:957) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:865) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-all-4.1.49.Final.jar:4.1.49.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-all-4.1.49.Final.jar:4.1.49.Final]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
Recently, I used Redission RSet to save Object Collections (size from 10,000 to 40,000). When I used readAll() action to fetch all of objects in the set, it caused a lot of slow queries(cost over 100,000 microseconds).

I know that storing too many objects, and that too long a key can be a performance drop, so I'd love to know how I can store so many objects and read them all efficiently with Redisson. 

Thanks~
Object Example:
public class DataDTO implements Serializable {
    private String data;
    private String datas;
    private String label;
    private Long posNum;
    private Long negNum;
    private Integer dataLength;
    private Integer posFreq;
    private Integer negFreq;
    private Long totalCountNum;
    private Long tgi;
}
RSet Example:
RSet<DataDTO> dataSet =   redissonClient.getSet(CacheName);
//when I store a list of obecjts (size over 100,000)
dataSet.addAll( dataList);

//when I read all of the objects
dataSet.readAll();
Redis connection properties:
            Config config = new Config();
            config.setThreads(0);
            config.setNettyThreads(0);
            config.setCodec(new FastjsonCodec());
            config.setTransportMode(TransportMode.NIO);

            String node = redisProperties.getSingle().getAddress();
            node = node.startsWith("redis://") ? node : "redis://" + node;
            SingleServerConfig serverConfig = config.useSingleServer()
                    .setDatabase(0)
                    .setAddress(node)
                    .setTimeout(5000)
                    .setConnectionPoolSize(64)
                    .setConnectionMinimumIdleSize(32)           
                    .setSubscriptionConnectionMinimumIdleSize(1)
                    .setSubscriptionConnectionPoolSize(50)
                    .setSubscriptionsPerConnection(5)
                    .setConnectTimeout(10000)
                    .setRetryAttempts(3)
                    .setRetryInterval(1500)
                    .setIdleConnectionTimeout(10000);
Redis Condition:
single model
Redisson Version:
3.10.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Correct removed index if exists in cluster mode or not removed if value index does not exists.
Actual behavior
Current call of AccessorInterceptor#removeIndex(RMap<String, Object>, Object, Field) raises an NPE if index value does not exists.
Steps to reproduce or test case
@REntity
@Data // auto generated getName/setName/getId/setId/equals/hashCode
public class Entity implements Serializable {
    @RId(generator = LongGenerator.class)
    private Long id;
    
    @RIndex
    private int idx1;
    @RIndex
    private int idx2;
}

Persist and delete entity

public void test() {
        final RLiveObjectService liveObjectService = PersistenceStateManager.getInstance()
                .getSyncClient().getLiveObjectService();
        liveObjectService.registerClass(Entity.class);
        
        Entity entity = new Entity();
        entity.setIdx1(1);
        entity.setIdx2(2);

        liveObjectService.persist(entity);
}

See throwed exception:
java.lang.NullPointerException in method removeIndex (line 200, liveMap.remove(String) returning null and isn't RLiveObjectInstancee) if idx1 not marked as REntity and using cluster

Object value = liveMap.remove(field.getName()); <-- null
RMultimapAsync<Object, Object> map = new RedissonSetMultimap<>(namingScheme.getCodec(), ce, indexName);
map.removeAsync(
         ((RLiveObject) value).getLiveObjectId(), <-- wtf?
         ((RLiveObject) me).getLiveObjectId()
);
Solutions to the problem:
add null check, or store woking functional
Redis version
6.0.6
Redisson version
3.14.1
Redisson configuration
cluster server configuration (3 master, 3 slaves)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Correct removed index.
Actual behavior
Current call of AccessorInterceptor#removeAsync(CommandBatchService, String, String, Codec, Object, String) raises an script exception ERR Error running script (call to f_7f573e8a56b15c812f93887e04b9fdb40d72f0e6): @user_script:1: WRONGTYPE Operation against a key holding the wrong kind of value.
Steps to reproduce or test case
@REntity
@Data // auto generated getName/setName/getId/setId/equals/hashCode
public class Entity implements Serializable {
    @RId(generator = LongGenerator.class)
    private Long id;
    
    @RIndex
    private int idx1;
    @RIndex
    private int idx2;
}

Persist and delete entity

public void test() {
        final RLiveObjectService liveObjectService = PersistenceStateManager.getInstance()
                .getSyncClient().getLiveObjectService();
        liveObjectService.registerClass(Entity.class);
        
        Entity entity = new Entity();
        entity.setIdx1(1);
        entity.setIdx2(2);

        liveObjectService.persist(entity);
}

See throwed exception:
ERR Error running script (call to f_7f573e8a56b15c812f93887e04b9fdb40d72f0e6): @user_script:1: WRONGTYPE Operation against a key holding the wrong kind of value

Redis version
6.0.6
Redisson version
3.14.1
Redisson configuration
single server configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
(BridgeRuntime.java:595)	handleHttp	[]	Unable to process request
java.lang.UnsupportedOperationException
at org.jboss.netty.buffer.CompositeChannelBuffer.array(CompositeChannelBuffer.java:166)
at org.atmosphere.nettosphere.BridgeRuntime.createAtmosphereRequest(BridgeRuntime.java:376)
at org.atmosphere.nettosphere.BridgeRuntime.handleHttp(BridgeRuntime.java:489)
at org.atmosphere.nettosphere.BridgeRuntime.messageReceived(BridgeRuntime.java:267)
at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
at org.jboss.netty.handler.stream.ChunkedWriteHandler.handleUpstream(ChunkedWriteHandler.java:142)
at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:296)
at org.jboss.netty.handler.codec.http.HttpChunkAggregator.messageReceived(HttpChunkAggregator.java:194)
at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:296)
at org.jboss.netty.handler.codec.frame.FrameDecoder.unfoldAndFireMessageReceived(FrameDecoder.java:452)
at org.jboss.netty.handler.codec.replay.ReplayingDecoder.callDecode(ReplayingDecoder.java:536)
at org.jboss.netty.handler.codec.replay.ReplayingDecoder.messageReceived(ReplayingDecoder.java:435)
at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268)
at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255)
at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:108)
at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:337)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:89)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Input code:
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1");
    RedissonClient client = Redisson.create(config);

Exception Message:
exception in thread "main" java.lang.StringIndexOutOfBoundsException: begin 8, end 5, length 17
at java.base/java.lang.String.checkBoundsBeginEnd(String.java:3734)
at java.base/java.lang.String.substring(String.java:1903)
at org.redisson.misc.RedisURI.(RedisURI.java:46)
at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:362)
at org.redisson.connection.MasterSlaveConnectionManager.(MasterSlaveConnectionManager.java:159)
at org.redisson.connection.SingleConnectionManager.(SingleConnectionManager.java:34)
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:200)
at org.redisson.Redisson.(Redisson.java:64)
at org.redisson.Redisson.create(Redisson.java:104)
Redisson version:
3.14.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my redisson version:3.12.3
redisson client:
config.setThreads(128).setNettyThreads(128).setCodec(new FstCodec()).setTransportMode(TransportMode.NIO)
.setLockWatchdogTimeout(15000)
.useClusterServers()
.setRetryAttempts(retryAttempts)
.setPassword(StringUtils.isBlank(redisPwd)?null:redisPwd)
.setLoadBalancer(new RoundRobinLoadBalancer())
.setSubscriptionConnectionPoolSize(200)
.setSubscriptionConnectionMinimumIdleSize(5)
.setSlaveConnectionPoolSize(Integer.parseInt(redisPoolSize)) //redisPoolSize = 512
.setMasterConnectionPoolSize(Integer.parseInt(redisPoolSize))
.setReadMode(ReadMode.SLAVE)
.setSubscriptionMode(SubscriptionMode.SLAVE)
.setPingConnectionInterval(0).setKeepAlive(false).setTcpNoDelay(false)
.addNodeAddress(redisArraynew);
return Redisson.create(config);
I use redissonMap to caching data and use RScheduledExecutorService to schedule tasks. Why there's no connection to use  ? Looks for your help, thanks.
My application error:
2020-12-29 06:02:47.279 [pool-6-thread-1] ERROR RedisCacheUtils [RedisCacheUtils.java:540] - org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=4568, addr=redis://192.168.11.248:6379, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local mode = redis.call('hget', KEYS[1], 'mode'); if (mode == false) then redis.call('publish', KEYS..., 2, {v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, redisson_rwlock:{v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, 1, 15000, e610596c-cb9f-4603-b593-b31f470ef756:172:write] after 0 retry attempts
CommonException: org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=4568, addr=redis://192.168.11.248:6379, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local mode = redis.call('hget', KEYS[1], 'mode'); if (mode == false) then redis.call('publish', KEYS..., 2, {v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, redisson_rwlock:{v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, 1, 15000, e610596c-cb9f-4603-b593-b31f470ef756:172:write] after 0 retry attempts
RedisCacheUtils.lambda$init$20(RedisCacheUtils.java:537)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:748)
Caused by: org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=4568, addr=redis://192.168.11.248:6379, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local mode = redis.call('hget', KEYS[1], 'mode'); if (mode == false) then redis.call('publish', KEYS..., 2, {v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, redisson_rwlock:{v103_cache_tbl}:b2Qvj7NBl3bGr/xULuMlIQ:rw_lock, 1, 15000, e610596c-cb9f-4603-b593-b31f470ef756:172:write] after 0 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:180)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
... 1 common frames omitted
2020-12-29 06:11:58.381 [pool-7-thread-1] ERROR RedisCacheUtils [RedisCacheUtils.java:552] - Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=381, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:200:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:1024:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.11.26:6380], nodeType=MASTER, firstFail=0]]], command: (HKEYS), params: [v103_sentry_cache] after 0 retry attempts
org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=381, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:200:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:1024:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.11.26:6380], nodeType=MASTER, firstFail=0]]], command: (HKEYS), params: [v103_sentry_cache] after 0 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:180)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
2020-12-29 06:12:44.188 [pool-6-thread-1] ERROR RedisCacheUtils [RedisCacheUtils.java:540] - org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=4568, addr=redis://192.168.11.248:6379, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local mode = redis.call('hget', KEYS[1], 'mode'); if (mode == false) then redis.call('hset', KEYS[1]..., 1, {v103_cache_tbl}:7swFf8RGPkVjjO6j8DrkYQ:rw_lock, 15000, e610596c-cb9f-4603-b593-b31f470ef756:172:write] after 0 retry attempts
CommonException: org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=4568, addr=redis://192.168.11.248:6379, redisClient=null, redirect=MOVED, entry=null], command: (EVAL), params: [local mode = redis.call('hget', KEYS[1], 'mode'); if (mode == false) then redis.call('hset', KEYS[1]..., 1, {v103_cache_tbl}:7swFf8RGPkVjjO6j8DrkYQ:rw_lock, 15000, e610596c-cb9f-4603-b593-b31f470ef756:172:write] after 0 retry attempts
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
redis cluster log:
master1:
22453:S 29 Dec 06:00:31.187 * Background saving terminated with success
22453:S 29 Dec 06:03:36.058 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
22453:S 29 Dec 06:05:32.040 * 10 changes in 300 seconds. Saving...
slave1
2648:S 29 Dec 05:56:34.100 * Background AOF rewrite terminated with success
22648:S 29 Dec 05:56:34.101 * Residual parent diff successfully flushed to the rewritten AOF (0.00 MB)
22648:S 29 Dec 05:56:34.101 * Background AOF rewrite finished successfully
22648:S 29 Dec 05:57:25.008 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
22648:S 29 Dec 05:58:03.059 * 10 changes in 300 seconds. Saving...
22648:S 29 Dec 05:58:03.061 * Background saving started by pid 5394
5394:C 29 Dec 05:58:03.200 * DB saved on disk
5394:C 29 Dec 05:58:03.202 * RDB: 0 MB of memory used by copy-on-write
22648:S 29 Dec 05:58:03.261 * Background saving terminated with success
22648:S 29 Dec 06:03:04.039 * 10 changes in 300 seconds. Saving...
master2:
25990:M 29 Dec 05:53:58.201 * Background saving terminated with success
25990:M 29 Dec 05:56:09.391 * Marking node cf2733775061da5d63eaef8ac0fc38bcdd0db410 as failing (quorum reached).
25990:M 29 Dec 05:56:09.722 * Marking node ff6259256766f595afb6c887eaf51a04c4096583 as failing (quorum reached).
25990:M 29 Dec 05:56:11.307 * Clear FAIL state for node cf2733775061da5d63eaef8ac0fc38bcdd0db410: slave is reachable again.
25990:M 29 Dec 05:56:12.312 # Failover auth granted to cf2733775061da5d63eaef8ac0fc38bcdd0db410 for epoch 84
25990:M 29 Dec 05:56:14.034 * Clear FAIL state for node ff6259256766f595afb6c887eaf51a04c4096583: slave is reachable again.
25990:M 29 Dec 05:56:58.036 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
25990:M 29 Dec 05:58:59.050 * 10 changes in 300 seconds. Saving...
25990:M 29 Dec 05:58:59.051 * Background saving started by pid 20065
20065:C 29 Dec 05:58:59.097 * DB saved on disk
20065:C 29 Dec 05:58:59.098 * RDB: 0 MB of memory used by copy-on-write
25990:M 29 Dec 05:58:59.151 * Background saving terminated with success
25990:M 29 Dec 06:04:00.039 * 10 changes in 300 seconds. Saving...
slave2:
6251:S 29 Dec 05:56:08.713 * Marking node ff6259256766f595afb6c887eaf51a04c4096583 as failing (quorum reached).
26251:S 29 Dec 05:56:09.392 * FAIL message received from 8d50b5a9bc578993b77aa729294217a37f80e183 about cf2733775061da5d63eaef8ac0fc38bcdd0db410
26251:S 29 Dec 05:56:11.307 * Clear FAIL state for node cf2733775061da5d63eaef8ac0fc38bcdd0db410: slave is reachable again.
26251:S 29 Dec 05:56:13.188 * Clear FAIL state for node ff6259256766f595afb6c887eaf51a04c4096583: master without slots is reachable again.
26251:S 29 Dec 05:56:58.084 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
26251:S 29 Dec 05:57:03.085 * 10 changes in 300 seconds. Saving...
26251:S 29 Dec 05:57:03.086 * Background saving started by pid 18641
18641:C 29 Dec 05:57:03.371 * DB saved on disk
18641:C 29 Dec 05:57:03.372 * RDB: 0 MB of memory used by copy-on-write
26251:S 29 Dec 05:57:03.386 * Background saving terminated with success
26251:S 29 Dec 06:02:04.067 * 10 changes in 300 seconds. Saving...
26251:S 29 Dec 06:02:04.068 * Background saving started by pid 22346
master3:
21463:M 29 Dec 05:56:12.674 * Starting BGSAVE for SYNC with target: disk
21463:M 29 Dec 05:56:12.677 * Background saving started by pid 8971
8971:C 29 Dec 05:56:12.852 * DB saved on disk
8971:C 29 Dec 05:56:12.854 * RDB: 1 MB of memory used by copy-on-write
21463:M 29 Dec 05:56:12.908 * Background saving terminated with success
21463:M 29 Dec 05:56:12.919 * Synchronization with slave 192.168.11.26:6380 succeeded
21463:M 29 Dec 05:56:14.010 * Clear FAIL state for node ff6259256766f595afb6c887eaf51a04c4096583: slave is reachable again.
21463:M 29 Dec 05:57:02.028 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
21463:M 29 Dec 06:01:13.058 * 10 changes in 300 seconds. Saving...
21463:M 29 Dec 06:01:13.077 * Background saving started by pid 14460
14460:C 29 Dec 06:01:13.312 * DB saved on disk
14460:C 29 Dec 06:01:13.315 * RDB: 1 MB of memory used by copy-on-write
21463:M 29 Dec 06:01:13.378 * Background saving terminated with success
slave3:
21705:M 29 Dec 05:54:45.131 * Background saving terminated with success
21705:M 29 Dec 05:56:09.391 * FAIL message received from 8d50b5a9bc578993b77aa729294217a37f80e183 about cf2733775061da5d63eaef8ac0fc38bcdd0db410
21705:M 29 Dec 05:56:09.715 * Marking node ff6259256766f595afb6c887eaf51a04c4096583 as failing (quorum reached).
21705:M 29 Dec 05:56:11.305 * Clear FAIL state for node cf2733775061da5d63eaef8ac0fc38bcdd0db410: slave is reachable again.
21705:M 29 Dec 05:56:12.311 # Failover auth granted to cf2733775061da5d63eaef8ac0fc38bcdd0db410 for epoch 84
21705:M 29 Dec 05:56:14.002 * Clear FAIL state for node ff6259256766f595afb6c887eaf51a04c4096583: slave is reachable again.
21705:M 29 Dec 05:59:46.078 * 10 changes in 300 seconds. Saving...
21705:M 29 Dec 05:59:46.085 * Background saving started by pid 12375
12375:C 29 Dec 05:59:46.111 * DB saved on disk
12375:C 29 Dec 05:59:46.111 * RDB: 0 MB of memory used by copy-on-write
21705:M 29 Dec 05:59:46.185 * Background saving terminated with success
21705:M 29 Dec 06:03:29.010 * Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.
21705:M 29 Dec 06:04:47.051 * 10 changes in 300 seconds. Saving...
21705:M 29 Dec 06:04:47.052 * Background saving started by pid 17249
17249:C 29 Dec 06:04:47.074 * DB saved on disk
17249:C 29 Dec 06:04:47.074 * RDB: 0 MB of memory used by copy-on-write
21705:M 29 Dec 06:04:47.152 * Background saving terminated with success
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We are using AWS elasticache Redis with cluster mode enabled. We are seeing below issue intermittently from Redisson, please guide how to resolve this issue.
Exception Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=6524, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@106880645 [redisClient=[addr=redis://], channel=[id: 0xdb426022, L:/:52758 - R:/:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@6b0e5454(failure: java.util.concurrent.CancellationException)], command=(GET), params=[], codec=org.redisson.codec.MarshallingCodec]], command: (GET), params: [**] after 5 retry attempts
Below is the cluster configuration:
Config config = new Config();
config.setNettyThreads(1000);
config.useClusterServers().addNodeAddress(REDIS_CLUSTER)
.setTimeout(30000)
.setMasterConnectionPoolSize(1000)
.setSlaveConnectionPoolSize(1000)
.setRetryAttempts(5)
.setRetryInterval(5000);
redissonCluster = Redisson.create(config);
I have tried increasing netty threads, connection pool size and retry attempts.
Average load on our system is around 500 requests/sec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I run redisson,there are some error logs:
LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 
#1:
        io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:610)
        org.springframework.core.io.buffer.NettyDataBuffer.write(NettyDataBuffer.java:177)
        org.springframework.core.io.buffer.NettyDataBuffer.write(NettyDataBuffer.java:43)
        org.springframework.http.codec.json.AbstractJackson2Encoder.encodeValue(AbstractJackson2Encoder.java:196)
        org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$0(AbstractJackson2Encoder.java:137)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
        reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:96)
        reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onNext(FluxPeekFuseable.java:845)
        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:147)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240)
        reactor.core.publisher.Operators$MonoSubscriber.onComplete(Operators.java:1824)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onComplete(MonoIgnoreThen.java:314)
        reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:81)
        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:270)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:144)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1783)
        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)
        reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114)
        reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onNext(MonoIgnoreThen.java:296)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782)
        reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:121)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252)
        reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:78)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252)
        reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:838)
        reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:600)
        reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:580)
        reactor.core.publisher.FluxFlatMap$FlatMapMain.onComplete(FluxFlatMap.java:457)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:144)
        reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:289)
        reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:225)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
        reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:363)
        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
        reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:161)
        reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:86)
        reactor.core.publisher.Mono.subscribe(Mono.java:4213)
        reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:199)
        reactor.core.publisher.MonoFlatMap.subscribeOrReturn(MonoFlatMap.java:53)
        reactor.core.publisher.InternalMonoOperator.subscribe(InternalMonoOperator.java:57)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240)
        reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189)
        reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:144)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240)
        reactor.core.publisher.Operators$MonoSubscriber.onComplete(Operators.java:1824)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onComplete(MonoIgnoreThen.java:314)
        reactor.core.publisher.Operators$MonoSubscriber.onComplete(Operators.java:1824)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onComplete(MonoIgnoreThen.java:314)
        reactor.core.publisher.Operators$MonoSubscriber.onComplete(Operators.java:1824)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onComplete(MonoIgnoreThen.java:314)
        reactor.core.publisher.Operators$MonoSubscriber.onComplete(Operators.java:1824)
        reactor.core.publisher.MonoIgnoreThen$ThenAcceptInner.onComplete(MonoIgnoreThen.java:314)
        reactor.core.publisher.Operators.complete(Operators.java:135)
        reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45)
        reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.ignoreDone(MonoIgnoreThen.java:190)
        reactor.core.publisher.MonoIgnoreThen$ThenIgnoreInner.onComplete(MonoIgnoreThen.java:240)
        reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:189)
        reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:260)
        reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:81)
        reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1783)
        reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247)
        reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782)
        reactor.core.publisher.MonoZip$ZipCoordinator.signal(MonoZip.java:247)
        reactor.core.publisher.MonoZip$ZipInner.onNext(MonoZip.java:329)
        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1782)
        reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:121)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252)
        reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onComplete(MonoFlatMapMany.java:203)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:292)
        reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96)
        reactor.core.publisher.FluxUsingWhen$UsingWhenSubscriber.deferredComplete(FluxUsingWhen.java:402)
        reactor.core.publisher.FluxUsingWhen$CommitInner.onComplete(FluxUsingWhen.java:536)
        reactor.core.publisher.Operators.complete(Operators.java:135)
        reactor.core.publisher.MonoEmpty.subscribe(MonoEmpty.java:45)
        reactor.core.publisher.Mono.subscribe(Mono.java:4213)
        reactor.core.publisher.FluxUsingWhen$UsingWhenSubscriber.onComplete(FluxUsingWhen.java:394)
        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)
        reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96)
        reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drainAsync(FluxFlattenIterable.java:334)
        reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.drain(FluxFlattenIterable.java:679)
        reactor.core.publisher.FluxFlattenIterable$FlattenIterableSubscriber.onComplete(FluxFlattenIterable.java:260)
        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)
        reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96)
        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)
        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2016)
        reactor.core.publisher.MonoNext$NextSubscriber.onComplete(MonoNext.java:96)
        reactor.core.publisher.FluxCreate$BaseSink.complete(FluxCreate.java:438)
        reactor.core.publisher.FluxCreate$BufferAsyncSink.drain(FluxCreate.java:784)
        reactor.core.publisher.FluxCreate$BufferAsyncSink.complete(FluxCreate.java:732)
        reactor.core.publisher.FluxCreate$SerializedSink.drainLoop(FluxCreate.java:239)
        reactor.core.publisher.FluxCreate$SerializedSink.drain(FluxCreate.java:205)
        reactor.core.publisher.FluxCreate$SerializedSink.complete(FluxCreate.java:196)
        org.redisson.reactive.CommandReactiveService.lambda$null$1(CommandReactiveService.java:63)
        org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
        io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
        io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
        io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
        io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
        io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
        io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
        io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
        org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
        org.redisson.command.RedisExecutor.handleSuccess(RedisExecutor.java:474)
        org.redisson.command.RedisExecutor.handleResult(RedisExecutor.java:457)
        org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:443)
        org.redisson.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:164)
        org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
        io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
        io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
        io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
        io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
        io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
        io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604)
        io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
        org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
        org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:433)
        org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:427)
        org.redisson.client.handler.CommandDecoder.decodeResult(CommandDecoder.java:416)
        org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:410)
        org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365)
        org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)
        org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
        org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)
        io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
        io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)

redisson version is 3.14.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to use  transactional isolation functionality in live object interceptors, or do I have to embed in the library code to implement the feature?
Do you plan to implement it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.RedissonMultiLock#tryLock(long, long, java.util.concurrent.TimeUnit)
In this method, both waittime and leasetime are specified. That is to say, the leasetime and waittime of the input parameter are not equal to - 1. When locking, newleasetime is used, which is twice as much as waittime. Why not use the leasetime in the input parameter
version：org.redisson:redisson:3.13.2
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisException: ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression. channel: [id: 0xf08ae8b0, L:/xxx - R:xxx] command: (EVAL), params: [local rate = redis.call('hget', KEYS[1], 'rate');local interval = redis.call('hget', KEYS[1], 'inter..., 3, token:refresh:xxx, {token:refresh:xxx}:value, {token:refresh:xxx}:value:xxx, 1]
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365)
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:196)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:134)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:104)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)

遇到与 #2754 一样的问题，使用redisson的RRateLimiter做限流，访问阿里云的cluster会抛上述异常。如果参考链接 https://www.cnblogs.com/tinywan/p/13064510.html 的解决方案，请问lua脚本在工程的什么位置改怎么改，或者有其它兼容或者解决办法吗，谢谢
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Looking at this example, there are different ways to iterate though a map
Set<String> allKeys = mapCache.readAllKeySet();
Collection<Integer> allValues = mapCache.readAllValues();
Set<Entry<String, Integer>> allEntries = mapCache.readAllEntrySet();

In addition, I can also use Java native API
for (Map.Entry<String, Integer> entry : mapCache.entrySet()) {
}

Suppose the map has millions of entries, what's the best way to iterate through the map to get all key/value pairs, without blocking Redis?
My understanding is that KEYS command may block other clients, so HSCAN may be better. Does Redisson support the map iteration based on HSCAN?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Avro Utf8 string cannot be deserialized properly by jsonjacksoncodec
Avro utf8 string is serialized as binary object but being deserialized as string hence causes transformation exception
12:12:48.700 [redisson-netty-2-11] ERROR org.redisson.client.handler.CommandDecoder - Unable to decode data. channel: [id: 0xab6c8391, L:/127.0.0.1:60267 - R:/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=204, widx=204), command: (HGET), params: [SESSIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 12, cap: 256)]
com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of java.lang.String out of START_OBJECT token
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 69] (through reference chain: com.avro.SessionData["displayName"])
at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59)
at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1468)
at com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1242)
at com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1148)
at com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:63)
at com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserializeWithType(StringDeserializer.java:71)
at com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserializeWithType(StringDeserializer.java:10)
at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:147)
at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:293)
at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:194)
at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:166)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:132)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:99)
at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:195)
at com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:710)
at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)
at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4524)
at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3503)
at org.redisson.codec.JsonJacksonCodec$2.decode(JsonJacksonCodec.java:95)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:834)
12:12:48.700 [redisson-netty-2-11] DEBUG org.redisson.command.RedisExecutor - connection released for command (HGET) and params [SESSIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 12, cap: 256)] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@434413671 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0xab6c8391, L:/127.0.0.1:60267 - R:/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@435e0643(failure: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of java.lang.String out of START_OBJECT token
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 69] (through reference chain: com.avro.SessionData["displayName"]))], command=(HGET), params=[SESSIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 12, cap: 256)], codec=org.redisson.codec.JsonJacksonCodec]]
Exception in thread "main" 12:12:48.701 [redisson-netty-2-11] ERROR org.redisson.client.handler.ErrorsLoggingHandler - Exception occured. Channel: [id: 0xab6c8391, L:/127.0.0.1:60267 - R:/127.0.0.1:6379]
io.netty.handler.codec.DecoderException: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of java.lang.String out of START_OBJECT token
at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 69] (through reference chain: com.avro.SessionData["displayName"])
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:834)
Expected behavior
Avro utf8 should be serialized as string and deserialized as string
OR
Avro utf8 should be serialized as binary object and deserialized as binary object
Actual behavior
Avro utf8 string is serialized as binary object but being deserialized as string hence causing transformation exception
Steps to reproduce or test case
avro sample used
``
{
"name": "SessionData",
"type": "record",
"namespace": "com.avro",
"doc": "Session information",
"fields": [
{
"name": "sessionId",
"type": [
"null",
"string"
],
"doc": "the unique identifier for the session"
},
{
"name": "displayName",
"type": [
"null",
"string"
],
"doc": "the display name of participant"
},
{
"name": "updateTimeMillis",
"type": "long",
"doc": "timestamp(miliseconds since wpoch) at which this dialog was last updated"
}
]
}
Code Sample
package com.redis.redissampleconnector;
import java.util.HashMap;
import java.util.Map;
import org.apache.avro.util.Utf8;
import org.redisson.Redisson;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.redisson.codec.JsonJacksonCodec;
import com.avro.SessionData;
public class RedisCodecJsonJacksonTest {
private static RMap<String, SessionData> sessionRMap = null;
public static void main(String[] args) {

	String keyStr = "keytest123";
	RedissonClient redissonClient = Redisson.create();

	JsonJacksonCodec testCodec = new JsonJacksonCodec();
	testCodec.getObjectMapper().findAndRegisterModules();

	sessionRMap = redissonClient.getMap("SESSIONS", testCodec);
	
	SessionData testSession  = new SessionData();
	testSession.setUpdateTimeMillis(System.currentTimeMillis());

	testSession.setDisplayName(keyStr);

	testSession.setDisplayName(new Utf8("James"));
	System.out.println("Current Time: " + testSession.getUpdateTimeMillis() );
	sessionRMap.put(keyStr, testSession);
	
	SessionData retSession = sessionRMap.get(keyStr);
	
	System.out.println("Stored Time: " + retSession.getUpdateTimeMillis() );
	
	
}

}
`
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3328
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson dependency : redisson-spring-boot-starter , version: 3.14.0
redisson config
spring:
  application:
    name: spring-boot-demo
  redis:
    database: 0
    password: 80e6eaab67dc5b8fef5f585d8f289e54
    cluster:
      nodes:
        - 172.21.22.22:9000 
        - 172.21.22.22:9001
        - 172.21.22.86:9000
        - 172.21.22.86:9001
        - 172.21.22.83:9000
        - 172.21.22.83:9001
Both redis in 172.21.22.22 are slave , when there is  one key in 9000‘redis and  one key in 9001`redis,   failed to get key in 9000'redis by RedisTemplate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Chinese wiki page you mentioned RXAResource class but I couldn't find in source code. Where can I find it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using:

redisson 3.14.1
hibernate 5.4.12

codec: SnappyCodec
When I try to put query data to Redis I receive an error
Caused by: java.lang.IllegalArgumentException: java.io.NotSerializableException: org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl at org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:727) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.RedissonObject.encodeMapKey(RedissonObject.java:297) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.RedissonMapCache.getOperationAsync(RedissonMapCache.java:524) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.RedissonMap.getAsync(RedissonMap.java:1072) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.RedissonMap.get(RedissonMap.java:618) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.hibernate.RedissonStorage.getFromCache(RedissonStorage.java:102) ~[redisson-hibernate-53-3.14.1.jar:3.14.1] ... 136 common frames omitted Caused by: java.io.NotSerializableException: org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:274) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1080) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1080) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.BlockMarshaller.doWriteObject(BlockMarshaller.java:65) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.BlockMarshaller.writeObject(BlockMarshaller.java:56) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.MarshallerObjectOutputStream.writeObjectOverride(MarshallerObjectOutputStream.java:50) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverObjectOutputStream.writeObjectOverride(RiverObjectOutputStream.java:179) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:344) ~[na:1.8.0_191] at java.util.HashMap.internalWriteEntries(HashMap.java:1790) ~[na:1.8.0_191] at java.util.HashMap.writeObject(HashMap.java:1363) ~[na:1.8.0_191] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_191] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_191] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_191] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_191] at org.jboss.marshalling.reflect.JDKSpecific$SerMethods.callWriteObject(JDKSpecific.java:163) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.reflect.SerializableClass.callWriteObject(SerializableClass.java:193) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1089) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteFields(RiverMarshaller.java:1143) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteSerializableObject(RiverMarshaller.java:1101) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:268) ~[jboss-marshalling-river-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.AbstractObjectOutput.writeObject(AbstractObjectOutput.java:58) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final] at org.jboss.marshalling.AbstractMarshaller.writeObject(AbstractMarshaller.java:111) ~[jboss-marshalling-2.0.10.Final.jar:2.0.10.Final] at org.redisson.codec.MarshallingCodec$4.encode(MarshallingCodec.java:170) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.codec.SnappyCodec$4.encode(SnappyCodec.java:96) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:725) ~[redisson-3.14.1.jar:3.14.1] ... 141 common frames omitted Caused by: org.jboss.marshalling.TraceInformation: null
Then I try to change the codec to Kryo5Codec
Caused by: com.esotericsoftware.kryo.KryoException: Class cannot be created (missing no-arg constructor): org.hibernate.cache.internal.QueryResultsCacheImpl$CacheItem at com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy.newInstantiatorOf(DefaultInstantiatorStrategy.java:114) ~[kryo-5.0.3.jar:na] at com.esotericsoftware.kryo.Kryo.newInstantiator(Kryo.java:1119) ~[kryo-5.0.3.jar:na] at com.esotericsoftware.kryo.Kryo.newInstance(Kryo.java:1128) ~[kryo-5.0.3.jar:na] at com.esotericsoftware.kryo.serializers.FieldSerializer.create(FieldSerializer.java:153) ~[kryo-5.0.3.jar:na] at com.esotericsoftware.kryo.serializers.FieldSerializer.read(FieldSerializer.java:118) ~[kryo-5.0.3.jar:na] at com.esotericsoftware.kryo.Kryo.readClassAndObject(Kryo.java:813) ~[kryo-5.0.3.jar:na] at org.redisson.codec.Kryo5Codec$4.decode(Kryo5Codec.java:95) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1] at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1] at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final] at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final] at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.45.Final.jar:4.1.45.Final] at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.45.Final.jar:4.1.45.Final] ... 1 common frames omitted
What am I doing wrong?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3333
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
in version 3.14.1 sentinel mode
配置了三个哨兵 10.6.193.52:6500,10.6.193.52:6501,10.6.193.52:6502
SentinelServersConfig useSentinelServers = config.useSentinelServers();
useSentinelServers.setMasterName(conf.getMasterName());
useSentinelServers.setPassword(conf.getRedisPassword());
用
useSentinelServers.addSentinelAddress循环加入，但是在 SentinelConnectionManager class 109 行
InetSocketAddress master = connection.sync(RedisCommands.SENTINEL_GET_MASTER_ADDR_BY_NAME, cfg.getMasterName());
返回 master 为 null，但是在利用redis的客户端是没问题的
127.0.0.1:6500> SENTINEL GET-MASTER-ADDR-BY-NAME mymaster

"10.6.193.52"
"6400"
127.0.0.1:6500>

不清楚是什么原因，怎么进行诊断？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One more question. I just tested out the redis server busy exception. But how to deal with other exceptions properly? Especially those unkown exceptions for which we should retry in watchdog logic ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3339
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
One more question. I just tested out the redis server busy exception. But how to deal with other exceptions properly? Especially those unkown exceptions for which we should retry in watchdog logic ...
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redis Cluster slave  reconnect or report error on startup after connect timeout
Actual behavior
Redis Cluster slave report "down"
Steps to reproduce or test case

Cluster slave connect timeout on startup

unable to add slave for: redis://xxxx:xxxx slot ranges: [[9832-13107]] org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 14 of 24 were initialized. Redis server: /xxxxxx:xxxx
 	at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:160)
        at org.redisson.misc.RedissonPromise.lambda$0(RedissonPromise.java:186)
 	at org.redisson.misc.RedissonPromise.lambda$onComplete$1(RedissonPromise.java:184)
 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)
 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
 	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
 	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
 	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:97)
 	at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:332)
 	at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:298)
 	at org.redisson.misc.RedissonPromise.lambda$0(RedissonPromise.java:186)
 	at org.redisson.misc.RedissonPromise.lambda$onComplete$1(RedissonPromise.java:184)
 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)
 	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)
 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)
 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)
 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)
 	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)
 	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
 	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:97)
 	at org.redisson.client.RedisClient$2$2.run(RedisClient.java:248)
 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497)
 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
  [1 skipped]
 Caused by: io.netty.channel.ConnectTimeoutException: connection timed out: /xxxxx:xxxx
 	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261) 
	at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98) 
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170) 
... 7 common frames omitted


cluster slave report error on every command

org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: /xxxxx:xxx Disconnected hosts: [/xxxx:xxx]
	at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:219)
	at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
	at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:253)
	at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:499)
	at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:575)
	at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:642)
	at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:114)
	at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:604)
	at org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:367)
	at org.redisson.RedissonBucket.getAsync(RedissonBucket.java:109)
	at org.redisson.RedissonBucket.get(RedissonBucket.java:104)

Redis version
4.0.12
Redisson version
3.13.4
Redisson configuration
clusterServersConfig:
      idleConnectionTimeout: 10000
      connectTimeout: 100
      timeout: 200
      retryAttempts: 0
      retryInterval: 200
      failedSlaveReconnectionInterval: 1000
      failedSlaveCheckInterval: 1000
      subscriptionsPerConnection: 5
      slaveSubscriptionConnectionMinimumIdleSize: 1
      slaveSubscriptionConnectionPoolSize: 50
      slaveConnectionMinimumIdleSize: 32
      slaveConnectionPoolSize: 64
      masterConnectionMinimumIdleSize: 32
      masterConnectionPoolSize: 64
      readMode: "SLAVE"
      nodeAddresses:
        - "redis://xxxxx:7004"
        - "redis://xxxxx:7001"
        - "redis://xxxxx:7000"
      scanInterval: 1000
      keepAlive: true
      tcpNoDelay: true

Please See: https://github.com/redisson/redisson/blob/redisson-3.13.4/redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java#L319
                future.onComplete((r, ex) -> {
                            if (ex != null) {
                                log.error("unable to add slave for: " + partition.getMasterAddress()
                                                + " slot ranges: " + partition.getSlotRanges(), ex);
                            }
               }
Maybe set result in failure is a solution
                future.onComplete((r, ex) -> {
                            if (ex != null) {
                                log.error("unable to add slave for: " + partition.getMasterAddress()
                                                + " slot ranges: " + partition.getSlotRanges(), ex);
                                // set result in failure
                                result.tryFailure(ex);
                            }
               }
cc/ @mrniko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3341
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
flags field that “sentinel slaves xxx” command result contains “s_down” or “disconnected”, manager will freezed the node,
but master-link-status than “sentinel slaves xxx” command result is “err”, slave node is in “LOADING Redis is loading the dataset in memory” status, why not add this condition in slave node state check? just like
String ip = map.get("ip");
String port = map.get("port");
String flags = map.get("flags");
String masterHost = map.get("master-host");
String masterPort = map.get("master-port");
String masterLinkStatus = map.get("master-link-status");

RedisURI slaveAddr = toURI(ip, port);
if (flags.contains("s_down") || flags.contains("disconnected") || masterLinkStatus.contains("err")) {
    slaveDown(slaveAddr);
    continue;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis集群某节点发生主备切换后，开始报以下错误
error.log中报
org.redisson.client.RedisNodeNotFoundException: Node for slot: 1888 hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increase value of retryAttempts and/or retryInterval settings.
at org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:578)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:562)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:648)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:244)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
info.log中报（几分钟会报一次）
2021-01-15 11:19:16,155 [redisson-netty-5-5] INFO  o.r.cluster.ClusterConnectionManager.shutdownEntry(ClusterConnectionManager.java:254) - /172.28.9.49:9004 master and related slaves: [addr=redis://172.28.9.48:9001] removed
2021-01-15 11:19:16,155 [redisson-netty-5-5] INFO  o.r.cluster.ClusterConnectionManager.checkSlotsMigration(ClusterConnectionManager.java:701) - 5461 slots removed from redis://172.28.9.49:9004
2021-01-15 11:19:16,677 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver.getClusterEndpoints(ConfigClusterResolver.java:43) - Resolving eureka endpoints via configuration
2021-01-15 11:19:46,256 [redisson-netty-5-3] INFO  o.r.c.p.MasterPubSubConnectionPool.lambda$run$0(ConnectionPool.java:167) - 1 connections initialized for /172.28.9.49:9004
2021-01-15 11:19:46,264 [redisson-netty-5-6] INFO  o.r.c.pool.MasterConnectionPool.lambda$run$0(ConnectionPool.java:167) - 24 connections initialized for /172.28.9.49:9004
2021-01-15 11:19:46,267 [redisson-netty-5-26] INFO  o.r.c.pool.PubSubConnectionPool.lambda$run$0(ConnectionPool.java:167) - 1 connections initialized for /172.28.9.48:9001
2021-01-15 11:19:46,290 [redisson-netty-5-16] INFO  o.r.cluster.ClusterConnectionManager.lambda$null$5(ClusterConnectionManager.java:325) - slaves: [redis://172.28.9.48:9001] added for slot ranges: [[0-5460]]
2021-01-15 11:19:46,291 [redisson-netty-5-16] INFO  o.r.cluster.ClusterConnectionManager.lambda$null$5(ClusterConnectionManager.java:332) - master: redis://172.28.9.49:9004 added for slot ranges: [[0-5460]]
2021-01-15 11:19:46,291 [redisson-netty-5-16] INFO  o.r.c.pool.SlaveConnectionPool.lambda$run$0(ConnectionPool.java:167) - 100 connections initialized for /172.28.9.48:9001
2021-01-15 11:19:51,317 [redisson-netty-5-5] INFO  o.r.cluster.ClusterConnectionManager.shutdownEntry(ClusterConnectionManager.java:254) - /172.28.9.49:9004 master and related slaves: [addr=redis://172.28.9.48:9001] removed
2021-01-15 11:19:51,318 [redisson-netty-5-5] INFO  o.r.cluster.ClusterConnectionManager.checkSlotsMigration(ClusterConnectionManager.java:701) - 5461 slots removed from redis://172.28.9.49:9004
2021-01-15 11:19:56,326 [redisson-netty-5-4] INFO  o.r.c.p.MasterPubSubConnectionPool.lambda$run$0(ConnectionPool.java:167) - 1 connections initialized for /172.28.9.49:9004
2021-01-15 11:19:56,334 [redisson-netty-5-7] INFO  o.r.c.pool.MasterConnectionPool.lambda$run$0(ConnectionPool.java:167) - 24 connections initialized for /172.28.9.49:9004
2021-01-15 11:19:56,338 [redisson-netty-5-3] INFO  o.r.c.pool.PubSubConnectionPool.lambda$run$0(ConnectionPool.java:167) - 1 connections initialized for /172.28.9.48:9001
2021-01-15 11:19:56,365 [redisson-netty-5-17] INFO  o.r.cluster.ClusterConnectionManager.lambda$null$5(ClusterConnectionManager.java:325) - slaves: [redis://172.28.9.48:9001] added for slot ranges: [[0-5460]]
2021-01-15 11:19:56,367 [redisson-netty-5-17] INFO  o.r.cluster.ClusterConnectionManager.lambda$null$5(ClusterConnectionManager.java:332) - master: redis://172.28.9.49:9004 added for slot ranges: [[0-5460]]
2021-01-15 11:19:56,367 [redisson-netty-5-17] INFO  o.r.c.pool.SlaveConnectionPool.lambda$run$0(ConnectionPool.java:167) - 100 connections initialized for /172.28.9.48:9001
redis集群信息CLUSTER NODES如下
CLUSTER NODES
d167ab629fd9e804b7b94d250b60634239899a77 172.28.9.48:9002@19002 myself,slave 3aa09cb227f90313f452c399c015767e2735dc19 0 1610699693000 2 connected
496cff30335016523fc8af38b3d2a64608e65afc 172.28.9.49:9003@19003 master - 0 1610699694293 3 connected 5461-10922
ef77423d42bde0d88f123f6bfdd235138b4ba864 172.28.9.48:9001@19001 slave b301296b5218c22332f77b1da719e5bb985170c2 0 1610699694000 9 connected
b301296b5218c22332f77b1da719e5bb985170c2 172.28.9.49:9004@19004 master - 0 1610699695295 9 connected 0-5460
eadbd9cc11b85bcf289b8a5963a99dcfff4b292a 172.28.9.50:9006@19006 slave 496cff30335016523fc8af38b3d2a64608e65afc 0 1610699693285 3 connected
3aa09cb227f90313f452c399c015767e2735dc19 172.28.9.50:9005@19005 master - 0 1610699696298 5 connected 10923-16383
Steps to reproduce or test case
网络波动时，某节点发生主备切换，才报以上错误，后续在redis安装的linux 中 ps -ef|grep redis 命令查看 实际redis服务所有节点都在运行，实际没有宕机
后续我将Redisson版本降至3.13.6后，没有报错，恢复正常
Redisson版本在3.10.6也不会报错
Redis version
4.0.14
Redisson version
3.14.1
Redisson configuration
	String redissonNodes = "172.28.9.48:9001,172.28.9.48:9002,172.28.9.49:9003,172.28.9.49:9004,172.28.9.50:9005,172.28.9.50:9006";
	String redissonPassword = "";
	Integer masterConnectionPoolSize = 200;
	Integer slaveConnectionPoolSize = 400;
	Integer slaveConnectionMinimumIdleSize = 100;
	Integer connectTimeout = 10000;
	Integer timeout = 10000;
	
	String[] hosts = redissonNodes.split(",");
	List<String> nodeList = new ArrayList<String>();
	for (String node : hosts) {
		nodeList.add("redis://" + node);
	}
	Config config = new Config();
	config.setCodec(new org.redisson.client.codec.StringCodec());
	ClusterServersConfig clusterServersConfig = config.useClusterServers().addNodeAddress(nodeList.toArray(new String[nodeList.size()]));
	if (redissonPassword != null && !"".equals(redissonPassword)) {
		clusterServersConfig.setPassword(redissonPassword);
	}
	clusterServersConfig.setMasterConnectionPoolSize(masterConnectionPoolSize);// 设置对于master节点的连接池中最大连接数
	clusterServersConfig.setSlaveConnectionPoolSize(slaveConnectionPoolSize);// 设置对于slave节点的连接池中最大连接数
	clusterServersConfig.setSlaveConnectionMinimumIdleSize(slaveConnectionMinimumIdleSize);
	clusterServersConfig.setConnectTimeout(connectTimeout);
	clusterServersConfig.setTimeout(timeout);
	return Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
env info：
jdk：1.8
redis：5.0.6
redission: 3.11.5
There are two data processing services here. When I use MapReduce to process data, the timeout (30 s) is set. However, when one of the services in the process of reducing data goes down unexpectedly, there is still no response from the map after the timeout, Does the data processed by the down service need to be reallocated to other machines? What is the specific meaning of this timeout? Is there something wrong with my use?
The following pictures are related information:
This is the normal data processing service:

This is a service that has been down unexpectedly:

This is the configuration code information:

This is the now time:

@mrniko   thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3348
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using RMapCache<String,Object> with map option with write mode as WRITE_BEHIND
now when i put something in cache after particular delay it is getting executed after dealy provided,
but what i need is map writer should pick entry from map unless it is cache but it is not doing so it is only getting executed once.
Can anyone help what can i do in this case or there is any alternative?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson 3.14 - Redis Cluster with cluster-require-full-coverage=no throwing NPE
I believe the NullPointerException happens because the slot is not allocated.  "MasterSlaveEntry msEntry = getEntry(source);"
returns null, and then get() is called with a null parameter, which is not allowed by the ConcurrentHashMap
Entry entry = commands.get(msEntry);
java.lang.NullPointerException
at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:947)
at org.redisson.command.BaseRedisBatchExecutor.addBatchCommandData(BaseRedisBatchExecutor.java:72)
at org.redisson.command.RedisBatchExecutor.execute(RedisBatchExecutor.java:53)
at org.redisson.command.CommandBatchService.async(CommandBatchService.java:144)
at org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:367)
at org.redisson.RedissonMap.getAllOperationAsync(RedissonMap.java:260)
at org.redisson.RedissonMap.getAllAsync(RedissonMap.java:226)

Could this be updated to return a Redisson exception?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior

org.redisson.client.RedisException: Unexpected exception while processing command

	at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:351)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:148)
	at org.redisson.RedissonScript.eval(RedissonScript.java:229)
	at org.redisson.RedissonScript.eval(RedissonScript.java:85)
	at com.github.**.redis.**.next(RedisUnifiedIdExtension.java:88)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53)
Caused by: java.io.IOException: Unsupported protocol version 51
	at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1360)
	at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:150)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:86)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:648)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:583)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:500)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:462)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)


Steps to reproduce or test case

lua

local array = {};
array[1]= redis.call('GET',KEYS[1]);
array[2]= redis.call('INCRBY', KEYS[1], 1);
return array;


java

        Object obj = script.eval(RScript.Mode.READ_WRITE, SCRIPT_AND_GET_BATCH, RScript.ReturnType.VALUE, keys,
                size);



Redis version
# Server
redis_version:6.0.9
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:ff6bfe6a96f5bb05
redis_mode:standalone
os:Linux 3.10.0-1062.12.1.el7.x86_64 x86_64

Redisson version
3.14.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
redis cluster master down one by one.After a period of time, restart master node, redisson client can't update cluster state
Actual behavior
redisson can't write command to master, and report error.
Steps to reproduce or test case
It doesn't have to happen
1.test case
3 master and 3 slave

master 1 down and wait slave 1 become master
master 2 down and wait slave 2 become master
master 3 down and wait slave 3 become master
restart all master and There's a certain probability

2.redisson can't update cluster state exception
WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=9394, addr=null, redisClient=null, redirect=null, entry=null], connection:
	at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:271) ~[redisson-3.14.0.jar:3.14.0]
	at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:58) ~[redisson-3.14.0.jar:3.14.0]
	at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:156) ~[redisson-3.14.0.jar:3.14.0]
	at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:153) ~[redisson-3.14.0.jar:3.14.0]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1009) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:870) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.54.Final.jar:4.1.54.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]
Caused by: io.netty.channel.StacklessClosedChannelException
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[netty-transport-4.1.54.Final.jar:4.1.54.Final]
3. a redisson-netty thread is runnable and recursion all the time
"redisson-netty-2-19" #31 prio=5 os_prio=0 tid=0x00007fac4c03c800 nid=0x4cd5 runnable [0x00007fac9c511000]
   java.lang.Thread.State: RUNNABLE
	at java.lang.Throwable.fillInStackTrace(Native Method)
	at java.lang.Throwable.fillInStackTrace(Throwable.java:783)
	- locked <0x00000000fbf21860> (a org.redisson.client.RedisConnectionException)
	at java.lang.Throwable.<init>(Throwable.java:265)
	at java.lang.Exception.<init>(Exception.java:66)
	at java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.redisson.client.RedisException.<init>(RedisException.java:35)
	at org.redisson.client.RedisConnectionException.<init>(RedisConnectionException.java:28)
	at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218)
	at org.redisson.connection.pool.PubSubConnectionPool.get(PubSubConnectionPool.java:32)
	at org.redisson.connection.pool.PubSubConnectionPool.get(PubSubConnectionPool.java:39)
	at org.redisson.connection.balancer.LoadBalancerManager.nextPubSubConnection(LoadBalancerManager.java:204)
	at org.redisson.connection.MasterSlaveEntry.nextPubSubConnection(MasterSlaveEntry.java:519)
	at org.redisson.pubsub.PublishSubscribeService.nextPubSubConnection(PublishSubscribeService.java:267)
	at org.redisson.pubsub.PublishSubscribeService.connect(PublishSubscribeService.java:273)
	at org.redisson.pubsub.PublishSubscribeService.access$200(PublishSubscribeService.java:55)
	at org.redisson.pubsub.PublishSubscribeService$1.run(PublishSubscribeService.java:164)
	at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)
	at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:150)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$0(PublishSubscribeService.java:127)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$68/1506703662.run(Unknown Source)
	at org.redisson.pubsub.AsyncSemaphore.tryRun(AsyncSemaphore.java:86)
	at org.redisson.pubsub.AsyncSemaphore.acquire(AsyncSemaphore.java:66)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:121)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:115)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:575)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
	at io.netty.util.concurrent.DefaultPromise.access$200(DefaultPromise.java:35)
	at io.netty.util.concurrent.DefaultPromise$1.run(DefaultPromise.java:502)
	at io.netty.util.concurrent.ImmediateEventExecutor.execute(ImmediateEventExecutor.java:118)
	at io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:842)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$subscribe$8(PublishSubscribeService.java:578)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$108/720202126.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.addListener(DefaultPromise.java:184)
	at org.redisson.misc.RedissonPromise.onComplete(RedissonPromise.java:181)
	at org.redisson.pubsub.PublishSubscribeService.subscribe(PublishSubscribeService.java:576)
	at org.redisson.pubsub.PublishSubscribeService.lambda$reattachPubSubListeners$7(PublishSubscribeService.java:568)
	at org.redisson.pubsub.PublishSubscribeService$$Lambda$107/1175549604.accept(Unknown Source)
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
	at org.redisson.misc.RedissonPromise$$Lambda$2/1011276990.operationComplete(Unknown Source)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
	at org.redisson.pubsub.PublishSubscribeService$5$1$1.onStatus(PublishSubscribeService.java:430)
	at org.redisson.pubsub.PubSubConnectionEntry$1.onStatus(PubSubConnectionEntry.java:187)
	at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:72)
	at org.redisson.client.RedisPubSubConnection$1.operationComplete(RedisPubSubConnection.java:116)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1009)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:870)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)
	at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(Redefined)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(Redefined)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:745)
4.Redis version
6.0.9
5.Redisson version
3.14.1
6.Redisson configuration
clusterServersConfig:
  idleConnectionTimeout: 60000
  connectTimeout: 10000
  timeout: 60000
  retryAttempts: 3
  retryInterval: 3000
  failedSlaveReconnectionInterval: 3000
  failedSlaveCheckInterval: 60000
  password: "xuanwu-T3st*17"
  subscriptionsPerConnection: 5
  clientName: null
  loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 4
  slaveConnectionMinimumIdleSize: 16
  slaveConnectionPoolSize: 64
  masterConnectionMinimumIdleSize: 16
  masterConnectionPoolSize: 64
  readMode: "MASTER_SLAVE"
  subscriptionMode: "SLAVE"
  nodeAddresses:
    - "redis://172.16.0.114:8001"
    - "redis://172.16.0.114:8002"
    - "redis://172.16.0.114:8003"
    - "redis://172.16.0.115:8001"
    - "redis://172.16.0.115:8002"
    - "redis://172.16.0.115:8003"
  scanInterval: 2000
  pingConnectionInterval: 5000
  keepAlive: true
  tcpNoDelay: true
codec: !<org.redisson.codec.JsonJacksonCodec> {}
transportMode: "NIO"
useScriptCache: true
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Got this exception continuously for a minute and then became fine. Would like to know what is the root cause of this.
Using Redisson : 3.13.2
org.redisson.client.RedisTimeoutException: Command still hasn’t been written into connection!
Increase nettyThreads and/or retryInterval settings.
Payload size in bytes: 0. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry
[masterEntry=[freeSubscribeConnectionsAmount=4, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=33,
freeConnectionsCounter=value:62:queue:0, freezed=false,
freezeReason=null, client=[addr=], nodeType=MASTER,
firstFail=0]]], connection: RedisConnection@145638153
[redisClient=[addr=], channel=[id: 0x20213438,
L:/10.20.13.18:45856 - R:*****], currentCommand=null],
command: null, params: null after 3 retry attempts
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson-all-3.12.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use version redisson-all-3.12.1
Data abnormal under high concurrency
normal data
"roleId2": "ROLEINFO#7001#21693#4002#4",
Fault data
"roleId2": "com.game.logical.role.beans.OtherHeroBean@5300e72",
"roleId2": [10006,10001,10007,12001],
"roleId2": [],
All of the places we assign are strings
Under what circumstances does this happen to the data or is it a bug that has been fixed? If so, in what version did you change those things
我们有个数据是string  所有赋值的地方也是string  数据会莫名其妙变成对象 不知道是写的问题还是读的问题  取出错误数据后使用会造成jvm宕机 不是必现 有概率出现
什么情况下数据会出现这种情况  还是这是个bug 已经修复  如果已经修复 是在哪个版本 修改了那些东西
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to implement query the message that exists in the RDelayQueue, and remove if it exists function.
The message DelayEvent is
`
@DaTa
@builder
@NoArgsConstructor
@AllArgsConstructor
@accessors(chain = true)
@EqualsAndHashCode(of = {"id"})
public class DelayEvent implements Serializable {
/**
 * PkId
 */
private String id;

/**
 * DelayEventEnum
 */
private E eventType;

}
`
The value is ture about this TestCase:
`
@SneakyThrows
@Test
public void isContain() {

    DelayEvent<DelayEventEnum> delayEvent = new DelayEvent<>();
    delayEvent.setId("123");
    delayEvent.setEventType(DelayEventEnum.CNFC_CLEAR_EVENT);

    redissonMessageTemplate.sendWithDelay("testQ", delayEvent, 600000);

    DelayEvent<DelayEventEnum> delayEventAlready = new DelayEvent<>();
    delayEventAlready.setId("123");
    delayEventAlready.setEventType(DelayEventEnum.CNFC_CLEAR_EVENT);
    boolean isContain = redissonMessageTemplate.valExists("testQ", delayEventAlready);
    Assert.assertTrue(isContain);  //true
}

`
The value is false about TestCase in the below:
`
@SneakyThrows
@Test
public void isContain() {

    DelayEvent<DelayEventEnum> delayEvent = new DelayEvent<>();
    delayEvent.setId("123");
    delayEvent.setEventType(DelayEventEnum.CNFC_CLEAR_EVENT);

    redissonMessageTemplate.sendWithDelay("testQ", delayEvent, 600000);

    DelayEvent<DelayEventEnum> delayEventAlready = new DelayEvent<>();
    delayEventAlready.setId("123");
    boolean isContain = redissonMessageTemplate.valExists("testQ", delayEventAlready);
    Assert.assertTrue(isContain); //false
}

`
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, I used redisson-tomcat-7 in my project.
Everything is ok.
and I tested how to works when redis down. Tomcat returned 500 Error.
org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1177986280 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x015ae5b0, L:0.0.0.0/0.0.0.0:58778], currentCommand=null], command: (HSET), params: [xxxxxx:redisson:tomcat_session:17BE13F676058A28AEBA5A80A5D29AF4.xxxxxx11, PooledUnsafeDirectByteBuf(ridx: 0, widx: 24, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 32, cap: 256)] after 3 retry attempts
        at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:271)
        at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:58)
        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:156)
        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:153)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1009)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:870)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)
        at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)
        at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.channel.StacklessClosedChannelException
        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)

My question is

Have a Bypass Mode? when redis down.(Use Local stored sessions)
If exist, Let me know how to use Bypass Mode.

Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can RLocalCachedMap be used with Broadcast mode tracking?
In Redis CLI we would enable this as "CLIENT TRACKING on REDIRECT 10 BCAST PREFIX"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson version
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.14.0</version>
</dependency>
config
@Bean
RedisMessageListenerContainer container(RedisConnectionFactory redisConnectionFactory) {
    RedisMessageListenerContainer container = new RedisMessageListenerContainer();
    container.setConnectionFactory(redisConnectionFactory);

    container.addMessageListener(new MyListener(), new PatternTopic("__keyspace@0__:mykey"));
    container.addMessageListener(new MyListener(), new PatternTopic("__keyevent@0__:del"));
    return container;
}

static class MyListener implements MessageListener {
    @Override
    public void onMessage(Message message, byte[] pattern) {
        printMsg("my custom", message);
    }
}

public static void printMsg(String prefix, Message message) {
    System.out.println(prefix + " -> body: " + new String(message.getBody()));
    System.out.println(prefix + " -> channel: " + new String(message.getChannel()));
}
test
@Test
public void test02(){
    redisTemplate.opsForValue().set("mykey", "2");
    redisTemplate.delete("mykey");
    String next = new Scanner(System.in).next();
}
When not using reidsson
my listener -> body: set;  channel: __keyspace@0__:mykey
my listener -> body: del;  channel: __keyspace@0__:mykey
my listener -> body: mykey;  channel: __keyevent@0__:del

use redisson

How can I get the same result as above?

my listener -> body: set;  channel: __keyspace@0__:mykey
my listener -> body: set;  channel: __keyspace@0__:mykey
my listener -> body: del;  channel: __keyspace@0__:mykey
my listener -> body: mykey;  channel: __keyevent@0__:del
my listener -> body: mykey;  channel: __keyevent@0__:del
my listener -> body: del;  channel: __keyspace@0__:mykey
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson should not exhaust the connection pool. In other words, it should release connections after every successful command.
And even if the pool is exhausted that should not make Redisson freeze completely until restarted I guess.
Actual behavior
We have experienced this error in production and now I have managed to reproduce the error with a clean Spring Boot project and one endpoint that executes a lua script on a redis cluster. I am using Locust (locust.io) for load testing.
More on how to reproduce the error later.
The screenshot shows an example Locust load test result: the first couple minutes are fine, I get around 1000 req per second and no errors.
But then requests start to fail and response times go up to ~6 seconds. Sometimes it takes around 5 minutes as the test is a bit random.
This is the log for one of those failed requests:
2021-01-21 10:41:17.497 ERROR 11426 --- [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], command: (EVAL), params: [local count
local ttl
count = redis.call("incr",KEYS[1])
ttl = redis.call("ttl",KEYS[1])
if tonumber..., 1, RATE_LIMIT_222.111.0.24, PooledUnsafeDirectByteBuf(ridx: 0, widx: 2, cap: 256)] after 0 retry attempts] with root cause

org.redisson.client.RedisTimeoutException: Unable to acquire connection! Increase connection pool size and/or retryInterval settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], command: (EVAL), params: [local count
local ttl
count = redis.call("incr",KEYS[1])
ttl = redis.call("ttl",KEYS[1])
if tonumber..., 1, RATE_LIMIT_222.111.0.24, PooledUnsafeDirectByteBuf(ridx: 0, widx: 2, cap: 256)] after 0 retry attempts
	at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:181) ~[redisson-3.14.1.jar:3.14.1]
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-common-4.1.58.Final.jar:4.1.58.Final]
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-common-4.1.58.Final.jar:4.1.58.Final]
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-common-4.1.58.Final.jar:4.1.58.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.58.Final.jar:4.1.58.Final]
	at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]

Once this happens, even if you stop the test, Redisson no longer recovers. All requests fail after 6 seconds and you have to restart the server for it to work again.
By the way, those 6 seconds seem to be related to retryAttempts and retryInterval settings, but even if I set retryAttempts to zero, it still takes 1.5 seconds for each request to fail. Why?
Anyways, the main problem is that it fails.
Steps to reproduce or test case
I have created a clean spring boot project with one endpoint that executes a lua script. The script is basically rate limiting:
local count
local ttl
count = redis.call("incr",KEYS[1])
ttl = redis.call("ttl",KEYS[1])
if tonumber(ttl) == -1 then
    redis.call("expire",KEYS[1],ARGV[1])
end
return count

The endpoint just takes the IP of the request (from a "True-client-ip" header) and executes the script with it, returning the IP and the number of requests made so far this minute so you can see if it is working or not.
And the test makes a bunch of requests to this endpoint, faking the True-client-ip header with 50 different IPs in an attempt to simulate a realistic environment.
So, how to test:
demo.zip

Download and extract the demo project
Change RedissonConfiguration to connect to a redis cluster. Ours has 3 master and 3 slaves.
Start the server and see if localhost:8080/redisson works on your browser.
Start Locust with locust -f demo.py from the root project directory (you will need to install locust with pip3 install locust)
Open Locust UI on your browser (localhost:8089) and enter the following parameters:
20 users, 5 spawn rate, http://localhost:8080
Wait a couple minutes for the server to explode (hopefully)

Redis version
Redis server v=4.0.6
Redisson version
3.14.1
Redisson configuration
Nothing fancy:
clusterConfig.setMasterConnectionPoolSize(100);
clusterConfig.setSlaveConnectionPoolSize(64);
[and the redis cluster nodes]

And those numbers probably are not even important, but now that I have managed to reproduce the error I don't want to change them.
Check RedissonConfiguration for the details.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
It's not an issue, it's a question I have not found an answer to in documentation.
Will tasks that were submitted via redisson ExecutorService be executed if redis instance is restarted?
For example, a task is submitted with a delay 10mins and right after it was submitted, redis is restarted. What will happen with that submitted task?
What if I have AWS ElastiCache with Redis Replication Group and Multi-AZ enabled - will that task be executed if it was successfully replicated to read instances and primary instance failed?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello everybody,
I try to use Redisson  as second level cache in my jpa spring boot application it works fine i see that it cache entities in redis it just i need to set a time to live and time to idle on cache entries i use this configuration below but it doesn't work:
`spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.cache.type=redis
hibernate.cache.redisson.entity.expiration.time_to_live=1000
hibernate.cache.redisson.entity.expiration.max_idle_time=1000
hibernate.cache.redisson.collection.expiration.time_to_live=1000
hibernate.cache.redisson.collection.expiration.max_idle_time=1000
spring.jpa.properties.hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory
spring.jpa.properties.hibernate.cache.redisson.config=redisson/redisson-dev.yaml
spring.jpa.properties.hibernate.cache.redisson.fallback=true
spring.jpa.properties.javax.persistence.sharedCache.mode=ENABLE_SELECTIVE
server.port=8888
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-plateform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.h2.console.enabled=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
`
i use  redisson-hibernate-53  as dependancy
Any help on this will help ,thank you.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3384
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3392
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3409
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3420
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3426
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3427
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3428
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3432
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3433
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3439
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I thought the xxxRx and xxx datastructures were equivalent in terms of functionality. I use a RMapCacheRx in my application and want to be notified on Entry expiration of the entries in that RMapCacheRx. With a regular RMapCache there is an addListener(listener: MapEntryListener) method, however on the RMapCacheRx there is only addListener(listener: ObjectListener) which only notifies me when the RMapCacheRx itself expires.
I tried making a non-rx client and getting the RMapCache with the same name to add the listener but then I get these errrors:
08:29:38.647 ERROR o.r.c.handler.ErrorsLoggingHandler - Exception occured. Channel: [id: 0x0017c2ae, L:/10.244.1.122:44632 - R:redis-master.redis/10.108.147.24:6379]                                                                                                        
││ io.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 34                                                                                                                                                                                
││     at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)                                                                                                                                                                                         
││     at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)                                                                                                                                                                                
││     at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)                                                                                                                                                              
││     at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)                                                                                                                                                              
││     at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)                                                                                                                                                                
││     at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)                                                                                                                                                                     
││     at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)                                                                                                                                                              
││     at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)                                                                                                                                                              
││     at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)                                                                                                                                                                              
││     at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)                                                                                                                                                                       
││     at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)                                                                                                                                                                                           
││     at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)                                                                                                                                                                                 
││     at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)                                                                                                                                                                                          
││     at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)                                                                                                                                                                                                          
││     at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)                                                                                                                                                                          
││     at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)                                                                                                                                                                                             
││     at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)                                                                                                                                                                                 
││     at java.base/java.lang.Thread.run(Thread.java:832)                       
...

I use Redisson 3.13.6 (last version with RxJava 2 support) and Redis 6.0.8
Can anyone help me?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public void executorService(int index) {
    WorkerOptions options = WorkerOptions.defaults()
            .workers(5)
            .taskTimeout(10, TimeUnit.SECONDS);

    RScheduledExecutorService executorService = redissonClient.getExecutorService("index1" + index);
    executorService.registerWorkers(options);
    executorService.submit(new RunnableTask());
}


@Log4j2
public class RunnableTask implements Callable<Long>, Serializable {

    @Override
    public Long call() throws Exception {
        try {
            Thread.sleep(5000);
            log.info("hi");
            return 1L;
        } catch (InterruptedException e) {
            log.error("sleep InterruptedException", e);
            return -1L;
        }
    }
}

and i found it will consume 16 thread once instead of 5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
Redisson version
3.14.1
Redisson configuration
failedSlaveCheckInterval = 180000
in redisson sentinel model:
use chaosblade to inject network delay in to redis port,keep delay time more than failedSlaveCheckInterval,
when netword delay finish, slaveConnectionPool not reconnect to redis slave node, slaveConnectionPool‘s all ClientConnectionsEntry in to RECONNECT status and keep throw exception:
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: 192.168.17.50/192.168.17.50:6316 Disconnected hosts: [192.168.17.50/192.168.17.50:6316, 192.168.17.52/192.168.17.52:6316, 192.168.17.51/192.168.17.51:6316]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:267) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:500) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:572) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:648) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116) ~[redisson-3.14.1.jar!/:3.14.1]
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:244) ~[redisson-3.14.1.jar!/:3.14.1]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-common-4.1.54.Final.jar!/:4.1.54.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-common-4.1.54.Final.jar!/:4.1.54.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-common-4.1.54.Final.jar!/:4.1.54.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.54.Final.jar!/:4.1.54.Final]
at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_282]
it‘s a bug?or i can set any config to fix it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Spring boot app does not start as we dont have cache in test env.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Introduce new methods with ability to specify chained arguments:
search()
searchWithDistance()
searchWithPosition()
storeSearchTo()
storeSortedSearchTo()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3446
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3447
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Usage examples:
List objects = geo.search(GeoSearchArgs.from(15, 37)
                                         .box(200, 200, GeoUnit.KILOMETERS)
                                         .order(GeoOrder.ASC)
                                         .count(1)));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3448
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We started receiving the following error multiple times:

org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Avoid to use blocking commands in Async/JavaRx/Reactive handlers. Try to increase nettyThreads setting. Payload size in bytes: 2832. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1079734857 [redisClient=[addr=redis://redis-x.x.svc.cluster.local:6379], channel=[id: 0xb44bed84, L:/100.67.6.118:34388 - R:rx.svc.cluster.local/172.30.155.10:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@2752e551(failure: java.util.concurrent.CancellationException)], command=(PEXPIRE), params=[SUFFIX/d376fe68-4cdf-4fd8-9528-10fae39c695a, 345600000], codec=org.redisson.client.codec.StringCodec]], command: (SET), params: [SUFFIX/40f09edc-7c11-4b5c-a8c3-99c7db33721d, PooledUnsafeDirectByteBuf(ridx: 0, widx: 2832, cap: 4096)] after 3 retry attempts

We do not use the async API. We got the same error for successive commands.
    String redisKey = createKey(cache, key);
    RBucket<Object> bucket = client.getBucket(redisKey);
    bucket.set(value);
    // It's crucial that set comes before expire, otherwise it will not work
    boolean success = bucket.expire(cache.getRetentionInDays(), TimeUnit.DAYS);

Isn't this API blocking and how can we avoid such exceptions?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version：3.15.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exception：


Command still hasn't been written into connection! Avoid to use blocking commands in Async/JavaRx/Reactive handlers. Try to increase nettyThreads setting. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1499434010 [redisClient=[addr=redis://IP:6379], channel=[id: 0xc449f4ae, L:/172.27.0.11:49048 - R:/IP:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@41262085(failure: java.util.concurrent.CancellationException)], command=(EVAL), params=[local rate = redis.call('hget', KEYS[1], 'rate');local interval = redis.call('hget', KEYS[1], 'inter..., 5, KEY, {KEY}:value, {KEY}:value:859ba508-aed6-4344-bd08-ba742535e81b, {KEY}:permits, {KEY}:permits:859ba508-aed6-4344-bd08-ba742535e81b, 1, 1614912037969, 15411819857297036], codec=org.redisson.client.codec.LongCodec]], command: (EVAL), params: [redis.call('hsetnx', KEYS[1], 'rate', ARGV[1]);redis.call('hsetnx', KEYS[1], 'interval', ARGV[2]);re..., 1, KEY, 30, 1000, 0] after 3 retry attempts


Caused By these codes:


RRateLimiter rateLimiter = redisson.getRateLimiter(XXX);
rateLimiter.trySetRate(RateType.OVERALL, rate, rateInterval, RateIntervalUnit.MILLISECONDS);
rateLimiter.tryAcquire();
rateLimiter.expireAsync(rateInterval * 2, TimeUnit.MILLISECONDS);

Redisson Version: 3.15.0. And I don't think it occurred in previous version
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
if failed no Attempts
Actual behavior
create redis connect error.
error mesage :Unable to init enough connections amount! Only " + 0 + " from " + 10 + " were initialized
when I read code I found maybe problem appear at org.redisson.connection.pool.ConnectionPool#tryAcquireConnection method.
this compare statement  entry.getFailedAttempts() < config.getFailedAttempts() is always true , so connect cannot create success.
Steps to reproduce or test case
Redis version
redis-client version is 1.2.2.15-RELEASE
Redisson version
3.6.0
Redisson configuration
Config config = new Config();
           config.useSingleServer()
                   .setAddress(new StringBuilder().append("redis://").append(redisUrl).toString())
                   .setFailedAttempts(1)
                   .setConnectTimeout(300)
                   .setRetryAttempts(0)
                   .setTimeout(500);

redisson = (Redisson) Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RMapCache has eviction feature which can expire entries and has EntryExpiredListener to handle the expired entries.
RSetCache also has eviction feature to expires entries but don't have such a listener to handle the expired entries.
Is there any plan to support it or any difficulty to implement it?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3453
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
update to 3.15.1, run in sentinel model,throw
2021-03-05 18:12:58.612  ERROR 10479  --- "redisson-netty-2-17" "SentinelConnectionManager.java:322" "org.redisson.connection.SentinelConnectionManager" : "Can't update cluster state"##
org.redisson.client.RedisException: ERR unknown command 'AUTH'. channel: [id: 0xda3d7f5d, L:/192.168.12.114:54379 - R:/192.168.1.21:26379] command: (AUTH), params: (password masked)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:345) ~[redisson-3.15.1.jar:3.15.1]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177) ~[redisson-3.15.1.jar:3.15.1]
i trace the code,find in MasterSlaveConnectionManager.connectToNode() will createClient(NodeType.MASTER)
but in 3.14.1, MasterSlaveConnectionManager.connectToNode() method called by SentinelConnectionManager.checkState,will pass a RedisClient by createClient(NodeType.SENTINEL)
i think it's a bug
commit info is
5550249 [5550249]
父级：
42313ba
作者：
Nikita Koksharov nkoksharov@redisson.pro
日期：
2021年2月26日 GMT+8 15:34:49
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
After a few minutes of redis operation, the following problems will appear:
The remote host forced an existing connection to close.
Steps to reproduce or test case
Redis version
Redisson version
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.redisson</groupId>
            <!-- for Spring Data Redis v.2.3.x -->
            <artifactId>redisson-spring-data-23</artifactId>
        </dependency>
Redisson configuration
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
                .setAddress("redis://192.168.1.1:6379")
                .setPassword("123456");
        return Redisson.create(config);
    }

my redis config

spring:
  ### redis
  redis:
    host: 192.168.1.1
    database: 0
    port: 6379
    password: 123456
    # 连接超时时间
    timeout: 2000ms
    jedis:
      pool:
        # 最大连接数
        max-active: 2000
        # 最大阻塞等待时间(负数表示没限制)
        max-wait: 1000ms
        # 最大空闲
        max-idle: 8
        # 最小空闲
        min-idle: 5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3456
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
As far as I know, Redisson implements delayQueue through zset and list,zset will not add repeatedly for the same member
127.0.0.1:6379> zadd myzset  1 mykey
(integer) 1
127.0.0.1:6379> zadd myzset  2 mykey
(integer) 0
127.0.0.1:6379> zcard myzset
(integer) 1
Below is my code：
`import junit.framework.TestCase;
import org.junit.Test;
import org.redisson.Redisson;
import org.redisson.api.RBlockingQueue;
import org.redisson.api.RDelayedQueue;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.TimeUnit;
public class RedissonTest extends TestCase {
private RedissonClient redisson;


protected void init() {
    // connects to 127.0.0.1:6379 by default

//        RedissonClient redisson = Redisson.create();
    Config config = new Config();
    config.useSingleServer().setAddress("redis://localhost:6379");
    redisson = Redisson.create(config);
}


@Test
public void testDelayedQueue() throws InterruptedException {
    init();
    RBlockingQueue<String> distinationQueue = redisson.getBlockingQueue("redisson-blocking-test");
    RDelayedQueue<String> delayedQueue = redisson.getDelayedQueue(distinationQueue);
    // move object to distinationQueue in 10 seconds
    delayedQueue.offer("msg1", 13, TimeUnit.HOURS);
    // move object to distinationQueue in 1 minutes
    delayedQueue.offer("msg1", 40, TimeUnit.HOURS);
}

}`
but there has two elements:
127.0.0.1:6379> keys *

"myzset"
"redisson_delay_queue:{redisson-blocking-test}"
"redisson_delay_queue_timeout:{redission-blocking}"
"redission-blocking"
"redisson_delay_queue:{redisson-blocking}"
"redisson_delay_queue:{redission-blocking}"
"redisson_delay_queue_timeout:{redisson-blocking}"
"redisson_delay_queue_timeout:{redisson-blocking-test}"
127.0.0.1:6379> zcard redisson_delay_queue_timeout:{redisson-blocking-test}
(integer) 2
127.0.0.1:6379> ZRANGEBYSCORE redisson_delay_queue_timeout:{redisson-blocking-test} -inf +inf
"\x0e\xb2\xb6!F[\xd9C\a\x00\x00\x00\x00\x00\x00\x00\x04>\x04msg1"
"NH\xef\x7f\x16\xb8\xb2\xc3\a\x00\x00\x00\x00\x00\x00\x00\x04>\x04msg1"

how can i tell redisson they are same member
Thank you for help me!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Editing and repurposing this issue after finding the underlying cause. Originally this issue was to improve the error messaging. The underlying problem is a failure to reconnect after a failed DNS change. After this scenario plays out, there are no connections in the pool, and the error message we end up seeing is an ArrayIndexOutOfBoundsException
Expected behavior
Reconnection to redis node
Actual behavior
after DNS monitor detects a change to an ip it cant reach, subsequent dns change to a good ip does not restore connections.
Steps to reproduce or test case

connect to a single redis master node
add a host file entry for some bogus ip address,
watch redis connection failures
remove the bogus host file entry, so that DNS monitor gets the good ip address again
re connection does not happen

Redis version
azure cache for redis 4.0.14
Redisson version
3.14.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to set an upper limit on the number of elements that are kept in the local cache?  I don't see a way to do this and our TTLs are very long.  I don't see a way to clear the local cache ourselves either.  Containers like RLocalCachedMap have clearLocalCache(), but RSetMultimapCache does not.
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I try to use redisson(3.7.0) as my redis cluster client, and I need to change the connection address of redisson dynamically, in Spring environment, is there a simple way to do that? Does it need to consider the instance with old connection's recycle?
I tried to get the redisson instance directly and update the node information of its config like:
Redisson redisson = ctx.getBean("redisson");
Config conf = redisson.getConfig();
conf.useClusterServers().getNodeAddresses().clear();
conf.useClusterServers().addNodeAddress("new-address");
but it failed(it could work sometimes).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Caused by: org.redisson.client.RedisConnectionException: MasterConnectionPool no available Redis entries.  Disconnected hosts: [/1**...**]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:198)
at org.redisson.connection.pool.MasterConnectionPool.get(MasterConnectionPool.java:31)
at org.redisson.connection.MasterSlaveEntry.connectionWriteOp(MasterSlaveEntry.java:535)
at org.redisson.connection.SingleEntry.connectionReadOp(SingleEntry.java:45)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:807)
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:496)
at org.redisson.command.CommandAsyncService.readAsync(CommandAsyncService.java:351)
at org.redisson.RedissonBucket.getAsync(RedissonBucket.java:102)
at org.redisson.RedissonBucket.get(RedissonBucket.java:97)
... 146 more
redisson配置
.setFailedAttempts(1).setConnectTimeout(300).setRetryAttempts(0).setTimeout(100);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to store a basic POJO called MobileNotificationDTO inside an RMap<Long,MobileNotificationDTO> using MarshallingCodec
public class MobileNotificationDTO implements Serializable {

    private Long id;
    private LocalDateTime createdOn;
    private boolean sent;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDateTime getCreatedOn() {
        return createdOn;
    }

    public void setCreatedOn(LocalDateTime createdOn) {
        this.createdOn = createdOn;
    }

    public boolean isSent() {
        return sent;
    }

    public void setSent(boolean sent) {
        this.sent = sent;
    }
}


Writing an integration test, it is failing to retrieve the POJO from the map
    @Before
    public void setUp() throws Exception {

        Config config = new Config();

        ObjectMapper objectMapper = new ObjectMapper();
        config.setCodec(new MarshallingCodec());
        config.useSingleServer()
                .setAddress("redis://localhost:6379");


        redissonClient = Redisson.create(config);
        cache = new MobileNotificationsCache(redissonClient);
    }


    @Test
    public void put_WhenMobileNotificationIsSet_ThenValueIsCachedCorrectly() {
        final Long id = 682124L;
        final LocalDateTime createdOn = LocalDateTime.now();
        final MobileNotificationDTO dto = new MobileNotificationDTO();
        dto.setId(123L);
        dto.setCreatedOn(createdOn);
        dto.setSent(true);

        redissonClient.getMapCache(MobileNotificationsCache.CACHE_NAME).put(id, dto);

        RMap<Long, MobileNotificationDTO> map = redissonClient.getMapCache(MobileNotificationsCache.CACHE_NAME, new LongCodec());
        assertThat(map.size()).isEqualTo(1);
        MobileNotificationDTO result = map.get(id);
        assertThat(result.getId()).isEqualTo(123L);
        assertThat(result.getCreatedOn()).isEqualTo(createdOn);
        assertThat(result.isSent()).isTrue();

    }

The full error is as follows

ERROR CommandDecoder:181 - Unable to decode data. channel: [id: 0x6ef3b6fd, L:/127.0.0.1:57900 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=171, widx=171), command: (HGET), params: [MOBILE_NOTIFICATIONS, PooledUnsafeDirectByteBuf(ridx: 0, widx: 10, cap: 256)]
java.io.IOException: Unsupported protocol version 0
at org.jboss.marshalling.river.RiverUnmarshaller.start(RiverUnmarshaller.java:1348)
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:150)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:359)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
2021-03-10 18:57:56 ERROR ErrorsLoggingHandler:47 - Exception occured. Channel: [id: 0x6ef3b6fd, L:/127.0.0.1:57900 - R:localhost/127.0.0.1:6379]
io.netty.handler.codec.DecoderException: java.io.IOException: Unsupported protocol version 0

Any ideas how to fix this issue? I have tried JsonMarshallingCode and StringCodec but still the same error
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
You can do it like MapOptions<K, V> mo = MapOptions.defaults();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
With an application server up and using redis, and hibernate.cache.redisson.fallback=true, I should be able to kill redis, and continue to use my application server.
Actual behavior
Hibernate+Redisson becomes unusable as soon as redis becomes unavailable - with failures coming from the nextTimestamp method in BaseRegion RedissonRegionFactory.
Steps to reproduce or test case

Configure hibernate L2 cache with redisson.
start application server with redis online
stop redis
try to use application (hibernate calls) - get errors.

Redis version
redis:latest from docker hub.
Redisson version
3.15.0
Redisson configuration
redisson.yaml
singleServerConfig:
  address: "redis://127.0.0.1:6379"

persistence.xml
            <property name="hibernate.cache.use_second_level_cache" value="true"/>
            <property name="hibernate.cache.redisson.config" value="/redisson.yaml" />
            <property name="hibernate.cache.redisson.fallback" value="true" />

Entity classes:
@Cacheable()
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a live object that holds a linked list that holds items from another live object. I am able to push the parent live object to the redis live object service just fine. When I retrieve the parent object, the linked list is null. If I insert a string, it works just fine, but with my child live object it always returns null. See below:
Parent class:
@getter
@Setter
@rentity
public class ParentObject {
@Rid
private String id;
private LinkedList parentLinkedList;
}
Child Class:
@getter
@Setter
@rentity
public class ChildObject {
@Rid
private String id;
private Long attribute1;
private Timestamp attribute2;
private String attribute3;
private String attribute4;
private String attribute5;
}
The variables and ID's sets removed for readability.
Implementation:
    RLiveObjectService liveObjectService = redisClient.getLiveObjectService();
    ChildObject child= new ChildObject();
    ParentObject parent = new ParentObject();

    LinkedList<Object> parentObjectLinkedList= new LinkedList<Object>();
    parentObjectLinkedList.addFirst(child);
    parent.setparentLinkedList(parentObjectLinkedList);
    
    liveObjectService.persist(parent);
    ParentObject myObject = liveObjectService.get(ParentObject.class, id);

The myObject will hold the ParentObject with the null linked list, this list is not null when sending to redis service. Also when I substitute the object type of the linkedList to String and not ChildObject, this works just fine and the list is not null. Its the nesting of the RLO within the RLO that is killing me. Any thoughts? Thanks for your time!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We are currently using Redisson 3.13.6 for session management of a java web application deployed in tomcat 7 and sessions stored in ElastiCache.
RedissonSessionManager is configured with readMode=MEMORY and updateMode=AFTER_REQUEST (due to the way the app is implemented this is the only configuration working for us).
We noticed high network outbound traffic on a single ElastiCache node, followed by CLUSTERDOWN errors because of bandwidth throttling.
I checked the implementation and found that RedissonSessionManager is implemented to use a single topic for pub/sub communication - https://github.com/redisson/redisson/blob/master/redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java#L153
Is there a reason for using a single topic?
Is it ok to update the implementation to create multiple topics, and use a balancer when accessing them from  RedissonSession?
I understand that the Redis slot is computed based on the topic name, so choosing the name for the topics in such a way that they will end up on different nodes is not that straightforward, but I am interested if there is another reason this approach might not work.
Thanks,
Ilie
P.S. The quick fix was to upgrade the ElastiCache node type to accommodate the traffic, but it's not ideal because of the price of the new instances and because the nodes not handling the pub/sub topic are not using these resources.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
Describe the solution you'd like
Describe alternatives you've considered
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
spring-native released a beta version, support spring boot 2.4.3, so our company plans to use it, so hope the next version of redisson boot starter upgrade to the spring boot version.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson-spring-boot-starter 3.15.1
查看源码，在 RedissonStreamCommands.xReadGroup 中，没有处理readOptions的noack参数

Expected behavior
redis stream 手动 ack
Actual behavior
无论设置成手动还是自动，均自动ack
Steps to reproduce or test case
@Component
public class StreamConsumerRunner implements ApplicationRunner, ApplicationListener<ContextClosedEvent> {

    static final Logger LOGGER = LoggerFactory.getLogger(StreamConsumerRunner.class);

    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    @Autowired
    ThreadPoolTaskScheduler taskScheduler;

    @Autowired
    StringRedisTemplate stringRedisTemplate;

    private StreamMessageListenerContainer<String, MapRecord<String, String, String>> streamMessageListenerContainer;

    @Override
    public void run(ApplicationArguments args) throws Exception {

        // 创建配置对象
        StreamMessageListenerContainerOptions<String, MapRecord<String, String, String>> streamMessageListenerContainerOptions = StreamMessageListenerContainerOptions
            .builder()
            // 一次性最多拉取多少条消息
            .batchSize(10)
            // 执行消息轮询的执行器
            .executor(this.taskScheduler)
            // 消息消费异常的handler
            .errorHandler(new ErrorHandler() {
                @Override
                public void handleError(Throwable t) {
                    // throw new RuntimeException(t);
                    t.printStackTrace();
                }
            })
            // 超时时间，设置为0，表示不超时（超时后会抛出异常）
            .pollTimeout(Duration.ZERO)
            // 序列化器
            .serializer(new StringRedisSerializer())
            .build();

        // 根据配置对象创建监听容器对象
        StreamMessageListenerContainer<String, MapRecord<String, String, String>> streamMessageListenerContainer = StreamMessageListenerContainer
            .create(this.redisConnectionFactory, streamMessageListenerContainerOptions);


        // 使用监听容器对象开始监听消费（使用的是手动确认方式）
        streamMessageListenerContainer.receive(Consumer.from("group-1", "consumer-1-1"),
            StreamOffset.create("mystream", ReadOffset.lastConsumed()), message -> {
                LOGGER.info("group-1, {}", message);
                 stringRedisTemplate.opsForStream().acknowledge("group-1", message);
            });

        this.streamMessageListenerContainer = streamMessageListenerContainer;
        // 启动监听
        this.streamMessageListenerContainer.start();
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        LOGGER.info("close");
        this.streamMessageListenerContainer.stop();
    }
}

Redis version
5.0.10
Redisson version
redisson-spring-boot-starter 3.15.1
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
what is the minimum version for "jackson-core" required for redisson 3.14.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
keep getting this error when i try this
Config.fromYAML(PropertiesUtil.getResourceAsFile(REDISSON_RESOURCE_NAME));
the exception is
Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/TSFBuilder
at org.redisson.config.ConfigSupport.(ConfigSupport.java:92)
at org.redisson.config.Config.fromYAML(Config.java:661)
at org.redisson.config.Config.fromYAML(Config.java:657)
when I try to look at the code can't find usage for TSFBuilder at class ConfigSupport
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3478
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
more info in this issue: #3345
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.RedisTimeoutException : Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=31, freeConnectionsCounter=value:299:queue:0, freezed=false, freezeReason=null, client=[addr=redis://xx.redis.rds.aliyuncs.com:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@2008593702 [redisClient=[addr=redis://xx.redis.rds.aliyuncs.com:6379], channel=[id: 0x0c40332e, L:/10.11.133.0:49268 - R:xx.redis.rds.aliyuncs.com/xxip:6379], currentCommand=null], command: null, params: null after 3 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Redisson version: 3.13.0
This problem will appear after every downgrade of redis cluster. Restarting the application can solve this problem at present.
However, how to solve the problem thoroughly?
More information :


Examples Code
RBatch batch = redissonClient.createBatch();
keyList.forEach((key) -> {
batch.getBucket(key).getAsync().onComplete((value, exception) -> {
if (exception == null && null !=value) {
// Just put the value to map
}
});
});
batch.execute();


2.Examples redisson.yaml
singleServerConfig:
address: xxx
password: xxx
idleConnectionTimeout: 10000
connectTimeout: 1000
timeout: 1000
retryAttempts: 3
retryInterval: 1500
subscriptionsPerConnection: 5
clientName: null
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 16
connectionMinimumIdleSize: 100
connectionPoolSize: 64
database: 0
threads: 8
nettyThreads: 32
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
any update?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3483
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hello, I spent my day trying to debug but I didn't succeed, do you have an idea?
java.util.ServiceConfigurationError: org.jboss.marshalling.ProviderDescriptor: Error reading configuration file
        at java.util.ServiceLoader.fail(ServiceLoader.java:232) ~[?:1.8.0_212]
        at java.util.ServiceLoader.parse(ServiceLoader.java:309) ~[?:1.8.0_212]
        at java.util.ServiceLoader.access$200(ServiceLoader.java:185) ~[?:1.8.0_212]
        at java.util.ServiceLoader$LazyIterator.hasNextService(ServiceLoader.java:357) ~[?:1.8.0_212]
        at java.util.ServiceLoader$LazyIterator.hasNext(ServiceLoader.java:393) ~[?:1.8.0_212]
        at java.util.ServiceLoader$1.hasNext(ServiceLoader.java:474) ~[?:1.8.0_212]
        at org.jboss.marshalling.Marshalling.loadMarshallerFactory(Marshalling.java:112) ~[?:?]
        at org.jboss.marshalling.Marshalling.getProvidedMarshallerFactory(Marshalling.java:101) ~[?:?]
        at org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:218) ~[?:?]
        at org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:195) ~[?:?]
        at org.redisson.codec.MarshallingCodec.<init>(MarshallingCodec.java:191) ~[?:?]
        at org.redisson.config.Config.<init>(Config.java:103) ~[?:?]
        at org.redisson.Redisson.<init>(Redisson.java:62) ~[?:?]
        at org.redisson.Redisson.create(Redisson.java:104) ~[?:?]
        at fr.xrths.lyranetwork.Main.redisSetup(Main.java:59) ~[?:?]
        at fr.xrths.lyranetwork.Main.onEnable(Main.java:45) ~[?:?]
        at org.bukkit.plugin.java.JavaPlugin.setEnabled(JavaPlugin.java:309) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.plugin.java.JavaPluginLoader.enablePlugin(JavaPluginLoader.java:318) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.plugin.SimplePluginManager.enablePlugin(SimplePluginManager.java:393) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.craftbukkit.v1_8_R3.CraftServer.loadPlugin(CraftServer.java:320) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.craftbukkit.v1_8_R3.CraftServer.enablePlugins(CraftServer.java:275) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.craftbukkit.v1_8_R3.CraftServer.reload(CraftServer.java:732) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.Bukkit.reload(Bukkit.java:540) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.command.defaults.ReloadCommand.execute(ReloadCommand.java:25) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.command.SimpleCommandMap.dispatch(SimpleCommandMap.java:137) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchCommand(CraftServer.java:626) ~[meowspigot.jar:1.0-Beta]
        at org.bukkit.craftbukkit.v1_8_R3.CraftServer.dispatchServerCommand(CraftServer.java:589) ~[meowspigot.jar:1.0-Beta]
        at net.minecraft.server.v1_8_R3.DedicatedServer.aO(DedicatedServer.java:409) ~[meowspigot.jar:1.0-Beta]
        at net.minecraft.server.v1_8_R3.MinecraftServer.lambda$run$6(MinecraftServer.java:602) ~[meowspigot.jar:1.0-Beta]
        at net.minecraft.server.v1_8_R3.MinecraftServer.lambda$schedule$7(MinecraftServer.java:668) ~[meowspigot.jar:1.0-Beta]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_212]
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [?:1.8.0_212]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_212]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [?:1.8.0_212]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_212]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_212]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_212]
Caused by: java.io.FileNotFoundException: JAR entry META-INF/services/org.jboss.marshalling.ProviderDescriptor not found in /data/plugins/LyraNetwork-SPIGOT-0.0.1-SNAPSHOT.jar
        at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:144) ~[?:1.8.0_212]
        at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:152) ~[?:1.8.0_212]
        at java.net.URL.openStream(URL.java:1045) ~[?:1.8.0_212]
        at java.util.ServiceLoader.parse(ServiceLoader.java:304) ~[?:1.8.0_212]
        ... 35 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have used write behind mode in mapoption,
my code written in write method is executing fine but after some time
i have observed that i am getting "org.redisson.client.RedisOutOfMemoryException" exception after that my write method of mapwriter is not getting called,
can yo please help me out in these.
Also observed that after getting any throwable error in write method same behaviour is getting replicate.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Do not print such logs
Actual behavior
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/10.xxx.xxx:5x] query timed out after 5000 milliseconds (no stack trace available)
2021-03-16 15:35:48,398 [redisson-netty-2-18] ERROR org.redisson.connection.DNSMonitor 112 - Unable to resolve redis.host
io.netty.resolver.dns.DnsResolveContext$SearchDomainUnknownHostException: Search domain query failed. Original hostname: 'redis.hostl' failed to resolve 'redis.host' after 2 queries
at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:816)
at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:777)
at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:310)
at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:299)
at io.netty.resolver.dns.DnsResolveContext.access$500(DnsResolveContext.java:62)
at io.netty.resolver.dns.DnsResolveContext$3.operationComplete(DnsResolveContext.java:356)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:511)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:504)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:483)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:424)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:121)
at io.netty.resolver.dns.DnsQueryContext.setFailure(DnsQueryContext.java:216)
at io.netty.resolver.dns.DnsQueryContext.access$300(DnsQueryContext.java:43)
at io.netty.resolver.dns.DnsQueryContext$4.run(DnsQueryContext.java:166)
at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:446)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:745)
Caused by: io.netty.resolver.dns.DnsNameResolverTimeoutException: [/10.xx.xx.x:x3] query timed out after 5000 milliseconds (no stack trace available)
Steps to reproduce or test case
After use, the exception log is printed every five seconds
Redis version
Redisson version
3.15.0
Redisson configuration
Config config = new Config();
config.useSingleServer()
.setAddress("redis://"+addressUrl)
.setConnectTimeout(20000)
.setRetryInterval(20000)
.setTimeout(20000);
return Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3487
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3491
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson-springboot-starter现在支持从springcloud config/nacos读取配置文件么
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3494
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson 3.15.1.
I thought of reporting a behavior I see during testing.
If I break connectivity to Redis, retryInterval works as expected, but if I use the CLIENT PAUSE, then
all retries are done at the same time. retryInterval  is not respected.
Config config = new Config();
config.useSingleServer().setTimeout( 50 ).setRetryAttempts( 10 ).setRetryInterval( 6000 ).setAddress( "redis://127.0.0.1:6379" );
RedissonClient redisson = Redisson.create(config);
// stop with debugger here and run
// redis-cli client pause 60000
System.out.println((new Date()) + " - start");
try {
redisson.getBucket("bucket").set("value");
} catch ( Exception e ) {
System.out.println((new Date())  + " - error: " + e.toString());
}
System.out.println((new Date()) + " - end ");
Does 10 attempts but doesn't respect the retry interval of 6000  - fails in the same second
Wed Mar 17 00:39:18 EDT 2021 - start
Wed Mar 17 00:39:19 EDT 2021 - error: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (50 ms) occured after 10 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: (SET), params: [bucket, PooledUnsafeDirectByteBuf(ridx: 0, widx: 8, cap: 256)], channel: [id: 0xb95d6467, L:/127.0.0.1:50083 - R:/127.0.0.1:6379]
Wed Mar 17 00:39:19 EDT 2021 - end
If I stop redis then it fails after a minute as expected  ( 10 attempts with 6000  retry interval)
Wed Mar 17 00:41:32 EDT 2021 - start
Wed Mar 17 00:42:32 EDT 2021 - error: org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@553090556 [redisClient=[addr=redis://127.0.0.1:6379], channel=[id: 0x9db03e64, L:0.0.0.0/0.0.0.0:50415], currentCommand=null], command: (SET), params: [bucket, PooledUnsafeDirectByteBuf(ridx: 0, widx: 8, cap: 256)] after 10 retry attempts
I don't really use CLIENT PAUSE. I was just trying to simulate latency and noticed this. I reported in case this behavior can impact other/real scenarios
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3496
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why i have this warning?
and how this dependency help me?

io.netty
netty-resolver-dns-native-macos
4.1.60.Final
osx-x86_64

i want to know why i need it??
question
#3406 for that
2021-03-17 12:23:24.471  WARN 34443 --- [           main] i.n.r.d.DnsServerAddressStreamProviders  : Unable to load io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider, fallback to system defaults. This may result in incorrect DNS resolutions on MacOS.
java.lang.ClassNotFoundException: io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider
at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) ~[na:na]
at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) ~[na:na]
at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) ~[na:na]
at java.base/java.lang.Class.forName0(Native Method) ~[na:na]
at java.base/java.lang.Class.forName(Class.java:398) ~[na:na]
at io.netty.resolver.dns.DnsServerAddressStreamProviders$1.run(DnsServerAddressStreamProviders.java:50) ~[netty-resolver-dns-4.1.58.Final.jar:4.1.58.Final]
at java.base/java.security.AccessController.doPrivileged(Native Method) ~[na:na]
at io.netty.resolver.dns.DnsServerAddressStreamProviders.(DnsServerAddressStreamProviders.java:46) ~[netty-resolver-dns-4.1.58.Final.jar:4.1.58.Final]
at org.redisson.connection.MasterSlaveConnectionManager.(MasterSlaveConnectionManager.java:203) ~[redisson-3.15.0.jar:3.15.0]
at org.redisson.connection.MasterSlaveConnectionManager.(MasterSlaveConnectionManager.java:155) ~[redisson-3.15.0.jar:3.15.0]
at org.redisson.connection.SingleConnectionManager.(SingleConnectionManager.java:34) ~[redisson-3.15.0.jar:3.15.0]
at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:200) ~[redisson-3.15.0.jar:3.15.0]
at org.redisson.Redisson.(Redisson.java:64) ~[redisson-3.15.0.jar:3.15.0]
at org.redisson.Redisson.create(Redisson.java:104) ~[redisson-3.15.0.jar:3.15.0]
at io.tezis.push.config.RedissonConfiguration.redissonClient(RedissonConfiguration.java:55) ~[classes/:na]
at io.tezis.push.config.RedissonConfiguration$$EnhancerBySpringCGLIB$$31f4372c.CGLIB$redissonClient$1() ~[classes/:na]
at io.tezis.push.config.RedissonConfiguration$$EnhancerBySpringCGLIB$$31f4372c$$FastClassBySpringCGLIB$$b9263e56.invoke() ~[classes/:na]
at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.3.3.jar:5.3.3]
at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331) ~[spring-context-5.3.3.jar:5.3.3]
at io.tezis.push.config.RedissonConfiguration$$EnhancerBySpringCGLIB$$31f4372c.redissonClient() ~[classes/:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1336) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1179) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:571) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:531) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887) ~[spring-beans-5.3.3.jar:5.3.3]
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791) ~[spring-beans-5.3.3.jar:5.3.3]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
session invalidated is applied to all servers.
when readMode="REDIS" session always should get from redis directly
Actual behavior
if there are more than 2 servers using redisson , when session invalidate method called one of server does not know that session is invalidated, because JSESSION ID is still on the cookie in user's browser.
Steps to reproduce or test case
setting redis configuration below.
make jsp file and prodcess login, logout, print session value.
load balance is infront of tomcat
server A : login - request.getSession(false)
server B : print session value : ok
server A : logout - session.invalidate()
server B : print session value : ok - still remain session)
Redis version
aws elasticache 6.x cluster mode
default.redis6.x.cluster.on (in-sync)
Redisson version
redisson tomcat 9-3.15.1
Redisson configuration
readMode=REDIS, others option are default
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3499
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using an asynchronously acquired RedissonClient (via. CompletableFuture.supplyAsync) with transactions I expect the class loader used to be correct.
Some constraints to narrow the scope of the problem:

I only encountered this when using Redisson Transactions.
If the client was acquired in a synchronous way, I did not see this behavior.

Actual behavior
Similar to #2984 I am seeing that on the first request to my WAR on a web server, the correct class loader is used.

But then on subsequent requests, it is using the URLClassPath loader what I assume to be the default for Jetty.

After this breaks, I get consistent ClassNotFound errors.
Steps to reproduce or test case
I created a minimal jetty project here in an effort to reproduce the code we are running.
In words, my steps were as follows:
Create a Jetty Server running 9.4.30.v20200611, and deploy a WAR on it. Place objects into Redis, using transactions, and try to retrieve them. After the first request succeeds, observe ClassNotFound issues when trying to retrieve other objects. The stack trace can be found in a gist.
Redis version
6.0.5
Redisson version
13.15.1
Redisson configuration
    redissonConfig
        .useSingleServer()
        .setConnectTimeout(10_000)
        .setTimeout(10_000)
        .setRetryAttempts(0)
        .setConnectionPoolSize(20)
        .setConnectionMinimumIdleSize(1)
        .setPassword("SECRET")
        .setAddress("redis://host.docker.internal:6379");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson should not try to authenticate against a password-less Sentinel instance.
Actual behavior
Redisson seems to send an AUTH instruction to the Sentinel instance, resulting in the following stacktrace repeating endlessly. However, the client seems to be successful at performing various operations on the Redis cluster (get/set).
org.redisson.client.RedisException: ERR Client sent AUTH, but no password is set. channel: [id: 0xf21be32b, L:/127.0.0.1:59370 - R:/127.0.0.1:26379] command: (AUTH), params: (password masked)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:345)
        at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.base/java.lang.Thread.run(Thread.java:834)

Steps to reproduce or test case
See the following repository and its README.md : https://github.com/MrKloan/redisson-sentinel-auth-issue/
Redis version
5.+
Redisson version
3.15.1
Redisson configuration
See https://github.com/MrKloan/redisson-sentinel-auth-issue/blob/master/src/main/java/org/example/redisson/RedissonSentinelAuthIssue.java#L25
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson 3.5.1
I am debugging why we are seeing ByteBuf leaks and native memory problems.
I suspect one reason could be serialization failing for some objects.
I created a simple test to run this code in a loop
Object MY_DUMMY_NON_SERIALIZABLE_OBJECT = Logger.getGlobal();
redisson.getMap("cacheMap").fastPut("value", MY_DUMMY_NON_SERIALIZABLE_OBJECT );
The code triggers: java.lang.IllegalArgumentException: java.io.NotSerializableException: java.util.logging.Logger
and looks like MarshallingCodec. Encoder.encode doesn't clean the ByteBuf  if there is an exception - and I
don't see a way to do it myself.
I enabled -Dio.netty.leakDetectionLevel=paranoid to get this output:
SEVERE: LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 
#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:616)
	org.redisson.codec.MarshallingCodec$ByteOutputWrapper.write(MarshallingCodec.java:131)
	org.jboss.marshalling.UTFUtils.writeUTFBytes(UTFUtils.java:131)
	org.jboss.marshalling.river.RiverMarshaller.writeKnownObject(RiverMarshaller.java:397)
	org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:217)
	org.jboss.marshalling.AbstractObjectOutput.writeObject(AbstractObjectOutput.java:58)
	org.jboss.marshalling.AbstractMarshaller.writeObject(AbstractMarshaller.java:111)
	org.redisson.codec.MarshallingCodec$4.encode(MarshallingCodec.java:170)
	org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:725)
	org.redisson.RedissonObject.encodeMapKey(RedissonObject.java:301)
	org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1375)
	org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1365)
	org.redisson.RedissonMap.fastPut(RedissonMap.java:1380)
	adhoc.testing.RedissonMemoryTest.main(RedissonMemoryTest.java:53)
#2:
	io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:616)
	org.redisson.codec.MarshallingCodec$ByteOutputWrapper.write(MarshallingCodec.java:131)
	org.jboss.marshalling.SimpleDataOutput.shallowFlush(SimpleDataOutput.java:353)
	org.jboss.marshalling.river.RiverMarshaller.writeKnownObject(RiverMarshaller.java:396)
	org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:217)
	org.jboss.marshalling.AbstractObjectOutput.writeObject(AbstractObjectOutput.java:58)
	org.jboss.marshalling.AbstractMarshaller.writeObject(AbstractMarshaller.java:111)
	org.redisson.codec.MarshallingCodec$4.encode(MarshallingCodec.java:170)
	org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:725)
	org.redisson.RedissonObject.encodeMapKey(RedissonObject.java:301)
	org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1375)
	org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1365)
	org.redisson.RedissonMap.fastPut(RedissonMap.java:1380)
	adhoc.testing.RedissonMemoryTest.main(RedissonMemoryTest.java:53)
Created at:
	io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:385)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:173)
	io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:107)
	org.redisson.codec.MarshallingCodec$4.encode(MarshallingCodec.java:165)
	org.redisson.command.CommandAsyncService.encodeMapKey(CommandAsyncService.java:725)
	org.redisson.RedissonObject.encodeMapKey(RedissonObject.java:301)
	org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1375)
	org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1365)
	org.redisson.RedissonMap.fastPut(RedissonMap.java:1380)
	adhoc.testing.RedissonMemoryTest.main(RedissonMemoryTest.java:53)

If I can't get the native memory issues sorted out, I need to see if this can help:
-Dio.netty.noPreferDirect=true  -Dio.netty.allocator.type=unpooled
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/redisson/redisson/wiki/2.-Configuration#masterconnectionpoolsize
Actually, the default value of  masterConnectionPoolSize in cluster setting is 64, but got 24.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3507
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How can I create redisson client with AWS role based authentication ?
I have used it with redis auth so far but don’t know if I can create redisson if I want to use role based auth.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3510
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
For now, taskRetryInterval config in ExecutorOptions, and taskTimeout config in WorkerOptions.
I need like this:
RScheduledExecutorService.schedule(jobRunnable, CronSchedule.of(jobConfig.getExpression()), timeout, retryInterval)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Before I submit a bug report on this, I wanted to check if maybe I'm doing something wrong.
I'm expecting to get a non-null value from getOldValue on CacheEntryEvent, when event type is UPDATED. I have set isOldValueRequired to true in the listener configuration.
Is there anything else I need to do to get this to work?
I just upgraded to Redisson 3.15.1.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
阿里云集群版redis限制了使用EVAL命令。
org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.redisson.client.RedisException: ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression. channel
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3515
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3516
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3522
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3523
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3526
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3529
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3534
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3536
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3538
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3542
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3545
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3549
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3556
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3558
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3559
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3561
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3563
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3569
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3571
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3576
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3577
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3578
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3581
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3584
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3586
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3589
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3591
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3592
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3593
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3594
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3600
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3601
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Did I use Rtopic incorrectly?
Code:
 void pubEvent(){
  RTopic topic = redissonClient.getTopic("test-topic")
  topic.publish(new Event("hello world"))
}

 void subEvent(){
   RTopic topic = redissonClient.getTopic("test-topic")
   topic.addListener(new MessageListener<Event>(){
            @Override
            public void onMessage(CharSequence channel, Event event) {
                log.debug("channel:{},Event :{}", channel, event);
            }
  })
}

 public static void main(String[] args){
             Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(this::pubEvent, 1000, 10000, TimeUnit.MILLISECONDS);
             subEvent();
             Thread.sleep(1000000);
 }

Config:
spring:
  redis:
    redisson:
      config: |
        singleServerConfig:
          address: "redis://localhost:6379"
          connectTimeout: 30000
          pingConnectionInterval: 10000
        codec: !<org.redisson.codec.JsonJacksonCodec> {}

Error:
2021-05-10 10:56:48.237 ERROR 10184 --- [isson-timer-4-1] o.r.c.handler.PingConnectionHandler      : Unable to send PING command over channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379]
org.redisson.client.RedisException: ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context. channel: [id: 0x6657975f, L:/2.0.1.49:54140 - R:/172.19.13.25:6379] command: (PING), params: []
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:343) ~[redisson-3.14.1.jar:3.14.1]
	at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:83) ~[redisson-3.14.1.jar:3.14.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) ~[redisson-3.14.1.jar:3.14.1]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) ~[redisson-3.14.1.jar:3.14.1]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) ~[netty-codec-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.51.Final.jar:4.1.51.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.51.Final.jar:4.1.51.Final]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_262]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3602
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redission 3.13.2
Redission-spring-data-22
The XGROUP_BOOLEAN parameter is wrong when the xGroupDelConsumer method of RedissonStreamCommands calls write.
I tried to modify the "XADD" of the XGROUP_BOOLEAN property to "XGROUP", and the test result was deleted successfully.
The following is the error log information before modification:
org.springframework.dao.InvalidDataAccessApiUsageException: ERR Invalid stream ID specified as stream command argument. channel: [id: 0x76c7f6e9, L:/192.168.16.221:64056 - R:/192.168.16.167:16379] command: (XADD), params: [DELCONSUMER, [100, 105, 97, 108, 111, 103, 58, 112, 114, 111, ...], dialog:process:group, dialog.process.c5af47c820d146259bdc9c1ba2fcad2a]; nested exception is org.redisson.client.RedisException: ERR Invalid stream ID specified as stream command argument. channel: [id: 0x76c7f6e9, L:/192.168.16.221:64056 - R:/192.168.16.167:16379] command: (XADD), params: [DELCONSUMER, [100, 105, 97, 108, 111, 103, 58, 112, 114, 111, ...], dialog:process:group, dialog.process.c5af47c820d146259bdc9c1ba2fcad2a]
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)
at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)
at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:217)
at org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:212)
at org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:378)
at org.redisson.spring.data.connection.RedissonConnection.write(RedissonConnection.java:744)
at org.redisson.spring.data.connection.RedissonStreamCommands.xGroupDelConsumer(RedissonStreamCommands.java:120)
at org.springframework.data.redis.connection.DefaultedRedisConnection.xGroupDelConsumer(DefaultedRedisConnection.java:472)
at org.springframework.data.redis.core.DefaultStreamOperations.lambda$deleteConsumer$4(DefaultStreamOperations.java:168)
at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)
at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)
at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)
at org.springframework.data.redis.core.DefaultStreamOperations.deleteConsumer(DefaultStreamOperations.java:168)
at cn.yuyitech.interfaces.dialog.controller.DemoController.lambda$stopStream$0(DemoController.java:61)
at java.util.ArrayList.forEach(ArrayList.java:1249)
at cn.yuyitech.interfaces.dialog.controller.DemoController.stopStream(DemoController.java:59)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at cn.yuyitech.common.xss.XssFilter.doFilter(XssFilter.java:37)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at cn.yuyitech.oauth2.filter.TenantFilter.doFilterInternal(TenantFilter.java:35)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:124)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)
at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at cn.yuyitech.oauth2.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:42)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)
at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)
at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)
at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)
at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)
at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:109)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92)
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)
at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)
at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
at java.lang.Thread.run(Thread.java:745)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3603
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
is my problem，iForgot to add port，
in RedisURI line 45，When rediss:// is configured, shouldn't it be https
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In a production environment, we use the redis is cloud services, in the event of network jitter occurs after org. Redisson. Client. RedisTimeoutException, specific exception is as follows:
org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=1, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=7, freeConnectionsCounter=value:97:queue:0, freezed=false, freezeReason=null, client=[addr=redis://pro-rdb-142.ms.uu.cc:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@293101102 [redisClient=[addr=redis://pro-rdb-142.ms.uu.cc:6379], channel=[id: 0xf40f1b91, L:/10.2.89.47:23078 - R:pro-rdb-142.ms.uu.cc/10.2.90.142:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7d55c2c0(failure: java.util.concurrent.CancellationException)], command=(EVAL), params=[local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, ms-pcsys:V1:11828:3.8.0, redisson__timeout__set:{ms-pcsys:V1:11828:3.8.0}, redisson__idle__set:{ms-pcsys:V1:11828:3.8.0}, redisson__map_cache__last_access__set:{ms-pcsys:V1:11828:3.8.0}, {ms-pcsys:V1:11828:3.8.0}:redisson_options, 1620636461408, PooledUnsafeDirectByteBuf(freed)], codec=org.redisson.codec.JsonJacksonCodec]], command: (EVAL), params: [local value = redis.call('hget', KEYS[1], ARGV[2]); if value == false then return nil; end; local t,..., 5, ms-pcsys:V1:10313:5.14.0, redisson__timeout__set:{ms-pcsys:V1:10313:5.14.0}, redisson__idle__set:{ms-pcsys:V1:10313:5.14.0}, redisson__map_cache__last_access__set:{ms-pcsys:V1:10313:5.14.0}, {ms-pcsys:V1:10313:5.14.0}:redisson_options, 1620636464643, PooledUnsafeDirectByteBuf(ridx: 0, widx: 38, cap: 256)] after 3 retry attempts at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:220) at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:680) at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:755) at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:483) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745)
Once this exception occurs, even if the network is back to normal, this exception will not disappear, can only restart the service.Has anyone ever had this problem?What configuration can be used to solve this problem?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3605
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
According to the brief documentation on the @RObjectField annotation I should be able to use this annotation on a field within a class annotated with @REntity to override the namespace and codec. For instance, in the below demo I'm using @RObjectField to override the serialization mechanism used to encode otherObject.
RootObject.java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@REntity
public class RootObject {
    @RId
    private String id;
    private String name;
    private Integer number;
    @RObjectField(codec = JsonJacksonCodec.class)
    private OtherObject otherObject;
}
OtherObject.java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OtherObject implements Serializable {
    private String otherId;
    private String otherName;
    private Integer otherNumber;
}
When I apply the @RObjectField annotation I expect the otherObject to be serialized using the JsonJacksonCodec. For instance, after I execute the following code:
RLiveObjectService liveObjectService = client.getLiveObjectService();
liveObjectService.persist(rootObject);
I should see a Redis command in my MONITOR log that looks like this (note the JSON format):
1620743885.392746 [0 127.0.0.1:64039] "HSET" "redisson_live_object:{22746573743132333422}:nl.devillers.redisson.RootObject" "\"otherObject\"" "{\"@class\":\"nl.devillers.redisson.OtherObject\",\"otherId\":\"other5678\",\"otherName\":\"other\",\"otherNumber\":5678}"
1

Actual behavior
When I check out the logs of my Redis instance using MONITOR I see the following HSET command
1620743370.396250 [0 127.0.0.1:63593] "HSET" "redisson_live_object:{043e087465737431323334}:nl.devillers.redisson.RootObject" "\x04>\x0botherObject" "\x04\x04\t>!nl.devillers.redisson.OtherObject\xa4P\xd9JL\xb1\xaf]\x00\x00\x00\x03>\aotherId\x16\x00>\totherName\x16\x00>\x0botherNumber\x16\x00\x16>\tother5678>\x05otherK\x00\x00\x16."

With or without the @RObjectField annotation, the result is always the above. I've also tried different codecs to see if there's a problem with the codec, but I think the annotation is simply being ignored all together. If I move the codec specification to the @REntity annotation, I do see the correct result, but then the entire entity will be serialized using Jackson, which is not what I want.
Steps to reproduce or test case
See above description.
Redis version
5.0.10
Redisson version
3.15.4
Redisson configuration
Single node setup.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have some code which adds a listener
					rmapCache.addListener(new EntryCreatedListener<String, Object>() { @Override public void onCreated(EntryEvent<String, Object> event) { publishRedisEvent(new RedisEvent(cacheKey, event)); } }); 
which works great, apart from the fact that I'm getting notifications on events in databases i'm not using.  I.e., i'm using database 0, but I get events from database 1.
How can I isolate events to the database that i'm using.
thanks, Mitchell
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I had a problem in my production . When the request qps increase,it taked a long time for the function that getBucket(key).get() .
I used the function in JAVA ExecutorService.When redis key is not exists , it has time consuming.But when redis key is exists, it is ok.
Expected behavior
Taked a little time for getBucket(key).get()
Actual behavior
Once in a while, it taked a long time for getBucket(key).get() .
Steps to reproduce or test case
1.code
@Slf4j
@RestController
@RequestMapping("/sql")
public class SqlController {
    @Resource
    private RedissonClient redissonClient;

    private static ExecutorService es = Executors.newFixedThreadPool(10);

    public String getToken2(){
        String key = "token_value";
        Long startTime = System.currentTimeMillis();
        String value = (String) redissonClient.getBucket(key).get();
        Long endTime = System.currentTimeMillis();

        if(endTime - startTime >= 300){
            log.info("[overtime][][][] use time：{}ms",endTime - startTime);
        }
        return "fail";
    }

    @PostMapping("/getToken")
    public String getToken() {
        for (int i = 0; i < 2; i++) {
            es.submit(() -> {getToken2();});

        }

        return "success";
    }
    
}

2.jmeter config


result
when redis key ：token_value  is not exist


but when key is exist , it is ok .
Redis version
4.0.11
cluster
Redisson version
3.15.4
Redisson configuration

   @Bean
    public RedissonClient getClient() throws Exception {
        // get redis ip
        String text = ConfigCenterClient.get("TCBase.Cache.v2");
        CacheInstance instance = JsonUtils.json(text, new TypeReference<List<CacheInstance>>() {
        }).get(0);

       //config
        Config config = new Config();
        config.setCodec(TypedJsonJacksonCodec.INSTANCE);
        ClusterServersConfig clusterServersConfig = config.useClusterServers();
        instance.getInstances().stream()
                .map(CacheInstance.Node::getIp).map(ip -> "redis://" + ip)
                .forEach(clusterServersConfig::addNodeAddress);
        return Redisson.create(config);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3608
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
return 13
Actual behavior
java.lang.StackOverflowError
at org.springframework.data.redis.connection.DefaultedRedisConnection.bitField(DefaultedRedisConnection.java:420)
Steps to reproduce or test case
String key = "ccc";
stringRedisTemplate.opsForValue().setBit(key,0,true);
stringRedisTemplate.opsForValue().setBit(key,1,true);
stringRedisTemplate.opsForValue().setBit(key,2,false);
stringRedisTemplate.opsForValue().setBit(key,3,true);
System.out.println(stringRedisTemplate.opsForValue().getBit(key,2));
System.out.println(stringRedisTemplate.execute((RedisCallback) con -> con.bitCount(key.getBytes())).intValue());
List longs = stringRedisTemplate.execute((RedisCallback<List>) con -> con.bitField(key.getBytes(),
BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(63)).valueAt(0)));
Redis version
6.2.1
Redisson version
3.15.0
Redisson configuration
redis:
host:
port: 6379
password:
database: 3
lettuce:
pool:
max-active: 32
max-wait: 300ms
max-idle: 16
min-idle: 8
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3609
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
containsKey looks for a key in local cache, then in redis, and, at last, invokes loader. If loader returns entry, put it in cache and report true.
Actual behavior
containsKey doesn't invoke loader at all and returns false for cold local cache/redis.
Steps to reproduce or test case
I have a map with loader, however for cold local cache and cold redis, this snipped produces different output
    final override fun isExists() = instrumentMap.containsKey(instrumentId)
    final fun isExists2() = instrumentMap[instrumentId] != null

The first one is false if cache + redis is empty, loader is not invoked. The second call invokes loader and populates cache. Subsequent containsKey calls start to work after that.
Probably, other Map implementations contains this issue.
Redis version
6.0
Redisson version
3.15.5
Redisson configuration
Single server, LocalCachedMapOptions.defaults() with loader.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3610
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RList already got its subList() method, but RDeque still could not pop multiple elements at one time.
This limits a lot RDeque's usage, and I have to use RList instead.
Redis realization[python]:
import redis
client = redis.Redis()

def batch_lpop(key, n):
    p = client.pipeline()
    p.lrange(key, 0, n - 1)
    p.ltrim(key, n, -1)
    data = p.execute()
    return data

batch_lpop('test_pipeline', 20)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
The program starts normally
Actual behavior
java.util.ServiceConfigurationError: javax.cache.spi.CachingProvider: Provider org.redisson.jcache.JCachingProvider could not be instantiated
        at java.util.ServiceLoader.fail(ServiceLoader.java:232) ~[?:1.8.0_262]
        at java.util.ServiceLoader.access$100(ServiceLoader.java:185) ~[?:1.8.0_262]
        at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:384) ~[?:1.8.0_262]
        at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404) ~[?:1.8.0_262]
        at java.util.ServiceLoader$1.next(ServiceLoader.java:480) ~[?:1.8.0_262]
        at javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:448) ~[cache-api-1.1.1.jar!/:?]
        at javax.cache.Caching$CachingProviderRegistry$1.run(Caching.java:442) ~[cache-api-1.1.1.jar!/:?]
        at java.security.AccessController.doPrivileged(Native Method) ~[?:1.8.0_262]
        at javax.cache.Caching$CachingProviderRegistry.getCachingProviders(Caching.java:442) ~[cache-api-1.1.1.jar!/:?]
        at javax.cache.Caching$CachingProviderRegistry.getCachingProviders(Caching.java:410) ~[cache-api-1.1.1.jar!/:?]
        at javax.cache.Caching.getCachingProviders(Caching.java:187) ~[cache-api-1.1.1.jar!/:?]
        at org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration$JCacheProviderAvailableCondition.getMatchOutcome(JCacheCacheConfiguration.java:160) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition$MemberOutcomes.getConditionOutcome(AbstractNestedCondition.java:194) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition$MemberOutcomes.<init>(AbstractNestedCondition.java:188) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition$MemberConditions.lambda$getMatchOutcomes$0(AbstractNestedCondition.java:168) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at java.util.Map.forEach(Map.java:630) ~[?:1.8.0_262]
        at java.util.Collections$UnmodifiableMap.forEach(Collections.java:1507) ~[?:1.8.0_262]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition$MemberConditions.getMatchOutcomes(AbstractNestedCondition.java:168) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition$MemberMatchOutcomes.<init>(AbstractNestedCondition.java:78) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.AbstractNestedCondition.getMatchOutcome(AbstractNestedCondition.java:63) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:47) ~[spring-boot-autoconfigure-2.4.4.jar!/:2.4.4]
        at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:108) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator.shouldSkip(ConfigurationClassBeanDefinitionReader.java:489) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:140) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:129) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:343) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:746) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:564) ~[spring-context-5.3.5.jar!/:5.3.5]
        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:144) ~[spring-boot-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:769) ~[spring-boot-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:761) ~[spring-boot-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:426) ~[spring-boot-2.4.4.jar!/:2.4.4]
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:326) ~[spring-boot-2.4.4.jar!/:2.4.4]
        at com.ontrade.perpetual.provider.PerpetualProviderApplication.main(PerpetualProviderApplication.java:44) ~[classes!/:0.0.1-SNAPSHOT]
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_262]
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_262]
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_262]
        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_262]
        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[ontrade-perpetual-provider.jar:0.0.1-SNAPSHOT]
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:107) ~[ontrade-perpetual-provider.jar:0.0.1-SNAPSHOT]
        at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[ontrade-perpetual-provider.jar:0.0.1-SNAPSHOT]
        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) ~[ontrade-perpetual-provider.jar:0.0.1-SNAPSHOT]
Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/core/JacksonException
        at java.lang.Class.getDeclaredConstructors0(Native Method) ~[?:1.8.0_262]
        at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) ~[?:1.8.0_262]
        at java.lang.Class.getConstructor0(Class.java:3075) ~[?:1.8.0_262]
        at java.lang.Class.newInstance(Class.java:412) ~[?:1.8.0_262]
        at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380) ~[?:1.8.0_262]
        ... 42 more
Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.core.JacksonException
        at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[?:1.8.0_262]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[?:1.8.0_262]
        at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) ~[ontrade-perpetual-provider.jar:0.0.1-SNAPSHOT]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[?:1.8.0_262]
        at java.lang.Class.getDeclaredConstructors0(Native Method) ~[?:1.8.0_262]
        at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) ~[?:1.8.0_262]
        at java.lang.Class.getConstructor0(Class.java:3075) ~[?:1.8.0_262]
        at java.lang.Class.newInstance(Class.java:412) ~[?:1.8.0_262]
        at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380) ~[?:1.8.0_262]
        ... 42 more

Steps to reproduce or test case
spring boot version: 2.4.4
Redis version
5.0
Redisson version
3.15.5
Redisson configuration
redisson config:
  @Bean(value = "redissonClient")
  @Primary
  public RedissonClient redissonClient() {
    Config config = new Config();
    config.useSingleServer()
            .setAddress("redis://" + redisProperties.getHost() + ":" + redisProperties.getPort())
            .setPassword(redisProperties.getPassword());
    if (!System.getProperty("java.version").startsWith("1.8")) {
      log.info("redisson init close useThreadClassLoader");
      config.setUseThreadClassLoader(false);
    }
    return Redisson.create(config);
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
a native RedisClient "should" allow pipelining of a list of commands.
Currently that seems impossible to achieve (or is at least undocumented as far as i know)!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3613
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the pom.xml from org.redisson:redisson pulls in the caching API from javax. as we do not use this in our projects at all, can this one be made optional? or if not is an exclusion on our side safe?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using Redission to connect AWS ElasticCache Redis(Cluster Mode Disabled), but we found exception below, even we upgraded to the version 3.15.1. And we don't see these exception unit we restart our service.
Exception:
org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=null, addr=null, redisClient=[addr=redis://xxx.cache.amazonaws.com:6379], redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:999:queue:0, freeConnectionsAmount=24, freeConnectionsCounter=value:10000:queue:0, freezed=false, freezeReason=null, client=[addr=redis://xxx.cache.amazonaws.com:6379], nodeType=MASTER, firstFail=0]]] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.
at org.redisson.connection.MasterSlaveConnectionManager.createNodeNotFoundFuture(MasterSlaveConnectionManager.java:647)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:629)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:643)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:115)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:243)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Version:
Redission: 3.15.1
AWS ElasticCache Redis(Cluster Mode Disabled): 5.0.6
Config:
Config config = new Config();
config.useSingleServer().setAddress("redis://" + host + ":" + port)
.setConnectTimeout(30000)
.setSubscriptionsPerConnection(5000)
.setSubscriptionConnectionPoolSize(1000)
.setConnectionPoolSize(10000)
.setPingConnectionInterval(1000)
.setRetryInterval(3000);
Do I need to change the config to useReplicatedServer() or useSingleServer() also can support AWS ElasticCache Redis(Cluster Mode Disabled)
Thanks a lot!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3616
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Using bb7b1b6 from master mvn dependency:tree reports multiple bad dependency management on redisson module:
$ mvn dependency:analyze  -pl redisson -DignoreNonCompile
...
[WARNING] Used undeclared dependencies found:
[WARNING]    com.fasterxml.jackson.core:jackson-annotations:jar:2.12.1:compile
[WARNING]    org.springframework:spring-core:jar:5.3.7:provided
[WARNING]    org.jboss.marshalling:jboss-marshalling:jar:2.0.11.Final:compile
[WARNING]    org.reactivestreams:reactive-streams:jar:1.0.3:compile
[WARNING]    org.springframework:spring-expression:jar:5.3.7:provided
[WARNING]    io.netty:netty-resolver:jar:4.1.60.Final:compile
[WARNING] Unused declared dependencies found:
[WARNING]    org.yaml:snakeyaml:jar:1.27:compile
[WARNING]    org.jboss.marshalling:jboss-marshalling-river:jar:2.0.11.Final:compile
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
My application has caffeine local cache and I'd like to use redisson for this, just like normal distributed map. I've configured store mode and provided loader, however loader doesn't start.
I've looked into code and it looks like this option was never considered, so, probably not a bug, however I think, loader and store mode should be compatible with each other.
Describe the solution you'd like
Run loader and store result in local cache.
Describe alternatives you've considered
Dedicated caffeine instance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3618
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3619
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
socketAddress1.getHostName()  and socketAddress2.getHostName()  is very slow, and the socketAddress3.getHostName() is fast.
        String ip1 = "10.10.3.24";
        byte[] addrBytes1 = new byte[]{10,10,3,24};
        InetSocketAddress socketAddress1 = new InetSocketAddress(InetAddress.getByAddress(addrBytes1), 27001);
        long startTime = System.currentTimeMillis();
        System.out.println(socketAddress1.getHostName());
        System.out.println(System.currentTimeMillis()-startTime);

        String ip2 = "10.10.3.25";
        byte[] addrBytes2 = new byte[]{10,10,3,25};
        InetSocketAddress socketAddress2 = new InetSocketAddress(InetAddress.getByAddress(addrBytes2), 27001);


        startTime = System.currentTimeMillis();
        System.out.println(socketAddress2.getHostName());
        System.out.println(System.currentTimeMillis()-startTime);

        String ip3 = "10.10.3.26";
        byte[] addrBytes3 = new byte[]{10,10,3,26};
        InetSocketAddress socketAddress3 = new InetSocketAddress(InetAddress.getByAddress(ip3, addrBytes3), 27001);


        startTime = System.currentTimeMillis();
        System.out.println(socketAddress3.getHostName());
        System.out.println(System.currentTimeMillis()-startTime);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3620
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
wiki "11. Redis commands mapping"
----- wrong
CONFIG GET -> RedisNode.
setConfig()
setConfigAsync()
CONFIG SET -> RedisNode.
getConfig()
getConfigAsync()
----- correct
CONFIG GET -> RedisNode.
getConfig()
getConfigAsync()
CONFIG SET  -> RedisNode.
setConfig()
setConfigAsync()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3621
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
redisson connection redis success
Actual behavior
redisson connection fail, but other redis client, connection success.
Steps to reproduce or test case
spring boot start
Redis version
5.0.9
Redisson version
3.15.5
Redisson configuration
    @Bean
    public RedissonClient redissonClient() {
        log.info("create redisson client:{}", redisProperties);
        Config config = new Config();
        SingleServerConfig singleServerConfig = config.useSingleServer();
        singleServerConfig.setAddress("redis://" + redisProperties.getHost() + ":" + redisProperties.getPort());
        singleServerConfig.setDatabase(redisProperties.getDatabase());
        if (StrUtil.isNotBlank(redisProperties.getPassword())) {
            singleServerConfig.setPassword(redisProperties.getPassword());
        }
        return Redisson.create(config);
    }
this is redis config log out , ip、port、password

this is spring boot run ,fail log

this is other redis client connection success.

redis server and springboot on one server ，
seek help.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3623
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
use spring data redis's factory for redisTemplate  was ok
  /**
   * 默认通用的 stringRedisTemplate.
   */
  @Bean(name = "stringRedisTemplate")
  @Primary
  public StringRedisTemplate stringRedisTemplate(@Autowired @Qualifier("templateFactory") RedisConnectionFactory redisConnectionFactory) {
    return new StringRedisTemplate(redisConnectionFactory);
  }

  @Bean(name = "templateFactory")
  public RedisConnectionFactory redisConnectionFactory() {

    LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
            .commandTimeout(Duration.ofSeconds(2))
            .shutdownTimeout(Duration.ZERO)
            .build();
    RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration(redisProperties.getHost(), redisProperties.getPort());
    configuration.setPassword(RedisPassword.of(redisProperties.getPassword()));
    return new LettuceConnectionFactory(configuration, clientConfig);
  }



use redisson's factory for redisTemplate  was error
  /**
   * 默认通用的 stringRedisTemplate.
   */
  @Bean(name = "stringRedisTemplate")
  @Primary
  public StringRedisTemplate stringRedisTemplate(@Autowired @Qualifier("redissonConnectionFactory") RedissonConnectionFactory redisConnectionFactory) {
    return new StringRedisTemplate(redisConnectionFactory);
  }

  @Primary
  @Bean(name = "redissonConnectionFactory")
  public RedissonConnectionFactory redissonConnectionFactory(@Autowired @Qualifier("redissonClient") RedissonClient redissonClient) {
    return new RedissonConnectionFactory(redissonClient);
  }

java.lang.StackOverflowError
	at org.springframework.data.redis.connection.DefaultedRedisConnection.zAdd(DefaultedRedisConnection.java:877)
	at org.springframework.data.redis.connection.DefaultedRedisConnection.zAdd(DefaultedRedisConnection.java:877)
	at org.springframework.data.redis.connection.DefaultedRedisConnection.zAdd(DefaultedRedisConnection.java:877)
	at org.springframework.data.redis.connection.DefaultedRedisConnection.zAdd(DefaultedRedisConnection.java:877)
	at org.springframework.data.redis.connection.DefaultedRedisConnection.zAdd(DefaultedRedisConnection.java:877)


my test code is
  @Autowired
  private StringRedisTemplate stringRedisTemplate;
  String stopProfitKey = "test.profit.key";
  String stopLossKey = "test.loss.key";
  @Test
  void contextLoads() {
    stringRedisTemplate.execute(new SessionCallback<List<Object>>() {
      @Override
      public <K, V> List<Object> execute(RedisOperations<K, V> operations)
              throws DataAccessException {
        String id = String.valueOf(10001);

        RedisOperations<String, String> operation = (RedisOperations<String, String>) operations;
        operation.multi();
        //先清除止盈缓存
        operation.boundZSetOps(stopProfitKey).remove(id);
        operation.boundZSetOps(stopProfitKey).add(id, 1);
        //先清除止损缓存
        operation.boundZSetOps(stopLossKey).remove(id);
        operation.boundZSetOps(stopLossKey).add(id, -1);
        return operation.exec();
      }
    });
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redisson-3.15.3.jar in my application and need to enable SSL. I have enabled SSL at redis with the help of this URL https://dzone.com/articles/how-to-connect-to-redis-on-java-over-ssl
It helped me generate two files: a .crt file and a .key file.
Now I need the configuration to send SSL encrypted calls to redis. I have tried the following but it didn't work:

CC: @mrniko
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3625
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am using redisson:3.13.2 as the redis client of springboot(2.2.9) project.
I build project as image and then run it locally. It works. But fail in k8s with the exception:
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.2.9.RELEASE)

2021-05-25 10:01:24.822  INFO 1 --- [           main] com.zhisheng.concise.demo.Application    : Starting Application on concise-demo-backend-6485d5755c-qp8lx with PID 1 (/service.jar started by root in /)
2021-05-25 10:01:24.825  INFO 1 --- [           main] com.zhisheng.concise.demo.Application    : The following profiles are active: test
2021-05-25 10:01:26.583  WARN 1 --- [           main] o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in '[com.zhisheng.concise.demo]' package. Please check your configuration.
2021-05-25 10:01:26.692 ERROR 1 --- [           main] o.s.boot.SpringApplication               : Application run failed

java.lang.IllegalArgumentException: Could not find class [org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration]
	at org.springframework.util.ClassUtils.resolveClassName(ClassUtils.java:334) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.core.annotation.TypeMappedAnnotation.adapt(TypeMappedAnnotation.java:446) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.core.annotation.TypeMappedAnnotation.getValue(TypeMappedAnnotation.java:369) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.core.annotation.TypeMappedAnnotation.asMap(TypeMappedAnnotation.java:284) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.core.annotation.AbstractMergedAnnotation.asAnnotationAttributes(AbstractMergedAnnotation.java:193) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.core.type.AnnotatedTypeMetadata.getAnnotationAttributes(AnnotatedTypeMetadata.java:106) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.AnnotationConfigUtils.attributesFor(AnnotationConfigUtils.java:285) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.AnnotationBeanNameGenerator.determineBeanNameFromAnnotation(AnnotationBeanNameGenerator.java:102) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.AnnotationBeanNameGenerator.generateBeanName(AnnotationBeanNameGenerator.java:81) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.registerBeanDefinitionForImportedConfigurationClass(ConfigurationClassBeanDefinitionReader.java:160) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:141) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:120) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:331) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:236) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:280) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:96) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:707) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:533) ~[spring-context-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) [spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) [spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.9.RELEASE.jar!/:2.2.9.RELEASE]
	at com.zhisheng.concise.demo.Application.main(Application.java:16) [classes!/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_202]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_202]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_202]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_202]
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) [service.jar:na]
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) [service.jar:na]
	at org.springframework.boot.loader.Launcher.launch(Launcher.java:51) [service.jar:na]
	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:52) [service.jar:na]
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration
	at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_202]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_202]
	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:92) ~[service.jar:na]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_202]
	at java.lang.Class.forName0(Native Method) ~[na:1.8.0_202]
	at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_202]
	at org.springframework.util.ClassUtils.forName(ClassUtils.java:284) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]
	at org.springframework.util.ClassUtils.resolveClassName(ClassUtils.java:324) ~[spring-core-5.2.8.RELEASE.jar!/:5.2.8.RELEASE]

I wonder what is wrong?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When we use cluster enabled Redis like AWS EC, it's possible that objects gets stored on different shards. Will the indexed based querying still work here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3627
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to bug in RedissonSemaphore#drainPermits implementation, the invocation of this methos throws ClassCastException.
    public RFuture<Integer> drainPermitsAsync() {
        return commandExecutor.evalWriteAsync(getRawName(), IntegerCodec.INSTANCE, RedisCommands.EVAL_LONG,
The return type parameter of the method is Integer but the argument evalCommandType passed to the commandExecutor is RedisCommands.EVAL_LONG
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3628
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Exception in thread "main" java.lang.NoSuchMethodError: io.netty.util.internal.ObjectUtil.checkNonEmptyAfterTrim(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; at io.netty.handler.codec.http.HttpMethod.<init>(HttpMethod.java:124) at io.netty.handler.codec.http.HttpMethod.<clinit>(HttpMethod.java:37)
<netty.version>4.1.65.Final</netty.version>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3629
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
3.2.9
Redisson version
3.5.0
Redisson configuration
redissonConfig.useClusterServers().addNodeAddress(address)
.setTimeout(1000)
.setMasterConnectionPoolSize(64)
.setSlaveConnectionPoolSize(64)
.setIdleConnectionTimeout(10000)
.setConnectTimeout(30000)
.setIdleConnectionTimeout(3000);
Use code
RLock lock = redissonClient.getLock(String.join("_", "taskExtSyncLock", taskId, classId));
if (lock.tryLock()) {
try{
//  ignore code
}catch（Exception e）{
throw e;
}finally{
if (lock != null && lock.isLocked())
{
lock.unlock();
}
}
}else {
//  ignore code
}
** Thread blocking , System restart can be unlocked   **
**The following figure shows the thread stack information **
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3630
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
List of missed methods:
bitField(byte[] key, BitFieldSubCommands subCommands)
exists(byte[]... keys)
touch(byte[]... keys)
encodingOf(byte[] key)
idletime(byte[] key)
refcount(byte[] key)
bitPos(byte[] key, boolean bit, org.springframework.data.domain.Range<Long> range)
restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis_version:6.0.2
 <!-- https://mvnrepository.com/artifact/org.redisson/redisson -->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.15.4</version>
        </dependency>

code
public class CallableTask implements Callable<Long>, Serializable {

    @Override
    public Long call() throws Exception {
        return 1L;
    }
}

main
   public static RedissonClient getRedissonClient() {
        // 默认连接地址 127.0.0.1:6379
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
        RedissonClient redisson = Redisson.create(config);
        return redisson;
    }


    public static void main(String[] args) throws ExecutionException, InterruptedException {
        RedissonClient redisson = getRedissonClient();
        ExecutorOptions options = ExecutorOptions.defaults();
        options.taskRetryInterval(10, TimeUnit.SECONDS);
        RExecutorService executorService = redisson.getExecutorService("myExecutorService", options);
        RExecutorFuture<Long> future = executorService.submit(new CallableTask());
        Long result = future.get();
        executorService.shutdown();
        redisson.shutdown();
    }


block here
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3632
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
is following exception is also related to netty version or there is other problem , by the way this is only happening  when I use it in RTopic pubsub MessageListener.OnMessage() :)
Redisson version
3.15.3
Caused by: java.io.IOException: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:65)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
... 2 more
Caused by: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:348)
at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:686)
at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:46)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1868)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
at java.util.ArrayList.readObject(ArrayList.java:797)
at sun.reflect.GeneratedMethodAccessor182.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1170)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2178)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2287)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2211)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:58)
... 23 more
ERROR 2021-06-02 18:24:58,477 - NorthstarMap.get:176 - redisson client exception: Unexpected exception while processing command
org.redisson.client.RedisException: Unexpected exception while processing command
at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:324)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:121)
at org.redisson.RedissonObject.get(RedissonObject.java:81)
at org.redisson.RedissonMap.get(RedissonMap.java:639)
at com.sibisoft.northstar.util.NorthstarMap.get(NorthstarMap.java:174)
at com.sibisoft.northstar.pms.interfaces.voicemail.homisco.HomiscoMessageListener.onMessage(HomiscoMessageListener.java:31)
at com.sibisoft.northstar.pms.interfaces.voicemail.homisco.HomiscoMessageListener.onMessage(HomiscoMessageListener.java:16)
at org.redisson.PubSubMessageListener.onMessage(PubSubMessageListener.java:79)
at org.redisson.client.RedisPubSubConnection.onMessage(RedisPubSubConnection.java:78)
at org.redisson.client.handler.CommandPubSubDecoder$1.run(CommandPubSubDecoder.java:149)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.IOException: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:65)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
... 2 more
Caused by: java.lang.ClassNotFoundException: com.sibisoft.northstar.pms.VoiceMailExtRequestDTO
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:348)
at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:686)
at org.redisson.codec.CustomObjectInputStream.resolveClass(CustomObjectInputStream.java:46)
at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1868)
at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
at java.util.ArrayList.readObject(ArrayList.java:797)
at sun.reflect.GeneratedMethodAccessor182.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1170)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2178)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2287)
at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2211)
at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069)
at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573)
at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)
at org.redisson.codec.SerializationCodec$1.decode(SerializationCodec.java:58)
... 23 more
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter/README.md
spring.redisson.config should be spring.redis.redisson.config
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, We found RedisException errors during stress testing。
CommandDecoder#handleResult running context:
CommandData<Object, Object>:
   command: ZADD
   codec: org.redisson.client.codec.StringCodec
parts: Collections.singletonList(null)
result: PONG

version:
redisson: 3.15.5
redis: 2.8.24
springboot: 1.5.22
redisson-spring-data: 3.15.5

code:
    @CachePut(key = "#resourceId",
            cacheNames = CACHE_NAME_RESOURCE_META,
            cacheManager = CACHE_MANAGER_RESOURCE_META)
    public JSONObject putCache(String resourceId, JSONObject resource) {
        return resource;
    }
Stack trace:
 org.springframework.dao.InvalidDataAccessApiUsageException: Unexpected exception while processing command; nested exception is org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:52)
	at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)
	at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:37)
	at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:230)
	at org.redisson.spring.data.connection.RedissonConnection.exec(RedissonConnection.java:1519)
	at sun.reflect.GeneratedMethodAccessor690.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.data.redis.core.CloseSuppressingInvocationHandler.invoke(CloseSuppressingInvocationHandler.java:57)
	at com.sun.proxy.$Proxy228.exec(Unknown Source)
	at org.springframework.data.redis.cache.RedisCache$RedisCachePutCallback.doInRedis(RedisCache.java:808)
	at org.springframework.data.redis.cache.RedisCache$RedisCachePutCallback.doInRedis(RedisCache.java:780)
	at org.springframework.data.redis.cache.RedisCache$AbstractRedisCacheCallback.doInRedis(RedisCache.java:578)
	at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:207)
	at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:169)
	at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:157)
	at org.springframework.data.redis.cache.RedisCache.put(RedisCache.java:233)
	at org.springframework.data.redis.cache.RedisCache.put(RedisCache.java:201)
	at org.springframework.cache.interceptor.AbstractCacheInvoker.doPut(AbstractCacheInvoker.java:85)
	at org.springframework.cache.interceptor.CacheAspectSupport$CachePutRequest.apply(CacheAspectSupport.java:783)
	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:413)
	at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:323)
	at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:61)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at com.nd.gaea.cache.aop.WafCacheAdvice.invoke(WafCacheAdvice.java:36)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:671)
	at com.nd.ndr.proxy.ResourceMetaCacheProxy$$EnhancerBySpringCGLIB$$8bb9e504.putCache(<generated>)
	at com.nd.ndr.proxy.ResourceMetaProxyAdapter.lambda$getResourceMetaBatch$6(ResourceMetaProxyAdapter.java:318)
	at com.nd.ndr.common.utils.CacheUtils.getFromL2(CacheUtils.java:146)
	at com.nd.ndr.common.utils.CacheUtils.getFromL2(CacheUtils.java:77)
	at com.nd.ndr.proxy.ResourceMetaProxyAdapter.getResourceMetaBatch(ResourceMetaProxyAdapter.java:298)
	at com.nd.ndr.proxy.ResourceMetaProxyAdapter.getResourceMetaBaseById(ResourceMetaProxyAdapter.java:109)
	at com.nd.ndr.proxy.ResourceMetaProxyAdapter$$FastClassBySpringCGLIB$$87fe52b1.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:667)
	at com.nd.ndr.proxy.ResourceMetaProxyAdapter$$EnhancerBySpringCGLIB$$a6f36903.getResourceMetaBaseById(<generated>)
	at com.nd.ndr.resource.controller.ResourceStatusController.status(ResourceStatusController.java:79)
	at com.nd.ndr.resource.controller.ResourceStatusController$$FastClassBySpringCGLIB$$d55f962b.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:736)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:96)
	at com.nd.gaea.rest.security.xss.aspect.XssFilterAspect.doAround(XssFilterAspect.java:79)
	at sun.reflect.GeneratedMethodAccessor301.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:627)
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:616)
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:671)
	at com.nd.ndr.resource.controller.ResourceStatusController$$EnhancerBySpringCGLIB$$8c08340.status(<generated>)
	at sun.reflect.GeneratedMethodAccessor660.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:854)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:765)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)
	at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:655)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:54)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.social.censor.waf.CensorExceptionFilter.doFilterInternal(CensorExceptionFilter.java:27)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:111)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:317)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.harmonyword.filter.NdrSensitiveWordFilter.doFilterInternal(NdrSensitiveWordFilter.java:44)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.globalsync.GlobalSyncFilter.doFilterInternal(GlobalSyncFilter.java:47)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.common.filter.NdrContainerReplaceFilter.doFilterInternal(NdrContainerReplaceFilter.java:35)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.common.filter.NdrParameterReplaceFilter.doFilterInternal(NdrParameterReplaceFilter.java:41)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.auth.core.filter.NdrTokenAuthenticationProcessFilter.doFilterInternal(NdrTokenAuthenticationProcessFilter.java:76)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.auth.core.filter.NdrContextValidatedFilter.doFilterInternal(NdrContextValidatedFilter.java:48)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.gaea.rest.filter.TokenAuthenticationProcessFilter.doFilterInternal(TokenAuthenticationProcessFilter.java:53)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at com.nd.ndr.common.filter.NdrContextFilter.doFilterInternal(NdrContextFilter.java:74)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331)
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.gaea.rest.filter.ExceptionFilter.doFilterInternal(ExceptionFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.gaea.rest.filter.WafContextFilter.doFilterInternal(WafContextFilter.java:42)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.gaea.rest.filter.WafHttpMethodOverrideFilter.doFilterInternal(WafHttpMethodOverrideFilter.java:76)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.gaea.rest.filter.WafCorsFilter.doFilterInternal(WafCorsFilter.java:47)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at com.nd.gaea.actuator.metrics.api.WafApiMetricFilter.doFilterInternal(WafApiMetricFilter.java:59)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:201)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:544)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:698)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:364)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:616)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:831)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1629)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)
Caused by: org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:324)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:121)
	at org.redisson.command.CommandBatchService.execute(CommandBatchService.java:196)
	at org.redisson.spring.data.connection.RedissonConnection.exec(RedissonConnection.java:1515)
	... 190 more
Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long
	at org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:27)
	at org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:23)
	at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:424)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:308)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:395)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367)
	at org.redisson.client.handler.CommandDecoder.decodeCommandBatch(CommandDecoder.java:246)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:188)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 more
>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3635
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson will   map slot-partitions  by the topology after re-sharding slots between nodes
Actual behavior
org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=8776, addr=redis://10.176.249.32:23000, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.
Steps to reproduce or test case

Initialize Redisson client and connect to redis cluster，and topology at the moment:

b95d849edb54cb15291a89ab5b04d33ecd45e5b1 10.176.35.198:6379@16379 myself,master - 0 1622711242321 0 connected 8192-16383
d5943631dc5475660fa09f4322dc58d2a708ae10 10.176.24.32:6379@16379 master - 0 1622711242334 0 connected 0-8191


Reshard the slots  between origin nodes


Wait utils the re-sharding slots finish, and the topology at the moment:


Reddsion update cluster topology, and the topology at the moment


b95d849edb54cb15291a89ab5b04d33ecd45e5b1 10.176.35.198:6379@16379 myself,master - 0 1622711053192 0 connected 0-8191
d5943631dc5475660fa09f4322dc58d2a708ae10 10.176.24.32:6379@16379 master - 0 1622711053189 0 connected 8192-16383

Try to access redis cluster
Exception happen

org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=8776, addr=redis://10.176.24.32:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet. Increase value of retryAttempts and/or retryInterval settings.

Cause analysis: org.redisson.cluster.ClusterConnectionManager#checkSlotsMigration has a bug.



the first loop:currentPartition(node:10.176.35.198:6379 slots:8192-16383) in code1 and the entry in code2 is related to partition(10.176.35.198:6379) in code
newPartition(node:10.176.35.198:6379 slots:0-8191) in code4，and add entry for slot(0-8191),MasterSlaveEntry(10.176.35.198:6379)  in code3
the second loop: currentPartition(node:10 10.176.24.32:6379 slots:0-8191) in code1 and the entry in code2 is still related to  partition(10.176.35.198:6379 ) in code, step 2 modify the mapping (0-8191-> 10.176.35.198:6379 )
newPartition(node:10 10.176.24.32:6379 slots:8192-16383) in code4，and add entry for slot(8192-16383),MasterSlaveEntry(10.176.35.198:6379)  in code3
As a result , 0-16383 is mapped to (node:10 10.176.24.32:6379)，that cause this exception.

Redis version
5.0.14
Redisson version
3.15.3
Redisson configuration
        Config config = new Config();
        config.useClusterServers().setReadMode(ReadMode.MASTER)
                .addNodeAddress("redis://10.176.24.32:6379").setScanInterval(30000);
        RedissonClient redisson = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3637
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The below code doesn't work:
        Condition condition = null;
        for (Map.Entry<String, List<String>> entry : paramMap.entrySet()) {
            if (condition == null) {
                condition = Conditions.in(entry.getKey(), entry.getValue());
            } else {
                condition = Conditions.and(condition, Conditions.in(entry.getKey(), entry.getValue()));
            }
        }

If I write the Conditions.in logic explicitly by looping the Conditions.eq, it starts working. Following code works:
        Condition condition = null;
        for (Map.Entry<String, List<String>> entry : paramMap.entrySet()) {
            Condition tempCondition = null;
            for (String param : entry.getValue()) {
                if (tempCondition == null) {
                    tempCondition = Conditions.eq(entry.getKey(), param);
                } else {
                    tempCondition = Conditions.or(tempCondition, Conditions.eq(entry.getKey(), param));
                }
            }
            if (condition == null) {
                condition = tempCondition;
            } else {
                condition = Conditions.and(condition, tempCondition);
            }
        }

Redis version
Redis 6.2.3 (00000000/0) 64 bit
Redisson version
<redisson.version>3.15.4</redisson.version>
Redisson configuration
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3638
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
return null or an result
Actual behavior
java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.lang.Double
at org.redisson.spring.data.connection.PointDecoder.decode(PointDecoder.java:44)
at org.redisson.spring.data.connection.PointDecoder.decode(PointDecoder.java:31)
at org.redisson.client.protocol.decoder.ListMultiDecoder.decode(ListMultiDecoder.java:175)
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:431)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:387)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:697)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:632)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:549)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:511)
at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Steps to reproduce or test case
this.redisTemplate.opsForGeo().position(key, members)
When getting a point without member
Redis version
5.0.10
Redisson version
3.11.4
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3639
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The problem I'm seeing is that I'm setting a Rate Limit of lets say 20/second. If there is a period where 20/s is not reached, it will compensate for that and allow a temporary burst of permits over that threshold.
I was hoping for a configuration change to set a hard limit for a rate limit -- so that irregardless of the average rate, the rate must never exceed this value.
This may be how the rate limiter is already set to function, and i've uncovered a bug, let me know if this is the case and I can attempt to simulate this issue in a test (or at least try).
This is how i'm creating my rate limiter:
RRateLimiter rl = sharedRedissonClient.getRateLimiter(this::class.simpleName);
rl.setRate(RateType.OVERALL, 18L, 1L,  RateIntervalUnit.SECONDS);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3640
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm trying to get values for a stored key from Redis and I am facing above error. I am trying to get the keys using this.redisson.getSet("TestClass"); and for saving the values to redis I am doing repo.save(TestClassObject);
I am not able to retrieve the objects when I try to this.repo.findAll() in that case I get values as a list but all elements inside the list are null. I also tried using getSet as stated above in that case I get the values but as string only hence not able to call getters as they are not of TestClass object type.
Can anyone please help with this?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3641
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi All,
Getting connection refused error while trying to use reddison-hibernate as hibernate second level cache
Please note that redis server is up and accepting redis-cli commands.
reddison hibernate version used : redisson-hibernate-53 as I am using spring data jpa that gives hibernate 5.X latest.
Also reddison.yaml is configured.
Getting the following error/
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:6379
app_1    | Caused by: java.net.ConnectException: Connection refused
app_1    |      at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:1.8.0_292]
app_1    |      at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:716) ~[na:1.8.0_292]
app_1    |      at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:707) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) ~[netty-transport-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.55.Final.jar!/:4.1.55.Final]
app_1    |      at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_292]
app_1    |
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3642
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
So I've adding redisson to my application. The config looks like what is defined here: https://pamesh12.github.io/spring-boot/spring-cache-redis.html
singleServerConfig: address: "redis://127.0.0.1:6379"
When I try adding Cacheable to the method that call external services using RestTemplate I'm able to see the result cache in redis-cli. Though when I try adding Cacheable to service methods that call underlying Mongo repositoy I'm getting IllegalArgumentException
Could someone explain if its because its not supported? I don;t remember exactly but saw that this is supported in only pro version. And if there are any alternatives I could look at without much code change.
ERROR com.controller.support.ExceptionController [http-nio-9006-exec-5]: [java.lang.IllegalArgumentException] with error Id, error code and message [[org.redisson.command.CommandAsyncService.encodeMapValue(CommandAsyncService.java:743), org.redisson.RedissonObject.encodeMapValue(RedissonObject.java:305), org.redisson.RedissonMap.fastPutOperationAsync(RedissonMap.java:1375), org.redisson.RedissonMap.fastPutAsync(RedissonMap.java:1365), org.redisson.RedissonMap.fas...
```

@Cacheable("ratings") //cacheManager = "redisCacheManager")
public List filterByRating(List vendor/, Pageable pageable/) {
    return ratingsRepo.findByIdIn(vendor/*, pageable*/);
}


Config: 

@configuration
public class RedissonSpringDataConfig {
@Bean
public RedissonConnectionFactory
redissonConnectionFactory(RedissonClient redisson) {
    return new RedissonConnectionFactory(redisson);
}

@Bean(destroyMethod = "shutdown")
public RedissonClient
redisson(@Value("classpath:redission/redisson-dev.yaml") Resource configFile)
        throws IOException {
    Config config = Config.fromYAML(configFile.getInputStream());
    return Redisson.create(config);
}

@Bean
public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redissonConnectionFactory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(redissonConnectionFactory);
    template.setKeySerializer(new StringRedisSerializer());
    template.setValueSerializer(new StringRedisSerializer());
    return template;
}

@Bean(name = "redisCacheManager")
public CacheManager redisCacheManager(RedissonClient redissonClient) throws IOException {
    //String configFileName = "cache-config-" + activeProfile + ".yml";
    return new RedissonSpringCacheManager(redissonClient);
}

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3643
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/3645
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Store an object of size greater than 64kb as allowable in docs.
Actual behavior
Client throws exception org.redisson.client.RedisException: ERR Protocol error: too big inline request
Steps to reproduce or test case
String baseString = "ba xy";
String dummyString = "";
for (int i = 0; i < ((1024*64)); i++) {
    dummyString = dummyString + baseString;
}
RBucket bucket = client.getBucket("key");
bucket.set(dummyString, 300, TimeUnit.SECONDS);
Redis version
5.0.12
Redisson version
3.15.5
Redisson configuration
Single server configuration w/ sslEnableEndpointIdentification = false. I've tried with both StringCodec and FstCodec with no success.
Let me know if there's a configuration to avoid inlining the request, I couldn't find one via the docs.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3646
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson client should be stable.
Actual behavior
Over the weekend we noticed that roughly 50,000 connections were made from Redisson clients or our AWS Elasticache Redis cluster. Typically our Redis cluster has a little over 1000 client connections. This introduced a lot of load on the Redis cluster until requests started timing out. Rebooting applications that use Redis seemed to remediate the issue. There are still some Redisson clients in a broken state.


One service is repeatedly logging the following a day later and is in a broken state.

org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: <redacted>:6379 Disconnected hosts: [<redacted>:6379] Hosts disconnected due to errors during `failedSlaveCheckInterval`: [<redacted>:6379] 	
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:218) 	
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30) 	
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:267) 	
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:500) 	
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:572) 	
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:648) 	
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:116) 	
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:244) 	
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) 
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) 	
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) 	
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	
at java.lang.Thread.run(Unknown Source)

I worked with our SRE team and with the use of netstat we discovered that this application was holding 2400 open connections to the Redis cluster! Typically each application will hold around 28 connections.
Rebooting the application resolves the issue, which seems to indicate it is a client side issue.
I looked back to when the issue started to occur and see no logs about creating new client connections. All I see are Redis operations beginning to timeout.
Steps to reproduce or test case
Unclear. We have been running this version of Redisson for months without issue. Typically our services are running for a maximum of 7 days.
Redis version
6.0.5
Redisson version
3.14.1
Redisson configuration
  public RedissonClient build() {

    final Config config = new Config();
    final ReplicatedServersConfig replicatedConfig = config.useReplicatedServers();
    nodes.forEach(replicatedConfig::addNodeAddress);

    if (!Strings.isNullOrEmpty(password)) {
      replicatedConfig.setPassword(password);
    }

    final RedissonClient redissonClient = Redisson.create(config);

    // If tracer is configured, wrap the client.
    if (tracer != null) {
      final TracingConfiguration tracingConfiguration = new TracingConfiguration.Builder(tracer)
          .build();
      return new TracingRedissonClient(redissonClient, tracingConfiguration);
    }

    return redissonClient;
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3647
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis_version:3.0.6 /redis_version:6.2.4  ，Non-distributed
 <dependency>
                <groupId>org.redisson</groupId>
                <artifactId>redisson</artifactId>
                <version>3.15.4</version>
            </dependency>

i read RMapReduce document 9.5  链接
Copy code in local ，but it does not work
block here

What happened here? Thank you
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3648
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I have 100 keys in redis
reactiveClient.keys.getKeysByPattern(null) size should be 100
Actual behavior
reactiveClient.keys.getKeysByPattern(null) size is 47 (always getting the magical result with size of 47...)
Steps to reproduce or test case
insert any number e.g. 100 of keys in local Redis console
call reactiveClient.keys.getKeysByPattern(null) --> get a Flux of size 47
call normalRedisClient.keys.getKeysByPattern(null) --> get correct list of size 100
Redis version
Redisson version
<redisson.version>3.15.5</redisson.version>
Redisson configuration
config.useSingleServer()
.setAddress("redis://${redis.host}:${redis.port}")
.setConnectionMinimumIdleSize(0)
.setSubscriptionConnectionMinimumIdleSize(0)
.setTimeout(20)
.setRetryAttempts(3)
.setRetryInterval(20)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3649
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3650
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson client could reconnect to redis server after network problem had been fixed
Actual behavior
Redisson client can't get data and threw InvalidDataAccessApiUsageException like below.
After we redeploy the project, redisson client can get data finally.
org.springframework.dao.InvalidDataAccessApiUsageException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1675505444 [redisClient=[addr=redis://....:6379], channel=[id: 0xc8213a39, L:/....48312 - R:/....:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@68d2affc(failure: java.util.concurrent.CancellationException)], command=(GET), params=[....., codec=org.redisson.codec.JsonJacksonCodec]], command: (INFO DEFAULT), params: [] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1675505444 [redisClient=[addr=redis://....:6379], channel=[id: 0xc8213a39, L:/.... - R:/....], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@68d2affc(failure: java.util.concurrent.CancellationException)], command=(GET), params=[....], codec=org.redisson.codec.JsonJacksonCodec]], command: (INFO DEFAULT), params: [] after 3 retry attempts\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)\n\tat org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)\n\tat org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:217)\n\tat org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:212)\n\tat org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:378)\n\tat org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:759)\n\tat org.redisson.spring.data.connection.RedissonConnection.info(RedissonConnection.java:1706)\n\tat io.opentracing.contrib.redis.spring.data2.connection.TracingRedisConnection.lambda$info$169(TracingRedisConnection.java:1073)\n\tat io.opentracing.contrib.redis.common.TracingHelper.activateAndCloseSpan(TracingHelper.java:314)\n\tat io.opentracing.contrib.redis.common.TracingHelper.doInScope(TracingHelper.java:293)\n\tat io.opentracing.contrib.redis.spring.data2.connection.TracingRedisConnection.info(TracingRedisConnection.java:1073)\n\tat org.springframework.boot.actuate.redis.RedisHealthIndicator.doHealthCheck(RedisHealthIndicator.java:64)\n\tat org.springframework.boot.actuate.health.AbstractHealthIndicator.health(AbstractHealthIndicator.java:82)\n\tat org.springframework.boot.actuate.health.HealthIndicator.getHealth(HealthIndicator.java:37)\n\tat org.springframework.boot.actuate.health.HealthEndpointWebExtension.getHealth(HealthEndpointWebExtension.java:95)\n\tat org.springframework.boot.actuate.health.HealthEndpointWebExtension.getHealth(HealthEndpointWebExtension.java:43)\n\tat org.springframework.boot.actuate.health.HealthEndpointSupport.getContribution(HealthEndpointSupport.java:108)\n\tat org.springframework.boot.actuate.health.HealthEndpointSupport.getAggregateHealth(HealthEndpointSupport.java:119)\n\tat org.springframework.boot.actuate.health.HealthEndpointSupport.getContribution(HealthEndpointSupport.java:105)\n\tat org.springframework.boot.actuate.health.HealthEndpointSupport.getHealth(HealthEndpointSupport.java:83)\n\tat org.springframework.boot.actuate.health.HealthEndpointSupport.getHealth(HealthEndpointSupport.java:70)\n\tat org.springframework.boot.actuate.health.HealthEndpointWebExtension.health(HealthEndpointWebExtension.java:81)\n\tat org.springframework.boot.actuate.health.HealthEndpointWebExtension.health(HealthEndpointWebExtension.java:70)\n\tat jdk.internal.reflect.GeneratedMethodAccessor315.invoke(Unknown Source)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\n\tat org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282)\n\tat org.springframework.boot.actuate.endpoint.invoke.reflect.ReflectiveOperationInvoker.invoke(ReflectiveOperationInvoker.java:77)\n\tat org.springframework.boot.actuate.endpoint.annotation.AbstractDiscoveredOperation.invoke(AbstractDiscoveredOperation.java:60)\n\tat org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter.handle(AbstractWebMvcEndpointHandlerMapping.java:305)\n\tat org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$OperationHandler.handle(AbstractWebMvcEndpointHandlerMapping.java:388)\n\tat jdk.internal.reflect.GeneratedMethodAccessor299.invoke(Unknown Source)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n\tat org.springframework.boot.actuate.autoconfigure.web.servlet.CompositeHandlerAdapter.handle(CompositeHandlerAdapter.java:58)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:634)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\n\tat org.apache.catalina.core.StandardHostValve.invoke$original$aqx6gJ2j(StandardHostValve.java:139)\n\tat org.apache.catalina.core.StandardHostValve.invoke$original$aqx6gJ2j$accessor$VB6wvAMh(StandardHostValve.java)\n\tat org.apache.catalina.core.StandardHostValve$auxiliary$fS8N5LVT.call(Unknown Source)\n\tat org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter.intercept(InstMethodsInter.java:86)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\n\tat org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:747)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\nCaused by: org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1675505444 [redisClient=[addr=redis://....:6379], channel=[id: 0xc8213a39, L:/....:48312 - R:/....:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@68d2affc(failure: java.util.concurrent.CancellationException)], command=(GET), params=[....], codec=org.redisson.codec.JsonJacksonCodec]], command: (INFO DEFAULT), params: [] after 3 retry attempts\n\tat org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200)\n\tat io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)\n\tat io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)\n\tat io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\t... 1 common frames omitted\n
Steps to reproduce or test case
rbucket.get(....)
Redis version
redis 4.0, redis in the cloud
redis server can be invoked successfully by cli
Redisson version
3.13.2
Redisson configuration
useSingleServer()
.setConnectionMinimumIdleSize(10)
.setConnectionPoolSize(200)
.setIdleConnectionTimeout(5000)
.setTimeout(3000);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3652
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my redission version is 3.15.1. using spring boot 2.4.1.
i run a task once per second, and will finish in 3 seconds,  but the timeout is 2 second,  this will trigger a new task to run, when the old task finish,  it will encounter and error, which cause the whole schedule task will no run anymore.
here is my example to reproduce the case:
@Slf4j
@SpringBootTest
public class TimeoutDemo {

    @Autowired
    private BeanFactory beanFactory;

    @Autowired
    private RedissonClient redisson;
    
    private static final String scheduleName = "timeout23";
   
    // flag for only wait first time
    private static final AtomicBoolean flag = new AtomicBoolean(false);

    @Test
    public void testTimeout() {
        RScheduledExecutorService executorService = getExecutorService();

        Runnable task = (Runnable & Serializable) () -> {
            log.info("hello world executed start {}", System.currentTimeMillis());
            // sleep not work, interrupt state will clear, see
            // at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:244)

            // only wait first time
            if(flag.compareAndSet(false, true)) {
                final long l = System.currentTimeMillis();
                while (System.currentTimeMillis() <= l + 3*1000) {
                }
            }
            log.info("hello world executed end  {}", System.currentTimeMillis());
        };
        executorService.schedule(task, CronSchedule.of("0/1 * * * * ?"));
        sleep();
    }

 
    // here i set the task timeout to 2 seconds
    private RScheduledExecutorService getExecutorService() {
        ExecutorOptions executorOptions = ExecutorOptions.defaults()
                .taskRetryInterval(15, TimeUnit.SECONDS);
        RScheduledExecutorService executorService = redisson.getExecutorService(scheduleName, executorOptions);
        WorkerOptions workerOptions = WorkerOptions.defaults().taskTimeout(2, TimeUnit.SECONDS);
        workerOptions.beanFactory(beanFactory);
        executorService.registerWorkers(workerOptions);
        return executorService;
    }

    private void sleep() {
        while (true) {
            silentSleep(1000);
        }
    }

    private void silentSleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (Exception e) {

        }
    }

}
this is the output log
00:38:20.096 [redisson-3-4] INFO  - [hello world executed start 1623256700096                                        ] - Caller+0	 at com.hello.redis.redisson.executor.schedule.TimeoutDemo.lambda$testTimeout$f0854f4e$1(TimeoutDemo.java:36)
00:38:22.104 [redisson-3-6] INFO  - [hello world executed start 1623256702104                                        ] - Caller+0	 at com.hello.redis.redisson.executor.schedule.TimeoutDemo.lambda$testTimeout$f0854f4e$1(TimeoutDemo.java:36)
00:38:23.098 [redisson-3-4] INFO  - [hello world executed end  1623256703098                                         ] - Caller+0	 at com.hello.redis.redisson.executor.schedule.TimeoutDemo.lambda$testTimeout$f0854f4e$1(TimeoutDemo.java:42)
00:38:23.105 [redisson-3-4] ERROR - [Can't execute: RemoteServiceRequest [requestId=018a42b46241520950c05530460c14abd8, methodName=schedule, signature=[J@138edd39, args=[org.redisson.executor.params.ScheduledCronExpressionParameters@77413796], options=RemoteInvocationOptions[ackTimeoutInMillis=null, executionTimeoutInMillis=null], date=1623256699204]] - Caller+0	 at org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:119)
java.lang.reflect.InvocationTargetException: null
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:105)
	at org.redisson.RedissonRemoteService.lambda$executeMethod$11(RedissonRemoteService.java:453)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: org.redisson.client.RedisException: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@154c1471(incomplete)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:142)
	at org.redisson.remote.AsyncRemoteProxy$2.cancel(AsyncRemoteProxy.java:299)
	at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:158)
	... 12 common frames omitted
Caused by: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@154c1471(incomplete)
	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:244)
	at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)
	at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:139)
	... 14 common frames omitted
00:38:25.105 [redisson-3-6] INFO  - [hello world executed end  1623256705105  


at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:158)

and at this line the  catch exception is
org.redisson.client.RedisException: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@71752bda(incomplete)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:142)
	at org.redisson.command.CommandSyncService.evalWrite(CommandSyncService.java:70)
	at org.redisson.executor.TasksRunnerService.finish(TasksRunnerService.java:388)
	at org.redisson.executor.TasksRunnerService.executeRunnable(TasksRunnerService.java:352)
	at org.redisson.executor.TasksRunnerService.schedule(TasksRunnerService.java:154)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.redisson.executor.RedissonExecutorRemoteService.invokeMethod(RedissonExecutorRemoteService.java:105)
	at org.redisson.RedissonRemoteService.lambda$executeMethod$11(RedissonRemoteService.java:453)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.InterruptedException: ImmediateEventExecutor$ImmediatePromise@71752bda(incomplete)
	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:244)
	at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)
	at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:139)
	... 17 more


Redis version
redis 5.0.7
Redisson version
3.15.1
Redisson configuration
    @Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient(){
        Config config = new Config();
        config.useSingleServer()
                .setAddress("redis://127.0.0.1:6379")
        ;
        return Redisson.create(config);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3653
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson shutdown takes much time if RBatch executed in REDIS_WRITE_ATOMIC or REDIS_READ_ATOMIC mode.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Sorry if this is obvious, but i did not find any documentstion about this:
If i am using RBatch and create let's say a Bucket from it, and call setAsync on the bucket 100 times before executing the batch, is the order of the operations in the batch guaranteed to be the order in which
setAsync(Object)

has been called?
In other words, is there any way i could end up with anything but the last value i set to the bucket after the RBatch is executed? For instance if the Marshalling of the 99th value took some time?
Bucket is just an example here, i am also using RMaps the same way.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3655
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to use a Redisson pubsub solution between several nodes running jobs.
Redisson crashes when trying to deserialize a message published by another node.
Quarkus version: 1.13.4.Final
Expected behavior
The message subscriber should receive the message without error
Actual behavior
Publishing works just fine. When the subscriber receives a message, a ClassNotFoundException is thrown during deserialization
2021-05-26 12:39:38,151 ERROR [org.red.cli.han.CommandPubSubDecoder] (redisson-netty-2-13) Unable to decode data. channel: [id: 0xb6172e95, L:/127.0.0.1:56969 - R:localhost/127.0.0.1:6379], reply: ReplayingDecoderByteBuf(ridx=228, widx=228): java.io.IOException: java.lang.ClassNotFoundException: org.acme.interfaces.dto.DTOJobTerminationRequest
        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)
        at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367)
        at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(CommandPubSubDecoder.java:72)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
        at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:88)
        at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
        at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.base/java.lang.Thread.run(Thread.java:830)
Caused by: java.lang.ClassNotFoundException: org.acme.interfaces.dto.DTOJobTerminationRequest
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:602)
        at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
        at io.quarkus.bootstrap.classloading.QuarkusClassLoader.loadClass(QuarkusClassLoader.java:421)
        at io.quarkus.bootstrap.classloading.QuarkusClassLoader.loadClass(QuarkusClassLoader.java:371)
        at java.base/java.lang.Class.forName0(Native Method)
        at java.base/java.lang.Class.forName(Class.java:416)
        at org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129)
        at org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110)
        at org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048)
        at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381)
        at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298)
        at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231)
        at org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41)
        at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146)
        ... 25 more

Steps to reproduce or test case
Subscribe to any message while running Redisson under Quarkus
Redis version
redis_version:5.0.8
Redisson version
3.15.6
Redisson configuration
        Config config = new Config();
        config.useSingleServer().setAddress(connectionString);
        redissonClient = Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3656
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When useScriptCache = true is in config evalsha should be used for all script executions rather than eval to reduce network load as specified in the docs.
Actual behavior
When useScriptCache = true in config eval rather than evalsha gets used for each lock call resulting in significant network load.
Steps to reproduce or test case

Open Redis CLI
Execute MONITOR command to see commands executed on Redis
Run redisson.getFairLock('lock-test').tryLock(10, TimeUnit.SECONDS); using the configuration below.

Note the EVAL from the MONITOR:
"EVAL" "while true do local firstThreadId2 = redis.call('lindex', KEYS[2], 0);if firstThreadId2 == false then break;end; local timeout = tonumber(redis.call('zscore', KEYS[3], firstThreadId2));if timeout <= tonumber(ARGV[4]) then redis.call('zrem', KEYS[3], firstThreadId2); redis.call('lpop', KEYS[2]); else break;end; end;if (redis.call('exists', KEYS[1]) == 0) then local nextThreadId = redis.call('lindex', KEYS[2], 0); if nextThreadId ~= false then redis.call('publish', KEYS[4] .. ':' .. nextThreadId, ARGV[1]); end; return 1; end;if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); if (counter > 0) then redis.call('pexpire', KEYS[1], ARGV[2]); return 0; end; redis.call('del', KEYS[1]); local nextThreadId = redis.call('lindex', KEYS[2], 0); if nextThreadId ~= false then redis.call('publish', KEYS[4] .. ':' .. nextThreadId, ARGV[1]); end; return 1; "
The reason for this is that CommandBatchService is hardcoded to ignore the config setting:

  
    
      redisson/redisson/src/main/java/org/redisson/command/CommandBatchService.java
    
    
        Lines 504 to 507
      in
      05bbe1c
    
  
  
    

        
          
           @Override 
        

        
          
           protected boolean isEvalCacheActive() { 
        

        
          
               return false; 
        

        
          
           } 
        
    
  


CommandBatchService is used by RedisBaseLock when executing its scripts.
Redis version
6.2
Redisson version
3.15.4
Redisson configuration
Config config = new Config();
config.setUseScriptCache(true);
config.useSingleServer()
   .setConnectionPoolSize(1024)
   .setAddress(String.format("redis://%s:%s", redisHost, redisPort));
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3657
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3658
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
How do I add the lowest possible TTL to Redisson? Some caches expire after long time. Or would it be better to write clear() on Spring application ready event?
This is what the Config looks like:
@Bean
public RedissonConnectionFactory
redissonConnectionFactory(RedissonClient redisson) {
    return new RedissonConnectionFactory(redisson);
}

@Bean(destroyMethod = "shutdown")
public RedissonClient
redisson(@Value("classpath:redission/redisson-dev.yaml") Resource configFile)
        throws IOException {
    Config config = Config.fromYAML(configFile.getInputStream());
    return Redisson.create(config);
}

@Bean
public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redissonConnectionFactory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(redissonConnectionFactory);
    template.setKeySerializer(new StringRedisSerializer());
    template.setValueSerializer(new StringRedisSerializer());
    return template;
}

@Bean(name = "redisCacheManager")
public CacheManager redisCacheManager(RedissonClient redissonClient) throws IOException {
    //String configFileName = "cache-config-" + activeProfile + ".yml";
    return new RedissonSpringCacheManager(redissonClient);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm seeing these errors in logs, this for Instant and others for Enums as well
My value serializer is StringSerializer and the codec is not defined explicitly so it would be picking by default.
What would be the issue? Do I need to change to JDK serializer or Jackson one?
2021-06-14 15:00:19,622 ERROR org.redisson.client.handler.CommandDecoder [redisson-netty-5-21] Unable to decode data. channel: [id: 0xa39136eb, L:/10.11.4.187:52704 - R:redis/172.20.33.10:6379], reply: ReplayingDecoderByteBuf(ridx=712, widx=712), command: (HGET), params: [new-vendor-date, PooledUnsafeDirectByteBuf(ridx: 0, widx: 469, cap: 512)]
java.lang.ClassCastException: Cannot cast java.lang.String to java.time.Instant
    at java.base/java.lang.Class.cast(Unknown Source)
    at org.jboss.marshalling.reflect.SerializableField.setObject(SerializableField.java:342)
    at org.jboss.marshalling.river.RiverUnmarshaller.readFields(RiverUnmarshaller.java:1864)
    at org.jboss.marshalling.river.RiverUnmarshaller.doInitSerializable(RiverUnmarshaller.java:1778)
    at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1406)
    at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283)
    at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231)
    at org.jboss.marshalling.river.RiverUnmarshaller.doReadCollectionObject(RiverUnmarshaller.java:187)
    at org.jboss.marshalling.river.RiverUnmarshaller.readCollectionData(RiverUnmarshaller.java:861)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In #3399, RExpirable#expireAt(Date) is deprecated, and the javadoc said Use expireAt(Instant) instead (in latest release it is called expire(Instant)).
But I notice that the implementaions of this two method is not equivalent actually.
This breaks some object expiration, such as RedissonBloomFilter.
Expected behavior
calling expire(Instant) should expire bloomfilter name and configName both
Actual behavior
only bloomfilter name is expired
Steps to reproduce or test case
expireAt(Date) calls expireAtAsync which is overridden in RedissonBloomFilter which expire name and configName both

  
    
      redisson/redisson/src/main/java/org/redisson/RedissonExpirable.java
    
    
         Line 58
      in
      5793388
    
  
  
    

        
          
           return commandExecutor.get(expireAtAsync(timestamp)); 
        
    
  



  
    
      redisson/redisson/src/main/java/org/redisson/RedissonBloomFilter.java
    
    
         Line 293
      in
      5793388
    
  
  
    

        
          
           return expireAsync(timeToLive, timeUnit, getName(), configName); 
        
    
  


expire(Instant) calls expireAtAsync(instant) which only expire name

  
    
      redisson/redisson/src/main/java/org/redisson/RedissonExpirable.java
    
    
         Line 68
      in
      5793388
    
  
  
    

        
          
           return get(expireAtAsync(instant)); 
        
    
  



  
    
      redisson/redisson/src/main/java/org/redisson/RedissonExpirable.java
    
    
         Line 73
      in
      5793388
    
  
  
    

        
          
           return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.PEXPIREAT, getName(), instant.toEpochMilli());
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3662
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
We understand that whenever we merge/persist a RLOS object, it will also created indices inside Redis for fields annotated with RIndex. Basically, this merge/persist operation includes multiple writes being carried out on the cache.
Is it fair to assume that this entire operation is a transaction, i.e. if any of the writes fail due to any reason, it will do a rollback and throw an error to the caller?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3663
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3666
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
Are there any plans to introduce reactive support for RLOS? If yes, by when do you think it will be available?
Thanks!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3667
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
RedissonReactiveSubscription keep the listener to process messages continuously
Actual behavior
RedissonReactiveSubscription remove listener after first 32 messages
Steps to reproduce or test case
using spring data redis backed by redisson to subscribe message from redis
Flux<Quote> quoteFlux = this.reactiveRedisTemplate.listenTo(ChannelTopic.of(quoteTopic)).subscribe();
after 32 messages, RedissonReactiveSubscription remove listener.
when debug I see that, it have counter with init value = 32, and it decrease to 0 and dispose ==> remove listener
in method receive()
line 233
emitter.onRequest(n -> {
...
AtomicLong counter = new AtomicLong(n);

n, counter = 32
line 245
@Override
public void onMessage(CharSequence channel, Object msg) {
    if (!channels.containsKey(new ChannelName(channel.toString()))) {
        return;
    }

emitter.next(new ChannelMessage<>(ByteBuffer.wrap(channel.toString().getBytes()), ByteBuffer.wrap((byte[])msg)));

  if (counter.decrementAndGet() == 0) {
      disposable.dispose();
      emitter.complete();
  }
}
onMessage after each call counter decreased, when received 32 messages, counter = 0 and call disposable.dispose();,
  disposable = () -> {
                        for (Entry<ChannelName, PubSubConnectionEntry> entry : channels.entrySet()) {
                            entry.getValue().removeListener(entry.getKey(), listener);
                        }
                        for (Entry<ChannelName, Collection<PubSubConnectionEntry>> entry : patterns.entrySet()) {
                            for (PubSubConnectionEntry pubSubConnectionEntry : entry.getValue()) {
                                pubSubConnectionEntry.removeListener(entry.getKey(), listener);
                            }
                        }
                    };
Redis version
6.2.4
Redisson version
3.15.6
reactor-core version: 3.4.6
Redisson configuration
    @Bean
    ReactiveRedisOperations<String, Object> reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
        KryoRedisSerializer serializer = new KryoRedisSerializer();

        RedisSerializationContext.RedisSerializationContextBuilder<String, Object> builder =
                RedisSerializationContext.newSerializationContext(new StringRedisSerializer());

        RedisSerializationContext<String, Object> context = builder.value(serializer).build();

        return new ReactiveRedisTemplate<>(factory, context);
    }
singleServerConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  password: null
  subscriptionsPerConnection: 5
  clientName: null
  address: "redis://127.0.0.1:6379"
  subscriptionConnectionMinimumIdleSize: 1
  subscriptionConnectionPoolSize: 50
  connectionMinimumIdleSize: 10
  connectionPoolSize: 64
  database: 0
  dnsMonitoringInterval: 5000
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
It should not throw an error and only use the columns that are present in the entity, unfortunately I don't know exactly how redisson stores that.
Actual behavior
If you have an entity and add or remove a column and try to load it, you get an error.
Steps to reproduce or test case
Run 2 Java applications use hibernate-core (5.5.2.Final) and redisson-hibernate-53 (3.13.4) and setup redisson 2LD cache.
First Application has the "old" entity like:
`
public class TestEntity implements Serializable {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "p_id", updatable = false, unique = true, nullable = false)
private Long id;

@NaturalId
@Column(name = "p_uuid")
private String uuid;

@Column(name = "p_name")
private String name;

@Column(name = "test_int")
private int test;

}
`
And the second application has the "new" entity like:
`
public class TestEntity implements Serializable {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "p_id", updatable = false, unique = true, nullable = false)
private Long id;

@NaturalId
@Column(name = "p_uuid")
private String uuid;

@Column(name = "p_name")
private String name;

@Column(name = "test_int")
private int test;

@Column(name = "bool")
private boolean bool;

}
`
Then try to load it on the first application it will work. But then try to load it on the second application and you will get this exception:
java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 at org.hibernate.type.TypeHelper.assemble(TypeHelper.java:97) at org.hibernate.cache.spi.entry.StandardCacheEntryImpl.assemble(StandardCacheEntryImpl.java:135) at org.hibernate.loader.entity.CacheEntityLoaderHelper.convertCacheEntryToEntity(CacheEntityLoaderHelper.java:308) at org.hibernate.loader.entity.CacheEntityLoaderHelper.processCachedEntry(CacheEntityLoaderHelper.java:174) at org.hibernate.loader.entity.CacheEntityLoaderHelper.loadFromSecondLevelCache(CacheEntityLoaderHelper.java:147) at org.hibernate.event.internal.DefaultLoadEventListener.doLoad(DefaultLoadEventListener.java:523) at org.hibernate.event.internal.DefaultLoadEventListener.load(DefaultLoadEventListener.java:208) at org.hibernate.event.internal.DefaultLoadEventListener.proxyOrLoad(DefaultLoadEventListener.java:327) at org.hibernate.event.internal.DefaultLoadEventListener.doOnLoad(DefaultLoadEventListener.java:108) at org.hibernate.event.internal.DefaultLoadEventListener.onLoad(DefaultLoadEventListener.java:74) at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:118) at org.hibernate.internal.SessionImpl.fireLoadNoChecks(SessionImpl.java:1215) at org.hibernate.internal.SessionImpl.fireLoad(SessionImpl.java:1204) at org.hibernate.internal.SessionImpl.access$2100(SessionImpl.java:203) at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.doLoad(SessionImpl.java:2819) at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.lambda$load$1(SessionImpl.java:2796) at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.perform(SessionImpl.java:2752) at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.load(SessionImpl.java:2796) at org.hibernate.internal.SessionImpl$SimpleNaturalIdLoadAccessImpl.load(SessionImpl.java:3241) at net.rushnation.rushhandler.command.CommandTest$CommandInsert.run(CommandTest.java:27) at picocli.CommandLine.executeUserObject(CommandLine.java:1939) at picocli.CommandLine.access$1300(CommandLine.java:145) at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2352) at picocli.CommandLine$RunLast.handle(CommandLine.java:2346) at picocli.CommandLine$RunLast.handle(CommandLine.java:2311) at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2179) at picocli.CommandLine.execute(CommandLine.java:2078) at net.rushnation.rushhandler.utils.terminal.TerminalConsole.runCommand(TerminalConsole.java:24) at net.minecrell.terminalconsole.SimpleTerminalConsole.processInput(SimpleTerminalConsole.java:87) at net.minecrell.terminalconsole.SimpleTerminalConsole.readCommands(SimpleTerminalConsole.java:168) at net.minecrell.terminalconsole.SimpleTerminalConsole.start(SimpleTerminalConsole.java:141) at net.rushnation.rushhandler.RushHandler.lambda$setupTerminal$2(RushHandler.java:202) at java.base/java.lang.Thread.run(Thread.java:834)
if you clear the cache and load it on the second application first and try to load in on the first application you will get this error:
org.hibernate.PropertyAccessException: Could not set field value [true] value by reflection : [class net.rushnation.database.entities.test.TestEntity.name] setter of net.rushnation.database.entities.test.TestEntity.name at org.hibernate.property.access.spi.SetterFieldImpl.set(SetterFieldImpl.java:72) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.tuple.entity.AbstractEntityTuplizer.setPropertyValues(AbstractEntityTuplizer.java:681) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.tuple.entity.PojoEntityTuplizer.setPropertyValues(PojoEntityTuplizer.java:144) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.persister.entity.AbstractEntityPersister.setPropertyValues(AbstractEntityPersister.java:5242) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.cache.spi.entry.StandardCacheEntryImpl.assemble(StandardCacheEntryImpl.java:159) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.loader.entity.CacheEntityLoaderHelper.convertCacheEntryToEntity(CacheEntityLoaderHelper.java:308) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.loader.entity.CacheEntityLoaderHelper.processCachedEntry(CacheEntityLoaderHelper.java:174) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.loader.entity.CacheEntityLoaderHelper.loadFromSecondLevelCache(CacheEntityLoaderHelper.java:147) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.internal.DefaultLoadEventListener.doLoad(DefaultLoadEventListener.java:523) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.internal.DefaultLoadEventListener.load(DefaultLoadEventListener.java:208) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.internal.DefaultLoadEventListener.proxyOrLoad(DefaultLoadEventListener.java:327) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.internal.DefaultLoadEventListener.doOnLoad(DefaultLoadEventListener.java:108) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.internal.DefaultLoadEventListener.onLoad(DefaultLoadEventListener.java:74) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:118) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl.fireLoadNoChecks(SessionImpl.java:1215) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl.fireLoad(SessionImpl.java:1204) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl.access$2100(SessionImpl.java:203) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.doLoad(SessionImpl.java:2819) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.lambda$load$1(SessionImpl.java:2796) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.perform(SessionImpl.java:2752) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl$IdentifierLoadAccessImpl.load(SessionImpl.java:2796) ~[rushhandler-1.0-SNAPSHOT.jar:?] at org.hibernate.internal.SessionImpl$SimpleNaturalIdLoadAccessImpl.load(SessionImpl.java:3241) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.rushnation.rushhandler.command.CommandTest$CommandInsert.run(CommandTest.java:27) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine.executeUserObject(CommandLine.java:1939) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine.access$1300(CommandLine.java:145) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2352) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine$RunLast.handle(CommandLine.java:2346) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine$RunLast.handle(CommandLine.java:2311) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2179) ~[rushhandler-1.0-SNAPSHOT.jar:?] at picocli.CommandLine.execute(CommandLine.java:2078) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.rushnation.rushhandler.utils.terminal.TerminalConsole.runCommand(TerminalConsole.java:24) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.minecrell.terminalconsole.SimpleTerminalConsole.processInput(SimpleTerminalConsole.java:87) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.minecrell.terminalconsole.SimpleTerminalConsole.readCommands(SimpleTerminalConsole.java:168) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.minecrell.terminalconsole.SimpleTerminalConsole.start(SimpleTerminalConsole.java:141) ~[rushhandler-1.0-SNAPSHOT.jar:?] at net.rushnation.rushhandler.RushHandler.lambda$setupTerminal$2(RushHandler.java:202) ~[rushhandler-1.0-SNAPSHOT.jar:?] at java.lang.Thread.run(Thread.java:834) [?:?] Caused by: java.lang.IllegalArgumentException: Can not set java.lang.String field net.rushnation.database.entities.test.TestEntity.name to java.lang.Boolean at jdk.internal.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167) ~[?:?] at jdk.internal.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:171) ~[?:?] at jdk.internal.reflect.UnsafeObjectFieldAccessorImpl.set(UnsafeObjectFieldAccessorImpl.java:81) ~[?:?] at java.lang.reflect.Field.set(Field.java:780) ~[?:?] at org.hibernate.property.access.spi.SetterFieldImpl.set(SetterFieldImpl.java:52) ~[rushhandler-1.0-SNAPSHOT.jar:?]
Redis version
redis_version:5.0.3
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:94145a25ce04923
redis_mode:standalone
Redisson version
 
            org.redisson
            redisson-hibernate-53
            3.13.4
        
Redisson configuration
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 8000
retryAttempts: 3
retryInterval: 1500
password:
subscriptionsPerConnection: 5
clientName: null
address: "redis://127.0.0.1:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 16
connectionMinimumIdleSize: 10
connectionPoolSize: 32
database: 0
dnsMonitoringInterval: 5000
threads: 16
nettyThreads: 16
codec: null
useThreadClassLoader: false
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3669
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can't set expiration time for bloomFilter key?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3670
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why does expire method not work for reactive client?
    RedissonReactiveClient rclient = ....;
    RBucketReactive<String> bucket = rclient.getBucket("demo");
    bucket.set("hello world").subscribe();
    bucket.expire(5, TimeUnit.SECONDS).subscribe();
    rclient.shutdown();

I can still see the keys and values after 10 seconds. Looks like the client should not be shutdown to expire the keys? Can we not set the expire key as part of the expire method invocation itself?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Why do we not have getLocalCachedMap for a reactive client when the blocking client has it.?
https://www.javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RedissonReactiveClient.html
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3672
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can we have corresponding reactive interfaces for below interfaces?
MapLoader
MapWriter
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3673
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Steps:

Create a RBlockingDequeReactive<Long> queue;
Create a producer to produce 100 items into the queue.

        Mono<Void> mono = Flux.range(1, 100)
                .flatMap(s -> this.queue.add(Long.valueOf(s)))
                .then();
        StepVerifier.create(mono)
                .verifyComplete();


Verify in redis that we have 100 elements in the List.
Now consume elements from the queue. (add delayElements to replicate this issue) It consumes only 32 elements. we lose all other items.

        this.queue.takeElements()
                .delayElements(Duration.ofMillis(2))
                .doOnNext(System.out::println)
                .doOnError(System.out::println)
                .repeat()
                .retry()
                .subscribe();

Log:
[ INFO] (main) onSubscribe(FluxCreate.BufferAsyncSink)
[ INFO] (main) request(32)
[ INFO] (main) onNext(1)
[ INFO] (redisson-netty-2-2) onNext(2)
[ INFO] (redisson-netty-2-5) onNext(3)
[ INFO] (redisson-netty-2-3) onNext(4)
[ INFO] (redisson-netty-2-10) onNext(5)
[ INFO] (redisson-netty-2-11) onNext(6)
[ INFO] (redisson-netty-2-6) onNext(7)
[ INFO] (redisson-netty-2-4) onNext(8)
[ INFO] (redisson-netty-2-8) onNext(9)
[ INFO] (redisson-netty-2-9) onNext(10)
[ INFO] (redisson-netty-2-24) onNext(11)
[ INFO] (redisson-netty-2-25) onNext(12)
[ INFO] (redisson-netty-2-30) onNext(13)
[ INFO] (redisson-netty-2-27) onNext(14)
[ INFO] (redisson-netty-2-31) onNext(15)
Consumer 1 => 1
Consumer 1 => 2
[ INFO] (redisson-netty-2-1) onNext(16)
[ INFO] (redisson-netty-2-4) onNext(17)
[ INFO] (redisson-netty-2-5) onNext(18)
Consumer 1 => 3
[ INFO] (redisson-netty-2-3) onNext(19)
[ INFO] (redisson-netty-2-2) onNext(20)
[ INFO] (redisson-netty-2-8) onNext(21)
[ INFO] (redisson-netty-2-9) onNext(22)
[ INFO] (redisson-netty-2-29) onNext(23)
Consumer 1 => 4
[ INFO] (redisson-netty-2-32) onNext(24)
[ INFO] (redisson-netty-2-7) onNext(25)
Consumer 1 => 5
[ INFO] (redisson-netty-2-2) onNext(26)
[ INFO] (redisson-netty-2-5) onNext(27)
Consumer 1 => 6
[ INFO] (redisson-netty-2-3) onNext(28)
[ INFO] (redisson-netty-2-10) onNext(29)
Consumer 1 => 7
[ INFO] (redisson-netty-2-11) onNext(30)
[ INFO] (redisson-netty-2-6) onNext(31)
[ INFO] (redisson-netty-2-4) onNext(32)
Consumer 1 => 8
[ INFO] (redisson-netty-2-4) onComplete()
Consumer 1 => 9
Consumer 1 => 10
Consumer 1 => 11
Consumer 1 => 12
Consumer 1 => 13
Consumer 1 => 14
Consumer 1 => 15
Consumer 1 => 16
Consumer 1 => 17
Consumer 1 => 18
Consumer 1 => 19
Consumer 1 => 20
Consumer 1 => 21
Consumer 1 => 22
Consumer 1 => 23
[ INFO] (parallel-3) request(24)
Consumer 1 => 24
Consumer 1 => 25
Consumer 1 => 26
Consumer 1 => 27
Consumer 1 => 28
Consumer 1 => 29
Consumer 1 => 30
Consumer 1 => 31
Consumer 1 => 32
[ INFO] (parallel-4) onSubscribe(FluxCreate.BufferAsyncSink)
[ INFO] (parallel-4) request(32)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3674
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This transaction works just great 1 time. I tried to execute in a loop just for 10 times!! I get the exception for the remaining 9 times.
org.redisson.transaction.TransactionTimeoutException: Transaction was discarded due to timeout 30000 milliseconds

        for (int counter = 0; counter < 10; counter++) {
            RTransactionReactive transaction = this.client.createTransaction(TransactionOptions.defaults().timeout(30, TimeUnit.SECONDS));
            RBucketReactive<Long> entry1 = transaction.getBucket("entry:1", LongCodec.INSTANCE);
            RBucketReactive<Long> entry2 = transaction.getBucket("entry:2", LongCodec.INSTANCE);
            entry1.get().map(i -> i + 1).flatMap(entry1::set).block();
            entry2.get().map(i -> i - 1).flatMap(entry2::set).block();
            transaction.commit()
                    .doOnError(System.out::println)
                    .onErrorResume(ex -> transaction.rollback())
                    .block();
        }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3675
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We run a Redis cluster in AWS ElastiCache. On a service startup we sometimes get the following exception (used dots instead of potential NDA data):
Application run failed
org.springframework.beans.factory.BeanCreationException: Error creating bean with name '...' defined in class path resource [...]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:456) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$1(AbstractBeanFactory.java:356) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.getBean(GenericScope.java:390) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.cloud.context.scope.GenericScope.get(GenericScope.java:184) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1105) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.cloud.context.scope.refresh.RefreshScope.eagerlyInitialize(RefreshScope.java:130) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.cloud.context.scope.refresh.RefreshScope.start(RefreshScope.java:121) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:115) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:71) ~[spring-cloud-context-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:402) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:359) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:896) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:162) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:552) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) ~[spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:743) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:390) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1214) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1203) [spring-boot-2.1.7.RELEASE.jar:2.1.7.RELEASE]
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redissonClient' threw exception; nested exception is org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	... 30 more
Caused by: org.redisson.client.RedisConnectionException: Not all slots covered! Only 7647 slots are available. Set checkSlotsCoverage = false to avoid this check.
	at org.redisson.cluster.ClusterConnectionManager.<init>(ClusterConnectionManager.java:157) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:206) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.Redisson.<init>(Redisson.java:64) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.Redisson.create(Redisson.java:104) ~[redisson-3.13.5.jar:3.13.5]
	at ...RedissonConfiguration.redissonClient(RedissonConfiguration.java:62) ~[...]
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at ...RedissonConfiguration$$EnhancerBySpringCGLIB$$72fc472b.redissonClient(<generated>) ~[...]
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?]
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:?]
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:?]
	at java.lang.reflect.Method.invoke(Method.java:566) ~[?:?]
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:622) ~[spring-beans-5.1.9.RELEASE.jar:5.1.9.RELEASE]
	... 30 more
Caused by: org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 9 of 32 were initialized. Redis server: <url>.cache.amazonaws.com/<ip>:6379
	at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:159) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.13.5.jar:3.13.5]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:500) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:474) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:413) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:538) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:531) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:111) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:329) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:295) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[redisson-3.13.5.jar:3.13.5]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:500) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:493) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:472) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:413) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:538) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:531) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:111) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[redisson-3.13.5.jar:3.13.5]
	at org.redisson.client.RedisClient$2$1.run(RedisClient.java:239) ~[redisson-3.13.5.jar:3.13.5]
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515) ~[netty-transport-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at java.lang.Thread.run(Thread.java:829) ~[?:?]
Caused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=rediss://<url>.cache.amazonaws.com:6379]
	at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:207) ~[redisson-3.13.5.jar:3.13.5]
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:682) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:757) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:485) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.38.Final.jar:4.1.38.Final]
	at java.lang.Thread.run(Thread.java:829) ~[?:?]

Pods restart several times and eventually they succeed to connect.
Redis version: 6.0.5
Redisson version: 3.13.5
Redisson config:
{"clusterServersConfig": {"idleConnectionTimeout":10000,"connectTimeout":10000,"timeout":3000,"retryAttempts":3,"retryInterval":1500,"subscriptionsPerConnection":5,"sslEnableEndpointIdentification":true,"sslProvider":"JDK","pingConnectionInterval":3000,"keepAlive":true,"tcpNoDelay":true,"loadBalancer":{"class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"},"slaveConnectionMinimumIdleSize":0,"slaveConnectionPoolSize":0,"failedSlaveReconnectionInterval":3000,"failedSlaveCheckInterval":180000,"masterConnectionMinimumIdleSize":32,"masterConnectionPoolSize":64,"readMode":"MASTER","subscriptionMode":"MASTER","subscriptionConnectionMinimumIdleSize":1,"subscriptionConnectionPoolSize":50,"dnsMonitoringInterval":5000,"natMapper":{"class":"org.redisson.api.DefaultNatMapper"},"nodeAddresses":["redis://..."],"scanInterval":5000,"checkSlotsCoverage":true},"threads":16,"nettyThreads":32,"codec":{"class":"..."},"referenceEnabled":true,"transportMode":"NIO","lockWatchdogTimeout":30000,"keepPubSubOrder":true,"decodeInExecutor":false,"useScriptCache":true,"minCleanUpDelay":5,"maxCleanUpDelay":1800,"cleanUpKeysAmount":100,"nettyHook":{"class":"org.redisson.client.DefaultNettyHook"},"useThreadClassLoader":true,"addressResolverGroupFactory":{"class":"org.redisson.connection.DnsAddressResolverGroupFactory"}}

As far as I understood, redisson sends a ping on AbstractNIOChannel.finishConnect if pingConnectionInterval > 0, and this ping fails.
Is it possible to fix this issue without disabling slot coverage check? If not, is it safe enough to disable that check?
Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3676
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When scaling up the cluster by adding new shards, we notice long lasting exceptions:

Can you share Redisson logs so I could trace why url is null?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3677
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
we got following exception with Redisson tomcat decode
version 3.14.0
codec: org.redisson.codec.SnappyCodec
java.lang.ClassNotFoundException: org.springframework.security.web.savedrequest.DefaultSavedRequest
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [redisson-all-3.14.0.jar:3.14.0]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]
Caused by: java.lang.ClassNotFoundException: org.springframework.security.web.savedrequest.DefaultSavedRequest
at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_261]
at java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[na:1.8.0_261]
at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[na:1.8.0_261]
at java.lang.Class.forName0(Native Method) ~[na:1.8.0_261]
at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_261]
at org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1033) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1366) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:216) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:151) ~[redisson-all-3.14.0.jar:3.14.0]
... 26 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3678
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
my problem is: use RScheduledExecutorService execute task, but no task key into redis(sometimes can into, sometimes can't, so what reason can cause this?).
my redisson version is 3.12.3.
Has anyone encountered the same problem,  eager for your solution.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3679
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
我在测试过程中创建分布式调度任务，但是发现我每次重新运行，都会创建一个新的Task，我看taskId是根据ThreadLocal生成的，导致后续work会执行两个task的任务，这个是我哪里理解不对，或者使用方法不对吗？
代码如下：
    @Test
    void test_schedule() {
        WorkerOptions workerOptions = WorkerOptions.defaults().workers(1);
        ExecutorOptions executorOptions = ExecutorOptions.defaults();
        RScheduledExecutorService executorService = redissonClient
                .getExecutorService("test", executorOptions);
        executorService.registerWorkers(workerOptions);

        executorService.scheduleAtFixedRate((Runnable & Serializable) () -> System.out.println("11111111"),
                                            10, 1, TimeUnit.SECONDS);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I want to listen to the redis link disconnection event
What should I do?
Can Redisson do such a thing?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3681
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3682
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3683
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3684
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3685
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3686
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3687
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3688
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3689
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3691
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3692
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3695
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3697
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3698
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3699
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3700
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3701
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3703
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3704
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3705
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3706
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3708
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3709
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3713
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3714
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3715
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3716
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3717
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3719
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3720
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3721
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3722
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3723
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3724
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3727
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3728
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3729
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3730
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3731
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3732
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3733
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3734
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3737
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3738
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3740
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3741
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3742
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3743
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3744
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3745
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3746
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3748
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3749
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3750
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3753
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3754
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3756
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3757
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3759
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3762
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3763
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3764
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3765
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3766
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3767
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3768
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3769
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3770
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3771
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3772
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3774
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3775
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3776
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3777
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3778
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3779
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3780
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3781
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3782
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3783
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3784
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3785
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3786
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3787
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3788
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3789
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3790
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3791
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3792
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I was writing some unit tests and I discovered that I could not perform any operations on a second instance of RedissonLocalCachedMap when I was storing non primitive key/values in the map.
My expectation is that a second instance of RedissonLocalCachedMap would be able to read values from a map as long as RedissonMap could. This is preventing me from using RedissonLocalCachedMap in my code.
Actual behavior
An exception is thrown
Unexpected exception while processing command
org.redisson.client.RedisException: Unexpected exception while processing command
	at org.redisson.command.CommandAsyncService.convertException(CommandAsyncService.java:324)
	at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:121)
	at org.redisson.RedissonObject.get(RedissonObject.java:82)
	at org.redisson.RedissonMap.readAllValues(RedissonMap.java:850)
	at ai.argo.viaduct.discovery.redis.RedissonDemo.localCachedMapNotWorking(RedissonDemo.kt:48)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at ...
Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.lang.String` from Object value (token `JsonToken.START_OBJECT`)
 at [Source: (io.netty.buffer.ByteBufInputStream); line: 1, column: 1]
	at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59)
	at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1601)
	at com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1375)
	at com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1280)
	at com.fasterxml.jackson.databind.DeserializationContext.extractScalarFromObject(DeserializationContext.java:872)
	at com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:62)
	at com.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:11)
	at com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:322)
	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4593)
	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3585)
	at org.redisson.codec.TypedJsonJacksonCodec$2.decode(TypedJsonJacksonCodec.java:63)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:358)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:402)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:367)
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:177)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:116)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:101)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:508)
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 more

Steps to reproduce or test case
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.redisson.api.LocalCachedMapOptions
import org.redisson.api.RLocalCachedMap
import org.redisson.api.RMap
import org.redisson.client.codec.Codec
import org.redisson.codec.TypedJsonJacksonCodec
import java.util.UUID

class RedissonDemo : RedisIntegrationTestBase() {

    data class DemoObject(
        val id: UUID
    )


    @BeforeEach
    fun beforeEach() {
        redisClient.keys.flushall()
    }

    @Test
    fun mapWorking() {
        val map1: RMap<String, DemoObject> = redisClient.getMap("test", generateCodec())
        val map2: RMap<String, DemoObject> = redisClient.getMap("test", generateCodec())
        map1.put("key", DemoObject(UUID.randomUUID()))
        map1.readAllValues()
        map2.readAllValues()
    }

    @Test
    fun localCachedMapNotWorking() {
        val map1: RLocalCachedMap<String, DemoObject> = redisClient.getLocalCachedMap("test", generateCodec(), LocalCachedMapOptions.defaults())
        val map2: RLocalCachedMap<String, DemoObject> = redisClient.getLocalCachedMap("test", generateCodec(), LocalCachedMapOptions.defaults())
        map1.put("key", DemoObject(UUID.randomUUID()))
        map1.readAllValues()
        map2.readAllValues() // FAILS HERE
    }

    /**
     * Generates a Jackson codec that supports Kotlin classes.
     */
    private fun generateCodec(): Codec {
        // Needed to serialize/deserialize kotlin objects into redis
        val objectMapper = jacksonObjectMapper()
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)

        return TypedJsonJacksonCodec(String::class.java, DemoObject::class.java, objectMapper)
    }
}
Redis version
6+
Redisson version
3.15.5
Redisson configuration
val address: String = redis.host
val port: Int = redis.firstMappedPort
val config = Config()
config.useSingleServer().address = "redis://$address:$port"
redisClient = Redisson.create(config)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3793
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi,
we have the following exception even we change the configuration to :
useThreadClassLoader = false
java.io.IOException: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:153) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.codec.SnappyCodec$3.decode(SnappyCodec.java:84) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:356) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:400) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:365) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:178) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-all-3.14.0.jar:3.14.0]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:102) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [redisson-all-3.14.0.jar:3.14.0]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [redisson-all-3.14.0.jar:3.14.0]
at java.lang.Thread.run(Thread.java:748) [na:1.8.0_261]
Caused by: java.lang.ClassNotFoundException: com.panaya.as.blexecuter.imp.BaseBLContext
at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1952) ~[catalina.jar:7.0.105]
at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1795) ~[catalina.jar:7.0.105]
at java.lang.Class.forName0(Native Method) ~[na:1.8.0_261]
at java.lang.Class.forName(Class.java:348) ~[na:1.8.0_261]
at org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1033) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1366) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:283) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:216) ~[redisson-all-3.14.0.jar:3.14.0]
at org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) ~[redisson-all-3.14.0.jar:3.14.0]
at org.redisson.codec.MarshallingCodec$3.decode(MarshallingCodec.java:151) ~[redisson-all-3.14.0.jar:3.14.0]
... 26 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3794
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3795
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Our redis cluster is composed of three nodes, and each node is loaded with two redis pods. Two redis pods die when a single node goes down. But redisson always tries to connect these dead redis pods.
When a single node goes down:
e5c76dbb3a07d6273bd710df937961620f1eadac 100.64.47.80:6379@16379 slave,fail 248aad504cfd0d86482eec2127bb9cc2fab52785 1629723963951 1629723963000 29 connected
80f97ed19137edf941960e90cf669c2adaa3823e 100.64.214.78:6379@16379 master - 0 1629770356000 31 connected 10923-16383
5f4659cc2a0dab399f4ac74ca2138954cf9c231b 100.64.47.89:6379@16379 master,fail - 1629723963649 1629723961000 23 connected
248aad504cfd0d86482eec2127bb9cc2fab52785 100.64.9.44:6379@16379 myself,master - 0 1629770356000 29 connected 5461-10922
6423ebd354791ce655f6a1e98225384a85576d5c 100.64.214.122:6379@16379 master - 0 1629770356419 20 connected 0-5460
66ad650d65a34d1bc619ac13cc467bbe71d9f7ee 100.64.9.2:6379@16379 slave 6423ebd354791ce655f6a1e98225384a85576d5c 0 1629770357420 20 connected

When the redis cluster returns to normal
e5c76dbb3a07d6273bd710df937961620f1eadac 100.64.47.98:6379@16379 slave 248aad504cfd0d86482eec2127bb9cc2fab52785 0 1629770520848 29 connected
80f97ed19137edf941960e90cf669c2adaa3823e 100.64.214.78:6379@16379 master - 0 1629770519847 31 connected 10923-16383
5f4659cc2a0dab399f4ac74ca2138954cf9c231b 100.64.47.72:6379@16379 slave 80f97ed19137edf941960e90cf669c2adaa3823e 0 1629770519000 31 connected
248aad504cfd0d86482eec2127bb9cc2fab52785 100.64.9.44:6379@16379 myself,master - 0 1629770518000 29 connected 5461-10922
6423ebd354791ce655f6a1e98225384a85576d5c 100.64.214.122:6379@16379 master - 0 1629770518000 20 connected 0-5460
66ad650d65a34d1bc619ac13cc467bbe71d9f7ee 100.64.9.2:6379@16379 slave 6423ebd354791ce655f6a1e98225384a85576d5c 0 1629770518845 20 connected

Redisson always tries to reconnect the changed redis pod(100.64.47.80) even after cluster recovery.
netstat -anp | grep "100.64.47.80"
tcp        0      1 100.64.214.69:51134     100.64.47.80:6379       SYN_SENT    13/java

2021-08-24 10:01:42:002 [redisson-timer-4-1] DEBUG [cea-collector,cea-collector-5bd5fb7584-clxj9,,,,13] org.redisson.client.handler.ConnectionWatchdog.tryReconnect:110 - reconnecting RedisConnection@717315379 [redisClient=[addr=redis://100.64.47.80:6379], channel=[id: 0x49e8aef6, L:/100.64.214.69:59118 ! R:100.64.47.80/100.64.47.80:6379], currentCommand=null] to 100.64.47.80/100.64.47.80:6379
2021-08-24 10:02:00:202 [redisson-timer-4-1] DEBUG [cea-collector,cea-collector-5bd5fb7584-clxj9,,,,13] org.redisson.client.handler.ConnectionWatchdog.tryReconnect:110 - reconnecting RedisConnection@717315379 [redisClient=[addr=redis://100.64.47.80:6379], channel=[id: 0x49e8aef6, L:/100.64.214.69:59118 ! R:100.64.47.80/100.64.47.80:6379], currentCommand=null] to 100.64.47.80/100.64.47.80:6379
2021-08-24 10:02:18:402 [redisson-timer-4-1] DEBUG [cea-collector,cea-collector-5bd5fb7584-clxj9,,,,13] org.redisson.client.handler.ConnectionWatchdog.tryReconnect:110 - reconnecting RedisConnection@717315379 [redisClient=[addr=redis://100.64.47.80:6379], channel=[id: 0x49e8aef6, L:/100.64.214.69:59118 ! R:100.64.47.80/100.64.47.80:6379], currentCommand=null] to 100.64.47.80/100.64.47.80:6379
2021-08-24 10:02:36:702 [redisson-timer-4-1] DEBUG [cea-collector,cea-collector-5bd5fb7584-clxj9,,,,13] org.redisson.client.handler.ConnectionWatchdog.tryReconnect:110 - reconnecting RedisConnection@717315379 [redisClient=[addr=redis://100.64.47.80:6379], channel=[id: 0x49e8aef6, L:/100.64.214.69:59118 ! R:100.64.47.80/100.64.47.80:6379], currentCommand=null] to 100.64.47.80/100.64.47.80:6379
2021-08-24 10:02:54:902 [redisson-timer-4-1] DEBUG [cea-collector,cea-collector-5bd5fb7584-clxj9,,,,13] org.redisson.client.handler.ConnectionWatchdog.tryReconnect:110 - reconnecting RedisConnection@717315379 [redisClient=[addr=redis://100.64.47.80:6379], channel=[id: 0x49e8aef6, L:/100.64.214.69:59118 ! R:100.64.47.80/100.64.47.80:6379], currentCommand=null] to 100.64.47.80/100.64.47.80:6379

Here is the complete log.
cea-collector.log
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3796
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, the "lpush" command of redis >= 2.4 supports multiple elements at a time, while the corresponding "RDeque.addFirst()" in redisson only supports one element.

https://redis.io/commands/lpush
Similar commands that are not fully supported include "rpush", "sadd", "srem".
Hope these features are supported, thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
hi,
regard #3793  wasn't able to reopen
we tried to remove jar from app, but it wasn't able to recognize the app classes that we saved in the cache ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3799
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public RFuture<Boolean> trySetPermitsAsync(int permits) {
        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                "local value = redis.call('get', KEYS[1]); " +
                "if (value == false or value == 0) then "
                    + "redis.call('set', KEYS[1], ARGV[1]); "
                    + "redis.call('publish', KEYS[2], ARGV[1]); "
                    + "return 1;"
                + "end;"
                + "return 0;",
                Arrays.<Object>asList(getRawName(), getChannelName()), permits);
    }
value == 0 is aways false , because value is String Type .
and in tryAcquireAsync method,  use tonumber method change String to int .
    public RFuture<Boolean> tryAcquireAsync(int permits) {
        if (permits < 0) {
            throw new IllegalArgumentException("Permits amount can't be negative");
        }
        if (permits == 0) {
            return RedissonPromise.newSucceededFuture(true);
        }

        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                  "local value = redis.call('get', KEYS[1]); " +
                  "if (value ~= false and tonumber(value) >= tonumber(ARGV[1])) then " +
                      "local val = redis.call('decrby', KEYS[1], ARGV[1]); " +
                      "return 1; " +
                  "end; " +
                  "return 0;",
                  Collections.<Object>singletonList(getRawName()), permits);
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3800
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
I've got rather confusing experience with loadAll() method. I used it on startup to 'sync' redisson map with database, however, it doesn't clean values not existed in database.
I can use
RMap.clear()
RMap.loadAll()

but it is not atomic and I've found no functions to lock entire map access while I do this.
As loadAll() calls loadAllKeys(), maybe it better to clean nonexistent keys at the end of loading if loadAllKeys = true?
Reproduction snipped to illustrate:
class Main {

    private val mapLoader = object : MapLoader<Int, String> {
        val data = mutableMapOf(
            1 to "foo",
            2 to "bar"
        )

        fun update() {
            data.clear()
            data[3] = "foobar"
        }

        override fun load(key: Int) = data[key]
        override fun loadAllKeys() = data.keys.toMutableList()
    }

    fun run() {
        val config = Config()
        val redisson = Redisson.create(config)
        val map: RMap<Int, String> = redisson.getMap(
            "test-map",
            MapOptions.defaults<Int, String>().loader(mapLoader)
        )

        map.clear()
        map.loadAll(true, 1)
        require(map.size == 2)
        mapLoader.update()
        map.loadAll(true, 1)
        println(map.entries)
    }
}

fun main() = Main().run()

will print [1=foo, 2=bar, 3=foobar]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
https://javadoc.io/doc/org.redisson/redisson/latest/index.html.
In the search box on the right, type redisson.
In the  search suggestions, scroll down to the Types section (second from the top), and click on org.redisson.Redisson.
Stare at the error below and wonder why.

AccessDeniedAccess Denied1YBT0RFTFR6X25GVLkDrkQL3l4T52jteTAMOSTWvQLTmEgvpARsyLKeTFzJYDrS2/NpAodRRM4AxpfmjY0HDMuMN8n8=
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3802
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
redis.call('hmget', KEYS[1], ARGV[2]) ... 


redis call trace  once
redis command hmget

Actual behavior
2021-08-31 17:42:32.294 DEBUG 35400 --- [           main] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@1777130355 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xfbf9de49, L:/127.0.0.1:41972 - R:localhost/127.0.0.1:6379], currentCommand=null]
2021-08-31 17:42:32.299 DEBUG 35400 --- [isson-netty-2-8] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1777130355 [redisClient=[addr=redis://localhost:6379], channel=[id: 0xfbf9de49, L:/127.0.0.1:41972 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7e3d5650(success: true)], command=(EVAL), params=[local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...], codec=org.redisson.codec.JsonJacksonCodec]]
2021-08-31 17:42:32.300 DEBUG 35400 --- [           main] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@2041929189 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x31eb7129, L:/127.0.0.1:41984 - R:localhost/127.0.0.1:6379], currentCommand=null]
2021-08-31 17:42:32.302 DEBUG 35400 --- [sson-netty-2-12] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@2041929189 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x31eb7129, L:/127.0.0.1:41984 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@68d4819c(success: true)], command=(EVAL), params=[local insertable = false; local v = redis.call('hget', KEYS[1], ARGV[2]); if v == false then inserta..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...], codec=org.redisson.codec.JsonJacksonCodec]]
2021-08-31 17:42:32.324 DEBUG 35400 --- [           main] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [local currentTime = tonumber(table.remove(ARGV, 1)); local maxSize = tonumber(redis.call('hget', KEY..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@501303000 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x750edc21, L:/127.0.0.1:41970 - R:localhost/127.0.0.1:6379], currentCommand=null]
2021-08-31 17:42:32.326 DEBUG 35400 --- [isson-netty-2-4] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [local currentTime = tonumber(table.remove(ARGV, 1)); local maxSize = tonumber(redis.call('hget', KEY..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@501303000 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x750edc21, L:/127.0.0.1:41970 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@59ccce76(success)], command=(EVAL), params=[local currentTime = tonumber(table.remove(ARGV, 1)); local maxSize = tonumber(redis.call('hget', KEY..., 8, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson_map_cache_created:{A:1}, redisson_map_cache_updated:{A:1}, redisson__map_cache__last_access__set:{A:1}, redisson_map_cache_removed:{A:1}, {A:1}:redisson_options, ...], codec=org.redisson.codec.JsonJacksonCodec]]
2021-08-31 17:42:33.342 DEBUG 35400 --- [aitility-thread] org.redisson.command.RedisExecutor       : acquired connection for command (EVAL) and params [local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores'); local currentTime = tonumber(t..., 5, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson__map_cache__last_access__set:{A:1}, {A:1}:redisson_options, 1630399353335, PooledUnsafeDirectByteBuf(ridx: 0, widx: 4, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 3, cap: 256), ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node localhost/127.0.0.1:6379... RedisConnection@1672945630 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x03a06d25, L:/127.0.0.1:41968 - R:localhost/127.0.0.1:6379], currentCommand=null]
2021-08-31 17:42:33.361 DEBUG 35400 --- [sson-netty-2-10] org.redisson.command.RedisExecutor       : connection released for command (EVAL) and params [local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores'); local currentTime = tonumber(t..., 5, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson__map_cache__last_access__set:{A:1}, {A:1}:redisson_options, 1630399353335, PooledUnsafeDirectByteBuf(ridx: 0, widx: 4, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 3, cap: 256), ...] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@1672945630 [redisClient=[addr=redis://localhost:6379], channel=[id: 0x03a06d25, L:/127.0.0.1:41968 - R:localhost/127.0.0.1:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@638f1e84(success: {a2=A(id=a2, age=20), a=A(id=a, age=10), a3=A(id=a3, age=30), a4=A(id=a4, age=40)})], command=(EVAL), params=[local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores'); local currentTime = tonumber(t..., 5, A:1, redisson__timeout__set:{A:1}, redisson__idle__set:{A:1}, redisson__map_cache__last_access__set:{A:1}, {A:1}:redisson_options, 1630399353335, PooledUnsafeDirectByteBuf(ridx: 0, widx: 4, cap: 256), PooledUnsafeDirectByteBuf(ridx: 0, widx: 3, cap: 256), ...], codec=org.redisson.codec.JsonJacksonCodec]]


Steps to reproduce or test case

save

        RedisMeta redisMeta = RedisSupport.findRedisMeta(obj);
        Object id = RedisSupport.findId(obj);

        RMapCache<Object, Object> mapCache = redisson.getMapCache(redisMeta.getNamespaceAndVersion());

        
        
            mapCache.fastPut(id, obj);


get

        RMapCache<K, V> mapCache = redisson.getMapCache(redisMeta.getNamespaceAndVersion());
        return mapCache.getAll(seq(ids).toSet());

Redis version
embeded-redis:0.7.3
Redisson version
3.16.1
Redisson configuration
org.redisson.spring.starter.RedissonAutoConfiguration
and codec custom
    @ConditionalOnMissingBean(value = RedissonAutoConfigurationCustomizer.class)
    @Bean
    RedissonAutoConfigurationCustomizer redissonCodecCustomizer() {
        return (config) -> {
            config.setCodec(JsonJacksonCodec.INSTANCE);
        };
    }


springboot logging config

logging:
  level:
    org.redisson: debug


SAMPLE DATA

SAMPLE CODE
    public <K, V> Map<K, V> findAllByIdsAsMap(Collection<K> ids, Class<V> clazz) {
        RedisMeta redisMeta = RedisSupport.findRedisMeta(clazz);
        RMapCache<K, V> mapCache = redisson.getMapCache(redisMeta.getNamespaceAndVersion());
        return mapCache.getAll(seq(ids).toSet());
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3803
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
The API to trim a redis stream (see the correspoding XTRIM command) supports different strategies via the org.redisson.api.stream.TrimStrategy type.
Yet the additional command parameters in the overloaded methods (e.g. trim, trimAsync, trimNonStrictAsync) will allow only ints.
Specifically you can now only pass a

int threshold (to say how many messages you want to keep)
int limit (to remove up to a given number of messages)

Those are inconsistent with the TrimStrategy.MINID which expects a message Id as input.
Since the message Ids are composed of a timestamp in millis from epoch and a number, the current int param won't be able to technically be used for such a job, even ignoring the semantics of the param.
An int is not enough to encode a valid millis timestamp which is part of the message Id.
Describe the solution you'd like
It would be nice to provide overloaded methods taking an instance of org.redisson.api.StreamMessageId, and - most importantly- a simple String, to allow partial matches.
Describe alternatives you've considered
I will probably use a work-around by calling the low-level redis client, but the issue is mostly about the current API which is a bit misleading in what it provides.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3805
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Since Redis 6.2 sentinel may return hostnames in result of "SENTINEL SENTINELS", "SENTINEL SLAVES", or "SENTINEL GET_MASTER_ADDR_BY_NAME" commands.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3806
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thank you for proposed changes.
Did you try this example https://github.com/redisson/redisson/blob/master/.github/CONTRIBUTING.md#running-the-tests
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3807
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Description
If hostname is given to Config with leading slash it causes exception 'port out of range:-1'
Expected behavior
Either of two variants:

exception about incorrect host should be thrown
slash should be trimmed silently from host string and proceed.

Actual behavior
Exception about incorrect port instead of incorrect host.
java.lang.IllegalArgumentException: port out of range:-1

	at java.base/java.net.InetSocketAddress.checkPort(InetSocketAddress.java:143)
	at java.base/java.net.InetSocketAddress.createUnresolved(InetSocketAddress.java:254)
	at org.redisson.client.RedisClient.resolveAddr(RedisClient.java:192)
	at org.redisson.connection.MasterSlaveEntry.setupMasterEntry(MasterSlaveEntry.java:118)
	at org.redisson.connection.MasterSlaveEntry.setupMasterEntry(MasterSlaveEntry.java:108)
	at org.redisson.connection.MasterSlaveConnectionManager.initSingleEntry(MasterSlaveConnectionManager.java:334)
	at org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:143)
	at org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:30)
	at org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:190)
	at org.redisson.Redisson.<init>(Redisson.java:67)
	at org.redisson.Redisson.create(Redisson.java:108)

This behaviour is very misleading and cause to search a ghost mistake with port configuration instead of host typo.
Steps to reproduce or test case
        int port = 6379;
        String host = "/localhost";      // <- hostname is started with slash by config mistake, typo, etc.
        Config config = new Config();
        config
                .useSingleServer()
                .setAddress("redis://" + host + ":" + port)
                .setDatabase(0);

        redisson = Redisson.create(config);

Redisson version
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.16.1</version>
        </dependency>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3808
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unable to decode data. channel: [id: 0xf59ac8a2], reply: ReplayingDecoderByteBuf(ridx=71, widx=192), command: (EXISTS), params : [sdk-1st-init:13763:637a436b28846efa] java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Long at org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:27) at org.redisson.client.protocol.convertor.BooleanAmountReplayConvertor.convert(BooleanAmountReplayConvertor.java:23) at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:432) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:316) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
Redis version
4.0
Redisson version
3.16.1
codec
JsonJacksonCodec
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when I choose redisson (version 3.16.1)  ,this problem  occurred, but go well for other version
2021-09-02 15:45:17.981  INFO 71992 --- [  restartedMain] org.redisson.Version                     : Redisson 3.16.1
2021-09-02 15:45:18.450  INFO 71992 --- [sson-netty-2-24] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for xxx.xxx.xxx
2021-09-02 15:45:23.543 ERROR 71992 --- [sson-netty-2-12] i.n.u.c.D.rejectedExecution              : Failed to submit a listener notification task. Event loop shut down?
java.util.concurrent.RejectedExecutionException: event executor terminated
at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:923) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:350) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:343) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:825) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:815) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:841) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:96) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture.setSuccess0(DefaultChannelGroupFuture.java:200) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture.access$400(DefaultChannelGroupFuture.java:41) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture$1.operationComplete(DefaultChannelGroupFuture.java:75) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture$1.operationComplete(DefaultChannelGroupFuture.java:48) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$CloseFuture.setClosed(AbstractChannel.java:1182) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(AbstractChannel.java:773) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:749) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:620) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.nio.NioEventLoop.closeAll(NioEventLoop.java:769) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:526) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]
2021-09-02 15:45:23.543 ERROR 71992 --- [sson-netty-2-12] i.n.u.c.D.rejectedExecution              : Failed to submit a listener notification task. Event loop shut down?
java.util.concurrent.RejectedExecutionException: event executor terminated
at io.netty.util.concurrent.SingleThreadEventExecutor.reject(SingleThreadEventExecutor.java:923) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.offerTask(SingleThreadEventExecutor.java:350) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.addTask(SingleThreadEventExecutor.java:343) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:825) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor.execute(SingleThreadEventExecutor.java:815) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.safeExecute(DefaultPromise.java:841) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:499) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:96) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture.setSuccess0(DefaultChannelGroupFuture.java:200) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture.access$400(DefaultChannelGroupFuture.java:41) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture$1.operationComplete(DefaultChannelGroupFuture.java:75) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.group.DefaultChannelGroupFuture$1.operationComplete(DefaultChannelGroupFuture.java:48) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$CloseFuture.setClosed(AbstractChannel.java:1182) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.doClose0(AbstractChannel.java:773) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:749) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.AbstractChannel$AbstractUnsafe.close(AbstractChannel.java:620) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.nio.NioEventLoop.closeAll(NioEventLoop.java:769) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:526) ~[netty-transport-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.67.Final.jar:4.1.67.Final]
at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]
2021-09-02 15:45:23.543  WARN 71992 --- [  restartedMain] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'xxx': Unsatisfied dependency expressed through field 'redissonClient'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [com/example/demo/service/xxx.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 5 of 24 were initialized. Redis server: xxx.xxx
2021-09-02 15:45:23.558  INFO 71992 --- [  restartedMain] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]
2021-09-02 15:45:23.558  INFO 71992 --- [  restartedMain] ConditionEvaluationReportLoggingListener :
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
2021-09-02 15:45:23.573 ERROR 71992 --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'xxx': Unsatisfied dependency expressed through field 'redissonClient'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [com/example/demo/service/xxx.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 5 of 24 were initialized. Redis server: xxx.xxx.xxx
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:660) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1413) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:601) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[spring-context-5.3.9.jar:5.3.9]
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.9.jar:5.3.9]
at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.5.4.jar:2.5.4]
at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-2.5.4.jar:2.5.4]
at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) ~[spring-boot-2.5.4.jar:2.5.4]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) ~[spring-boot-2.5.4.jar:2.5.4]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-2.5.4.jar:2.5.4]
at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) ~[spring-boot-2.5.4.jar:2.5.4]
at com.example.demo.DemoApplication.main(DemoApplication.java:10) ~[classes/:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.5.4.jar:2.5.4]
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [com/example/demo/service/xxx.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 5 of 24 were initialized. Redis server: xxx.xxx
at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:486) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.9.jar:5.3.9]
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) ~[spring-beans-5.3.9.jar:5.3.9]
... 25 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3810
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson: 3.6.1
redis: 6.2.5 in cluster mode
use redisson.getBucket().get(keys...) success,
but when i use redisson.getBucket().set(Map<String,?>) and keys hashed in different slot,throw a CROSSSLOT
it's a bug? or because of other considerations
and i can pr to fix it?
[redisson-netty-2-2] INFO org.redisson.cluster.ClusterConnectionManager - master: redis://192.168.1.183:7000 added for slot ranges: [[10923-16383]]
[redisson-netty-2-2] INFO org.redisson.connection.pool.SlaveConnectionPool - 24 connections initialized for 192.168.1.187/192.168.1.187:7000
Exception in thread "main" org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0x04b473c3, L:/172.30.1.206:52837 - R:192.168.1.183/192.168.1.183:7000] command: (MSET), params: [test123221, PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 256), tesdasdadasdasdasd1, PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 256), tesdasdasd3221, PooledUnsafeDirectByteBuf(ridx: 0, widx: 16, cap: 256)]
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:353)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3811
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The reason I want to set the expiration time:

The 'countDownLatch.countDown()' method may not be called
The server went down when the 'countDownLatch.await(10L, TimeUnit.SECONDS);' method was called

RCountDownLatch countDownLatch = redissonClient.getCountDownLatch(key);
      try {
          countDownLatch.trySetCount(1);
          // todo: I want to set the expiration time of the key here
          Thread.sleep(10000);
          boolean await = countDownLatch.await(10L, TimeUnit.SECONDS);
          return await + "";
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3812
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I submit 200 tasks into RExecutorService and get 202 tasks executed.
The log shows the task :  00e3b0a299b6e8e71dc887aa9e728f4ac8 push into
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService} twice because the command
if redis.call('exists', KEYS[2]) == 0 then redis.call('hset', KEYS[5], ARGV[2], ARGV[3]);redis.call('rpush', KEYS[6], ARGV[2]); redis.call('incr', KEYS[1]);if tonumber(ARGV[5]) > 0 then redis.call('zadd', KEYS[8], ARGV[5], ARGV[2]);end; if tonumber(ARGV[1]) > 0 then redis.call('set', KEYS[7], ARGV[4]);redis.call('zadd', KEYS[3], ARGV[1], 'ff' .. ARGV[2]);local v = redis.call('zrange', KEYS[3], 0, 0); if v[1] == ARGV[2] then redis.call('publish', KEYS[4], ARGV[1]); end; end;return 1;end;return 0; are also execute twice for task 00e3b0a299b6e8e71dc887aa9e728f4ac8
it seems like the redis.call('rpush', KEYS[6], ARGV[2]); will put two 00e3b0a299b6e8e71dc887aa9e728f4ac8 into
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService} because rpush does not check the result of hset
I guess it may cause by retry mechanism, because the client connect to REDIS via VPN and the network is slow and unstable.
the result : task 00e3b0a299b6e8e71dc887aa9e728f4ac8 executed twice.
attachment is the log store in json format.
debug.txt
Expected behavior
200 tasks executed.
Actual behavior
202 tasks executed.
Steps to reproduce or test case
Redis version
5.0.6
Redisson version
3.16.1
Redisson configuration
config.useSingleServer()
.setConnectionMinimumIdleSize(1) //
.setConnectionPoolSize(64) //
.setTimeout(30 * 1000)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3813
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
when i use getBuckets().get("{test}abcd", "{test}bcdf", "{test}efgc");
i trace the code and find the 3 key use hash tags, so their have the same hash code(by connectionManager.calcSlot)
but in executeBatchedAsync, cretae 3 command (mget {test}abcd, mget {test}bcdf, mget {test}efgc ) and run in CommandBatchService
why? and i think send a command (mget {test}abcd, {test}bcdf, {test}efgc) is better than now?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3814
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am tring to use RExecutorService in my project.
The test env connect to redis via VPN and the network is slow and unstable.
In my test. sometimes the RExecutorService will stuck and does NOT resume task anymore.
The RExecutorService is named : "redisson-web-online-test-DistSvc"
The RExecutorService will store request in : {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}
and store task into {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks
I found the {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService} is empty but the task in {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks does not processed and remain in {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks
relative data store in redis:
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:counter : 1
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:retry-interval : 60000
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:scheduler :
value=ff0013440745fec575af0b3bff9c3a9f71e3
score=1630914700110
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks :
key : 0013440745fec575af0b3bff9c3a9f71e3
attachement is the debug log for the test:
java_api.txt
Expected behavior
Task submit into RExecutorService being executed.
Actual behavior
The RExecutorService being stick and task remain in {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks .
Steps to reproduce or test case

Start my application
after started , waiting for 5 minutes.
submit task into RExecutorService
the task does NOT executed and remain in {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:tasks
{redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService} is empty
value store in {redisson-web-online-test-DistSvc:org.redisson.executor.RemoteExecutorService}:counter is 1

Redis version
5.0.6
Redisson version
3.16.1
Redisson configuration
config.useSingleServer()
.setConnectionMinimumIdleSize(1) //
.setConnectionPoolSize(64) //
.setTimeout(2 * 1000)
.setConnectTimeout(2 * 1000)
.setIdleConnectionTimeout(10 * 1000)
.setKeepAlive(false)
.setRetryAttempts(1)
.setPingConnectionInterval(1 * 1000)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3815
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I used org.redisson.config.Config#fromJSON(java.lang.String) to generate Config, I found that this method has been deprecated.
When using redisson-spring-boot-starter, the value of spring.redis.redisson.config is String. I think json String is less prone to format errors than yaml String.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
springboot启动时，出现以下错误
2021-09-07 10:09:59.615 ERROR 61553 [           main] [] o.s.boot.SpringApplication               : Application run failed

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'scopedTarget.configHolder' defined in file [/Users/luozhenzhong/Documents/IdeanProjects/Horizon/capture-service/graphics-web/target/classes/com/eastedu/graphics/config/ConfigHolder.class]: Bean instantiation via constructor failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.eastedu.graphics.config.ConfigHolder$$EnhancerBySpringCGLIB$$3d64f0b6]: Constructor threw exception; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:315)
	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:296)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1354)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$1(AbstractBeanFactory.java:374)
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.getBean(GenericScope.java:376)
	at org.springframework.cloud.context.scope.GenericScope.get(GenericScope.java:179)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:371)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154)
	at org.springframework.cloud.context.scope.refresh.RefreshScope.eagerlyInitialize(RefreshScope.java:125)
	at org.springframework.cloud.context.scope.refresh.RefreshScope.start(RefreshScope.java:117)
	at org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:112)
	at org.springframework.cloud.context.scope.refresh.RefreshScope.onApplicationEvent(RefreshScope.java:67)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:176)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:169)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:421)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:378)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:938)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:144)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:771)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:763)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:438)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:339)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1329)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1318)
	at com.eastedu.GraphicsServiceApplication.main(GraphicsServiceApplication.java:34)
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.eastedu.graphics.config.ConfigHolder$$EnhancerBySpringCGLIB$$3d64f0b6]: Constructor threw exception; nested exception is java.lang.NullPointerException
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:221)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:117)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:311)
	... 30 common frames omitted
Caused by: java.lang.NullPointerException: null
	at org.redisson.RedissonMapCache.addListener(RedissonMapCache.java:1884)
	at com.eastedu.graphics.config.ConfigHolder$DefaultNodeMonitor.initListener(ConfigHolder.java:244)
	at com.eastedu.graphics.config.ConfigHolder$DefaultNodeMonitor.<init>(ConfigHolder.java:216)
	at com.eastedu.graphics.config.ConfigHolder.<init>(ConfigHolder.java:65)
	at com.eastedu.graphics.config.ConfigHolder$$EnhancerBySpringCGLIB$$3d64f0b6.<init>(<generated>)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:208)
	... 32 common frames omitted


经过debug排查，发现下面这段代码会抛出java.lang.NullPointerException

Redis version
4.0.11
Redisson version
3.11.5
Redisson configuration
default
@eager
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3817
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Not Execption
Actual behavior
long addTypeAmount(int type, long amount) {
RMap<Integer, Number> map = redisson.getMap("sumAmount:Id:7");
Number sum = map.addAndGet(type, amount);
return sum == null ? 0 : sum.longValue();
}
09-07 11:38:17.364 ERROR[CommandDecoder] - Unable to decode data. channel: [id: 0xb42d4b58, L:/192.168.0.1:44540 - R:192.168.0.1/192.168.0.1:7011], reply: ReplayingDecoderByteBuf(ridx=7, widx=7), command: (HINCRBYFLOAT), params: [sumAmount:Id:7, Poo
ledUnsafeDirectByteBuf(ridx: 0, widx: 4, cap: 256), 100]
java.lang.NumberFormatException: For input string: "PONG"
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.lang.Long.parseLong(Long.java:589)
at java.lang.Long.parseLong(Long.java:631)
at org.redisson.client.protocol.convertor.NumberConvertor.convert(NumberConvertor.java:38)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:432)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:316)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
09-07 11:38:17.364 ERROR[ErrorsLoggingHandler] - Exception occured. Channel: [id: 0xb42d4b58, L:/192.168.0.1:44540 - R:192.168.0.1/192.168.0.1:7011]
io.netty.handler.codec.DecoderException: java.lang.NumberFormatException: For input string: "PONG"
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:421)
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NumberFormatException: For input string: "PONG"
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.lang.Long.parseLong(Long.java:589)
at java.lang.Long.parseLong(Long.java:631)
at org.redisson.client.protocol.convertor.NumberConvertor.convert(NumberConvertor.java:38)
at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:432)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:316)
at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:183)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:122)
at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:107)
at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
... 17 common frames omitted
Steps to reproduce or test case
Redis version
6.2
Redisson version
3.16.2
Redisson configuration
<bean id="jsonJacksonCodec" class="org.redisson.codec.JsonJacksonCodec" />

<redisson:client id="redisson"
                 name="redisson"
                 codec-ref="jsonJacksonCodec"
                 >

	<redisson:cluster-servers client-name="client1" 
			retry-attempts="0" 
			master-connection-minimum-idle-size="150" 
			master-connection-pool-size="150" 
			slave-connection-minimum-idle-size="150" 
			slave-connection-pool-size="150"
			connect-timeout="30000"
			read-mode="SLAVE"
	>
		<redisson:node-address value="redis://192.168.0.1:7011"/>
		<redisson:node-address value="redis://192.168.0.2:7011"/>
		<redisson:node-address value="redis://192.168.0.3:7011"/>
		<redisson:node-address value="redis://192.168.0.1:7012"/>
		<redisson:node-address value="redis://192.168.0.2:7012"/>
		<redisson:node-address value="redis://192.168.0.3:7012"/>
	</redisson:cluster-servers>                                
	
</redisson:client>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3818
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3819
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When using redis and sentinel in hostname mode, when redis and sentinel instances are restarted, the redisson client should allow its known slaves to reconnect to the same master.
Actual behavior
Redisson is comparing the hostname to a saved IP address and not realized it is the same.
Steps to reproduce or test case
Redis deployed into K8s using the following settings:
replica-announce-ip <hostname>
sentinel announce-ip <hostname>
sentinel resolve-hostnames yes
sentinel announce-hostnames yes

Redis version
6.0.15
Redisson version
9a7eb2e  (3.16.2-SNAPSHOT taken after the linked issue was merged)
Redisson configuration
sentinelServersConfig:
  sentinelAddresses:
    - "redis://${REDIS_SENTINEL_SVC}:26379"
  username: "${REDIS_USER}"
  password: "${REDIS_PASSWORD}"
  sentinelPassword: "${REDIS_SENTINEL_PASSWORD}"
  masterName: mymaster
codec: !<org.redisson.codec.SerializationCodec> {}

Setup:
3 redis + 3 sentinel (running in a Kubernetes cluster), kill off 2 pairs of redis/sentinels pods (redis master and a replica)
the pods come back with different IP address sometimes (but not always) and they a
Redis returns to a healthy state, but running into issues where the client can't recover.
One issue is that replicas coming back are not being considered having the same master

We can see here that the SentinelConnectionManager thinks current master is 100.64.110.145 while the replica is reporting its master as redis-node-1's hostname
they both point to the same instance, but the comparison is not working correctly.

I'm not sure yet if its caused by the same comparison issue, when killing and recreating the pod which was running the master redis node, we are running into a state where the ClientConnectionsEntry for MASTER is marked as frozen, even after it should have been working. I think it may be a timing issue with the unfreeze call during re-connection, but still working on isolating it. (if i manually unfreeze the master entry via remote debugging, it starts to work again)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3820
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I submit Lambda task into RExecutorService but get strange executing result.
below is my code:
private RExecutorService rExecutorService;

for (int i = 0; i < count; i++) {
            int j = i;
            rExecutorService.submit((Runnable & Serializable) () -> {
                logger.info("test-1-sleep-" + j);
            });
        }

for count = 2, I expect the log will print
test-1-sleep-0
test-1-sleep-1

but indeed it will print
test-1-sleep-0
test-1-sleep-0

The j in Lambda after deserialize will always be 0 in remote debugging.
Expected behavior
the log print
test-1-sleep-0
test-1-sleep-1

Actual behavior
the log print
test-1-sleep-0
test-1-sleep-0

Steps to reproduce or test case
samplecode.tar.gz
Redis version
5.0.6
Redisson version
3.16.1
3.16.3 SNAPSHOT
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3821
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson/redisson/src/main/java/org/redisson/RedissonLock.java
    
    
         Line 238
      in
      f7fbb9f
    
  
  
    

        
          
           if (!subscribeFuture.cancel(false)) { 
        
    
  


RFuture<RedissonLockEntry> subscribeFuture = subscribe(threadId);
        if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {
            if (!subscribeFuture.cancel(false)) {
                subscribeFuture.onComplete((res, e) -> {
                    if (e == null) {
                        unsubscribe(subscribeFuture, threadId);
                    }
                });
            }
            acquireFailed(waitTime, unit, threadId);
            return false;
        }

The tryLock(long waitTime, long leaseTime, TimeUnit unit) method, if the subscribe timeout, and then subscribeFuture.cancel success,when to call unsubscribe , the subscribeFuture.onComplete should move out ,before the if block.
RFuture<RedissonLockEntry> subscribeFuture = subscribe(threadId);
       subscribeFuture.onComplete((res, e) -> {
                    if (e == null) {
                        unsubscribe(subscribeFuture, threadId);
                    }
                });
        if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {
           subscribeFuture.cancel(false);
            acquireFailed(waitTime, unit, threadId);
            return false;
        }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3822
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redis:4.0.14
redisson:3.16.1
use client.getBitSet("bitsettest").getByte(1)
it will send "bitfield bitsettest get i8 1" to slave node
but redis return a error -READONLY You can't write against a read only slave.
so bitfield xx get ...  command only work on master node?so we need use “commandExecutor.writeAsync” to execute command?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3823
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unable to reproduce
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
SENTINEL SENTINELS command returns less than 2 nodes! At least two sentinels should be defined in Redis configuration. Set checkSentinelsList = false to avoid this check.

Any idea why this could happen
spring:
  redis:
    ssl: false
    lettuce:
      pool: 
        maxActive: 100      
        maxIdle: 10         
        maxWait: 30000       
    timeout: 15000
    password: xxxx
    sentinel:
      master: local-master
      nodes: ip1:26379,ip1:26380,ip1:26381

note：redisson version 3.15.0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3825
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We use Azure Cache for Redis.
We configure Redisson as follows:
clusterServersConfig:
nodeAddresses:

"rediss://ixcc-sbx-26-redis.redis.cache.windows.net:6380"

In our application log we see Redisson querying cluster nodes details and obtaining info about two specific instances (Master and Replica; ports 15000 and 15001)
02/09/2021 12:40:26.570 [main] INFO org.redisson.cluster.ClusterConnectionManager Redis cluster nodes configuration got from ixcc-sbx-26-redis.redis.cache.windows.net/10.226.20.4:6380:
128ecd2830f3ee29d7906c40dc839d15838907cd 10.226.20.4:15000 slave e314c539ea4647b84e1908362cc24e18f8674e57 0 1630586426346 7 connected
e314c539ea4647b84e1908362cc24e18f8674e57 10.226.20.4:15001 myself,master - 0 0 7 connected 0-16383
Based on Redisson logs it seems the library is connecting to specific instances, e.g.:
02/09/2021 12:40:27.174 [redisson-netty-2-7] DEBUG org.redisson.connection.ClientConnectionsEntry new connection created: RedisConnection@1173046334 [redisClient=[addr=rediss://10.226.20.4:15001], channel=[id: 0x87578bff, L:/10.226.9.69:48264 - R:10.226.20.4/10.226.20.4:15001], currentCommand=null]
We're observing issues when there's a scheduled maintenance on Redis instances (github issue 3739).
Microsoft support came back to us with following feedback: your application is directly connecting to the port 15001 which means it is connecting to specific instance. Please note that it is not a good practice to connect to the specific instance as during patching, if it goes down for an update, you start seeing errors. I would suggest you to connect to Redis over port 6380.
Is it possible to make Redisson follow this recommendation i.e. always connect to port 6380 and not to specific instances?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3826
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3827
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello,
We have multiple instances of an application running in AWS ECS.
We periodically encounter a scenario where one (not all) container's RedissonClient with ConnectionListener receives onDisconnect calls from previously connected Redis hosts that never connects again. Other containers remain connected to the same hosts and are able to operate as expected.
Hoping for assistance to understand a way to avoid this scenario.
When we run against a docker cluster on our local computers, we are able to restart Redis instances at will and see disconnects and reconnects as we expect. Only in AWS do we find permanent disconnects. Eventually, our RedissonClient is disconnected from Redis completely and cannot make any progress on its work.
Thank you for any help.
Our RedissonClient is created more or less like so:
    val redissonConfig = new RedissonConfig
    val clusterConfig  = redissonConfig.useClusterServers

    clusterConfig
      .setConnectTimeout(...)
      .setTimeout(...)
      .setPingConnectionInterval(...)
      .setRetryAttempts(...)
      .setScanInterval(...)
      .setPassword(...)

    for (host <- hosts)
      clusterConfig.addNodeAddress(host)

    redissonConfig.setConnectionListener(new RedisConnectionListener(...))
    val client = Redisson.create(redissonConfig)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3828
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson: 3.16.2
Netty: 4.1.67.Final
Netty-epoll : 4.1.67.Final
org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:50:queue:0, freeConnectionsAmount=2, freeConnectionsCounter=value:15:queue:0, freezeReason=null, client=[addr=redis://10.178.22.6:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@1103912317 [redisClient=[addr=redis://10.178.22.6:6379], channel=[id: 0x7839e36f, L:/10.171.102.45:46670 ! R:10.178.22.6/10.178.22.6:6379], currentCommand=null], command: null, params: null after 0 retry attempts
at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:280)
at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:60)
at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:161)
at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:158)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1017)
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:878)
at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367)
at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717)
at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764)
at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: io.netty.channel.StacklessClosedChannelException
at io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source)
Redisson Config
Config config = new Config();
config.setTransportMode(OsUtils.getTransportMode());
ClusterServersConfig serversConfig = config.useClusterServers();
serversConfig.setReadMode(ReadMode.MASTER_SLAVE);
serversConfig.setRetryInterval(1500);
serversConfig.setRetryAttempts(0);
serversConfig.setConnectTimeout(10000);
serversConfig.setMasterConnectionPoolSize(15);
serversConfig.setSlaveConnectionPoolSize(15);
serversConfig.setMasterConnectionMinimumIdleSize(2);
serversConfig.setSlaveConnectionMinimumIdleSize(2);
serversConfig.setSubscriptionConnectionMinimumIdleSize(0);
You can't try to checkFuture by write command to redis, the slave node in redis cluster shouldn't be allowed to do this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
While running a load test, I'm occasionally seeing these "Unable to send PING command" errors. Wondering if there's a particular timeout setting I can use to try to overcome these. Separately, trying to understand if this could be related to spurious disconnects seen by a configured ConnectionListener. In a previous question, I asked about any experience/advice regarding how to manage cases where a RedissonClient loses connections that are never re-established. If a RedissonClient has disconnected from a cluster, what is the best way to heal it and re-establish connections to the cluster?
[redisson-timer-11-1] 14 Sep 2021 12:04:25,110-0400 ERROR PingConnectionHandler  Unable to send PING command over channel: [id: 0x3a394b04, L:0.0.0.0/0.0.0.0:36126 ! R:prom-cnrpoc-redlock-1-dev-0001-002.prom-cnrpoc-redlock-1-dev.kct6w1.use1.cache.amazonaws.com/10.147.1
at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:219)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3831
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 的配置好像无法使用 jasypt 进行加密解密？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3832
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When a master/slave fails over, the appropriate connection pool should only reconnect once and no. of connections on redis server should be 2X at max.
Actual behavior
Seeing multiple connection pools being initialised and repeatedly a pub sub connection being initialised, making failover redis node unresponsive due to connection exhaustion.
Logs from a single application server, initialising slave pool 20 times, in less than 4 seconds
16-09-2021;13:16:27.222 [redisson-netty-18-7] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:27.403 [redisson-netty-18-21] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:27.443 [redisson-netty-15-19] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:27.852 [redisson-netty-18-15] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.104 [redisson-netty-18-25] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.342 [redisson-netty-18-1] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.343 [redisson-netty-15-16] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.431 [redisson-netty-15-28] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.476 [redisson-netty-15-1] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.577 [redisson-netty-15-29] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.781 [redisson-netty-15-25] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.970 [redisson-netty-18-31] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:28.993 [redisson-netty-15-19] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.158 [redisson-netty-18-9] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.181 [redisson-netty-15-29] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.601 [redisson-netty-15-25] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.803 [redisson-netty-15-18] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.825 [redisson-netty-18-32] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:29.998 [redisson-netty-18-17] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:30.154 [redisson-netty-15-11] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:30.197 [redisson-netty-15-4] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002 16-09-2021;13:16:30.266 [redisson-netty-18-28] INFO  o.r.c.pool.SlaveConnectionPool - 24 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:9002
Steps to reproduce or test case
Not sure, as it was an unexpected outage of redis server. But you can try failing multiple redis nodes at once.
Redis version
6.2.1
Redisson version
3.16.1
Redisson configuration
config.useClusterServers();
for (String hostAndPort : hostAndPorts) {
LOGGER.info("Configuring RedissonUtil with Redis Server Response timeout : {}",timeout);
config.useClusterServers().addNodeAddress("redis://"+hostAndPort)
.setTimeout(timeout)
.setScanInterval(200)
.setRetryInterval(100);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3833
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
If a redis server goes down, maximum of 2x connections should be seen on the failover node, with no change needed in pub sub connections.
Actual behavior
We are seeing much more connections than 2x (Reaching 50k connected clients in this case) and pub sub connections being initialised repeatedly to the nodes on the unreachable server.
Does redisson require pub sub pool for any internal functions or can the pool size be set to 0, effectively disabling it?
16-09-2021;18:30:59.829 [redisson-netty-11-31] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:00.728 [redisson-netty-11-15] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:01.111 [redisson-netty-11-24] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:03.032 [redisson-netty-11-22] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:03.224 [redisson-netty-11-8] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:03.643 [redisson-netty-11-26] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:04.060 [redisson-netty-11-17] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:04.697 [redisson-netty-11-14] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:04.806 [redisson-netty-8-20] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:05.784 [redisson-netty-8-4] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:05.951 [redisson-netty-11-1] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:06.359 [redisson-netty-11-7] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:06.360 [redisson-netty-11-25] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:07.830 [redisson-netty-8-1] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:08.214 [redisson-netty-8-24] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:08.475 [redisson-netty-11-19] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:08.857 [redisson-netty-11-6] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:08.857 [redisson-netty-8-10] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:09.564 [redisson-netty-8-14] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:09.756 [redisson-netty-11-1] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:10.347 [redisson-netty-8-32] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:10.353 [redisson-netty-11-5] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:12.180 [redisson-netty-8-27] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:12.232 [redisson-netty-8-27] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:12.232 [redisson-netty-8-19] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:12.375 [redisson-netty-11-26] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:12.695 [redisson-netty-8-24] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:13.079 [redisson-netty-8-28] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:13.334 [redisson-netty-11-20] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:13.469 [redisson-netty-11-19] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:14.054 [redisson-netty-8-21] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:14.166 [redisson-netty-8-1] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:14.224 [redisson-netty-8-19] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:14.224 [redisson-netty-11-27] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:14.224 [redisson-netty-11-9] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:14.586 [redisson-netty-8-9] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:15.007 [redisson-netty-8-17] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:15.869 [redisson-netty-11-22] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:16.679 [redisson-netty-8-3] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:17.052 [redisson-netty-11-12] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:17.886 [redisson-netty-11-20] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:18.767 [redisson-netty-8-5] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:19.353 [redisson-netty-8-18] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:19.383 [redisson-netty-11-16] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:19.616 [redisson-netty-11-25] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:19.740 [redisson-netty-11-26] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:19.745 [redisson-netty-11-28] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:19.838 [redisson-netty-11-8] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:20.262 [redisson-netty-8-14] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:20.825 [redisson-netty-11-13] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:20.883 [redisson-netty-11-27] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:20.903 [redisson-netty-11-30] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:21.208 [redisson-netty-8-4] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:21.722 [redisson-netty-11-20] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:21.727 [redisson-netty-11-28] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:22.803 [redisson-netty-11-16] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:23.195 [redisson-netty-11-31] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:23.512 [redisson-netty-11-4] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:23.592 [redisson-netty-8-31] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:25.181 [redisson-netty-8-13] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:25.289 [redisson-netty-8-26] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:25.628 [redisson-netty-11-17] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:25.705 [redisson-netty-8-24] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:26.137 [redisson-netty-8-7] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:26.358 [redisson-netty-8-8] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:27.288 [redisson-netty-8-16] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:28.224 [redisson-netty-8-11] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:29.504 [redisson-netty-11-12] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 16-09-2021;18:31:29.701 [redisson-netty-11-6] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7003 16-09-2021;18:31:29.745 [redisson-netty-11-11] INFO  o.r.c.pool.PubSubConnectionPool - 1 connections initialized for IP_OF_REDIS_SERVER/IP_OF_REDIS_SERVER:7001 
Steps to reproduce or test case
1 VM was running 3/18 cluster nodes in the redis cluster.  It became unresponsive and we saw a surge in connections to that VM after that.
Redis version
3.2.6
Redisson version
3.16.1
Redisson configuration
config.useClusterServers();
for (String hostAndPort : hostAndPorts) {
LOGGER.info("Configuring RedissonUtil with Redis Server Response timeout : {}",timeout);
config.useClusterServers().addNodeAddress("redis://"+hostAndPort)
.setTimeout(timeout)
.setScanInterval(200)
.setRetryInterval(100);
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We have Redis setup in as a Master with 2 Slaves.  Generally it works well.  Occasionally when we pull a large cached object from Redis, the time to pull the data from the cache is 50-60 seconds.  The good times we have seen are 3-6 seconds to pull the same data.  Is their anything we can do to make it more consistent (obviously we want it to be in the 3-6 seconds range).  The data is stored in an RList.  This particular case the data is very large, 16-17MB.  This is an unusual case, but we need to be faster nonetheless.
I have run the latency checks on the server, no issues there.
I will add that we are constantly adding new items to the cache.  These items expire after 60 minutes (ttl).  The cache typically has about 1600 items in it at any given time (during peak usage hours).  Redis is running inside a Kubernetes environment, as is the client application (same K8S environment).  Memory usage for the 3 Redis instances is hovering around 70-80MB we have allocated 2G for each (max).
Is there anything you can think of that would cause a request for cached item to suddenly take 50-60 seconds?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3835
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
1、Write the data to the redisson delay queue and set delay time is 30s
2、Shutdown the consumer application within 30s and starts again
3、Start consumer application before or after 30s
4、I expect to receive a delayed message

Actual behavior
1、The consumer application is no longer received until the delay queue's data is delay
2、Write a new data to the redisson delay queue , the consumer side can receive historically unspent and newly written data

Steps to reproduce or test case
@Override
public void addDelayQueue(T data, long delayTime, TimeUnit timeUnit, String queueName) {
    try {
        RBlockingDeque<Object> blockingDeque = redissonClient.getBlockingDeque(queueName);
        RDelayedQueue<Object> delayedQueue = redissonClient.getDelayedQueue(blockingDeque);
        // delayedQueue.offer(data, delayTime, timeUnit);
        delayedQueue.offerAsync(data, delayTime, timeUnit);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

@Override
public <T> T getDelayQueue(String queueName) throws InterruptedException {
    RBlockingDeque<Map> blockingDeque = redissonClient.getBlockingDeque(queueName);
    T result = (T) blockingDeque.take();
    // T result = (T) blockingDeque.poll();
    // TimeUnit.SECONDS.sleep(5);
    return  result;
}
STEP 1 Offer data to the delay queue, set delay 30s
delayQueueService.addDelayQueue("HELLO", 30, TimeUnit.SECONDS, "TEST");

STEP 2 Shutdown consumer application 

STEP 3 Start consumer application
the delay data can not be recevied, Expected recevied the delay data

STEP 4 Offer data to delay queue again,but do not shutdown consumer application
delayQueueService.addDelayQueue("HELLO AGAIN", 30, TimeUnit.SECONDS, "TEST");

STEP 5 The consumer application received the message "HELLO" immediately, and 30s later , the message "HELLO AGAIN" can be received
I expect to receive a delayed message without pushing a new or null data to the delay queue
Redis version
6.2.4

Redisson version
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.16.2</version>
</dependency>
Redisson configuration
@Configuration
public class RedissonConfig {
  
    @Value("${spring.redis.host}")
    private String host;
    @Value("${spring.redis.port}")
    private int port;
    @Value("${spring.redis.database:0}")
    private int database;
  
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://" + host + ":" + port)
            .setDatabase(database);
        return Redisson.create(config);
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3836
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Spring Boot 2.4.10

@Slf4j
@SpringBootTest
class Demo1ApplicationTests {
	@Autowired
	private RedisTemplate redisTemplate;

	@Test
	void testString() {
		redisTemplate.opsForValue().set("keyString", "222");
	}

	@Test
	void testZSet() {
		redisTemplate.opsForZSet().add("keyZSet", "11", 1.0D);
	}


}


This is simple demo.
string is ok.


Spring Boot 2.5.4


This is ok
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3837
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Due to security issues, I want him to use the default dns instead of netty to read /etc/hosts。
:)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3838
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
From the dependency of redisson 3.11.3 version, we can see that the spring boot used is 2x, and now our project uses spring boot 1.5.9, how should I upgrade to redisson 3.11.3 version? The following is a screenshot of the error report


The reason for the upgrade is to fix the bugs of versions before 3.9.1
#1811
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3839
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Let's imagine a stream created like this.
RStreamReactive<String, PaymentEvent> stream = redissonReactiveClient.getStream("payment-stream", new TypedJsonJacksonCodec(String.class, PaymentEvent.class));
I thought I should be able to add a list of payment events into the stream. But looks like I need to always convert it into a map to add it to the stream.
  StreamAddArgs.entry()
  StreamAddArgs.entries(....)

My point is - each stream entry is for 1 event. Not for collection of events.
I have to add it like this.
  for(paymentevent : events){
  	StreamAddArgs.entry("unnessaryKey", paymentevent);
  	.....
  }

If we see, the key is basically unnecessary here.
Can you please explain the reason behind the such data structure? Is it because redis's limitation? Or do we have any other better use case?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3840
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson Version : 3.16.1
Redis : 6.0.5
Getting the below error when trying to remove cache entries in bulk(more than 10000) in Redis.
org.redisson.client.RedisException: ERR Error running script (call to f_9b685e1701377cfef2bd44d1c23770aaa4143fbf): @user_script:1: user_script:1: too many results to unpack . channel: [id: 0x6145c965, L:/100.72.9.98:39942 - R:ampm-redis-cluster-0001-002.ampm-redis-cluster.a8y5su.use1.cache.amazonaws.com/100.72.14.183:6379] command: (EVAL), params: [local maxSize = tonumber(redis.call('hget', KEYS[6], 'max-size')); if maxSize ~= nil and maxSize ~= ..., 6, INST_CACHE, redisson__timeout__set:
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3842
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Does Redisson expose an interface to execute any Redis command? Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Use ExecutorService to obtain the redis value. After obtaining the redis value, cancel the task, and redisson throws an exception.
org.redisson.client.RedisException: Unexpected exception while processing command
Demo Code
@Slf4j
@SpringBootTest
class RedisTest {
	private static final Integer SUM_I = 1000;
	private static final Integer SECONDS = 60 * 60;
	private static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(SUM_I);
	@Resource  private RedisService redisService;

	@Test  void test() { 
		// init redis value  
		for (int i = 1; i <= SUM_I; i++) {
            setRedis(i);  
        }

        // create task  
        List<FutureTask<Integer>> futureTasks = Lists.newArrayList();
        for (int i = 1; i <= SUM_I; i++) { 
        	int finalI = i;  FutureTask<Integer> futureTask = new FutureTask<>(() -> getRedis(finalI));
        	  futureTasks.add(futureTask); 
	    } 

	   // get redis value  
	   futureTasks.forEach(EXECUTOR_SERVICE::submit);  
	   for (int i = 0; i < futureTasks.size(); i++) {
            Integer value = null;  
            try {
                value = futureTasks.get(i).get();  
            } catch (Exception e) {
                e.printStackTrace();  
            } 
            int skipI = i + 1;  
            if (Objects.nonNull(value)) {
                futureTasks.stream()
                        .skip(skipI)
                        .forEach(task -> task.cancel(true));  
                break;  
            }
        }
    } 

    private void setRedis(Integer no) {
        String key = "TEST:" + no;  
        redisService.set(key, no, SECONDS); 
    }

    private Integer getRedis(Integer no) {
        String key = "TEST:" + no;
        try {
            Thread.sleep(500L + no);  
        } catch (InterruptedException e) {
            e.printStackTrace();  
        }
        Integer redisNo = redisService.get(key);  
        System.out.println("TEST:" + redisNo);  
        return redisNo;  
    }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
RKeys keys = redissonClient.getKeys();
	Iterable<String> keysByPattern = keys.getKeysByPattern("district:city:name:*" + name + "*");
	List<Object> objects = new ArrayList<>();
	keysByPattern.forEach(key->{
		RBucket<Object> bucket = redissonClient.getBucket(key);
		Object o = bucket.get();
		if (o!=null){
			objects.add(o);
		}
	});

why this code cost 42047ms,but only 6000+ keys in my redis,redisson ver 3.16.1
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3845
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
EntryXXXListener is working
Actual behavior
EntryXXXListener is not working on Turkish language Windows 10
You can read at https://mattryall.net/blog/the-infamous-turkish-locale-bug for more information.
Easiest fix will be changing toLowerCase() calls to toLowerCase(Locale.ENGLISH)
I guess problem comes from usage at CommandPubSubDecoder.java
Steps to reproduce or test case
You can force Turkish language by giving JVM argument -Duser.language=tr and try to use listeners on any map with name which includes character 'i'
Redis version
6.2.4
Redisson version
3.16.1
Redisson configuration
        Codec codec = new Kryo5Codec();
        Config config = new Config();
        config.setCodec(codec);
        config.useSingleServer().setAddress(this.redisURL);
        return Redisson.create(config);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3846
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
When I use the keys method for fuzzy matching, there are only 15 keys, which takes 7-800 milliseconds after iterative processing
Steps to reproduce or test case
RedissonClient.keys("server:*").iterator()
Redis version
5.0
Redisson version
redisson-all-3.15.0
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3848
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3849
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
@mrniko
How is master slave mode different from replicated mode, after keep aside AWS EC support ?
Is it possible to do sharding using redisson across multiple standalone servers (non clustered) ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3850
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson should fail fast  when dealing with no idempotent operations instead of retrying.
Actual behavior
Redisson is retrying on no idempotent operations like  RDeque.pollFirst() / RPOP:
17:41:08.403 [main] DEBUG org.redisson.command.RedisExecutor - acquired connection for command (RPOP) and params [4ca54c23-b1eb-40f6-8969-6dd524894e88] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node /127.0.0.1:34851... RedisConnection@786189680 [redisClient=[addr=redis://127.0.0.1:34851], channel=[id: 0xd467f47d, L:/127.0.0.1:59257 - R:/127.0.0.1:34851], currentCommand=null]
17:41:08.483 [redisson-timer-4-1] DEBUG org.redisson.command.RedisExecutor - connection released for command (RPOP) and params [4ca54c23-b1eb-40f6-8969-6dd524894e88] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@786189680 [redisClient=[addr=redis://127.0.0.1:34851], channel=[id: 0xd467f47d, L:/127.0.0.1:59257 - R:/127.0.0.1:34851], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7cda9d9e(failure: java.util.concurrent.CancellationException)], command=(RPOP), params=[4ca54c23-b1eb-40f6-8969-6dd524894e88], codec=org.redisson.codec.MarshallingCodec]]
17:41:08.484 [redisson-timer-4-1] DEBUG org.redisson.command.RedisExecutor - attempt 1 for command (RPOP) and params [4ca54c23-b1eb-40f6-8969-6dd524894e88]
17:41:08.486 [redisson-timer-4-1] DEBUG org.redisson.command.RedisExecutor - acquired connection for command (RPOP) and params [4ca54c23-b1eb-40f6-8969-6dd524894e88] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using node /127.0.0.1:34851... RedisConnection@924378696 [redisClient=[addr=redis://127.0.0.1:34851], channel=[id: 0x3b7b128c, L:/127.0.0.1:59254 - R:/127.0.0.1:34851], currentCommand=null]
17:41:08.538 [redisson-netty-2-7] DEBUG org.redisson.command.RedisExecutor - connection released for command (RPOP) and params [4ca54c23-b1eb-40f6-8969-6dd524894e88] from slot NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null] using connection RedisConnection@924378696 [redisClient=[addr=redis://127.0.0.1:34851], channel=[id: 0x3b7b128c, L:/127.0.0.1:59254 - R:/127.0.0.1:34851], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@642daaf(success: [consumerName=PlaceholderConsumer,eventId=6801da50-f27f-4ed2-9b31-b734e2082052,moduleName=<null>,queuedDate=2021-09-27T17:41:03.617130Z,storedDate=<null>,ttl=2021-09-27T17:40:43.617130Z])], command=(RPOP), params=[4ca54c23-b1eb-40f6-8969-6dd524894e88], codec=org.redisson.codec.MarshallingCodec]]

In the above scenario, the queue was popped twice, causing data loss.
Steps to reproduce or test case
Redis version
Any
Redisson version
Any
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I had to do a bit of a workaround to pick the Redisson Hibernate 2LC instead of the official Quarkus 2LC:
class CacheServiceContributor : ServiceContributor {
    override fun contribute(serviceRegistryBuilder: StandardServiceRegistryBuilder) {
        serviceRegistryBuilder.addInitiator(CacheRegionFactoryInitiator.INSTANCE)
    }
}

class CacheRegionFactoryInitiator : StandardServiceInitiator<RegionFactory> {

    override fun getServiceInitiated(): Class<RegionFactory> {
        return RegionFactory::class.java
    }

    override fun initiateService(
        configurationValues: MutableMap<Any?, Any?>?,
        registry: ServiceRegistryImplementor?
    ): RegionFactory {
        return CustomisedRedissonRegionFactory()
    }

    companion object {
        val INSTANCE = CacheRegionFactoryInitiator()
    }
}

class CustomisedRedissonRegionFactory : RedissonRegionFactory() {
    override fun createRedissonClient(properties: MutableMap<Any?, Any?>?): RedissonClient {
        val inputStream = Thread.currentThread().contextClassLoader.getResourceAsStream("redisson.yaml")
        return Redisson.create(Config.fromYAML(inputStream))
    }
}
#resources/META-INF/services/org.hibernate.service.spi.ServiceContributor
com.myorg.CacheServiceContributor

Notice how I've also had to override createRedissonClient(). This was due to the config file not being found when running in Quarkus Dev Mode.
See Quarkus#2531. They suggest using currentThread() to get the correct classloader
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3853
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
By official tutorials, the maximum sessions valid time would be 30 minutes, and my application’s maximum valid time is expected to set to 24hours, how to configure the redisson?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3855
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
We usually add custom tags, like "environment", to our Spring Boot apps the way recommended by Spring Boot docs:
management.metrics.tags.environment=LOCAL
So that all metrics exported to our InfluxDB contains this tag.
We moved to Redisson recently, with a PRO license, and configured the metrics export with Influx as pointed in docs this way:
	@Bean
	public RedissonClient redissonClient(final RedissonProperties redissonProperties, @Nullable final InfluxMeterRegistryProvider influxMeterRegistryProvider) {

		final Config config = new Config();

		(...)

		if (nonNull(influxMeterRegistryProvider)) {
			//https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#1414-statistics-monitoring-jmx-and-other-systems
			config.setMeterRegistryProvider(influxMeterRegistryProvider);
		}

		return Redisson.create(config);
	}

	@Bean
	@ConditionalOnProperty(name = "management.metrics.export.influx.enabled", havingValue = "true")
	InfluxMeterRegistryProvider influxMeterRegistryProvider(final InfluxProperties influxProperties) {

		final InfluxMeterRegistryProvider provider = new InfluxMeterRegistryProvider();

		provider.setBatchSize(influxProperties.getBatchSize().toString());
		provider.setStep(influxProperties.getStep().getSeconds() + "s");
		provider.setUri(influxProperties.getUri());
		provider.setDb(influxProperties.getDb());

		return provider;
	}

We can correctly see metrics in our InfluxDB but the environment custom tag is missing.
Also tried this with no luck:
	@Bean
	MeterRegistryCustomizer<MeterRegistry> metricsConfiguration() {

		return registry -> registry.config()

			// Common tags to put in every metric
			.commonTags("environment", "LOCAL")

How can we do this?
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3856
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3857
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson Jar causes all servers in the cluster to crash due to SIGSEGV issues related to Date Format
Below is the Thread details .
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007f65d359d56f, pid=705, tid=0x00007f652e66b700
#
# JRE version: OpenJDK Runtime Environment (8.0_302-b08) (build 1.8.0_302-b08)
# Java VM: OpenJDK 64-Bit Server VM (25.302-b08 mixed mode linux-amd64 compressed oops)
# Problematic frame:
# J 529951 C2 java.text.SimpleDateFormat.compile(Ljava/lang/String;)[C (678 bytes) @ 0x00007f65d359d56f [0x00007f65d359d520+0x4f]
#
# Failed to write core dump. Core dumps have been disabled. To enable core dumping, try "ulimit -c unlimited" before starting Java again
#
# If you would like to submit a bug report, please visit:
#   https://bugzilla.redhat.com/enter_bug.cgi?product=Red%20Hat%20Enterprise%20Linux%207&component=java-1.8.0-openjdk
#

---------------  T H R E A D  ---------------

Current thread (0x00007f6570049000):  JavaThread "redisson-netty-1-4" [_thread_in_Java, id=1913, stack(0x00007f652e56b000,0x00007f652e66c000)]

siginfo: si_signo: 11 (SIGSEGV), si_code: 1 (SEGV_MAPERR), si_addr: 0x0000000000000044

Registers:
RAX=0x00000007c3dc7440, RBX=0x00000007c3dc7440, RCX=0x00000000d9d93fe2, RDX=0x00000007c3dc7440
RSP=0x00007f652e669780, RBP=0x00000007c3742840, RSI=0x00000007c3742840, RDI=0x00000006cec6c6e0
R8 =0x00000000000a87d7, R9 =0x00000000000a87d6, R10=0x00000007c3742840, R11=0x0000000000000007
R12=0x0000000000000000, R13=0x00000007d080e980, R14=0x00000000d9d8d8dc, R15=0x00007f6570049000
RIP=0x00007f65d359d56f, EFLAGS=0x0000000000010202, CSGSFS=0x0000000000000033, ERR=0x0000000000000004
  TRAPNO=0x000000000000000e

Top of Stack: (sp=0x00007f652e669780)
0x00007f652e669780:   00000006f87119c9 00000007000a810a
0x00007f652e669790:   00000006cec6c6e0 00007f65d3bf3ee0
0x00007f652e6697a0:   00000000e30dd247 00000007c3742840
0x00007f652e6697b0:   00000007c3dc7440 000000071ff13278
0x00007f652e6697c0:   00000000e5afdc59 00007f65d99cfba0
0x00007f652e6697d0:   00000006dbfc17d0 00000007d080e980
0x00007f652e6697e0:   0000000000000008 00000006d39921c0
0x00007f652e6697f0:   00000007186e8bf0 00000007c3742840
0x00007f652e669800:   00000006cec6c6a0 0000000100000002
0x00007f652e669810:   00000006e5afdc59 000000072d7ee2c8
0x00007f652e669820:   00000006cec6c6a0 00000007c3742840
0x00007f652e669830:   00000007c3742840 00007f65d51453c8
0x00007f652e669840:   00000007c3742840 00000007d083dfd0
0x00007f652e669850:   00000007d2374988 00000007d0849918
0x00007f652e669860:   000000071ff13278 000000070c3d96d8
0x00007f652e669870:   0000000723618aa0 00000000d83dacb9
0x00007f652e669880:   00000000dbb0b697 00007f65d7eed0e8
0x00007f652e669890:   0000000000000001 00000006cec6c8f0
0x00007f652e6698a0:   00000006e17925e0 000a8568000a8568
0x00007f652e6698b0:   00000007c3743060 00007f65d6a79384
0x00007f652e6698c0:   dbb0b69700000000 00007f65a697c000
0x00007f652e6698d0:   da732438d9d8d8d4 00000006cec6c6a0
0x00007f652e6698e0:   00000007d0849b38 00000006dd85b4b8
0x00007f652e6698f0:   00000007186e9320 00000007d0800f28
0x00007f652e669900:   00000006b5644898 00000006d39921c0
0x00007f652e669910:   00000006cec6c6a0 00000007c3742840
0x00007f652e669920:   00000007186e8bf0 00000007c3743008
0x00007f652e669930:   00000007186e92a8 00000007d083dfd0
0x00007f652e669940:   00000007d2374988 00000007d0849918
0x00007f652e669950:   00000006cec6c6a0 000a857c000a857c
0x00007f652e669960:   00000000f87119c9 00007f65d2dcbdec
0x00007f652e669970:   000000070000040c 00000007c3742840 

Instructions: (pc=0x00007f65d359d56f)
0x00007f65d359d54f:   48 89 74 24 28 48 89 54 24 30 48 85 d2 0f 84 37
0x00007f65d359d55f:   20 00 00 44 8b 5a 0c 45 85 db 0f 84 3a 20 00 00
0x00007f65d359d56f:   43 8b 5c dc 0c 41 bb 08 dd 00 00 49 ba 00 00 80
0x00007f65d359d57f:   d0 07 00 00 00 4d 03 d3 4c 89 54 24 20 49 8b 47 

Register to memory mapping:

RAX=0x00000007c3dc7440 is pointing into object: 0x00000007c3d781d0

[error occurred during error reporting (printing register info), id 0xb]

Stack: [0x00007f652e56b000,0x00007f652e66c000],  sp=0x00007f652e669780,  free space=1017k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
J 529951 C2 java.text.SimpleDateFormat.compile(Ljava/lang/String;)[C (678 bytes) @ 0x00007f65d359d56f [0x00007f65d359d520+0x4f]
J 56984 C2 java.text.SimpleDateFormat.readObject(Ljava/io/ObjectInputStream;)V (114 bytes) @ 0x00007f65d51453c8 [0x00007f65d5145360+0x68]
J 56992 C2 sun.reflect.GeneratedMethodAccessor623.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (66 bytes) @ 0x00007f65d7eed0e8 [0x00007f65d7eed080+0x68]
J 55224 C2 org.nustaq.serialization.FSTObjectInput.readObjectCompatibleRecursive(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Ljava/lang/Object;Lorg/nustaq/serialization/FSTClazzInfo;Ljava/lang/Class;)V (254 bytes) @ 0x00007f65d6a79384 [0x00007f65d6a78600+0xd84]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a9b8 [0x00007f65d152a020+0x998]
J 66059 C2 org.nustaq.serialization.FSTObjectInput.readObjectFields(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Lorg/nustaq/serialization/FSTClazzInfo;[Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Ljava/lang/Object;II)V (538 bytes) @ 0x00007f65d99cfba0 [0x00007f65d99cfa20+0x180]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a624 [0x00007f65d152a020+0x604]
J 66059 C2 org.nustaq.serialization.FSTObjectInput.readObjectFields(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Lorg/nustaq/serialization/FSTClazzInfo;[Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Ljava/lang/Object;II)V (538 bytes) @ 0x00007f65d99cfba0 [0x00007f65d99cfa20+0x180]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a624 [0x00007f65d152a020+0x604]
J 66059 C2 org.nustaq.serialization.FSTObjectInput.readObjectFields(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Lorg/nustaq/serialization/FSTClazzInfo;[Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Ljava/lang/Object;II)V (538 bytes) @ 0x00007f65d99cfba0 [0x00007f65d99cfa20+0x180]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a624 [0x00007f65d152a020+0x604]
J 29700 C2 org.nustaq.serialization.serializers.FSTMapSerializer.instantiate(Ljava/lang/Class;Lorg/nustaq/serialization/FSTObjectInput;Lorg/nustaq/serialization/FSTClazzInfo;Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;I)Ljava/lang/Object; (118 bytes) @ 0x00007f65d6124430 [0x00007f65d61231c0+0x1270]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a8e4 [0x00007f65d152a020+0x8c4]
J 66059 C2 org.nustaq.serialization.FSTObjectInput.readObjectFields(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Lorg/nustaq/serialization/FSTClazzInfo;[Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;Ljava/lang/Object;II)V (538 bytes) @ 0x00007f65d99cfba0 [0x00007f65d99cfa20+0x180]
J 67226 C2 org.nustaq.serialization.FSTObjectInput.readObjectWithHeader(Lorg/nustaq/serialization/FSTClazzInfo$FSTFieldInfo;)Ljava/lang/Object; (189 bytes) @ 0x00007f65d152a624 [0x00007f65d152a020+0x604]
J 54185 C2 org.redisson.codec.FstCodec$1.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/handler/State;)Ljava/lang/Object; (41 bytes) @ 0x00007f65d48ca880 [0x00007f65d48ca600+0x280]
J 298825 C2 org.redisson.client.handler.CommandDecoder.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/ChannelHandlerContext;Z)V (845 bytes) @ 0x00007f65d333ab78 [0x00007f65d333a860+0x318]
J 76834 C2 org.redisson.client.handler.CommandDecoder.decodeList(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/ChannelHandlerContext;JLjava/util/List;Z)V (268 bytes) @ 0x00007f65d47ef088 [0x00007f65d47eef20+0x168]
J 298825 C2 org.redisson.client.handler.CommandDecoder.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/ChannelHandlerContext;Z)V (845 bytes) @ 0x00007f65d333aa9c [0x00007f65d333a860+0x23c]
J 126439 C2 org.redisson.client.handler.CommandDecoder.decode(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Ljava/util/List;)V (124 bytes) @ 0x00007f65dbb9bacc [0x00007f65dbb9b6a0+0x42c]
J 53435 C2 io.netty.handler.codec.ReplayingDecoder.callDecode(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Ljava/util/List;)V (297 bytes) @ 0x00007f65d20123a8 [0x00007f65d2012220+0x188]
J 57751 C2 io.netty.handler.codec.ByteToMessageDecoder.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (317 bytes) @ 0x00007f65d97f74e8 [0x00007f65d97f70c0+0x428]
J 25677 C2 io.netty.channel.ChannelInboundHandlerAdapter.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (9 bytes) @ 0x00007f65d5309814 [0x00007f65d53095e0+0x234]
J 25677 C2 io.netty.channel.ChannelInboundHandlerAdapter.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (9 bytes) @ 0x00007f65d5309814 [0x00007f65d53095e0+0x234]
J 25677 C2 io.netty.channel.ChannelInboundHandlerAdapter.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (9 bytes) @ 0x00007f65d5309814 [0x00007f65d53095e0+0x234]
J 29094 C2 io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (9 bytes) @ 0x00007f65d3563814 [0x00007f65d35635e0+0x234]
J 95089 C2 io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized()V (99 bytes) @ 0x00007f65dab02288 [0x00007f65dab01a00+0x888]
J 34609% C2 io.netty.channel.nio.NioEventLoop.run()V (236 bytes) @ 0x00007f65d71aeab8 [0x00007f65d71ae900+0x1b8]
j  io.netty.util.concurrent.SingleThreadEventExecutor$5.run()V+44
j  io.netty.util.concurrent.FastThreadLocalRunnable.run()V+4
j  java.lang.Thread.run()V+11
v  ~StubRoutines::call_stub
V  [libjvm.so+0x6a051e]  JavaCalls::call_helper(JavaValue*, methodHandle*, JavaCallArguments*, Thread*)+0xf5e
V  [libjvm.so+0x69d8e4]  JavaCalls::call_virtual(JavaValue*, KlassHandle, Symbol*, Symbol*, JavaCallArguments*, Thread*)+0x2c4
V  [libjvm.so+0x69def9]  JavaCalls::call_virtual(JavaValue*, Handle, KlassHandle, Symbol*, Symbol*, Thread*)+0x59
V  [libjvm.so+0x734c21]  thread_entry(JavaThread*, Thread*)+0xa1
V  [libjvm.so+0xb0e4d2]  JavaThread::thread_main_inner()+0x212
V  [libjvm.so+0x93ed52]  java_start(Thread*)+0xf2
C  [libpthread.so.0+0x7ea5]  start_thread+0xc5

Not able to reproduce as I am not able to find the actual data. It looks it has something to do with  java.text.SimpleDateFormat.compile. However pushing this to all servers in the cluster and crashing is not expected.
Redis version
AWS ElastiCache 5.0.3
Redisson version
redisson-all-3.10.0.jar
Redisson configuration
{
   "clusterServersConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":6000,
      "retryAttempts":6,
      "retryInterval":3000,
      "failedSlaveReconnectionInterval":3000,
      "failedSlaveCheckInterval":60000,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "loadBalancer":{
         "class":"org.redisson.connection.balancer.RoundRobinLoadBalancer"
      },
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "slaveConnectionMinimumIdleSize":32,
      "slaveConnectionPoolSize":610,
      "masterConnectionMinimumIdleSize":32,
      "masterConnectionPoolSize":610,
      "readMode":"MASTER_SLAVE",
      "subscriptionMode":"SLAVE",
      "nodeAddresses":[
        "redis://aws-redis:xxxx"
      ],
      "scanInterval":1000,
      "pingConnectionInterval": 0,
      "keepAlive": false,
      "tcpNoDelay": false,
   },
   "threads":0,
   "nettyThreads": 0,
   "codec":{
          "class":"org.redisson.codec.FstCodec"
   },
   "transportMode":"NIO"
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3859
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Redisson getLock timeouts after timeout
Actual behavior
Redisson getLock timeouts after timeout + 1 second
Caused by: org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (1100 ms) occured after 0 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null, channel: [id: 0xa0b2c30d, L:/10.2.134.137:51870 - R:10.31.32.14/10.31.32.14:6379]
Redis version
Reproduced on 3.15 and 3.16.3
Redisson version
Any
Redisson configuration
connectTimeout: 75
timeout: 100
retryAttempts: 0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3860
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'm doing a batch command in the following way:
...
  final RBatch rBatch = redissonClient.createBatch();
        for (final String key : keys) {
            rBatch.getMap(key, StringCodec.INSTANCE).getAsync(fieldName);
        }
  final List<?> responses = rBatch.execute().getResponses();
 ...

From time to time we get the following Timeout exception:
org.redisson.client.RedisResponseTimeoutException: Redis server response timeout (20 ms) occured after 0 retry attempts. Increase nettyThreads and/or timeout settings. Try to define pingConnectionInterval setting. Command: null, params: null

I'm wondering about the Try to define pingConnectionInterval setting. in the WARN message. We use the default setting for PING (the 30s interval). What is the meaning of that sentence in the message? Is the PING necessary? Could we disable the PING?  How does the PING influences the batch command? Any suggestions how this WARN can be avoided?
Redis: 5.0.5
Redisson: 3.16.3
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3861
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Weve had to revert to using reddison and creating the client ourselves as it seems only config used at build time is injected into the client, which is then causing issues for the native build. Looking here it seems this may be the case. Is this to be expected, or am i missing something here. we need this to read from an external yaml file thats managed in kubernetes.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3862
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi
We create datastructures from RTransaction so that we can see uncomitted changes.
While this works on the same instance of the datastructure, it does not when the same thread retrieves it again from the same instance of the RTransaction.
As the RTransaction is the isolating bit, we were wondering, if the same RTransaction should return the same instance of the datastructure on subsequent calls.
This seems to be true with all datastructures (Bucket, Map, ...)
quick test:
class RedissonRtransactionApplicationTests {

  private RedissonClient redisson;

  @BeforeEach
  void setup() {
    Config config = new Config();
//assumes redis running on localhost
    config.useSingleServer().setAddress("redis://127.0.0.1:6379");
    redisson = Redisson.create(config);
  }

  @Test
  void readUncommitted() {
    RBucket<String> bucketBeforeTx = redisson.getBucket("someBucket");
    bucketBeforeTx.set("before");

    RTransaction tx = redisson.createTransaction(TransactionOptions.defaults());
    RBucket<String> bucket = tx.getBucket("someBucket");

    bucket.set("foo");
    Assertions.assertEquals("foo", bucket.get());

    bucket.set("bar");
    Assertions.assertEquals("bar", bucket.get());

    tx.rollback();

    Assertions.assertEquals("before", bucketBeforeTx.get());
  }

  @Test
  void readUncommittedRefetchBucket() {
    RBucket<String> bucketBeforeTx = redisson.getBucket("someBucket");
    bucketBeforeTx.set("before");


    RTransaction tx = redisson.createTransaction(TransactionOptions.defaults());
    RBucket<String> bucket = tx.getBucket("someBucket");

    bucket.set("foo");
    Assertions.assertEquals("foo", bucket.get());

    bucket = tx.getBucket("someBucket");
    // should still be foo, as it is the same TX ?
    try {
      Assertions.assertEquals("foo", bucket.get());
    } finally {
      tx.rollback();
    }
  }
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3863
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
adding redisson-spring-boot-starter as a dependency should not pull in junit and assertj as compile-time dependencies. these artefacts should not be deployed to a productive environment
currently pom.xml defines this:
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
        </dependency>
Actual behavior
pom.xml should define this:
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <scope>test</scope>
        </dependency>
Steps to reproduce or test case

create a spring-boot project
add redisson-spring-boot-starter as a dependency
build war file
war file includes junit and assertj

Redis version
6.0.3
Redisson version
3.16.3
Redisson configuration
unconfigured
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3864
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I would like to add a value synchronous on a RedissonPriorityQueue. The add méthod use method evalWriteAsync to add the value :
public boolean add(V value) {

        lock.lock();
        try {
            checkComparator();

            BinarySearchResult<V> res = binarySearch(value);
            int index = 0;
            if (res.getIndex() < 0) {
                index = -(res.getIndex() + 1);
            } else {
                index = res.getIndex() + 1;
            }
                
            commandExecutor.evalWriteAsync(getName(), codec, RedisCommands.EVAL_VOID,
               "local len = redis.call('llen', KEYS[1]);"
                + "if tonumber(ARGV[1]) < len then "
                    + "local pivot = redis.call('lindex', KEYS[1], ARGV[1]);"
                    + "redis.call('linsert', KEYS[1], 'before', pivot, ARGV[2]);"
                    + "return;"
                + "end;"
                + "redis.call('rpush', KEYS[1], ARGV[2]);", 
                    Arrays.<Object>asList(getName()), 
                    index, encode(value));
            return true;
        } finally {
            lock.unlock();
        }
    }

Why this method is async? How can i add a value synchronous?
For information, i use redisson version 3.15.2. I check the master : the method is the same.
Thanks in advance
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3865
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
In Redisson 3.15.2, getReferenceCodecProvider() was removed from RedissonObjectBuilder.java.
This breaks code that adds a reference codec with the RedissonObjectBuilder, for example:
redisson.getCommandExecutor().getObjectBuilder().getReferenceCodecProvider().registerCodec((Class) <MyClass.getClass(), myClassTypedCodec);
RedissonObjectBuilder now only allows registration of the single codec set on the Redisson Config object.
Is there an alternative way to add another reference codec?  We need to use JsonJacksonCodec by default for references, but have a sub class that needs to use TypedJsonJacksonCodec.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3866
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
when cache entry is expired, JCache call registered CacheEntryExpiredListener#onExpired method
Actual behavior
Did not call onExpired.
Other event types (CREATED, UPDATED, REMOVED) did call onCreted, onUpdated, onRemoved except onExpired
Steps to reproduce or test case

Build jcache with redisson
register CacheEntryEventListener to configuration

        override fun onExpired(events: MutableIterable<CacheEntryEvent<out K, out V>>) {
            log.info { "Cache entries is expired. keys=${events.map { it.key }.joinToString()} " }
            dispatch(events) { cache, event ->
                log.debug { "Remove cache entry. cache=$cache, key=${event.key}, value=${event.value}" }
                cache.remove(event.key)
            }
        }
test cases
        val jcacheConfiguration = jcacheConfiguration<String, Any> {
            setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(Duration(MILLISECONDS, 50)))
        }
        val config = RedissonConfiguration.fromInstance(redisson, jcacheConfiguration)
        val remoteCache =  jcacheManager<JCachingProvider>().getOrCreate("redis-jcache-test", config)

        val key = "expired key"
        val value = "expired value"

        var expiredKey: String? = null
        val listenerConfiguration = MutableCacheEntryListenerConfiguration<String, Any>(
            { CacheEntryExpiredListener { events -> expiredKey = events.first().key } },
            null,
            false,
            true
        )
        remoteCache.registerCacheEntryListener(listenerConfiguration)

        remoteCache.put(key, value)

        Thread.sleep(200)

        remoteCache.containsKey(key).shouldBeFalse()
        expiredKey shouldBeEqualTo key

Cant' grap log message.

Redis version
6.2
Redisson version
3.15.6, 3.16.3
Redisson configuration
       // use testcontainers. only use redis url as single server
        val redisson = RedisServer.Launcher.RedissonLib.getRedisson()
        val jcacheConfiguration = jcacheConfiguration<String, Any> {
            setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(Duration(MILLISECONDS, 50)))
        }
        val config = RedissonConfiguration.fromInstance(redisson, jcacheConfiguration)
        jcacheManager<JCachingProvider>().getOrCreate("redis-jcache-test", config)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
After switching to version 3.16.3, I see tons of next exceptions:
org.redisson.client.handler.PingConnectionHandler : Unable to send PING command over channel: [id: 0x76185fba, L:/127.0.0.1:59095 - R:localhost/127.0.0.1:6379]

 org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://localhost:6379]
	at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:255)
	at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)
	at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)
	at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)

And I don't see the same in v3.16.2.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3868
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3869
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3870
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3871
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3872
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3873
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3875
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3876
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3877
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3878
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3879
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3880
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3881
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3882
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3883
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3884
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3885
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3886
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3887
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3888
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3889
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3890
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3891
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3892
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3893
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3894
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3895
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3896
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3897
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3898
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3899
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3901
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3902
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3904
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3905
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3906
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3907
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3908
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3909
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3910
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3911
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3912
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3913
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3914
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3915
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3916
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3917
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3918
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3919
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3920
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3922
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3923
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3924
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3925
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3926
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3927
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3929
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3930
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3931
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3933
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3934
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3935
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3936
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3937
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3939
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3940
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3941
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3942
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3943
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3944
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3945
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3946
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3947
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3948
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3949
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3950
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3952
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3954
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3955
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3956
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3957
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3958
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3959
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3960
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3961
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3962
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3963
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3964
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3965
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3966
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3967
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3968
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3969
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3970
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3972
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are experiencing the error what seems like network related errors using the 3.13.2 version of redisson.
Caused by: org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1897737917 [redisClient=[addr=redis://10.0.2.185:6379], channel=[id: 0xcfc764bc, L:/172.xx.xx.xx:36380 - R:/10.0.2.185:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@7fdadeee(failure: java.util.concurrent.CancellationException)], command=(GET), params=[[115, 101, 114, 118, 105, 99, 101, 58, 109, 101, ...]], codec=org.redisson.client.codec.ByteArrayCodec]], command: (GET), params: [[115, 101, 114, 118, 105, 99, 101, 58, 109, 101, ...]] after 3 retry attempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:200)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
... 1 common frames omitted

config:
nettyThreads: 32
retryInterval: 1.5s

We run  code in the docker of rancher,  then have been occurred  on some pods. so confused am I.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3973
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
for(String key:keys){ 
batch.getMap(key).readAllMapAsync(); 
}
BatchResult<?> result = batch.execute(); 
pipelineMapList = (List<Map<String, String>>) result.getResponses(); 

Are pipelineMapList and keys kept the same order? If not, is there a way to get ordered result with response to the keys order.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3974
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson:3.16.3
2021-11-23T09:19:58.498Z APP 2021-11-23 09:19:58.445 [redisson-timer-4-1] ERROR org.redisson.client.handler.PingConnectionHandler - Unable to send PING command over channel: [id: 0x47a3d5e2, L:/1**..118.:38562 - R:.6.79.87/.6.79.87:6381]
2021-11-23T09:19:58.499Z APP  at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:255)
2021-11-23T09:19:58.499Z APP org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://**.6.79.87:6381]
2021-11-23T09:19:58.500Z APP  at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
2021-11-23T09:19:58.500Z APP  at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
2021-11-23T09:19:58.500Z APP  at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
2021-11-23T09:19:58.501Z APP  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
2021-11-23T09:19:58.501Z APP  at java.lang.Thread.run(Thread.java:748)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3975
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Code  :
RMap.readAllValues().stream().forEach => OOM Getting here..
Can someone please help me out, Is any available solution to read this load data in RMap, or will have to be read in batches ??
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3976
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Insertion order should be preserved regardless of codecs configuration but unfortunately it is working only for StringCodec . The problem with string codec is during retrieval it will display the contents as "to string" implementation of java . So need resolution for JSONJackson Codec for preserving insertion order
Actual behavior
Currently it is not working for JSONJackson Codec , it is only working for String codec
Steps to reproduce or test case
Just Create a Bean of RedissonClient and then setup a RMap or RMapCache Bean with JSONJacksonCodec instance and try to insert the contents into redis the latest item is placed first and the previous one to the last no insertion order is maintained
Redis version
6.2.6
Redisson version
3.16.3
Redisson configuration
@bean
public RedissonClient redissonClient() {
    Config    config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379");

    this.redissonClient = Redisson.create(config);
    return redissonClient;
}

@bean
public RMap<Long, Employee> employeeRMapCache() {
final RMap<Long, Employee> employeeRMapCache = redissonClient().getMap(CACHE_NAME, JsonJacksonCodec.INSTANCE, MapOptions.<Long, Employee>defaults()
.writer(getMapWriter())
return employeeRMapCache;
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3977
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3978
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is a extension of the issue #3966 because we could not reproduce the problem with the provided test.
So, we are trying to provide a new test trying to reproduce the actual issue that we observed on our application.
Expected behavior
We execute these operations on a local cache that points to a redis map already initialized:

get initial value
put new value
get new value

We expect to receive the new value on the third operation.
Actual behavior
Sometimes we get the initial value on the third operation.
Steps to reproduce or test case
A test to reproduce the issue:
@Test
public void testLocalCacheGetAndPut() {
    int numberOfKeys = 5_000;

    initializeRedis(numberOfKeys);

    RMap<String, String> localCachedMap = redisson.getLocalCachedMap("test", LocalCachedMapOptions.defaults());
    for (int i = 0; i < numberOfKeys; i++) {
        localCachedMap.get("key" + i);
        localCachedMap.put("key" + i, "value-" + i);
        String cachedValue = localCachedMap.get("key" + i);
        assertThat(cachedValue).isEqualTo("value-" + i);
    }
}

private void initializeRedis(int numberOfKeys) {
    RMap<String, String> map = redisson.getMap("test");
    for (int i = 0; i < numberOfKeys; i++) {
        map.put("key" + i, "initial-value");
    }
}
It fails on different iterations when you execute the test more than once:
org.opentest4j.AssertionFailedError: 
expected: "value-377"
 but was: "initial-value"

(...)

org.opentest4j.AssertionFailedError: 
expected: "value-1109"
 but was: "initial-value"

(...)

org.opentest4j.AssertionFailedError: 
expected: "value-0"
 but was: "initial-value"

Redis version
Redis 5.0.7
Redisson version
3.16.5-SNAPSHOT
Redisson configuration
Default configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3979
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
集群模式下推送的延时任务到达队列中，但是部分延时任务没有在take的时候弹出，没有报错信息
redisson：3.16.3
RBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(queueName);
RDelayedQueue<T> delayedQueue = redissonClient.getDelayedQueue(blockingFairQueue);
delayedQueue.offer(t, delay, timeUnit);

while (!Thread.currentThread().isInterrupted() && !destroy) {
                try {
                    RBlockingQueue<T> blockingFairQueue = redissonClient.getBlockingQueue(queueName);
                    T t = blockingFairQueue.take();
                    log.info("监听队列线程{},获取到值:{}", queueName, JSON.toJSONString(t));
                    executor.execute(() -> {
                        try {
                            listener.invoke(t);
                        } catch (Exception e) {
                            log.error("延迟队列{}发送任务异常：", queueName, e);
                        }
                    });
                } catch (Exception e) {
...
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3980
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Specification we are using:
AWS Elasticache- Redis 5.0.6 (Cluster Mode with master and slave)
Redisson library; 3.16.4
connectTimeout: 3000
timeout: 1000
retryAttempts: 1
slaveConnectionMinimulIdleSize: 24
slaveConnectionPoolSize: 64
masterConnectionMinimulIdleSize: 24
masterConnectionPoolSize: 64
nodeAddres: clusterendpoint:6379
readmode: SLAVE
using: ClusterServers and RBucket to set and get
We are intermittently facing the below error. I think this is because the Master instance is loosing connection to the slave instance.
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: XX.XXX.XXX/XX.XXX.XXX:6379 Disconnected hosts: [XX.XXX.XXX/1XX.XXX.XXX:6379]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:216)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:273)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:499)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:549)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:555)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:121)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:251)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:829)
If we check the elasticache, all instance in the cluster are in available status.
Only way to resolve is to redeploy the application.
Any idea on configuration that should be tweaked? Or does redisson provides any time interval to refresh the connection to avoid this?
I checked the other post but looks it is closed but doesn't have an answer to the question.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3981
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Spec Used:
Redis Version: 5.0.6 (AWS Elasticache with cluster mode)
Redisson: 3.16.4
ConnectTimeout: 3000
timeout: 1000
retryAttempt: 1
readMode: SLAVE
slaveConnectionMinimumIdleSize: 24
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 24
masterConnectionPoolSize: 64
using: ClusterMode and Rbucket for GET and SET
We intermittently get below error .. I think this is because the Master instance is loosing connection with the Slave instance. If we check in Elasticache, all the nodes are in "available" status.  Only solution we do is to redeploy the app to resolve the error.
Any idea what parameter should be added or tweaked related to this issue? or can Redisson provide any interval option to refresh the connection pool?
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: XX,XXX.XXX/XX,XXX.XXX:6379 Disconnected hosts: [XX,XXX.XXX/XX,XXX.XXX:6379]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:216)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:273)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:499)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:549)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:555)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:121)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:251)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:829)
Note: I verifed the post 2535 .. it is in closed state but the question isn't addressed.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3982
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson locks can consistency guarantee as raft consensus protocol (ex:hazelcast) with schemes cluser and master+slave(sentinel) ? It dont have problems as has hazelcast before cp-subsystem(ver3.12) "at least once" https://docs.hazelcast.org/docs/3.11.2/manual/html-single/index.html#exactly-once-at-least-once-or-at-most-once-execution
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3983
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behaviour : When the Redis pod(stateful set) restarts, the application should be able to reconnect to the redis pod automatically.
Actual behaviour : When the Redis pod restarts, the application is unable to reconnect to Redis even after multiple retry attempts. I tried this in a single node setup. When Redis pod is brought down, another pod is spun up in few seconds. But the app is unable to reconnect automatically. After the app pod restart, it works fine.
This is the exception thrown.
org.redisson.client.RedisConnectionException: SlaveConnectionPool no available Redis entries. Master entry host: / Disconnected hosts: [/]
at org.redisson.connection.pool.ConnectionPool.get(ConnectionPool.java:216)
at org.redisson.connection.pool.SlaveConnectionPool.get(SlaveConnectionPool.java:30)
at org.redisson.connection.balancer.LoadBalancerManager.nextConnection(LoadBalancerManager.java:275)
at org.redisson.connection.MasterSlaveEntry.connectionReadOp(MasterSlaveEntry.java:503)
at org.redisson.connection.MasterSlaveConnectionManager.connectionReadOp(MasterSlaveConnectionManager.java:549)
at org.redisson.command.RedisExecutor.getConnection(RedisExecutor.java:572)
at org.redisson.command.RedisExecutor.execute(RedisExecutor.java:124)
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:254)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Redis version : 6.2.3
Redisson version :
Tried both 3.15.5 and 3.16.4 - Facing same issue in both
Redisson configuration :
config.useReplicatedServers()
.setReadMode(ReadMode.MASTER_SLAVE)
.setScanInterval(masterScanInterval)
.setPassword(redisPassword)
.addNodeAddress(redisUrl.split(","))
Please let me know if there's any workaround for this other than the restart. Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3985
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello all i am trying to access json filed in criteria query but getting above error could you please help me for the same.
subquery.select(root).where(this.criteriaBuilder.equal((packageRoot.get("publis")), userEmail));
here publis is the json in repository
@createdby
@column(name = "pub_by", columnDefinition = "jsonb", updatable = false)
@type(type = "jsonb")
private User publis;
and error is below
java.lang.IllegalArgumentException: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'local': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')
at [Source: (String)"local.user@registry.com"; line: 1, column: 6]
at com.vladmihalcea.hibernate.type.util.ObjectMapperWrapper.toJsonNode(ObjectMapperWrapper.java:68) ~[hibernate-types-52-2.4.3.jar:na]
at com.vladmihalcea.hibernate.type.json.internal.JsonTypeDescriptor.unwrap(JsonTypeDescriptor.java:105) ~[hibernate-types-52-2.4.3.jar:na]
at com.vladmihalcea.hibernate.type.json.internal.JsonBinarySqlTypeDescriptor$1.doBind(JsonBinarySqlTypeDescriptor.java:25) ~[hibernate-types-52-2.4.3.jar:na]
at org.hibernate.type.descriptor.sql.BasicBinder.bind(BasicBinder.java:73) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:276) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:271) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.param.NamedParameterSpecification.bind(NamedParameterSpecification.java:53) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.hql.QueryLoader.bindParameterValues(QueryLoader.java:648) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.bindPreparedStatement(Loader.java:2125) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:2102) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:2034) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:2012) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.doQuery(Loader.java:948) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:349) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.doList(Loader.java:2843) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.doList(Loader.java:2825) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2657) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.Loader.list(Loader.java:2652) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:506) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:400) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:219) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.internal.SessionImpl.list(SessionImpl.java:1414) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.query.internal.AbstractProducedQuery.doList(AbstractProducedQuery.java:1636) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.query.internal.AbstractProducedQuery.list(AbstractProducedQuery.java:1604) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.query.Query.getResultList(Query.java:165) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at org.hibernate.query.criteria.internal.compile.CriteriaQueryTypeQueryAdapter.getResultList(CriteriaQueryTypeQueryAdapter.java:76) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
at com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl.findAllArtifactsWithFilter(LibraryArtifactRepositoryCustomImpl.java:104) ~[classes/:na]
at com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl$$FastClassBySpringCGLIB$$e8ae07f5.invoke() ~[classes/:na]
at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:783) ~[spring-aop-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.12.jar:5.3.12]
at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137) ~[spring-tx-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) ~[spring-aop-5.3.12.jar:5.3.12]
at com.sap.apac.lcnc.library.repository.LibraryArtifactRepositoryCustomImpl$$EnhancerBySpringCGLIB$$bac61a19.findAllArtifactsWithFilter() ~[classes/:na]
at com.sap.apac.lcnc.library.service.LibraryService.getAllArtifacts(LibraryService.java:107) ~[classes/:na]
at com.sap.apac.lcnc.library.service.LibraryService$$FastClassBySpringCGLIB$$bbd19e44.invoke() ~[classes/:na]
at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.12.jar:5.3.12]
at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.3.12.jar:5.3.12]
at com.sap.apac.lcnc.library.service.LibraryService$$EnhancerBySpringCGLIB$$2f8e75eb.getAllArtifacts() ~[classes/:na]
at com.sap.apac.lcnc.library.controller.LibraryController.getArtifacts(LibraryController.java:62) ~[classes/:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]
at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.12.jar:5.3.12]
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.12.jar:5.3.12]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) ~[tomcat-embed-core-9.0.54.jar:4.0.FR]
at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.12.jar:5.3.12]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.54.jar:4.0.FR]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:204) ~[spring-security-web-5.4.9.jar:5.4.9]
at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) ~[spring-security-web-5.4.9.jar:5.4.9]
at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) ~[spring-web-5.3.12.jar:5.3.12]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:97) ~[spring-boot-actuator-2.4.12.jar:2.4.12]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.12.jar:5.3.12]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.3.12.jar:5.3.12]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at com.sap.apac.lcnc.shared.security.xss.XSSFilter.doFilter(XSSFilter.java:26) ~[classes/:na]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:769) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:382) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:895) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1722) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.54.jar:9.0.54]
at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na]
Caused by: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'local': was expecting (JSON String, Number, Array, Object or token 'null', 'true' or 'false')
at [Source: (String)"local.user@registry.com"; line: 1, column: 6]
at com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1851) ~[jackson-core-2.11.4.jar:2.11.4]
at com.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:717) ~[jackson-core-2.11.4.jar:2.11.4]
at com.fasterxml.jackson.core.json.ReaderBasedJsonParser._reportInvalidToken(ReaderBasedJsonParser.java:2898) ~[jackson-core-2.11.4.jar:2.11.4]
at com.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddValue(ReaderBasedJsonParser.java:1944) ~[jackson-core-2.11.4.jar:2.11.4]
at com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:776) ~[jackson-core-2.11.4.jar:2.11.4]
at com.fasterxml.jackson.databind.ObjectMapper._readTreeAndClose(ObjectMapper.java:4553) ~[jackson-databind-2.11.2.jar:2.11.2]
at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2972) ~[jackson-databind-2.11.2.jar:2.11.2]
at com.vladmihalcea.hibernate.type.util.ObjectMapperWrapper.toJsonNode(ObjectMapperWrapper.java:66) ~[hibernate-types-52-2.4.3.jar:na]
... 106 common frames omitted
2021-11-26 04:12:15.964  INFO 21844 --- [nio-8080-exec-2] c.s.a.l.s.c.h.TenantConnectionProvider   : [RELEASE CONNECTION FOR TENANT] tlocaltenant
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3986
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
That code format is stable and I see a change in the code format
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3987
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
On connection with redis I'm getting this:
org.redisson.client.RedisConnectionException: Unable to connect to Redis server: IP/IP:6379
at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:158) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:313) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$3(ConnectionPool.java:279) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[patched_1.17.1.jar:git-Airplane-92]
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at org.redisson.client.RedisClient$2$1.run(RedisClient.java:242) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[patched_1.17.1.jar:git-Airplane-92]
at java.lang.Thread.run(Thread.java:831) [?:?]
Caused by: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (AUTH), params: (password masked), Redis client: [addr=redis://IP:6379]
at org.redisson.client.RedisConnection.lambda$async$1(RedisConnection.java:251) ~[CuriosLibrary-1.1.0-BETA-shaded(1).jar:?]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744) ~[patched_1.17.1.jar:git-Airplane-92]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469) ~[patched_1.17.1.jar:git-Airplane-92]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am unable to understand this error. Please help.
Execution exception[[RedisException: ERR Error running script (call to f_0fd7cdd6c1224471b29d6f7fc503462f3b252f12): @user_script:1: user_script:1: bad argument #2 to 'unpack' (data string too short) . channel: [id: 0xd4089e92, L:/10.212.134.41:60921 - R:core-dev-redis.6cbkbd.0001.aps1.cache.amazonaws.com/192.168.2.46:6379] command: (EVAL), params: [local result = {}; local idleKeys = {}; local res; if (#ARGV == 4) then  res = redis.call('hscan', K..., 3, ALLUS_XXX, redisson__timeout__set:{ALLUS_XXX}, redisson__idle__set:{ALLUS_XXX}, 1637948919729, 0, 10]]]\
I am trying to read using getMapCache(ALLUS_XXX)
also, in redis cli if I do hgetall ALLUS_XXX.  This is the output
 1) "3"
 2) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"3\",\"ax\":\"21\",\"bp\":331.27,\"ap\":331.3,\"bs\":2,\"as\":1,\"t\":\"1637948895747\",\"q\":\"42893371\",\"z\":3}"
 3) "2"
 4) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"2\",\"ax\":\"19\",\"bp\":330.03,\"ap\":330.13,\"bs\":2,\"as\":3,\"t\":\"1637949585689\",\"q\":\"46053648\",\"z\":3}"
 5) "12"
 6) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"12\",\"ax\":\"11\",\"bp\":329.91,\"ap\":330.25,\"bs\":1,\"as\":12,\"t\":\"1637949676507\",\"q\":\"46258127\",\"z\":3}"
 7) "9"
 8) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"9\",\"ax\":\"15\",\"bp\":330.43,\"ap\":330.44,\"bs\":3,\"as\":3,\"t\":\"1637949113455\",\"q\":\"43838492\",\"z\":3}"
 9) "15"
10) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"15\",\"ax\":\"12\",\"bp\":330.34,\"ap\":330.37,\"bs\":2,\"as\":4,\"t\":\"1637949549028\",\"q\":\"45809932\",\"z\":3}"
11) "10"
12) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"10\",\"ax\":\"12\",\"bp\":330.26,\"ap\":330.37,\"bs\":1,\"as\":2,\"t\":\"1637949585833\",\"q\":\"46055016\",\"z\":3}"
13) "18"
14) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"18\",\"ax\":\"11\",\"bp\":330.15,\"ap\":330.25,\"bs\":2,\"as\":12,\"t\":\"1637949683953\",\"q\":\"46258667\",\"z\":3}"
15) "1"
16) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"1\",\"ax\":\"17\",\"bp\":330.21,\"ap\":330.31,\"bs\":4,\"as\":1,\"t\":\"1637949583379\",\"q\":\"46033150\",\"z\":3}"
17) "11"
18) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"11\",\"ax\":\"12\",\"bp\":329.91,\"ap\":330.2,\"bs\":4,\"as\":1,\"t\":\"1637949688637\",\"q\":\"46259504\",\"z\":3}"
19) "7"
20) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"7\",\"ax\":\"11\",\"bp\":330.15,\"ap\":330.25,\"bs\":2,\"as\":12,\"t\":\"1637949684316\",\"q\":\"46258719\",\"z\":3}"
21) "20"
22) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"20\",\"ax\":\"12\",\"bp\":330.11,\"ap\":330.26,\"bs\":1,\"as\":1,\"t\":\"1637949586232\",\"q\":\"46058248\",\"z\":3}"
23) "19"
24) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"19\",\"ax\":\"11\",\"bp\":329.91,\"ap\":330.25,\"bs\":2,\"as\":12,\"t\":\"1637949676537\",\"q\":\"46258138\",\"z\":3}"
25) "8"
26) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"8\",\"ax\":\"11\",\"bp\":330.06,\"ap\":330.25,\"bs\":1,\"as\":12,\"t\":\"1637949685035\",\"q\":\"46258880\",\"z\":3}"
27) "17"
28) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"17\",\"ax\":\"17\",\"bp\":329.37,\"ap\":330.16,\"bs\":2,\"as\":2,\"t\":\"1637949606270\",\"q\":\"46241118\",\"z\":3}"
29) "21"
30) "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"21\",\"ax\":\"12\",\"bp\":330.9,\"ap\":331.09,\"bs\":1,\"as\":1,\"t\":\"1637949581667\",\"q\":\"46012327\",\"z\":3}"

This is easlily reproducible,

 HMSET ALLUS_XXX 1 "{\"ev\":\"Q\",\"sym\":\"XXX\",\"bx\":\"1\",\"ax\":\"20\",\"bp\":157.2,\"ap\":157.21,\"bs\":5,\"as\":1,\"t\":\"1637949207844\",\"q\":\"60303179\",\"z\":3}"
Now try to access this using redisson getMapCache("ALLUS_XXX").readAllEntrySet()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3990
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
询问分布式调度任务服务（Scheduler Service）中，如何达到在多台工作服务器（worker）上每次只有其中一台执行任务？
我的配置代码如下：
配置代码：
@bean(destroyMethod = "shutdown")
public RedissonNode redissonNode(@qualifier("redissonConfig") Config config, @qualifier("redissonClient") RedissonClient redissonClient) {
RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
nodeConfig.setExecutorServiceWorkers(Collections.singletonMap(GoogleRefundService.executorServiceName, 1));
RedissonNode node = RedissonNode.create(nodeConfig, redissonClient);
node.start();
return node;
}
调度任务代码：
@value("${sdk.payment.thirdparty.google.refund.cronSchedule:0/5 * * * * ?}")
private String refundCronSchedule;
@PostConstruct
public void initGoogleRefundSchedule() {
    ExecutorOptions options = ExecutorOptions.defaults();
    // 设定为0则不进行重试
    options.taskRetryInterval(0, TimeUnit.MINUTES);
    RScheduledExecutorService executorService = redissonClient.getExecutorService(executorServiceName, options);
    int taskCount = executorService.getTaskCount();
    log.info("initGoogleRefundSchedule taskCount:{}", taskCount);
    if (taskCount == 0) {
        executorService.schedule((Runnable & Serializable) () -> log.info("task has been executed!"), CronSchedule.of(refundCronSchedule));
    }
}

按照配置，会每隔5秒钟输出一次log("task has been executed!"), 目前在单台服务器上启动，调度任务服务可以运行
但是如果在多台服务器上启动服务，每台服务器上的进程都会每隔5秒输出一次，可我希望达到的效果是：在多台工作服务器（worker）上，每次只有其中一台（或随机，或轮询，或抢占）每隔5秒执行一次任务。
请问我应该如何配置分布式调度任务服务，才能达到这个效果？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3991
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Inquire about the distributed scheduling task service (Scheduler Service), how to achieve that only one of the multiple worker servers (worker) executes tasks at a time?
My code is as follows:
Configuration code:
@Bean(destroyMethod = "shutdown")
public RedissonNode redissonNode(@Qualifier("redissonConfig") Config config, @Qualifier("redissonClient") RedissonClient redissonClient) {
    RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
    nodeConfig.setExecutorServiceWorkers(Collections.singletonMap(GoogleRefundService.executorServiceName, 1));
    RedissonNode node = RedissonNode.create(nodeConfig, redissonClient);
    node.start();
    return node;
}

Schedule task code:
@Value("${sdk.payment.thirdparty.google.refund.cronSchedule:0/5 * * * * ?}")
private String refundCronSchedule;

@PostConstruct
public void initGoogleRefundSchedule() {
    ExecutorOptions options = ExecutorOptions.defaults();
    // 设定为0则不进行重试
    options.taskRetryInterval(0, TimeUnit.MINUTES);
    RScheduledExecutorService executorService = redissonClient.getExecutorService(executorServiceName, options);
    int taskCount = executorService.getTaskCount();
    log.info("initGoogleRefundSchedule taskCount:{}", taskCount);
    if (taskCount == 0) {
        executorService.schedule((Runnable & Serializable) () -> log.info("task has been executed!"), CronSchedule.of(refundCronSchedule));
    }
}

According to the configuration, log("task has been executed!") will be output every 5 seconds. It is currently started on a single server, and the scheduled task service can run.
But if you start the service on multiple servers, the process on each server will output every 5 seconds, but what I want to achieve is: on multiple workers (workers), only one of them (or Random, or polling, or preemption) execute a task every 5 seconds.
How should I configure the distributed scheduling task service to achieve this effect?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3992
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
rename session id
Actual behavior
org.springframework.data.redis.RedisSystemException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0xd86c1794, L:/11.2.2.202:58295 - R:11.11.113.183/11.11.113.183:6379] command: (RENAME), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@35d041c2(incomplete)], params: [[103, 119, 58, 115, 101, 115, 115, 105, 111, 110, ...], [103, 119, 58, 115, 101, 115, 115, 105, 111, 110, ...]]; nested exception is org.redisson.client.RedisException: CROSSSLOT Keys in request don't hash to the same slot. channel: [id: 0xd86c1794, L:/11.2.2.202:58295 - R:11.11.113.183/11.11.113.183:6379] command: (RENAME), promise: RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@35d041c2(incomplete)], params: [[103, 119, 58, 115, 101, 115, 115, 105, 111, 110, ...], [103, 119, 58, 115, 101, 115, 115, 105, 111, 110, ...]]
at org.redisson.spring.data.connection.RedissonBaseReactive.lambda$write$3(RedissonBaseReactive.java:94)
Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:
Error has been observed at the following site(s):
|_ checkpoint ⇢ org.springframework.security.web.server.authentication.logout.LogoutWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.savedrequest.ServerRequestCacheWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.context.SecurityContextServerWebExchangeWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.authentication.AuthenticationWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.context.ReactorContextWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.header.HttpHeaderWriterWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.config.web.server.ServerHttpSecurity$ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.cloud.sleuth.instrument.web.TraceWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain]
|_ checkpoint ⇢ HTTP POST "/auth/logout" [ExceptionHandlingWebHandler]
Steps to reproduce or test case
My app is a spring cloud gateway app, and store session information in Redis through Redission.
This is my facroty bean:
@Bean
fun reactiveRedisConnectionFactory(redissonClient: RedissonClient): ReactiveRedisConnectionFactory {
    return RedissonConnectionFactory(redissonClient)
}

I found some issurs with the same CROSSSLOT error at October, 2020 and fixed by https://github.com/redisson/redisson/pull/3141/commits
But the reactive connection do not use the ReactiveKeyCommands class fixed in that PR. Maybe this bug is happening again?
Redisson version
org.redisson:redisson and redisson-spring-data-24,  version is 3.16.4
Redisson configuration
Redisson config in cluster mode
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3993
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson can client-side sharding or partitioning ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3995
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[DC-STG][ERROR][sort][2021-11-28 15:02:10.497][]-[]-[][Thread-12] (ThreadPoolAgent.java:55)[get()] -> 系统异常
java.util.concurrent.ExecutionException: org.springframework.dao.InvalidDataAccessApiUsageException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts
at java.util.concurrent.FutureTask.report(FutureTask.java:122) ~[?:1.8.0_91]
at java.util.concurrent.FutureTask.get(FutureTask.java:192) ~[?:1.8.0_91]
at com.szatc.biz.service.sort.common.agent.ThreadPoolAgent.get(ThreadPoolAgent.java:52) [classes!/:1.0.0-SNAPSHOT]
at com.szatc.biz.service.sort.sort.impl.DataCacheImpl.init(DataCacheImpl.java:135) [classes!/:1.0.0-SNAPSHOT]
at com.szatc.biz.service.sort.sort.SortManagerCommon.setTime(SortManagerCommon.java:42) [classes!/:1.0.0-SNAPSHOT]
at com.szatc.biz.service.sort.sort.impl.SortServiceImpl.sortRealtime(SortServiceImpl.java:63) [classes!/:1.0.0-SNAPSHOT]
at com.szatc.biz.service.sort.controller.job.SortJobHandler.sortRealTime(SortJobHandler.java:109) [classes!/:1.0.0-SNAPSHOT]
at sun.reflect.GeneratedMethodAccessor579.invoke(Unknown Source) ~[?:?]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_91]
at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_91]
at com.xxl.job.core.handler.impl.MethodJobHandler.execute(MethodJobHandler.java:29) [xxl-job-core-2.3.0.jar!/:?]
at com.xxl.job.core.thread.JobThread.run(JobThread.java:163) [xxl-job-core-2.3.0.jar!/:?]
Caused by: org.springframework.dao.InvalidDataAccessApiUsageException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]
at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:234) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:229) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:459) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:840) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:574) ~[redisson-spring-data-21-3.11.2.jar!/:3.11.2]
at org.springframework.data.redis.cache.DefaultRedisCacheWriter.lambda$get$1(DefaultRedisCacheWriter.java:109) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]
at org.springframework.data.redis.cache.DefaultRedisCacheWriter.execute(DefaultRedisCacheWriter.java:242) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]
at org.springframework.data.redis.cache.DefaultRedisCacheWriter.get(DefaultRedisCacheWriter.java:109) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]
at org.springframework.data.redis.cache.RedisCache.lookup(RedisCache.java:82) ~[spring-data-redis-2.1.8.RELEASE.jar!/:2.1.8.RELEASE]
at org.springframework.cache.support.AbstractValueAdaptingCache.get(AbstractValueAdaptingCache.java:58) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.AbstractCacheInvoker.doGet(AbstractCacheInvoker.java:73) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.CacheAspectSupport.findInCaches(CacheAspectSupport.java:554) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.CacheAspectSupport.findCachedItem(CacheAspectSupport.java:519) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:401) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.CacheAspectSupport.execute(CacheAspectSupport.java:345) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.cache.interceptor.CacheInterceptor.invoke(CacheInterceptor.java:61) ~[spring-context-5.1.9.RELEASE.jar!/:5.1.9.RELEASE]
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]
at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE]
at com.szatc.biz.service.sort.service.impl.PointsKeywordServiceImpl$$EnhancerBySpringCGLIB$$d538eda5.selectAll() ~[classes!/:1.0.0-SNAPSHOT]
at com.szatc.biz.service.sort.sort.impl.DataCacheImpl.lambda$init$0(DataCacheImpl.java:117) ~[classes!/:1.0.0-SNAPSHOT]
at org.springframework.cloud.sleuth.instrument.async.TraceCallable.call(TraceCallable.java:70) ~[spring-cloud-sleuth-core-2.1.1.RELEASE.jar!/:2.1.1.RELEASE]
at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_91]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[?:1.8.0_91]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[?:1.8.0_91]
at java.lang.Thread.run(Thread.java:745) ~[?:1.8.0_91]
Caused by: org.redisson.client.RedisTimeoutException: Unable to send command! Try to increase 'nettyThreads' and/or connection pool size settings Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=19, freeConnectionsCounter=value:59:queue:0, freezed=false, freezeReason=null, client=[addr=redis://192.168.53.179:6379], nodeType=MASTER, firstFail=0]]], connection: RedisConnection@131875383 [redisClient=[addr=redis://192.168.53.179:6379], channel=[id: 0x699c31ec, L:/100.111.156.155:48866 - R:192.168.53.179/192.168.53.179:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@18ca11e9(failure: org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=redis://192.168.53.179:6379])], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]], command: (GET), params: [[115, 122, 45, 100, 99, 58, 115, 111, 114, 116, ...]] after 3 retry attempts
at org.redisson.command.CommandAsyncService$6.run(CommandAsyncService.java:715) ~[redisson-3.11.2.jar!/:3.11.2]
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472) ~[netty-all-4.1.58.Final.jar!/:4.1.58.Final]
at java.lang.Thread.run(Thread.java:745) ~[?:1.8.0_91]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3996
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
no OutOfMemoryError on applications using the same Redis server but the previous version of redisson 3.16.3
Actual behavior
applications starting to OOM running version 3.16.3 while an application running with 3.16.5 was fine
crm@thread-pool-redisson-general-netty@thread-4
  at io.netty.buffer.AbstractByteBuf.checkReadableBytes0(I)V (AbstractByteBuf.java:1442)
  at io.netty.buffer.AbstractByteBuf.checkReadableBytes(I)V (AbstractByteBuf.java:1428)
  at io.netty.buffer.AbstractByteBuf.readBytes([BII)Lio/netty/buffer/ByteBuf; (AbstractByteBuf.java:895)
  at io.netty.buffer.AbstractByteBuf.readBytes([B)Lio/netty/buffer/ByteBuf; (AbstractByteBuf.java:903)
  at org.redisson.cache.LocalCachedMessageCodec.lambda$new$0(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/handler/State;)Ljava/lang/Object; (LocalCachedMessageCodec.java:68)
  at org.redisson.cache.LocalCachedMessageCodec$$Lambda$1805+0x0000000801d6ab08.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/handler/State;)Ljava/lang/Object; (Unknown Source)
  at org.redisson.client.handler.CommandDecoder.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/Channel;ZLjava/util/List;)V (CommandDecoder.java:383)
  at org.redisson.client.handler.CommandDecoder.decodeList(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/Channel;JLjava/util/List;ZLjava/util/List;)V (CommandDecoder.java:427)
  at org.redisson.client.handler.CommandDecoder.decode(Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/CommandData;Ljava/util/List;Lio/netty/channel/Channel;ZLjava/util/List;)V (CommandDecoder.java:392)
  at org.redisson.client.handler.CommandPubSubDecoder.decodeCommand(Lio/netty/channel/Channel;Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/QueueCommand;I)V (CommandPubSubDecoder.java:84)
  at org.redisson.client.handler.CommandDecoder.decode(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Lorg/redisson/client/protocol/QueueCommand;I)V (CommandDecoder.java:137)
  at org.redisson.client.handler.CommandDecoder.decode(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Ljava/util/List;)V (CommandDecoder.java:94)
  at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Ljava/util/List;)V (ByteToMessageDecoder.java:507)
  at io.netty.handler.codec.ReplayingDecoder.callDecode(Lio/netty/channel/ChannelHandlerContext;Lio/netty/buffer/ByteBuf;Ljava/util/List;)V (ReplayingDecoder.java:366)
  at io.netty.handler.codec.ByteToMessageDecoder.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (ByteToMessageDecoder.java:276)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(Ljava/lang/Object;)V (AbstractChannelHandlerContext.java:379)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;)V (AbstractChannelHandlerContext.java:365)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(Ljava/lang/Object;)Lio/netty/channel/ChannelHandlerContext; (AbstractChannelHandlerContext.java:357)
  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(Lio/netty/channel/ChannelHandlerContext;Ljava/lang/Object;)V (DefaultChannelPipeline.java:1410)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(Ljava/lang/Object;)V (AbstractChannelHandlerContext.java:379)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(Lio/netty/channel/AbstractChannelHandlerContext;Ljava/lang/Object;)V (AbstractChannelHandlerContext.java:365)
  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(Ljava/lang/Object;)Lio/netty/channel/ChannelPipeline; (DefaultChannelPipeline.java:919)
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read()V (AbstractNioByteChannel.java:166)
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(Ljava/nio/channels/SelectionKey;Lio/netty/channel/nio/AbstractNioChannel;)V (NioEventLoop.java:719)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized()V (NioEventLoop.java:655)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys()V (NioEventLoop.java:581)
  at io.netty.channel.nio.NioEventLoop.run()V (NioEventLoop.java:493)
  at io.netty.util.concurrent.SingleThreadEventExecutor$4.run()V (SingleThreadEventExecutor.java:986)
  at io.netty.util.internal.ThreadExecutorMap$2.run()V (ThreadExecutorMap.java:74)
  at java.lang.Thread.run()V (Thread.java:832)

Steps to reproduce or test case
access the same Redis server with different versions of the library (3.16.3 vs. 3.16.5)
Redis version
5.0.3
Redisson version
3.16.3 and 3.16.5
Redisson configuration
local cache map config
    @Nonnull
    @Override
    public <T extends RedisCacheable> RedisWithLocalCache<String, T> getLocallyCachedMap(@Nonnull final CacheKey cacheName,
            final int cacheSize,
            @Nonnull final Duration timeToLive,
            @Nonnull final Duration localCacheTimeToLive) {
        final var options = LocalCachedMapOptions.<String, T> defaults() //
                .cacheSize(cacheSize) //
                .timeToLive(timeToLive.toMillis()) //
                .maxIdle(localCacheTimeToLive.toMillis()) //
                .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.LRU) //
                .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.LOAD) //
                .syncStrategy(LocalCachedMapOptions.SyncStrategy.UPDATE) //
                .writeMode(MapOptions.WriteMode.WRITE_BEHIND);
        return new RedisWithLocalCacheWrapper<>(redisson.getLocalCachedMap(cacheName.keyName(), options));
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3997
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
2021-11-30 21:12:10.804 [http-nio-8010-exec-5] ERROR o.a.c.c.C.[.[.[/psai_saas].[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [/psai_saas] threw exception [Request processing failed; nested exception is org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=1627, addr=//101.253.171.129:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet] with root cause
org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=1627, addr=//101.253.171.129:6379, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet
at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:543)
at org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:684)
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:539)
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:628)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:669)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:744)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:469)
at java.lang.Thread.run(Thread.java:748)
rdisson version :3.8.2
#Redisson配置
masterSlaveServersConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
failedAttempts: 3
password: "is666"
subscriptionsPerConnection: 5
clientName: null
loadBalancer: !<org.redisson.connection.balancer.RoundRobinLoadBalancer> {}
slaveSubscriptionConnectionMinimumIdleSize: 1
slaveSubscriptionConnectionPoolSize: 50
slaveConnectionMinimumIdleSize: 32
slaveConnectionPoolSize: 64
masterConnectionMinimumIdleSize: 32
masterConnectionPoolSize: 64
readMode: "SLAVE"
slaveAddresses:
- "redis://101.253.171.129:6380"
- "redis://101.253.171.130:6380"
- "redis://101.253.171.131:6380"
masterAddress: "redis://101.253.171.131:6379"
database: 0
threads: 0
nettyThreads: 0
codec: !<org.redisson.codec.JsonJacksonCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3998
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Can I configure this command somewhere?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/3999
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
6.2.1
Redisson version
3.16.4
Redisson configuration
结合 StringRedisTemplate 使用   restore  的时候，
当恢复的 KEY 已经存在的时候，
replace 参数传 false 时，数据没有被修改抛出 org.redisson.client.RedisBusyException 异常。
replace 参数传 true 时，数据被修改 但是也 抛出 org.redisson.client.RedisBusyException 异常。
不知道是不是源代码这里出了问题， restore(key, ttlInMillis, serializedValue);   是不是应该是在 else 里面的呀。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4000
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When upgrade the redisson version from 3.10.4 to 3.16.4
netty-transport should be 4.1.68
just upgrade the redisson version 3.16.4 in a gradle project
3.16.4
Hello, I have the same issue for 3.16.4. I am using gradle and I updated my redissson version from 3.10.4 to 3.16.4 to solve a CVE. But when I checked the dependencies I realised that some how I do not know why, the versions were downgraded from 4.1.68 to 4.1.65 for netty-transport (it comes with redisson).
Could you take a look, please?
Thank you.
Here is the output;
+--- org.redisson:redisson:3.16.4
| +--- io.netty:netty-common:4.1.68.Final -> 4.1.65.Final
| +--- io.netty:netty-codec:4.1.68.Final -> 4.1.65.Final
| | +--- io.netty:netty-common:4.1.65.Final
| | +--- io.netty:netty-buffer:4.1.65.Final
| | | --- io.netty:netty-common:4.1.65.Final
| | --- io.netty:netty-transport:4.1.65.Final
| | +--- io.netty:netty-common:4.1.65.Final
| | +--- io.netty:netty-buffer:4.1.65.Final ()
| | --- io.netty:netty-resolver:4.1.65.Final
| | --- io.netty:netty-common:4.1.65.Final
| +--- io.netty:netty-buffer:4.1.68.Final -> 4.1.65.Final ()
| +--- io.netty:netty-transport:4.1.68.Final -> 4.1.65.Final ()
| +--- io.netty:netty-resolver:4.1.68.Final -> 4.1.65.Final ()
| +--- io.netty:netty-resolver-dns:4.1.68.Final -> 4.1.65.Final
| | +--- io.netty:netty-common:4.1.65.Final
| | +--- io.netty:netty-buffer:4.1.65.Final ()
| | +--- io.netty:netty-resolver:4.1.65.Final ()
| | +--- io.netty:netty-transport:4.1.65.Final ()
| | +--- io.netty:netty-codec:4.1.65.Final ()
| | +--- io.netty:netty-codec-dns:4.1.65.Final
| | | +--- io.netty:netty-common:4.1.65.Final
| | | +--- io.netty:netty-buffer:4.1.65.Final ()
| | | +--- io.netty:netty-transport:4.1.65.Final ()
| | | --- io.netty:netty-codec:4.1.65.Final ()
| | --- io.netty:netty-handler:4.1.65.Final
| | +--- io.netty:netty-common:4.1.65.Final
| | +--- io.netty:netty-resolver:4.1.65.Final ()
| | +--- io.netty:netty-buffer:4.1.65.Final ()
| | +--- io.netty:netty-transport:4.1.65.Final ()
| | --- io.netty:netty-codec:4.1.65.Final ()
| +--- io.netty:netty-handler:4.1.68.Final -> 4.1.65.Final ()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4001
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
We use redisson to connect to 3 redis nodes in replicated mode and MASTER_SLAVE read mode (AWS ElastiCache).
We expect to distribute the redis read operations evenly among the 3 redis nodes.
Actual behavior
Since the upgrade of redisson to version 3.16.15 PRO we notice that our application does not distribute the redis read opeations evenly to all the nodes, and only one redis node receives almost 100% of the read operations.
Yesterday at 20:40 we deployed our application with only one change: upgrade redisson from 3.16.4 to 3.16.5.
And today at 11:10 we rolled back our application to the redisson 3.16.4 version.
This graph shows:

Until 20:40 the 3 redis nodes received the read operations evenly (redisson 3.16.4)
From 20:40 just one redis node receives almost all the read operations (upgrade to redisson 3.16.5)
From 11:10 the 3 redis nodes receive the read operations evenly again (rollback to redisson 3.16.4)


Steps to reproduce or test case
Connect to 3 nodes in replicated mode and MASTER_SLAVE read mode.
Execute multiple read operations.
Check redis read operations metrics.
Redis version
Redis 5.0.7
Redisson version
3.16.15 PRO
Redisson configuration

replicated mode
MASTER_SLAVE read mode
3 AWS ElastiCache nodes (1 master + 2 slaves)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4002
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
MessageListener can be annotated by FunctionalInterface to use lambda?
Describe the solution you'd like
java.lang.FunctionalInterface
Describe alternatives you've considered
this interface have only one method  onMessage  now
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4003
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Connected using SentinelServer config, all the Redis pods(1master, 2 slave) are up and running in the Kubernetes cluster. Sentinels are also running along with the Redis containers like a sidecar. No WARN logs to be printed when connection is fine.
I am connecting to the Redis headless service in kube.
Actual behavior
Getting continuous WARN logs like below for all the IPs where Redis pods are running
02 Dec 2021 14:03:15,355  WARN [redisson-netty-5-30]  SentinelConnectionManager:546 - sentinel: redis://10.244.164.253:26379 is down
02 Dec 2021 14:03:15,356  WARN [redisson-netty-5-30]  SentinelConnectionManager:546 - sentinel: redis://10.244.154.103:26379 is down
02 Dec 2021 14:03:15,356  WARN [redisson-netty-5-30]  SentinelConnectionManager:546 - sentinel: redis://10.244.226.111:26379 is down
02 Dec 2021 14:03:19,548  WARN [redisson-netty-2-19]  SentinelConnectionManager:546 - sentinel: redis://10.244.164.253:26379 is down
02 Dec 2021 14:03:19,548  WARN [redisson-netty-2-19]  SentinelConnectionManager:546 - sentinel: redis://10.101.141.35:26379 is down
02 Dec 2021 14:03:19,548  WARN [redisson-netty-2-19]  SentinelConnectionManager:546 - sentinel: redis://10.244.226.111:26379 is down
02 Dec 2021 14:03:19,552  INFO [redisson-netty-2-22]  SentinelConnectionManager:613 - sentinel: redis://10.102.102.69:26379 added
02 Dec 2021 14:03:19,731  INFO [redisson-netty-5-25]  SentinelConnectionManager:613 - sentinel: redis://10.244.164.253:26379 added
02 Dec 2021 14:03:19,732  INFO [redisson-netty-5-21]  SentinelConnectionManager:613 - sentinel: redis://10.244.154.103:26379 added
02 Dec 2021 14:03:19,732  INFO [redisson-netty-5-23]  SentinelConnectionManager:613 - sentinel: redis://10.244.226.111:26379 added
02 Dec 2021 14:03:19,885  INFO [redisson-netty-2-26]  SentinelConnectionManager:613 - sentinel: redis://10.244.226.111:26379 added
Steps to reproduce or test case
3 Redis pods running along with Sentinels
App connected to Redis with Sentinel config
Redis version
6.2.3
Redisson version
3.16.5
Redisson configuration
String redisUrls = "redis://redis:26379";
config.useSentinelServers()
.setReadMode(ReadMode.MASTER_SLAVE)
.setScanInterval(5000)
.setRetryAttempts(2)
.setRetryInterval(1000)
.setPassword(redisPassword)
.setPingConnectionInterval(5000)
.setMasterName("redis-master")
.addSentinelAddress(redisUrls.split(","));
Please let me know if i have mis-configured anything. Thanks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4004
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Using Java 16/17 I can connect with a host by host name successfully, just as with Java 8
Actual behavior
When running the same code with Java 8, I can successfully connect to a remote host by name, but with Java 9, 16 and 17 I cannot.
Stacktrace:
java.lang.ExceptionInInitializerError
at xxx
Caused by: java.net.UnknownHostException: failed to resolve 'somehost' after 10 queries
at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:1046)
at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:999)
at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:417)
at io.netty.resolver.dns.DnsResolveContext.onResponse(DnsResolveContext.java:628)
at io.netty.resolver.dns.DnsResolveContext.access$400(DnsResolveContext.java:65)
at io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:461)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
at io.netty.resolver.dns.DnsQueryContext.trySuccess(DnsQueryContext.java:200)
at io.netty.resolver.dns.DnsQueryContext.finish(DnsQueryContext.java:192)
at io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:1301)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:97)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.base/java.lang.Thread.run(Thread.java:833)
Steps to reproduce or test case
I am using Redisson, which is using Netty:
Config config = new Config();
config.useSingleServer()
        .setAddress("redis://somehost:5379");
CLIENT = Redisson.create(config);

Redis version
6.2.6 (dockerised)
Redisson version
Tried 3.16.4 and 3.16.5
Redisson configuration
As above
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Have 1 master and 1 slave (with AWS ElastiCache). When testing failover by through modifying of the node type of the redis instance, expect after failover that there are no errors when querying the new master/slave.
Actual behavior
Getting the following error message:
Can't find replicaAddr/<host> in slaves! Available slaves: [[addr=master1Addr], [addr=master1Addr], [addr=master1Addr], [addr=replicaAddr]]
Trace:
  at java.lang.Thread.getStackTrace(Thread.java:1596)
   at ch.qos.logback.core.UnsynchronizedAppenderBase.doAppend(UnsynchronizedAppenderBase.java:84)
   at ch.qos.logback.core.spi.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:51)
   at ch.qos.logback.classic.Logger.appendLoopOnAppenders(Logger.java:270)
   at ch.qos.logback.classic.Logger.callAppenders(Logger.java:257)
   at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:421)
   at ch.qos.logback.classic.Logger.filterAndLog_2(Logger.java:414)
   at ch.qos.logback.classic.Logger.error(Logger.java:530)
   at org.redisson.connection.balancer.LoadBalancerManager.unfreeze(LoadBalancerManager.java:127)
   at org.redisson.connection.MasterSlaveEntry.slaveUp(MasterSlaveEntry.java:424)
   at org.redisson.connection.ReplicatedConnectionManager.slaveUp(ReplicatedConnectionManager.java:206)
   at org.redisson.connection.ReplicatedConnectionManager.lambda$checkNode$5(ReplicatedConnectionManager.java:195)
   at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
   at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
   at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
   at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
   at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
   at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
   at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)
   at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
   at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
   at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:460)
   at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:454)
   at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:385)
   at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198)
   at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137)
   at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113)
   at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)
   at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366)
   at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
   at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
   at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
   at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
   at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
   at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
   at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
   at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
   at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
   at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
   at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
   at java.lang.Thread.run(Thread.java:831)

Steps to reproduce or test case

Deploy Service
Modify node type of redis instance
View application logs and see errors

Redis version
6.0.5
Redisson version
3.16.5
Redisson configuration
    redissonConfig
      .useReplicatedServers()
      .setTimeout(5000)
      .setNodeAddresses(addressList);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4006
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
请问这个问题解决了吗？在哪个版本解决的？
我现在用的是redisson-spring-data-24:3.15.2
spring-projects/spring-data-redis/issues/2147
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4007
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When using RRateLimiter.expire(), RRateLimiter sets TTL to config Hash set, but doesn't set TTL to value and permits.
IIUC, value and permits consumes more memory compared to config Hash set.
Is there a way to expire value and permits?
NOTE:

config = key returned bygetRawName()
value = key returned by https://github.com/redisson/redisson/blob/redisson-3.16.6/redisson/src/main/java/org/redisson/RedissonRateLimiter.java#L53-L55
permits = key returned by https://github.com/redisson/redisson/blob/redisson-3.16.6/redisson/src/main/java/org/redisson/RedissonRateLimiter.java#L45-L47
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
This is happening on my CI/CD tool (Semaphore CI). After adding the Redisson dependency, the build always fails with the error:
*** buffer overflow detected ***: /usr/lib/jvm/java-11-openjdk-amd64/bin/java terminated
My CI/CD uses a Ubuntu 18.04 VM and has Java 11.0.11 installed.
I think the problem is likely related to that VM, as if I run the tests locally (Ubuntu 20.04, OpenJDK Runtime Environment AdoptOpenJDK-11.0.11+9) the tests are executed as expected.
Has anybody had this problem before? Do you have any idea on what might be creating this error?
Thanks in advance for any help!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4009
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We want to enforce that Application can only read the data from Redis Master node but is not able to write or make into modifications into the Redis Master node in replicatedServerConfig. Can you please inform how can we do that?  Is that using readMode :MASTER ? Can you please provide the yaml configuration for that ?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4010
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey guys.
When moving from version 3.16.3 to 3.16.5 I've noticed compilation issues due to the missing method getAmount() which underneath was running freeConnectionsCounter.getCounter():
https://github.com/redisson/redisson/blob/redisson-3.16.3/redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java#L155-L157
My question is was that intentional and is there a substitute method somewhere? I couldn't find a quick solution for this.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4011
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a limit of 20 connections per server and in previous versions the initialization was correct. But in version 3.16.5, the SlaveConnectionPool was initialized, which creates 24 connections by default. But I cannot reduce their number for configuration in single server mode and I cannot disable the creation of this pool either.
Expected behavior
2021-12-08 12:04:26.535    INFO 297287 --- [           main] org.redisson.Version                     : Redisson 3.16.4
2021-12-08 12:04:26.806    INFO 297287 --- [isson-netty-2-3] o.r.c.pool.MasterConnectionPool          : 4 connections initialized for 127.0.0.1/127.0.0.1:6383
2021-12-08 12:04:26.808    INFO 297287 --- [isson-netty-2-3] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for 127.0.0.1/127.0.0.1:6383
Actual behavior
2021-12-08 12:06:41.232    INFO 297579 --- [           main] org.redisson.Version                     : Redisson 3.16.5
2021-12-08 12:06:41.540    INFO 297579 --- [isson-netty-2-2] o.r.c.pool.MasterPubSubConnectionPool    : 1 connections initialized for 127.0.0.1/127.0.0.1:6383
2021-12-08 12:06:41.540    INFO 297579 --- [isson-netty-2-4] o.r.c.pool.PubSubConnectionPool          : 1 connections initialized for 127.0.0.1/127.0.0.1:6383
2021-12-08 12:06:41.544    INFO 297579 --- [isson-netty-2-4] o.r.c.pool.MasterConnectionPool          : 4 connections initialized for 127.0.0.1/127.0.0.1:6383
2021-12-08 12:06:41.553    INFO 297579 --- [isson-netty-2-4] o.r.connection.pool.SlaveConnectionPool  : 24 connections initialized for 127.0.0.1/127.0.0.1:6383
Steps to reproduce or test case
Redis version
Redisson version
3.16.5,...
Redisson configuration
single server
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The document said 'Replicated mode' is for Azure or AWS, but these cloud service can also use jedis as client which just has single or cluster mode.
So what's the difference if I use the 'Replicated mode' instead of the 'single mode'?
文档里说云托管模式是用来连接云计算运营商提供的Redis云服务，但是这些云服务厂商也可以通过jedis直接连接，而jedis只有常规的单机或者集群连接，是没有这种云托管模式的。
所以使用云托管模式的话，跟用单机或者集群的方式有什么区别吗
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4013
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
not hope to oom;
Actual behavior
home get  redissonClient.getLocalCachedMap() can olny single entity,but evrytime get a new new RedissonLocalCachedMap<K, V>(xxxx)，more request lead to OOM
Steps to reproduce or test case
Redis version
Redisson version
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4014
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public class App 
{
    public static void main( String[] args )
    {
        RedissonClient client = Redisson.create();
        
    }
}
Above code by default it create client using single server config, but it still opens many connection for other purpose, why?
[main] INFO org.redisson.Version - Redisson 3.16.6
[redisson-netty-2-5] INFO org.redisson.connection.pool.MasterPubSubConnectionPool - 1 connections initialized for 127.0.0.1/127.0.0.1:6379
[redisson-netty-2-29] INFO org.redisson.connection.pool.PubSubConnectionPool - 1 connections initialized for 127.0.0.1/127.0.0.1:6379
[redisson-netty-2-4] INFO org.redisson.connection.pool.MasterConnectionPool - 24 connections initialized for 127.0.0.1/127.0.0.1:6379
[redisson-netty-2-5] INFO org.redisson.connection.pool.SlaveConnectionPool - 24 connections initialized for 127.0.0.1/127.0.0.1:6379
What if I just want single connection to my single server?
server info:
# Replication
role:master
connected_slaves:0
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4015
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
问题：
在使用redisson-spring-data-18哨兵模式，客户端地址配置为2204::51，2204::52，2204::53。在启动时候报错Skipped slave up redis://2204:0:0:0:0:0:0:51:8379 for master redis://2204:0:0:0:0:0:0:53:8379 differs from current redis://2204::53:8379。master地址check有误，2204:0:0:0:0:0:0:53与2204::53被判断不是相同的IPv6地址。
日志:
2021-12-10 17:18:59.590  WARN [ibnsapp,,,] 1 --- [isson-netty-2-3] o.r.c.SentinelConnectionManager          : Skipped slave up redis://2204:0:0:0:0:0:0:51:8379 for master redis://2204:0:0:0:0:0:0:53:8379 differs from current redis://2204::53:8379
2021-12-10 17:18:59.590  WARN [ibnsapp,,,] 1 --- [isson-netty-2-3] o.r.c.SentinelConnectionManager          : Skipped slave up redis://2204:0:0:0:0:0:0:52:8379 for master redis://2204:0:0:0:0:0:0:53:8379 differs from current redis://2204::53:8379
ers from current redis://2204::53:8379
2021-12-10 17:18:59.592  INFO [ibnsapp,,,] 1 --- [isson-netty-2-3] o.redisson.connection.MasterSlaveEntry   : master 2204::53/2204:0:0:0:0:0:0:53:8379 used as slave
2021-12-10 17:18:59.592  WARN [ibnsapp,,,] 1 --- [isson-netty-2-3] o.r.c.SentinelConnectionManager          : slave: redis://2204:0:0:0:0:0:0:53:8379 is down
2021-12-10 17:18:59.593  INFO [ibnsapp,,,] 1 --- [sson-netty-2-27] o.r.connection.pool.SlaveConnectionPool  : 8 connections initialized for 2204::53/2204:0:0:0:0:0:0:53:8379
2021-12-10 17:18:59.593  INFO [ibnsapp,,,] 1 --- [isson-netty-2-1] o.r.c.pool.PubSubConnectionPool          : 9 connections initialized for 2204::53/2204:0:0:0:0:0:0:53:8379
依赖版本
redis: 6.2.5
redisson-spring-data-18：3.16.4
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4016
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
java.lang.NullPointerException: null
at org.redisson.RedissonBaseLock.createCommandBatchService(RedissonBaseLock.java:238) ~[redisson-3.16.2.jar!/:3.16.2]
at org.redisson.RedissonBaseLock.evalWriteAsync(RedissonBaseLock.java:212) ~[redisson-3.16.2.jar!/:3.16.2]
at org.redisson.RedissonWriteLock.tryLockInnerAsync(RedissonWriteLock.java:55) ~[redisson-3.16.2.jar!/:3.16.2]
at org.redisson.RedissonLock.tryAcquireAsync(RedissonLock.java:175) ~[redisson-3.16.2.jar!/:3.16.2]
at org.redisson.RedissonLock.tryAcquire(RedissonLock.java:143) ~[redisson-3.16.2.jar!/:3.16.2]
at org.redisson.RedissonLock.tryLock(RedissonLock.java:223) ~[redisson-3.16.2.jar!/:3.16.2]
the redis model is cluster
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4017
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4018
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
使用的是阿里云redis服务器
redisson.Version  3.16.5
日志
2021-12-14 20:01:51.142 [redisson-netty-2-2] INFO  org.redisson.connection.pool.MasterConnectionPool - 15 connections initialized for xxx
2021-12-14 20:01:51.149 [redisson-netty-2-2] INFO  org.redisson.connection.pool.PubSubConnectionPool - 5 connections initialized for xxx
2021-12-14 20:01:51.149 [redisson-netty-2-2] INFO  o.r.connection.pool.MasterPubSubConnectionPool - 5 connections initialized for xxxx
2021-12-14 20:01:51.159 [redisson-netty-2-2] INFO  org.redisson.connection.pool.SlaveConnectionPool - 24 connections initialized for xxx
配置
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 3000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: xxx
subscriptionsPerConnection: 5
address: redis://xxxx:6379
subscriptionConnectionMinimumIdleSize: 5
subscriptionConnectionPoolSize: 5
connectionMinimumIdleSize: 15
connectionPoolSize: 15
database: 0
dnsMonitoringInterval: 5000
keepPubSubOrder: true
lockWatchdogTimeout: 30000
codec: !<org.redisson.codec.JsonJacksonCodec> {}
threads: 2
nettyThreads: 2
问题1:singleServerConfig模式下为何出现slave的连接初始化
问题2:singleServerConfig模式下 slaveConnectionMinimumIdleSize 好像不能设置
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4019
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi, We are looking to configure redisson-mybatis, so that when for some reason Redis does not respond, the application can be running without problems.
The idea is to leave a trace of the connection error, but that the application executes the sentences and continues working.
I found this similar report, but for Tomcar. Issue
The question is if this behavior is possible, and if not, could I report a feature?
Thanks for your time
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4020
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Consider the following scenario in a service HA cluster:
service 1 node 1 is at version 1, with task-legacy-1
service 1 node 2 is upgraded to version 2, with task-legacy-1, task-new-1
service 1 node 2 submits task-new-1 to Redisson executor. 

There's a chance that service 1 node 1 picks up the submitted task-new-1, but will fail due to lack of definition.

I think this issue is common for all services that using Redisson executor. What's the best practice?
Thinking of potential solutions:

Normally with distributed scheduler, there's a tag filter, to filter worker nodes for task. But can't find similar thing in Redisson. ------ please advise.
Another idea is to use different executor namespaces, and each service version N submits tasks to executor-N (the latest) and executes task from both executor-N-1 and executor N.  However this is also hard for upgrade and eviction of old executor is needed. Seems a blocker when there's recurring schedule submitted in old executor. Not sure how to migrate.  ----- please advise.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4021
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Any one can help me ?
Why the eval method in RedissonConnection use codec:StringCodec.INSTANCE , but evalSha method use ByteArrayCodec.INSTANCE.
I found that the eval may encode the byte array (response from redis server ) into String, which may cause Serialization problems.
Is it a bug?
    public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... keysAndArgs) {
        if (isQueueing()) {
            throw new UnsupportedOperationException();
        }
        if (isPipelined()) {
            throw new UnsupportedOperationException();
        }

        RedisCommand<?> c = toCommand(returnType, "EVAL");
        List<Object> params = new ArrayList<Object>();
        params.add(script);
        params.add(numKeys);
        params.addAll(Arrays.asList(keysAndArgs));
        return write(null, StringCodec.INSTANCE, c, params.toArray()); // this line
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4022
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
When I call method runWithRwLock and method runWithMultiLock at same time, it works fine. When I call method runWithLock and method runWithRwLock/runWithMultiLock, the following error is frequently reported
2021-12-16 12:30:22.647 [pool-1-thread-1] ERROR com.pain.blue.cache.RedisTest:217 - lockAndUnlock
org.redisson.client.RedisTimeoutException: Subscribe timeout: (7500ms). Increase 'subscriptionsPerConnection' and/or 'subscriptionConnectionPoolSize' parameters.
	at org.redisson.command.CommandAsyncService.syncSubscription(CommandAsyncService.java:118)
	at org.redisson.RedissonLock.lock(RedissonLock.java:185)
	at org.redisson.RedissonLock.lock(RedissonLock.java:156)
	at com.pain.blue.cache.RedisTest.runWithRwLock(RedisTest.java:254)
	at com.pain.blue.cache.RedisTest.lambda$benchmark$2(RedisTest.java:211)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

This is my test code:
private static void benchmark() throws InterruptedException {
    ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(5000);
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 20, 30, TimeUnit.SECONDS, queue, new ThreadPoolExecutor.CallerRunsPolicy());
    Config config = new Config();
    config.useSingleServer()
            .setAddress("redis://127.0.0.1:6379")
            .setSubscriptionsPerConnection(5000)
            .setSubscriptionConnectionPoolSize(50);
    config.setLockWatchdogTimeout(15 * 1000);
    RedissonClient client = Redisson.create(config);
    AtomicLong counter = new AtomicLong();
    long startTime = System.currentTimeMillis();
    Random random = new Random();

    for (int i = 0; i < 100000; ++i) {
        int ii = i;
        executor.submit(() -> {
            try {
                int resource1 = random.nextInt(20);
                int resource2 = random.nextInt(20);
                int resource3 = random.nextInt(20);
                boolean write = ii % 2 == 0;
                // runWithLock(client, String.valueOf(resource1));
                runWithRwLock(client, String.valueOf(resource2), write);
                runWithMultiLock(client, String.valueOf(resource3), write);
                log.info("task: {}, count: {}", ii, counter.incrementAndGet());
            } catch (Exception ex) {
                ex.printStackTrace();
                log.error("lockAndUnlock", ex);
            }
        });
    }

    executor.shutdown();
    executor.awaitTermination(1000, TimeUnit.SECONDS);

    long endTime = System.currentTimeMillis();
    client.shutdown();

    log.info("counter: {}, cost: {}", counter.get(), (endTime - startTime));
}

private static void runWithLock(RedissonClient client, String resource) throws InterruptedException {
    log.info("{}, prepare lock", Thread.currentThread().getId());
    RLock lock = client.getLock(resource);
    log.info("{}, before lock", Thread.currentThread().getId());
    lock.lock(800, TimeUnit.MILLISECONDS);
    log.info("{}, after lock", Thread.currentThread().getId());
    Thread.sleep(10);
    log.info("{}, unlock", Thread.currentThread().getId());
    lock.unlock();
}

private static void runWithRwLock(RedissonClient client, String resource, boolean write) throws InterruptedException {
    log.info("{}, prepare {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    RReadWriteLock rwLock = client.getReadWriteLock(resource);
    RLock lock;

    if (write) {
        lock = rwLock.writeLock();
    } else {
        lock = rwLock.readLock();
    }

    log.info("{}, before {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    lock.lock(800, TimeUnit.MILLISECONDS);
    log.info("{}, after {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    Thread.sleep(10);
    log.info("{}, {} unlock", Thread.currentThread().getId(), write ? "write" : "read");
    lock.unlock();
}

private static void runWithMultiLock(RedissonClient client, String resource, boolean write) throws InterruptedException {
    log.info("{}, prepare {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    RReadWriteLock rwLock1 = client.getReadWriteLock(resource);
    int value = Integer.parseInt(resource);
    RReadWriteLock rwLock2 = client.getReadWriteLock(String.valueOf(value + 3));
    RReadWriteLock rwLock3 = client.getReadWriteLock(String.valueOf(value + 6));
    RReadWriteLock rwLock4 = client.getReadWriteLock(String.valueOf(value + 9));
    RLock lock1;
    RLock lock2;
    RLock lock3;
    RLock lock4;

    if (write) {
        lock1 = rwLock1.writeLock();
        lock2 = rwLock2.writeLock();
        lock3 = rwLock3.writeLock();
        lock4 = rwLock4.writeLock();
    } else {
        lock1 = rwLock1.readLock();
        lock2 = rwLock2.readLock();
        lock3 = rwLock3.readLock();
        lock4 = rwLock4.readLock();
    }

    RLock lock = client.getMultiLock(lock1, lock2, lock3, lock4);

    log.info("{}, before {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    lock.lock(800, TimeUnit.MILLISECONDS);
    log.info("{}, after {} lock", Thread.currentThread().getId(), write ? "write" : "read");
    Thread.sleep(10);
    log.info("{}, {} unlock", Thread.currentThread().getId(), write ? "write" : "read");
    lock.unlock();
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4024
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
The Redis version was upgraded from 5.0.3 to 6.2.4, and this problem occurred.
The configuration file for Redission has not been modified
Redission version is 3.15.5
This is a detailed error message ：
org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 3 of 8 were initialized. Redis server: 192.168.34.102/192.168.34.103:6379
at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:158)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:328)
at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$1(ConnectionPool.java:294)
at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
at org.redisson.client.RedisClient$2$2.run(RedisClient.java:251)
at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalStateException: failed to create a new resolver
at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:72)
at io.netty.bootstrap.Bootstrap.doResolveAndConnect0(Bootstrap.java:194)
at io.netty.bootstrap.Bootstrap.access$000(Bootstrap.java:46)
at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:180)
at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:166)
at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)
at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(AbstractChannel.java:1012)
at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:516)
at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:429)
at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:486)
... 7 common frames omitted
Caused by: io.netty.channel.ChannelException: Unable to create Channel from class class io.netty.channel.socket.nio.NioDatagramChannel
at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:46)
at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:310)
at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:227)
at io.netty.resolver.dns.DnsNameResolver.(DnsNameResolver.java:497)
at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:488)
at io.netty.resolver.dns.DnsAddressResolverGroup.newNameResolver(DnsAddressResolverGroup.java:114)
at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:92)
at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:77)
at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:70)
... 22 common frames omitted
Caused by: java.lang.reflect.InvocationTargetException: null
at sun.reflect.GeneratedConstructorAccessor83.newInstance(Unknown Source)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:44)
... 30 common frames omitted
Caused by: io.netty.channel.ChannelException: Failed to open a socket.
at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:90)
at io.netty.channel.socket.nio.NioDatagramChannel.(NioDatagramChannel.java:119)
... 34 common frames omitted
Caused by: java.net.SocketException: maximum number of DatagramSockets reached
at sun.net.ResourceManager.beforeUdpCreate(ResourceManager.java:73)
at sun.nio.ch.DatagramChannelImpl.(DatagramChannelImpl.java:107)
at sun.nio.ch.SelectorProviderImpl.openDatagramChannel(SelectorProviderImpl.java:42)
at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:88)
... 35 common frames omitted
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4026
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We've wasted way to much time searching for a problem in our codebase. I think it won't hurt to add a note in the official guide :)
Here:
https://redisson.org/articles/redis-integration-with-micronaut.html
and here:
https://github.com/redisson/redisson/tree/master/redisson-micronaut
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4027
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4028
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[http-nio-30050-exec-8] jnpf.ResultException                    : org.springframework.dao.QueryTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@544414644 [redisClient=[addr=redis://218.90.122.145:6370], channel=[id: 0x78a18e59, L:/10.115.43.189:60890 - R:/218.90.122.145:6370], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@56f03af3(failure: java.util.concurrent.CancellationException)], command=(GET), params=[[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]], codec=org.redisson.client.codec.ByteArrayCodec]], command: (GET), params: [[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]] after 3 retry attempts; nested exception is org.redisson.client.RedisTimeoutException: Command still hasn't been written into connection! Increase nettyThreads and/or retryInterval settings. Payload size in bytes: 0. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@544414644 [redisClient=[addr=redis://218.90.122.145:6370], channel=[id: 0x78a18e59, L:/10.115.43.189:60890 - R:/218.90.122.145:6370], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@56f03af3(failure: java.util.concurrent.CancellationException)], command=(GET), params=[[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]], codec=org.redisson.client.codec.ByteArrayCodec]], command: (GET), params: [[103, 99, 108, 108, 111, 103, 105, 110, 95, 116, ...]] after 3 retry attempts
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:48)
at org.redisson.spring.data.connection.RedissonExceptionConverter.convert(RedissonExceptionConverter.java:35)
at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44)
at org.redisson.spring.data.connection.RedissonConnection.transform(RedissonConnection.java:223)
at org.redisson.spring.data.connection.RedissonConnection.syncFuture(RedissonConnection.java:218)
at org.redisson.spring.data.connection.RedissonConnection.sync(RedissonConnection.java:384)
at org.redisson.spring.data.connection.RedissonConnection.read(RedissonConnection.java:765)
at org.redisson.spring.data.connection.RedissonConnection.get(RedissonConnection.java:499)
at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57)
at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60)
at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228)
at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188)
at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96)
at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53)
at jnpf.util.RedisUtil.getString(RedisUtil.java:216)
at jnpf.util.UserProvider.get(UserProvider.java:56)
at jnpf.util.UserProvider.get(UserProvider.java:72)
at jnpf.DataSourceBindAspect.doAroundService(DataSourceBindAspect.java:58)
at sun.reflect.GeneratedMethodAccessor605.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4029
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4030
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am trying to integrate redis with hibernate 4.1.3.Final. But expire time configuration not working.
Here are my redission configuratio:
{
"singleServerConfig": {
"idleConnectionTimeout": 10000,
"connectTimeout": 10000,
"timeout": 5000,
"retryAttempts": 3,
"retryInterval": 1500,
"password": null,
"subscriptionsPerConnection": 5,
"clientName": null,
"address": "redis://${REDIS_PORT:-127.0.0.1:6379}",
"subscriptionConnectionMinimumIdleSize": 1,
"subscriptionConnectionPoolSize": 50,
"connectionMinimumIdleSize": 10,
"connectionPoolSize": 64,
"database": 0,
"dnsMonitoringInterval": 5000
},
"threads": 0,
"nettyThreads": 0,
"codec": null
}
Hibernate configuration:
            <prop key="hibernate.default_schema">${hibernate.default_schema}</prop>
            <prop key="hibernate.dialect">${hibernate.dialect}</prop>
            <prop key="hibernate.show_sql">false</prop>
            <prop key="hibernate.format_sql">true</prop>
            <prop key="hibernate.generate_statistics">true</prop>
            <prop key="hibernate.cache.use_query_cache">true</prop>
            <prop key="hibernate.cache.use_structured_entries">true</prop>
            <prop key="hibernate.cache.use_second_level_cache">true</prop>
            <prop key="hibernate.javax.cache.missing_cache_strategy">create</prop>
            <prop key="hibernate.cache.redisson.fallback">true</prop>
            <prop key="hibernate.cache.region.factory_class">org.redisson.hibernate.RedissonRegionFactory</prop>
            <prop key="hibernate.cache.redisson.config">/redisson.json</prop>
            <prop key="hibernate.cache.redisson.my_object.eviction.max_entries">10000</prop>
            <prop key="hibernate.cache.redisson.my_object.expiration.time_to_live">18000000</prop>
            <prop key="hibernate.cache.redisson.my_object.expiration.max_idle_time">12000000</prop>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4032
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for proposed contribution. Please fix all PR checks.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


https://github.com/redisson/redisson/issues/4034
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have 2 servers that use the same RLocalCachedMap. Server A I use to put data and Server B just use to query data.
I'm facing with issue that sometime Server A updates data but Server B data is still old (cached value is not updated). I checked log but no Redisson exception there.
If I invoke localCachedMap.preloadCache() on server B (via SOS REST call), data of server B will be updated.
I'm using Redisson 3.16.5
This is my LocalCacheOptions
LocalCachedMapOptions.defaults() .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.NONE) .cacheSize(0) .syncStrategy(LocalCachedMapOptions.SyncStrategy.UPDATE) .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.NONE) .writeMode(MapOptions.WriteMode.WRITE_BEHIND);
This is my RedissonConfig
config.useSentinelServers() .setMasterName(****) .setPassword(****) .setReadMode(ReadMode.SLAVE) .setSubscriptionMode(SubscriptionMode.SLAVE) .setKeepAlive(true) .setTcpNoDelay(true) .addSentinelAddress(redisUri) .setSubscriptionsPerConnection(100) .setSlaveConnectionPoolSize(1000) .setMasterConnectionPoolSize(1000);
Please help me to point out some ways to investigate and resolve this issue.
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4035
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
mget  group keys by master slave entry,  different slot with same master slave entry keys send one command
Actual behavior
mget  group keys by slot, different slot with same master slave entry keys send multi command
Steps to reproduce or test case
Redis version
all
Redisson version
3.16.6
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4036
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
原因：
log4j被曝安全漏洞，紧急进行版本修复。
解决方案：
将log4j-api和log4j-core改到2.15.0及其以上版本
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
按照描述时间设置为负数时应该直接返回
但实际发生了等待
RRateLimiter aaaa = redisson.getRateLimiter("test");
        aaaa.setRate(RateType.OVERALL, 2,10, RateIntervalUnit.SECONDS);
        if (!aaaa.tryAcquire(1,0L, TimeUnit.SECONDS)) {
            throw new RuntimeException("error");
        }
        if (!aaaa.tryAcquire(1,-1L, TimeUnit.SECONDS)) {
            throw new RuntimeException("error");
        }
        if (!aaaa.tryAcquire(1,-1L, TimeUnit.SECONDS)) {
            throw new RuntimeException("error");
        }
        if (!aaaa.tryAcquire(1,-1L, TimeUnit.SECONDS)) {
            throw new RuntimeException("error);
        }
        if (!aaaa.tryAcquire(1,-1L, TimeUnit.SECONDS)) {
            throw new RuntimeException("error");
        }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4038
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson 是否不支持从注册中心获取redis实例信息，看文档只支持在初始化时指定node的ip:port。
在这种情况下redis集群的实例发生变化，不能动态调整。请问有什么好的办法，或者文档。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4039
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4040
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior

The Lua script executes on the Slave node

Actual behavior

The Lua script executes on the Master node

Steps to reproduce or test case
Here is the Java code:
redissonClient
          .getScript()
          .evalSha(
              RScript.Mode.READ_ONLY,
              "<sha1-hash>",
              RScript.ReturnType.MULTI,
              getKeys(),
              getArgs());
Here is the Lua script
local id = redis.call("CLUSTER", "MYID")

redis.log(redis.LOG_NOTICE, "I'm get master account " .. id)
return redis.call('hmget', KEYS[1], unpack(ARGV))
After executing Java code and the Redis's log like bellow

We can see that the Lua script is executed on the master node (127.0.0.1:7001) instead of the slave node (127.0.0.1:7005), but I have already config the readMode to SLAVE & pass the RScript.Mode.READ_ONLY config when evalSha.
Please help me correct if I'm wrong, thanks!
Redis version
v6.2.0
Redisson version
v3.16.2
Redisson configuration
  redissonConfig:
    clusterServersConfig:
      idleConnectionTimeout: 10000
      pingTimeout: 1000
      connectTimeout: 3000
      timeout: 5000
      retryAttempts: 2
      retryInterval: 100
      failedSlaveReconnectionInterval: 3000
      failedSlaveCheckInterval: 60000
      password: null
      subscriptionsPerConnection: 5
      clientName: null
      subscriptionConnectionMinimumIdleSize: 1
      subscriptionConnectionPoolSize: 10
      slaveConnectionMinimumIdleSize: 1
      slaveConnectionPoolSize: 1
      masterConnectionMinimumIdleSize: 1
      masterConnectionPoolSize: 4
      readMode: "SLAVE"
      subscriptionMode: "MASTER"
      scanInterval: 1000
      pingConnectionInterval: 1000
      keepAlive: true
      tcpNoDelay: true
      nodeAddresses:
        - "redis://127.0.0.1:7000"
        - "redis://127.0.0.1:7001"
        - "redis://127.0.0.1:7002"
        - "redis://127.0.0.1:7003"
        - "redis://127.0.0.1:7004"
        - "redis://127.0.0.1:7005"
    threads: 128
    nettyThreads: 128
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4041
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
There should be just MasterConnectionPool enabled when useSingleServer.
Actual behavior
When trying to connect to Redis containing one node, slave connection pool will also be created.
Steps to reproduce or test case
Connect to single redis server.
3.16.6 version
org.redisson.connection.MasterSlaveEntry#setupMasterEntry#154
there is a addSlave() call when single server is used.
This maybe edited for creating slave connection correctly in some cases. But it will also create a pool when using single server.

Redis version
4&6
Redisson version
After 3.16.5
Redisson configuration
config.useSingleServer()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4043
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
first, please forgive my poor english。
my question :
is there any efficient way to batch add object with bloomfilter?
such as pipeline?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4045
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4046
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
We are using the clustered connection in aws for redis, but the read is always happening from the primary node.
The versions we are using:
Redis engine in aws  : 4.0.10
Client:

org.redisson
redisson
3.16.6

Config:
URL: aws cluster url
final int poolSize = Runtime.getRuntime().availableProcessors() * 2 + 2;
Config config = new Config();
config
.useClusterServers()
.setScanInterval(2000)
.addNodeAddress(redisUrl)
.setMasterConnectionPoolSize(poolSize)
.setMasterConnectionMinimumIdleSize(poolSize)
.setSlaveConnectionPoolSize(poolSize)
.setSlaveConnectionMinimumIdleSize(poolSize)
.setReadMode(ReadMode.SLAVE);
	config.setCodec(codec);
	redissonClient = Redisson.create(config);

Cache read:
            final RMap<String, Config> cache = this.redissonClient.getMap(CONFIG_CACHE);
	if (cache.isEmpty()) {
		log.info("found Config cache empty... reloading from database");
		reloadPartnerConfig();
	}
	return cache.get(apiKey);

@mrniko  Could you check this once you have some time. I am sure you can provide a relevant answer very fast.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4047
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Unfortunately, the docs doesn't contain any information about Reactive and RxJava Redisson apis. How you even use them?
For example, RMapRx#get(K) returns Maybe<V>, how it can be considered reactive? Shouldn't it be an Observable<V>? How it is any more useful than just returning something like a CompletableFuture<V>?
What is the use case of these apis?
Also, .getLocalCachedMap() is unavailable in reactive and rx apis, why?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4048
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
I should be able to create a RedissonClient
Actual behavior
This only happens with version 3.16.6. 3.16.4 doesn't cause this error. Also, this error only happens with the local embedded Redis. On a real remote Redis server, it works fine.
On create, I get this error:
org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 16 of 24 were initialized. Redis server: localhost/127.0.0.1:6614
        at org.redisson.connection.pool.ConnectionPool$1.lambda$run$0(ConnectionPool.java:158)
        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
        at org.redisson.connection.pool.ConnectionPool.promiseFailure(ConnectionPool.java:313)
        at org.redisson.connection.pool.ConnectionPool.lambda$createConnection$3(ConnectionPool.java:279)
        at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:183)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609)
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)
        at org.redisson.misc.RedissonPromise.tryFailure(RedissonPromise.java:96)
        at org.redisson.client.RedisClient$2$2.run(RedisClient.java:251)
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
        at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IllegalStateException: failed to create a new resolver
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:72)
        at io.netty.bootstrap.Bootstrap.doResolveAndConnect0(Bootstrap.java:194)
        at io.netty.bootstrap.Bootstrap.access$000(Bootstrap.java:46)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:180)
        at io.netty.bootstrap.Bootstrap$1.operationComplete(Bootstrap.java:166)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578)
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491)
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616)
        at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605)
        at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104)
        at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:84)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetSuccess(AbstractChannel.java:1008)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:516)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:429)
        at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:486)
        ... 7 common frames omitted
Caused by: io.netty.channel.ChannelException: Unable to create Channel from class class io.netty.channel.socket.nio.NioDatagramChannel
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:46)
        at io.netty.bootstrap.AbstractBootstrap.initAndRegister(AbstractBootstrap.java:310)
        at io.netty.bootstrap.AbstractBootstrap.register(AbstractBootstrap.java:227)
        at io.netty.resolver.dns.DnsNameResolver.<init>(DnsNameResolver.java:497)
        at io.netty.resolver.dns.DnsNameResolverBuilder.build(DnsNameResolverBuilder.java:488)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newNameResolver(DnsAddressResolverGroup.java:114)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:92)
        at io.netty.resolver.dns.DnsAddressResolverGroup.newResolver(DnsAddressResolverGroup.java:77)
        at io.netty.resolver.AddressResolverGroup.getResolver(AddressResolverGroup.java:70)
        ... 22 common frames omitted
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.GeneratedConstructorAccessor41.newInstance(Unknown Source)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at io.netty.channel.ReflectiveChannelFactory.newChannel(ReflectiveChannelFactory.java:44)
        ... 30 common frames omitted
Caused by: io.netty.channel.ChannelException: Failed to open a socket.
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:90)
        at io.netty.channel.socket.nio.NioDatagramChannel.<init>(NioDatagramChannel.java:119)
        ... 34 common frames omitted
Caused by: java.net.SocketException: maximum number of DatagramSockets reached
        at sun.net.ResourceManager.beforeUdpCreate(ResourceManager.java:73)
        at sun.nio.ch.DatagramChannelImpl.<init>(DatagramChannelImpl.java:107)
        at sun.nio.ch.SelectorProviderImpl.openDatagramChannel(SelectorProviderImpl.java:42)
        at io.netty.channel.socket.nio.NioDatagramChannel.newSocket(NioDatagramChannel.java:88)
        ... 35 common frames omitted

Steps to reproduce or test case
N/A
Redis version
https://mvnrepository.com/artifact/com.github.kstyrc/embedded-redis/0.6
Redisson version
3.16.6
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4049
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
use codec

What's happen? Sometimes this error happens。
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4051
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently, if you deserialize an object it will always be created using the same class instance as when it was serialized. This will result in a ClassCastException if you serialize and deserialize from classes loaded by different class loaders (which is a case when using something like hot code reload).
The proposed solution is to add a type parameter in every method that deserializes an object, e.g.
MyClass value = rMap.get("key", MyClass.class);
Which is the same as in a popular GSON library.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4053
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
diff method is broken RScoredSortedSetReactive.
Create 2 SortedSet and do the diffstore in redis.
zadd set:1 0 a
zadd set:1 1 b
zadd set:1 2 c

zadd set:2 1 c
zadd set:2 2 b

zdiffstore set:1 2 set:1 set:2

check what set:1 contains. It contains only "a"
Now do the exact thing with redission.
zadd set:1 0 a
zadd set:1 1 b
zadd set:1 2 c

zadd set:2 1 c
zadd set:2 2 b

RScoredSortedSetReactive<String> set1 = client.getScoredSortedSet("set:1:", StringCodec.ISNTANCE);
set1.diff("set:2")
    .subscribe();

It does not do any diff. set:1 contains all the original elements.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4054
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When invoking RedissonMapCache.readAllKeySet() the codec's map key decoder should be invoked, i.e  Codec.getMapKeyDecoder()
Actual behavior
The codec's map value decoder is being used to decode keys, i.e. Codec.getMapValueDecoder() which causes exceptions to be thrown depending on the codec being used.
This is caused by RedisCommands.EVAL_MAP_KEY_SET being defined using MapValueDecoder instead of MapKeyDecoder.  I have locally amended the command to use MapKeyDecoder which fixed the problem
Steps to reproduce or test case
public class User {
    @JsonProperty("username")
    private final String username;

    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public User(@JsonProperty("username") String username) {
        this.username = username;
    }

    public String getUsername() {
        return username;
    }
}

        final RedissonClient client = ...;
        final Codec codec = new TypedJsonJacksonCodec(null, Long.class, User.class);
        final RMapCache<Long, User> redissonMap = client.getMapCache("test", codec, MapOptions.defaults());
        System.out.println(redissonMap.put(1L, new User("test")));
        System.out.println(redissonMap.readAllKeySet());

Redisson version
3.16.5
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4055
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hey! After doing this as just a test of Redisson pubsub
Config config = new Config();
config.useSingleServer().setAddress("redis://149.56.242.170:6379").setPassword("pepo0804")
                .setConnectionMinimumIdleSize(1)
                .setConnectionMinimumIdleSize(1)
                .setConnectionPoolSize(2);
config.setMinCleanUpDelay(0);
config.setThreads(1);
config.setNettyThreads(2);
config.setTransportMode(TransportMode.NIO);
config.setCodec(new StringCodec());
RedissonClient redisson = Redisson.create(config);
Thread thread = new Thread(()-> {
            RTopic topic = redisson.getTopic("tfq");
            topic.addListenerAsync(Object.class, (channel, message) ->{
                /*at.getAndIncrement();
                if (at.get() % 1000 == 0) {
                    Bukkit.getLogger().log(Level.INFO,"Reached: " + at.get() + " in " + (System.currentTimeMillis() - time));
                }*/
            });
        });
thread.start();

new Thread(()->{
     RTopic topic = redisson.getTopic("tfq");
     while (true){
     topic.publishAsync("fwa");
     }
}).start();
        

The thing is, when using the method .publishAsync, memory usage increases too much really fast, but when using .publish, it doesn't
Is this an expected behavior? am I doing something wrong that could be causing that?
I'm running this with 8GB of ram
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4056
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Thanks for contribution!
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4057
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Increase connection pool size. Node source: NodeSource [slot=0, addr=null, redisClient=null, redirect=null, entry=null], connection: RedisConnection@1343879621 [redisClient=[addr=redis://172.31.142.7:6379], channel=[id: 0x371731e4, L:/10.0.134.241:35464 ! R:172.31.142.7/172.31.142.7:6379], currentCommand=null, usage=0], command: (EVAL), params: [local key = KEYS[1] local obj = ARGV[1] local items = redis.call('lrange', key, 0, -1) for i=1,#item..., 1, testJobUnitsPopKey_83924b22-20cd-4d42-abc6-5c236e8792c9, PooledUnsafeDirectByteBuf(ridx: 0, widx: 38, cap: 256)] after 3 retry attempts
        at org.redisson.command.RedisExecutor.checkWriteFuture(RedisExecutor.java:282) ~[redisson-3.16.7.jar!/:3.16.7]
        at org.redisson.command.RedisExecutor.access$100(RedisExecutor.java:62) ~[redisson-3.16.7.jar!/:3.16.7]
        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:165) ~[redisson-3.16.7.jar!/:3.16.7]
        at org.redisson.command.RedisExecutor$1.operationComplete(RedisExecutor.java:162) ~[redisson-3.16.7.jar!/:3.16.7]
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:552) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:609) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.AbstractChannel$AbstractUnsafe.safeSetFailure(AbstractChannel.java:1021) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(AbstractChannel.java:882) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.DefaultChannelPipeline$HeadContext.write(DefaultChannelPipeline.java:1367) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:717) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:764) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.65.Final.jar!/:4.1.65.Final]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_212]
Caused by: io.netty.channel.StacklessClosedChannelException
        at io.netty.channel.AbstractChannel$AbstractUnsafe.write(Object, ChannelPromise)(Unknown Source) ~[netty-transport-4.1.65.Final.jar!/:4.1.65.Final]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4058
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4059
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4060
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4061
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4062
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4063
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4064
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4065
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4066
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4067
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4068
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4069
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4070
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4071
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4072
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4073
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4074
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4075
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4076
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4077
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4078
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4079
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4080
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4081
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4082
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4084
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4085
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4086
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4087
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4088
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4089
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4090
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4091
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4092
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4093
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4094
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4095
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4096
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4097
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4098
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4100
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4102
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4103
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4104
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4105
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4106
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4107
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4108
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4109
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4110
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4111
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4112
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4113
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4114
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4115
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4116
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4117
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4118
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4120
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4121
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4122
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4123
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4124
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4127
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4128
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4130
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4132
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4134
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4135
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4136
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4137
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4138
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4141
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4142
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4144
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4145
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
问题说明
背景
版本号:
        <!-- https://mvnrepository.com/artifact/org.redisson/redisson -->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.16.8</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.redisson/redisson-spring-boot-starter -->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <version>3.16.8</version>
        </dependency>
问题重现
测试代码：
@Data @NoArgsConstructor @AllArgsConstructor
public class Vo implements Serializable {
    Integer id;
    String value;
}
        //指定编码器的Bucket
        RSortedSet<Vo> jsonSet = redissonClient.getSortedSet("testJsonObjVoZSet", JsonJacksonCodec.INSTANCE);
        if(jsonSet.isEmpty()){
            //在集合没有元素的时候，设置元素比对规则
            jsonSet.trySetComparator(Comparator.nullsFirst((Comparator<Vo> & Serializable)(x,y)->Integer.compare(x.id,y.id)));
        }
        jsonSet.add(new Vo(1,"测试1"));
        jsonSet.add(new Vo(1,"测试1"));
        jsonSet.add(new Vo(3,"测试3"));
        jsonSet.add(new Vo(2,"测试2"));
        System.out.println(jsonSet.readAll());
在第一次运行测试代码之后，redis保存了如下数据：


在第二次运行测试代码之后，出现了以下异常：
java.lang.IllegalStateException: java.lang.InstantiationException: java.util.Comparators$NullComparator

	at org.redisson.RedissonSortedSet.loadComparator(RedissonSortedSet.java:126)
	at org.redisson.RedissonSortedSet.checkComparator(RedissonSortedSet.java:226)
	at org.redisson.RedissonSortedSet.add(RedissonSortedSet.java:195)

问题原因
在执行 jsonSet.add(new Vo(1,"测试1")); 代码时，执行到org.redisson.RedissonSortedSet#loadComparator方法的comparator = (Comparator<V>) clazz.newInstance(); 语句时，出现了异常，该方法的代码如下：
private void loadComparator() {
        try {
            String comparatorSign = comparatorHolder.get();
            if (comparatorSign != null) {
                String[] parts = comparatorSign.split(":");
                String className = parts[0];
                String sign = parts[1];

                String result = calcClassSign(className);
                if (!result.equals(sign)) {
                    throw new IllegalStateException("Local class signature of " + className + " differs from used by this SortedSet!");
                }

                Class<?> clazz = Class.forName(className);
                comparator = (Comparator<V>) clazz.newInstance();
            }
        } catch (IllegalStateException e) {
            throw e;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }
表面原因是java.util.Comparators.NullComparator  无法通过(Comparator<V>) clazz.newInstance() 来构建一个实例，因为它没有空的构造方法。
实际原因是在设计org.redisson.RedissonSortedSet时，假设所有的Comparator 都可以通过(Comparator<V>) clazz.newInstance() 来构建一个新的Comparator ，从而没有真实的保存下Comparator 的实例，导致在需要从Redis中取出Comparator时，无法完全恢复Comparator。
解决方案
建议修改org.redisson.RedissonSortedSet，将Comparator 的校验、储藏和恢复使用序列化和反序列化方式来处理，从而避免Comparator 的不能储藏和不能恢复问题。
改造org.redisson.RedissonSortedSet

1、 增加private RBucket<Comparator<? super V>> comparatorInstance; 用于管理Comparator的实例
2、新增getComparatorInstanceKeyName方法，用于配置 comparatorInstance的Redis的Bucket

    private String getComparatorInstanceKeyName() {
        return "redisson_sortedset_comparator_instance:{" + getRawName() + "}";
    }

3、修改构造方法，增加comparatorInstance的初始化代码

    protected RedissonSortedSet(CommandAsyncExecutor commandExecutor, String name, RedissonClient redisson) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.redisson = redisson;
        comparatorHolder = redisson.getBucket(getComparatorKeyName(), StringCodec.INSTANCE);
        comparatorInstance = redisson.getBucket(getComparatorInstanceKeyName(), new SerializationCodec());
        lock = redisson.getLock("redisson_sortedset_lock:{" + getRawName() + "}");
        list = (RedissonList<V>) redisson.<V>getList(getRawName());
    }

    public RedissonSortedSet(Codec codec, CommandAsyncExecutor commandExecutor, String name, Redisson redisson) {
        super(codec, commandExecutor, name);
        this.commandExecutor = commandExecutor;

        comparatorHolder = redisson.getBucket(getComparatorKeyName(), StringCodec.INSTANCE);
        comparatorInstance = redisson.getBucket(getComparatorInstanceKeyName(), new SerializationCodec());
        lock = redisson.getLock("redisson_sortedset_lock:{" + getRawName() + "}");
        list = (RedissonList<V>) redisson.<V>getList(getRawName(), codec);
    }

4、修改loadComparator方法，替换原代码的构造comparator的处理代码

private void loadComparator() {
        try {
            String comparatorSign = comparatorHolder.get();
            if (comparatorSign != null) {
                String[] parts = comparatorSign.split(":");
                String className = parts[0];
                String sign = parts[1];

                String result = calcClassSign(className);
                if (!result.equals(sign)) {
                    throw new IllegalStateException("Local class signature of " + className + " differs from used by this SortedSet!");
                }
                comparator = comparatorInstance.get();
                if(comparator==null){
                    Class<?> clazz = Class.forName(className);
                    comparator = (Comparator<V>) clazz.newInstance();
                }
            }
        } catch (IllegalStateException e) {
            throw e;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

5、修改trySetComparator方法，在保存comparator的签名成功之后，将comparator的实例也保存到Redis

    @Override
    public boolean trySetComparator(Comparator<? super V> comparator) {
        String className = comparator.getClass().getName();
        final String comparatorSign = className + ":" + calcClassSign(className);
        Boolean res = commandExecutor.get(commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                "if redis.call('llen', KEYS[1]) == 0 then "
                + "redis.call('set', KEYS[2], ARGV[1]); "
                + "return 1; "
                + "else "
                + "return 0; "
                + "end",
                Arrays.<Object>asList(getRawName(), getComparatorKeyName()), comparatorSign));
        if (res) {
            this.comparator = comparator;
            if(comparator instanceof Serializable){
                comparatorInstance.set(comparator);
            }
        }
        return res;
    }
完整代码如下：
/**
 * Copyright (c) 2013-2021 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.redisson;

import io.netty.buffer.ByteBuf;
import org.redisson.api.*;
import org.redisson.api.mapreduce.RCollectionMapReduce;
import org.redisson.client.RedisClient;
import org.redisson.client.codec.Codec;
import org.redisson.client.codec.StringCodec;
import org.redisson.client.protocol.RedisCommands;
import org.redisson.codec.SerializationCodec;
import org.redisson.command.CommandAsyncExecutor;
import org.redisson.iterator.RedissonBaseIterator;
import org.redisson.mapreduce.RedissonCollectionMapReduce;
import org.redisson.misc.RPromise;
import org.redisson.misc.RedissonPromise;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.*;

import static org.redisson.client.protocol.RedisCommands.EVAL_LIST_SCAN;

/**
 *
 * @author Nikita Koksharov
 *
 * @param <V> value type
 */
public class RedissonSortedSet<V> extends RedissonObject implements RSortedSet<V> {

    public static class BinarySearchResult<V> {

        private V value;
        private Integer index;

        public BinarySearchResult(V value) {
            super();
            this.value = value;
        }

        public BinarySearchResult() {
        }

        public void setIndex(Integer index) {
            this.index = index;
        }
        public Integer getIndex() {
            return index;
        }

        public V getValue() {
            return value;
        }


    }

    private Comparator comparator = Comparator.naturalOrder();

    CommandAsyncExecutor commandExecutor;
    
    private RLock lock;
    private RedissonList<V> list;
    private RBucket<String> comparatorHolder;
    private RBucket<Comparator<? super V>> comparatorInstance;
    private RedissonClient redisson;

    protected RedissonSortedSet(CommandAsyncExecutor commandExecutor, String name, RedissonClient redisson) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.redisson = redisson;
        comparatorHolder = redisson.getBucket(getComparatorKeyName(), StringCodec.INSTANCE);
        comparatorInstance = redisson.getBucket(getComparatorInstanceKeyName(), new SerializationCodec());
        lock = redisson.getLock("redisson_sortedset_lock:{" + getRawName() + "}");
        list = (RedissonList<V>) redisson.<V>getList(getRawName());
    }

    public RedissonSortedSet(Codec codec, CommandAsyncExecutor commandExecutor, String name, Redisson redisson) {
        super(codec, commandExecutor, name);
        this.commandExecutor = commandExecutor;

        comparatorHolder = redisson.getBucket(getComparatorKeyName(), StringCodec.INSTANCE);
        comparatorInstance = redisson.getBucket(getComparatorInstanceKeyName(), new SerializationCodec());
        lock = redisson.getLock("redisson_sortedset_lock:{" + getRawName() + "}");
        list = (RedissonList<V>) redisson.<V>getList(getRawName(), codec);
    }
    
    @Override
    public <KOut, VOut> RCollectionMapReduce<V, KOut, VOut> mapReduce() {
        return new RedissonCollectionMapReduce<V, KOut, VOut>(this, redisson, commandExecutor);
    }

    private void loadComparator() {
        try {
            String comparatorSign = comparatorHolder.get();
            if (comparatorSign != null) {
                String[] parts = comparatorSign.split(":");
                String className = parts[0];
                String sign = parts[1];

                String result = calcClassSign(className);
                if (!result.equals(sign)) {
                    throw new IllegalStateException("Local class signature of " + className + " differs from used by this SortedSet!");
                }
                comparator = comparatorInstance.get();
                if(comparator==null){
                    Class<?> clazz = Class.forName(className);
                    comparator = (Comparator<V>) clazz.newInstance();
                }
            }
        } catch (IllegalStateException e) {
            throw e;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    // TODO cache result
    private static String calcClassSign(String name) {
        try {
            Class<?> clazz = Class.forName(name);

            ByteArrayOutputStream result = new ByteArrayOutputStream();
            ObjectOutputStream outputStream = new ObjectOutputStream(result);
            outputStream.writeObject(clazz);
            outputStream.close();

            MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(result.toByteArray());

            return new BigInteger(1, crypt.digest()).toString(16);
        } catch (Exception e) {
            throw new IllegalStateException("Can't calculate sign of " + name, e);
        }
    }

    @Override
    public Collection<V> readAll() {
        return get(readAllAsync());
    }

    @Override
    public RFuture<Collection<V>> readAllAsync() {
        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.LRANGE_SET, getRawName(), 0, -1);
    }
    
    @Override
    public int size() {
        return list.size();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public boolean contains(final Object o) {
        return binarySearch((V) o, codec).getIndex() >= 0;
    }

    @Override
    public Iterator<V> iterator() {
        return list.iterator();
    }

    @Override
    public Object[] toArray() {
        return list.toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return list.toArray(a);
    }

    @Override
    public boolean add(V value) {
        lock.lock();
        
        try {
            checkComparator();
    
            BinarySearchResult<V> res = binarySearch(value, codec);
            if (res.getIndex() < 0) {
                int index = -(res.getIndex() + 1);
                
                ByteBuf encodedValue = encode(value);
                
                commandExecutor.get(commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                   "local len = redis.call('llen', KEYS[1]);"
                    + "if tonumber(ARGV[1]) < len then "
                        + "local pivot = redis.call('lindex', KEYS[1], ARGV[1]);"
                        + "redis.call('linsert', KEYS[1], 'before', pivot, ARGV[2]);"
                        + "return;"
                    + "end;"
                    + "redis.call('rpush', KEYS[1], ARGV[2]);", Arrays.<Object>asList(getRawName()), index, encodedValue));
                return true;
            } else {
                return false;
            }
        } finally {
            lock.unlock();
        }
    }

    private void checkComparator() {
        String comparatorSign = comparatorHolder.get();
        if (comparatorSign != null) {
            String[] vals = comparatorSign.split(":");
            String className = vals[0];
            if (!comparator.getClass().getName().equals(className)) {
                loadComparator();
            }
        }
    }

    public RFuture<Boolean> addAsync(final V value) {
        final RPromise<Boolean> promise = new RedissonPromise<Boolean>();
        commandExecutor.getConnectionManager().getExecutor().execute(new Runnable() {
            public void run() {
                try {
                    boolean res = add(value);
                    promise.trySuccess(res);
                } catch (Exception e) {
                    promise.tryFailure(e);
                }
            }
        });
        return promise;
    }

    @Override
    public RFuture<Boolean> removeAsync(final Object value) {
        final RPromise<Boolean> promise = new RedissonPromise<Boolean>();
        commandExecutor.getConnectionManager().getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                try {
                    boolean result = remove(value);
                    promise.trySuccess(result);
                } catch (Exception e) {
                    promise.tryFailure(e);
                }
            }
        });

        return promise;
    }

    @Override
    public boolean remove(Object value) {
        lock.lock();

        try {
            checkComparator();
            
            BinarySearchResult<V> res = binarySearch((V) value, codec);
            if (res.getIndex() < 0) {
                return false;
            }

            list.remove((int) res.getIndex());
            return true;
        } finally {
            lock.unlock();
        }
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        for (Object object : c) {
            if (!contains(object)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean addAll(Collection<? extends V> c) {
        boolean changed = false;
        for (V v : c) {
            if (add(v)) {
                changed = true;
            }
        }
        return changed;
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        boolean changed = false;
        for (Iterator<?> iterator = iterator(); iterator.hasNext();) {
            Object object = (Object) iterator.next();
            if (!c.contains(object)) {
                iterator.remove();
                changed = true;
            }
        }
        return changed;
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        boolean changed = false;
        for (Object obj : c) {
            if (remove(obj)) {
                changed = true;
            }
        }
        return changed;
    }

    @Override
    public void clear() {
        delete();
    }

    @Override
    public Comparator<? super V> comparator() {
        return comparator;
    }

    @Override
    public SortedSet<V> subSet(V fromElement, V toElement) {
        throw new UnsupportedOperationException();
//        return new RedissonSubSortedSet<V>(this, connectionManager, fromElement, toElement);
    }

    @Override
    public SortedSet<V> headSet(V toElement) {
        return subSet(null, toElement);
    }

    @Override
    public SortedSet<V> tailSet(V fromElement) {
        return subSet(fromElement, null);
    }

    @Override
    public V first() {
        V res = list.getValue(0);
        if (res == null) {
            throw new NoSuchElementException();
        }
        return res;
    }

    @Override
    public V last() {
        V res = list.getValue(-1);
        if (res == null) {
            throw new NoSuchElementException();
        }
        return res;
    }

    private String getComparatorKeyName() {
        return "redisson_sortedset_comparator:{" + getRawName() + "}";
    }

    private String getComparatorInstanceKeyName() {
        return "redisson_sortedset_comparator_instance:{" + getRawName() + "}";
    }

    @Override
    public boolean trySetComparator(Comparator<? super V> comparator) {
        String className = comparator.getClass().getName();
        final String comparatorSign = className + ":" + calcClassSign(className);
        Boolean res = commandExecutor.get(commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                "if redis.call('llen', KEYS[1]) == 0 then "
                + "redis.call('set', KEYS[2], ARGV[1]); "
                + "return 1; "
                + "else "
                + "return 0; "
                + "end",
                Arrays.<Object>asList(getRawName(), getComparatorKeyName()), comparatorSign));
        if (res) {
            this.comparator = comparator;
            if(comparator instanceof Serializable){
                comparatorInstance.set(comparator);
            }
        }
        return res;
    }

    @Override
    public Iterator<V> distributedIterator(final int count) {
        String iteratorName = "__redisson_sorted_set_cursor_{" + getRawName() + "}";
        return distributedIterator(iteratorName, count);
    }

    @Override
    public Iterator<V> distributedIterator(final String iteratorName, final int count) {
        return new RedissonBaseIterator<V>() {

            @Override
            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
                return distributedScanIterator(iteratorName, count);
            }

            @Override
            protected void remove(Object value) {
                RedissonSortedSet.this.remove((V) value);
            }
        };
    }

    private ScanResult<Object> distributedScanIterator(String iteratorName, int count) {
        return get(distributedScanIteratorAsync(iteratorName, count));
    }

    private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iteratorName, int count) {
        return commandExecutor.evalWriteAsync(getRawName(), codec, EVAL_LIST_SCAN,
                "local start_index = redis.call('get', KEYS[2]); "
                + "if start_index ~= false then "
                    + "start_index = tonumber(start_index); "
                + "else "
                    + "start_index = 0;"
                + "end;"
                + "if start_index == -1 then "
                    + "return {0, {}}; "
                + "end;"
                + "local end_index = start_index + ARGV[1];"
                + "local result; "
                + "result = redis.call('lrange', KEYS[1], start_index, end_index - 1); "
                + "if end_index > redis.call('llen', KEYS[1]) then "
                    + "end_index = -1;"
                + "end; "
                + "redis.call('setex', KEYS[2], 3600, end_index);"
                + "return {end_index, result};",
                Arrays.<Object>asList(getRawName(), iteratorName), count);
    }

    // TODO optimize: get three values each time instead of single
    public BinarySearchResult<V> binarySearch(V value, Codec codec) {
        int size = list.size();
        int upperIndex = size - 1;
        int lowerIndex = 0;
        while (lowerIndex <= upperIndex) {
            int index = lowerIndex + (upperIndex - lowerIndex) / 2;

            V res = list.getValue(index);
            if (res == null) {
                return new BinarySearchResult<V>();
            }
            int cmp = comparator.compare(value, res);

            if (cmp == 0) {
                BinarySearchResult<V> indexRes = new BinarySearchResult<V>();
                indexRes.setIndex(index);
                return indexRes;
            } else if (cmp < 0) {
                upperIndex = index - 1;
            } else {
                lowerIndex = index + 1;
            }
        }

        BinarySearchResult<V> indexRes = new BinarySearchResult<V>();
        indexRes.setIndex(-(lowerIndex + 1));
        return indexRes;
    }

    @SuppressWarnings("AvoidInlineConditionals")
    public String toString() {
        Iterator<V> it = iterator();
        if (! it.hasNext())
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            V e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4146
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
出现这个日志的时候会造成一部分key找不到指定的node
通过加日志调试怀疑是这个位置的问题

之后我修改源码使用HashSet替换BitSet后就正常了
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Correct me if I am wrong, currently, we have to make 3 calls to redis if I want to apply 3 rate limit to a call before allowing it. Is there any way we can reduce the number of calls by making a batch call?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi Team,
We are getting below error while using elasticache redis cluster. While update or save values we are getting this error everytime.
It is not the case of failover. All nodes are active and i can see slot 7188 is also available.
Redisson version - 3.7.5
org.redisson.client.RedisNodeNotFoundException: Node: NodeSource [slot=7188, addr=//1.1.1.7:8992, redisClient=null, redirect=MOVED, entry=null] hasn't been discovered yet
at org.redisson.connection.MasterSlaveConnectionManager.connectionWriteOp(MasterSlaveConnectionManager.java:550)
at org.redisson.command.CommandAsyncService.getConnection(CommandAsyncService.java:644)
at org.redisson.command.CommandAsyncService.async(CommandAsyncService.java:499)
at org.redisson.command.CommandAsyncService$8.run(CommandAsyncService.java:588)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:670)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:745)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:473)
at java.lang.Thread.run(Thread.java:748)
CLUSTER NODES
2faa414bf9c563ea5db3c4cecb3c470a5695c437 1.1.1.2:8992@1122 myself,slave f8c6bdc58a17c2aa196d88dcba6ea31297bcb88c 0 1645461237000 12 connected
811513819033d8128e29967fe865e40999c71275 1.1.1.3:8992@1122 slave 9e50425e4db917c8c09f201dfd708b955f9793ba 0 1645461238000 4 connected
4b54e8949673ff50f416ba99c90edee59ab174c9 1.1.1.4:8992@1122 slave 616ccd8f07fc64e275e2f8d730ae2c395d53be69 0 1645461237000 3 connected
616ccd8f07fc64e275e2f8d730ae2c395d53be69 1.1.1.5:8992@1122 master - 0 1645461239704 3 connected 8192-10142 12873-16383
9e50425e4db917c8c09f201dfd708b955f9793ba 1.1.1.6:8992@1122 master - 0 1645461238700 4 connected 3768-6498 10143-12872
f8c6bdc58a17c2aa196d88dcba6ea31297bcb88c 1.1.1.7:8992@1122 master - 0 1645461238000 12 connected 0-3767 6499-8191
Could you please help to look into the issue on priority.
Thanks,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4151
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4152
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[]
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hello, I started getting weird exception after sentinel cluster failover. Application restart does not help. Looks like sentinel cluster might be at a faulty state, but there's no signs of it.
Redisson version: 3.16.7
Caused by: j.lang.IllegalStateException: Only 2 of 1 slaves were synced
	at org.redisson.RedissonBaseLock.lambda$evalWriteAsync$0(RedissonBaseLock.java:235)
	at o.r.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
	at i.n.u.c.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at i.n.u.c.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at i.n.u.c.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at i.n.u.c.DefaultPromise.setValue0(DefaultPromise.java:616)
	at i.n.u.c.DefaultPromise.setSuccess0(DefaultPromise.java:605)
	at i.n.u.c.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at o.r.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
	at o.r.c.CommandBatchService.lambda$executeAsync$7(CommandBatchService.java:331)
	at o.r.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
	at i.n.u.c.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at i.n.u.c.DefaultPromise.notifyListeners0(DefaultPromise.java:571)
	at i.n.u.c.DefaultPromise.notifyListenersNow(DefaultPromise.java:550)
	at i.n.u.c.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at i.n.u.c.DefaultPromise.setValue0(DefaultPromise.java:616)
	at i.n.u.c.DefaultPromise.setSuccess0(DefaultPromise.java:605)
	at i.n.u.c.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at o.r.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)
	at o.r.c.RedisCommonBatchExecutor.handleResult(RedisCommonBatchExecutor.java:164)
	at o.r.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:465)
	at o.r.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:173)
	at o.r.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187)
	at i.n.u.c.DefaultPromise.notifyListener0(DefaultPromise.java:578)
	at i.n.u.c.DefaultPromise.notifyListenersNow(DefaultPromise.java:552)
	at i.n.u.c.DefaultPromise.notifyListeners(DefaultPromise.java:491)
	at i.n.u.c.DefaultPromise.setValue0(DefaultPromise.java:616)
	at i.n.u.c.DefaultPromise.setSuccess0(DefaultPromise.java:605)
	at i.n.u.c.DefaultPromise.trySuccess(DefaultPromise.java:104)
	at o.r.misc.RedissonPromise.trySuccess(RedissonPromise.java:82)

Steps to reproduce or test case
Still figuring it out. We were experimenting on sentinel cluster with 3 nodes, killing master for test purposes.
Redis info
Server
redis_version:6.2.6
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:117005704b7d572d
redis_mode:standalone
os:Linux 5.4.156-83.273.amzn2.x86_64 x86_64
arch_bits:64
multiplexing_api:epoll
atomicvar_api:c11-builtin
gcc_version:8.3.0
process_id:1
process_supervised:no
run_id:8d5d7867c0685a1a162696c505793e870f44ef25
tcp_port:6379
server_time_usec:1645556982046578
uptime_in_seconds:6823
uptime_in_days:0
hz:10
configured_hz:10
lru_clock:1389813
executable:/redis-server
config_file:
io_threads_active:0

# Clients
connected_clients:221
cluster_connections:0
maxclients:10000
client_recent_max_input_buffer:40
client_recent_max_output_buffer:0
blocked_clients:0
tracking_clients:0
clients_in_timeout_table:0

# Memory
used_memory:12026224
used_memory_human:11.47M
used_memory_rss:23326720
used_memory_rss_human:22.25M
used_memory_peak:27203384
used_memory_peak_human:25.94M
used_memory_peak_perc:44.21%
used_memory_overhead:7255192
used_memory_startup:810480
used_memory_dataset:4771032
used_memory_dataset_perc:42.54%
allocator_allocated:12542192
allocator_active:14557184
allocator_resident:21155840
total_system_memory:16593977344
total_system_memory_human:15.45G
used_memory_lua:39936
used_memory_lua_human:39.00K
used_memory_scripts:880
used_memory_scripts_human:880B
number_of_cached_scripts:2
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
allocator_frag_ratio:1.16
allocator_frag_bytes:2014992
allocator_rss_ratio:1.45
allocator_rss_bytes:6598656
rss_overhead_ratio:1.10
rss_overhead_bytes:2170880
mem_fragmentation_ratio:1.91
mem_fragmentation_bytes:11118000
mem_not_counted_for_evict:2554
mem_replication_backlog:1048576
mem_clients_slaves:41024
mem_clients_normal:4532984
mem_aof_buffer:2560
mem_allocator:jemalloc-5.1.0
active_defrag_running:0
lazyfree_pending_objects:0
lazyfreed_objects:0

# Persistence
loading:0
current_cow_size:0
current_cow_size_age:0
current_fork_perc:0.00
current_save_keys_processed:0
current_save_keys_total:0
rdb_changes_since_last_save:3481418
rdb_bgsave_in_progress:0
rdb_last_save_time:1645550247
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
rdb_last_cow_size:741376
aof_enabled:1
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok
aof_last_cow_size:5128192
module_fork_in_progress:0
module_fork_last_cow_size:0
aof_current_size:65106117
aof_base_size:931967
aof_pending_rewrite:0
aof_buffer_length:0
aof_rewrite_buffer_length:0
aof_pending_bio_fsync:0
aof_delayed_fsync:0

# Stats
total_connections_received:700643
total_commands_processed:11386723
instantaneous_ops_per_sec:1422
total_net_input_bytes:1028876426
total_net_output_bytes:46767630387
instantaneous_input_kbps:119.32
instantaneous_output_kbps:6807.82
rejected_connections:0
sync_full:3
sync_partial_ok:0
sync_partial_err:2
expired_keys:67829
expired_stale_perc:1.05
expired_time_cap_reached_count:0
expire_cycle_cpu_milliseconds:337
evicted_keys:0
keyspace_hits:2623786
keyspace_misses:324519
pubsub_channels:3
pubsub_patterns:0
latest_fork_usec:680
total_forks:10
migrate_cached_sockets:0
slave_expires_tracked_keys:0
active_defrag_hits:0
active_defrag_misses:0
active_defrag_key_hits:0
active_defrag_key_misses:0
tracking_total_keys:0
tracking_total_items:0
tracking_total_prefixes:0
unexpected_error_replies:0
total_error_replies:7
dump_payload_sanitizations:0
total_reads_processed:7655271
total_writes_processed:10129346
io_threaded_reads_processed:0
io_threaded_writes_processed:0

# Replication
role:master
connected_slaves:2
slave0:ip=redis-sentinel-node-1.redis-sentinel-headless.default.svc.cluster.local,port=6379,state=online,offset=28711301244,lag=1
slave1:ip=redis-sentinel-node-0.redis-sentinel-headless.default.svc.cluster.local,port=6379,state=online,offset=28711301244,lag=1
master_failover_state:no-failover
master_replid:ab572f8c1c8a733396709bade2a5bc700701ec86
master_replid2:01e55261afc7c5505d7da94699e5a403d2eef737
master_repl_offset:28711301281
second_repl_offset:28196501650
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:28710252706
repl_backlog_histlen:1048576

# CPU
used_cpu_sys:206.684823
used_cpu_user:174.922001
used_cpu_sys_children:0.035053
used_cpu_user_children:0.152909
used_cpu_sys_main_thread:205.938414
used_cpu_user_main_thread:174.665218

# Modules

# Errorstats
errorstat_ERR:count=4
errorstat_NOAUTH:count=3

# Cluster
cluster_enabled:0

# Keyspace
db0:keys=8696,expires=8696,avg_ttl=106041980

Sentinel config:
dir "/tmp"
port 26379
sentinel monitor mymaster redis-sentinel-node-2.redis-sentinel-headless.default.svc.cluster.local 6379 2
sentinel down-after-milliseconds mymaster 2000
sentinel failover-timeout mymaster 5000
# User-supplied sentinel configuration:
# End of sentinel configuration
sentinel auth-pass mymaster ***
requirepass "***"
sentinel myid 6b28db582bd8af66c1e0ddbcc9afcce2daba4354
sentinel known-replica mymaster redis-sentinel-node-1.redis-sentinel-headless.default.svc.cluster.local 6379
sentinel known-sentinel mymaster redis-sentinel-node-1.redis-sentinel-headless.default.svc.cluster.local 26379 5add24b6f14969527b26e2b3d62ebfa73e2de554
sentinel known-replica mymaster redis-sentinel-node-0.redis-sentinel-headless.default.svc.cluster.local 6379
sentinel known-sentinel mymaster redis-sentinel-node-2.redis-sentinel-headless.default.svc.cluster.local 26379 5f4ff5b1f3024ce375ab027ac24adb717305f02c
sentinel announce-hostnames yes
sentinel resolve-hostnames yes
sentinel announce-port 26379
sentinel announce-ip "redis-sentinel-node-0.redis-sentinel-headless.default.svc.cluster.local"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the execute method does not compare the parameter length and parameter type. When a method is overloaded,such as the ttl method, it may cause java.lang.IllegalArgumentException exceptions.
@OverRide
public Object execute(String command, byte[]... args) {
for (Method method : this.getClass().getDeclaredMethods()) {
if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
try {
Object t = execute(method, args);
if (t instanceof String) {
return ((String) t).getBytes();
}
return t;
} catch (IllegalArgumentException e) {
if (isPipelined()) {
throw new RedisPipelineException(e);
}
                throw new InvalidDataAccessApiUsageException(e.getMessage(), e);
            }
        }
    }
    throw new UnsupportedOperationException();
}

private Object execute(Method method, byte[]... args) {
    if (method.getParameterTypes().length > 0 && method.getParameterTypes()[0] == byte[][].class) {
        return ReflectionUtils.invokeMethod(method, this, args);
    }
    if (args == null) {
        return ReflectionUtils.invokeMethod(method, this);
    }
    return ReflectionUtils.invokeMethod(method, this, Arrays.asList(args).toArray());
}
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4156
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
All keys matching pattern are deleted
Actual behavior
Keys are not deleted
Steps to reproduce or test case
internal fun purge() {
        client.keys.deleteByPattern("$metadataNamespace*")
        client.keys.deleteByPattern("$valueNamespace*")
    }

The above code works correctly on 3.16.7 to delete all keys matching 2 patterns we pass in.  On 3.16.8 the keys are not deleted.
Redis version
6.2.6
Redisson version
3.16.8
Redisson configuration
RedisDataShelf.Builder(
        "test",
        defaultTtl,
        client,
        NullCryptApi(),
        TemporaryFileStore(Files.createTempDirectory("RedisDataShelfTest"))
    )
    ```
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Hi,
I have 2 module A and B, using same Redisson 3.16.1. The modules are using a RLocalCachedMap. I want to change Redisson version of B server to 3.16.8. And I'm facing with exception.
java.lang.IndexOutOfBoundsException: readerIndex(21) + length(1668246830) exceeds writerIndex(264): UnpooledSlicedByteBuf(ridx: 21, widx: 264, cap: 264/264, unwrapped: PooledUnsafeDirectByteBuf(ridx: 672, widx: 896, cap: 1024))
	at io.netty.buffer.AbstractByteBuf.checkReadableBytes0(AbstractByteBuf.java:1442)
	at io.netty.buffer.AbstractByteBuf.checkReadableBytes(AbstractByteBuf.java:1428)
	at io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:895)
	at io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:903)
	at org.redisson.cache.LocalCachedMessageCodec.lambda$new$0(LocalCachedMessageCodec.java:68)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383)
	at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427)
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392)

I know that LocalCachedMessageCodec encode and decode methods were changed for a reason. And this exception is thrown when LocalCachedMap updated.
I wonder that does it have any way to run server A and B with different Redisson version?
P/s: That is my example. Now I have more than 10 modules are using Redisson and I just want to update some of them
Thanks
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I'd like to add a Distributed data structure named RedissonMapMultimap (It'll be similar to RedissonListMultimap).
For The following Map:
Map("id1" to Map("innerId1" : "value1", "innerId2": "value2")) 
the user could use the RedissonMapMultimap to get value1 without making 2 network calls / writing the logic themselves.
The interface will have functions like RedissonMapMultimap.get(key: Key, innerKey: Key).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have keys in array of ByteArray (ByteArray for each key) and I am wondering if redisson enable returning value/timeout/null(miss) for different key with batch execute. Would batch support this? Or batch.execute() is just an atomic operation and will fail for all batch once a key is missed?
eg:
val batch = redissonClient.createBatch();
keys.foreach(key -> batch.getBucket(key).async.get();
val vals = batch.excute().getResponse()
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4161
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is your feature request related to a problem? Please describe.
My application uses TOML for its configurations and it would be nice if the Redisson configs were TOML too. TOML is an INI-like human-readable config language that's increasing in popularity.
Here's some references on TOML:

https://toml.io/
https://github.com/toml-lang/toml
https://en.wikipedia.org/wiki/TOML

Describe the solution you'd like
TOML support should be added to Redisson Config using Jackson.
Redisson Config seems to use Jackson to handle JSON and YAML. As of Jackson 2.13, jackson-dataformats-text supports TOML in addition to YAML. It seems that Redisson upgraded to Jackson 2.13 with commit 3f457c9 on Dec 21, 2021.
By adding the TOML backend, jackson-dataformats-toml, the TomlFactory type can be used similar to how the YAMLFactory type is used in org.redisson.config.ConfigSupport.
Describe alternatives you've considered
Current workaround is to not use TOML and have Redisson's configs stored in YAML. Resulting in my application requiring multiple config formats.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Currently I don't plan to remove JSON support in 3.x version. Can you suggest changes without removing JSON?

Maybe I forgot to add it back somewhere, but as far as I can tell my changes leave the existing JSON code in tact. Several of the diffs may seem like the code is being removed, but I'm just moving it so the code attempts to parse as TOML before trying JSON.
There were a few instances I found where the code only handled YAML so I only updated with TOML support.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Simplest service interface:
public interface IService {
  void ping();
}

Service Implementation:
public class MyService implements IService {
  public MyService() {
    RedissonClient client = Redisson.create();

    // register myself as a remote service
    client.getRemoteService(JsonJacksonCodec.INSTANCE).register(IService.class, this);
  }

  public void ping() {
    Logger.getGlobal().info("I was pinged");
  }
}

Client:
public class Client {
  public Client() {
    RedissonClient client = Redisson.create();

    IService service = client.getRemoteService(JsonJacksonCodec.INSTANCE).get(IService.class);

    // test communication with "ping"
    service.ping();
    Logger.getGlobal().info("pinged");
  }
}

Service is instantiated locally and then the client (both on same JVM, Redis server is running locally with default Ubuntu 20 configuration)
Expected behavior

Log to have the line "I was pinged"
Log to have the line "pinged"
No timeout or exceptions

Actual behavior

Log has "I was pinged"
Exception:


org.redisson.remote.RemoteServiceTimeoutException: No response after 30000ms for request: RemoteServiceRequest [requestId=46edfd042fba0b14bf6469bb490c0d42, methodName=ping, signature=[-5212114190830492821, -5560568237385073498], args=null, options=RemoteInvocationOptions[ackTimeoutInMillis=1000, executionTimeoutInMillis=30000], date=1645976606667]
at org.redisson.remote.SyncRemoteProxy$1.invoke(SyncRemoteProxy.java:133)
at jdk.proxy4/jdk.proxy4.$Proxy47.ping(Unknown Source)

Steps to reproduce or test case
Use code above
Redis version
$ redis-server --version
Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=636cde3b5c7a3923

Redisson version
<!-- Redis client: Redisson -->
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
			<version>3.16.4</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.0</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.13.0</version>
		</dependency>

Redisson configuration
As seen in the code, bare minimal
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Used classes:
public class Value<T> {
  public T value;
}

public class IntegerValue<Integer> implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

  public IntegerValue(int value) {
    this.value = value;
  }
}

public class DoubleValue<Double> implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

  public DoubleValue(double value) {
    this.value = value;
  }
}

public class StringValue<String> implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

  public StringValue(String value) {
    this.value = value;
  }
}


Service interface:
public interface IService {
  void set(Map<String, Value<?>> values);
  Map<String, Value<?>> get();
}

Service Implementation:
public class MyService implements IService {
  private Map<String, Value<?>> values = Collections.synchronizedMap(new HashMap<>());
  public MyService() {
    RedissonClient client = Redisson.create();

    // register myself as a remote service
    client.getRemoteService().register(IService.class, this);

    // Set some initial value
    values.put("initial", new IntegerValue(17));
  }

  public void set(Map<String, Value<?>> values) {
    Logger.getGlobal().info("Set values");
    this.values = Collections.synchronizedMap(values);

    for (Map.Entry<String, Value<?>> entry: values.entrySet())
      Logger.getGlobal().info("S: key = "+entry.getKey()+", value = "+entry.getValue());
  }

  public Map<String, Value<?>> get() {
    return values;
  }
}

Client:
public class Client {
  public Client() {
    RedissonClient client = Redisson.create();

    IService service = client.getRemoteService().get(IService.class);

    // get initial value
    Map<String, Value<?>> values = service.get();

    // check what we've got
    for (Map.Entry<String, Value<?>> entry: values.entrySet())
      Logger.getGlobal().info("C: key = "+entry.getKey()+", value = "+entry.getValue());

    // change something
    values.put("another", new StringValue("value"));

    // send to the service
    service.set(values);
  }
}

Service is instantiated locally and then the client (both on same JVM, Redis server is running locally with default Ubuntu 20 configuration)
Expected behavior
Expected log output:
C: key = initial, value = [class of IntegerValue & address]
S: key = initial, value = [class of IntegerValue & address]
S: key = another, value = [class of StringValue & address]
Actual behavior
Actual log output:
C: key = initial, value = null
S: key = initial, value = null
S: key = another, value = null
Steps to reproduce or test case
Code as above
Redis version
$ redis-server --version
Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=636cde3b5c7a3923

Redisson version
<!-- Redis client: Redisson -->
		<dependency>
			<groupId>org.redisson</groupId>
			<artifactId>redisson</artifactId>
			<version>3.16.4</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.0</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.13.0</version>
		</dependency>

Redisson configuration
As seen in the code, bare minimal
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4165
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
Error not occurring.
Actual behavior
Error occurring.
Steps to reproduce or test case
Create a topic and send objects through the topic every second. After a few minutes or so this error occurs repeatedly randomly.
[19:25:12 ERROR] [org.redisson.client.handler.PingConnectionHandler]: Unable to send PING command over channel: [id: 0x1b4d363c, L:/<IP Redacted> - R:<IP Redacted>]
org.redisson.client.RedisTimeoutException: Command execution timeout for command: (PING), params: [], Redis client: [addr=<IP Redacted>]
        at org.redisson.client.RedisConnection.lambda$async$0(RedisConnection.java:245) ~[?:?]
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.run(HashedWheelTimer.java:715) ~[velocity.jar:3.1.1]
        at io.netty.util.concurrent.ImmediateExecutor.execute(ImmediateExecutor.java:34) ~[velocity.jar:3.1.1]
        at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:703) ~[velocity.jar:3.1.1]
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:790) ~[velocity.jar:3.1.1]
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:503) ~[velocity.jar:3.1.1]
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[velocity.jar:3.1.1]
        at java.lang.Thread.run(Thread.java:831) [?:?]
Redis version
6.2.3
Redisson version
3.16.8
Redisson configuration
 Config config = new Config();
        config.setCodec(new JsonJacksonCodec());
        config.setKeepPubSubOrder(true);
        config.setThreads(4);
        config.setNettyThreads(8);
        var msc = config.useSingleServer();
        msc.setAddress("redis://" + url + ":" + port);
        msc.setUsername(user);
        msc.setPassword(pass);
        msc.setTcpNoDelay(true);
        msc.setConnectionMinimumIdleSize(2);
        msc.setConnectionPoolSize(32);
        msc.setSubscriptionConnectionMinimumIdleSize(1);
        msc.setSubscriptionConnectionPoolSize(32);
        msc.setSubscriptionsPerConnection(5);
        msc.setTimeout(3000);
        msc.setConnectTimeout(10000);
        msc.setRetryAttempts(3);
        msc.setRetryInterval(1500);
        msc.setPingConnectionInterval(10000);
Question
Is there maven dependencies for snapshot versions such as 3.16.9? If not, can they be added?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I am saving and later retrieving a serialized object using an RBucket. When doing so, the serialVersionUID has no effect - redisson tries to retrieve and de-serialized the object and throws an exception it this fails. Is this done this way deliberately? Is there a way to make redisson respect the serialVersionUID, or do I need to serialize and de-serialize  the object myself?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4168
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Please add a below settings description in cluster settings wiki
failedSlaveReconnectionInterval
Default value: 3000
Interval of Redis Slave reconnection attempt when it was excluded from internal list of available servers. On each timeout event Redisson tries to connect to disconnected Redis server. Value in milliseconds.
failedSlaveCheckInterval
Default value: 60000
Redis Slave node failing to execute commands is excluded from the internal list of available nodes when the time interval from the moment of first Redis command execution failure on this server reaches defined value. Value in milliseconds.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
No description provided.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
redisson/redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
    
    
         Line 483
      in
      e0d9c18
    
  
  
    

        
          
           if (readMode == ReadMode.MEMORY) { 
        
    
  


Is this condition here restricting REDIS read mode from syncing attributes between tomcats utilizing same JSESSIONID for the same user?

Have two tomcats running same application. Sticky session disabled.
Redission tomcat session manager configured (version 3.16.4)
Scenario:
Tomcat1 --> updates a attribute in Session.
After 1 second, Tomcat2 --> reads the same attribute in session but do not have updated value but instead it reads the old value.

@mrniko could you please help?
Please help on fixing this scenario.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
There's an existing closed bug #1548 that seems to be manifesting in my installation.  I'm using AWS Managed Redis CLUSTER with Hibernate.

ERROR [mylj,6221345d0f4ad9a5bd79127fd4f5f470,ef81dea77c5f0729] 1 --- [nio-8080-exec-2] org.redisson.hibernate.RedissonStorage : MOVED redirection loop detected. Node redis://10.95.240.133:6379 has further redirect to redis://10.95.240.133:6379
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4173
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I have a LockFactory class which provides the default and multilock. The following code results in a bad request with no logs at all:
public Uni<Void> test() {
        Lock lock = lockFactory.getLock("test Lock");
        return lock.acquire()
                .invoke(() -> Log.debug("\n\n\nLockAcquired : " + lock + "\n\n\n"))
                .eventually(lock::release);
    }

application.json
quarkus:
  redisson:
    cluster-servers-config:
      nodeAddresses: ${REDIS_HOSTS}

In normal mode and in native mode locally, I see redisson logs. However, when I deploy the native build, I don't see a single redisson log. Any ideas what might be happening here?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
org.redisson.connection.SentinelConnectionManager
row  175   break;  is bug
it let this code always error.
throw new RedisConnectionException("SENTINEL SENTINELS command returns less than 2 nodes! At least two sentinels should be defined in Redis configuration. Set checkSentinelsList = false to avoid this check.", lastException);
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Is there a way to retrieve the value of all the keys matching the given pattern?
Also, can it be generalised to any key type? I'm able to get keys matching the pattern but how can we get all the values at once too?
Below is code snippet, however here I'm calling get for each key:
public void getRateLimiterKeyValues() {
        String pattern = API_RATE_LIMITER_KEY.concat("*");
        Iterable<String> keys = redisson.getKeys().getKeysByPattern(pattern);
        String[] cache = StreamSupport.stream(keys.spliterator(), false).toArray(String[]::new);

        for (String key : cache) {
            log.info("Key: {} value: {}", key, redisson.getRateLimiter(key).getConfig().toString());
        }
    }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4177
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
about issue#4033,I don't need to wait,so i set waittime=0,but the result is failure,why Rlock set waittime=0 result is successful?i need get the lock fail,end business at once.
see source code,when waitime=0,leaseTime assignment zero.

Expected behavior
Actual behavior
Steps to reproduce or test case
Redis version
6.2.6
Redisson version
3.16.8
Redisson configuration
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Elastic-cache recently released a data-tiering which lets offload LRU keys to disk.
In an attempt to onboard to the feature, we ran some tests where we would fill up our memory till 100% and observe keys being offloaded to disk. We repeated the test using both redis-benchmark tool & Redisson ( Client we use for production).
With redisson as soon as MemoryUtilisation reached 100% we observed a sudden spike in CPU , accompanied with WriteRedisConnectionException . This CPU spike lead to node failures again and again. We didnt observe the same behaviour with redis-benchmark tool.
My question is : Why would there be a spike in CPU with Redisson ? How can we avoid this & is there an ability to perform exponential backoff timeout in redisson?
Redisson Error Message when memory reaches 100%  : Error message: org.redisson.client.WriteRedisConnectionException: Unable to write command into connection! Increase connection pool size).
** Setup for Replicating behaviour **
Redis Cluster : 1 shard with 1 replica of node type r6gd.2xlarge.
Redisson Config :
REDIS_SCAN_INTERVAL_MS = (int) Duration.ofMinutes(1).toMillis();
REDIS_PING_CONNECTION_INTERVAL_MS = 5000;
RETRY_INTERVAL = 50;
RETRY_ATTEMPTS = 3;
TIMEOUT = 30000;
CONNECTION_TIMEOUT = 60000 * 5;
NETTY_THREADS = 128;

redissonConfig
        .useClusterServers()
        .addNodeAddress(redisAddress)
        .setScanInterval(REDIS_SCAN_INTERVAL_MS)
        .setRetryInterval(RETRY_INTERVAL)
        .setRetryAttempts(RETRY_ATTEMPTS)
        .setPingConnectionInterval(REDIS_PING_CONNECTION_INTERVAL_MS)
        .setKeepAlive(true)
        .setConnectTimeout(CONNECTION_TIMEOUT)
        .setTimeout(TIMEOUT);

IMO, the timeouts are already quite high. I dont see new connections being formed as well.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Redisson version :

To create Redisson Client :
    // 1. Create config object
    Config config = new Config();
    config.setNettyThreads(64);
    config.useSingleServer().setAddress("redis://"+redisAddress+":"+redisPort).setPassword(redisPassword);
    return Redisson.create(config);

We have the following RMapCache beans that will basically create the RMapCache for us :
@configuration
public class RedisConfig {
private final RedissonClient redissonClient;

public RedisConfig(RedissonClient redissonClient) {
    this.redissonClient = redissonClient;
}

@Bean
RMapCache<String, List<LocalizedData>> localizedDataCache (){return redissonClient.getMapCache(Constants.LOCALIZED_DATA_REDIS_HASH);}

//MarketHierarchyRedisHash is the mapCache name
@Bean
RMapCache<String, MarketHierarchy> marketHierarchyCache (){return redissonClient.getMapCache(Constants.MARKET_HIERARCHY_REDIS_HASH);}

@Bean
RMapCache<String, MarketHierarchy> marketHierarchyCacheOld (){return redissonClient.getMapCache(Constants.MARKET_HIERARCHY_REDIS_HASH_OLD);}

}
Stacktrace :

Expected :
For our spring application to start without any issues.  The application fails to start because the redisson client cannot be initialized. This error is intermittent and difficult to reproduce all the time
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Expected behavior
When I remove values, using RedissonLocalCachedMap#removeAsync method, expectation is that values are removed i.e. no longer retrievable from cache.
Actual behavior
Does not seem to be the case. "Removed" values are retrievable via "getAsync" operation
Steps to reproduce or test case
Here's the reproducible test project: https://github.com/62mkv/redisson-remove-repro/blob/master/src/test/java/com/example/redissonremoverepro/RedissonRemoveReproApplicationTests.java
Steps to reproduce:

clone the project
./gradlew check (test fails)
go to build/test-results/test, file is TEST-com.example.redissonremoverepro.RedissonRemoveReproApplicationTests.xml
in the system-out element body, we observe the following:

Testing value:bba34688-fdd7-4756-8508-50ff169ff365=Value{uuid=bba34688-fdd7-4756-8508-50ff169ff365, name='value2', attribute=2}
Removing value:bba34688-fdd7-4756-8508-50ff169ff365=Value{uuid=bba34688-fdd7-4756-8508-50ff169ff365, name='value2', attribute=2}
Testing value:96a878ab-bc2e-41cc-9fc4-e41ecffb8a68=Value{uuid=96a878ab-bc2e-41cc-9fc4-e41ecffb8a68, name='value4', attribute=4}
Removing value:96a878ab-bc2e-41cc-9fc4-e41ecffb8a68=Value{uuid=96a878ab-bc2e-41cc-9fc4-e41ecffb8a68, name='value4', attribute=4}
Testing value:8fbb1b7d-6292-4d32-8ebd-63295bee3250=Value{uuid=8fbb1b7d-6292-4d32-8ebd-63295bee3250, name='value1', attribute=1}
Testing value:d588bf37-005e-414b-a17d-a45ac72f78bd=Value{uuid=d588bf37-005e-414b-a17d-a45ac72f78bd, name='value3', attribute=3}

i.e. all values with even "attribute" are removed from the cache.
However, the test fails with:
expectation "expectComplete" failed (expected: onComplete(); actual: onNext(Value{uuid=69d54141-3cfb-4a84-81ae-7812b7fb6ce4, name='value4', attribute=4}))

Redis version
5.0.3
Redisson version
3.16.8
Redisson configuration
            Config config = new Config();
            config.useSingleServer().setAddress("redis://" + address + ":" + port);
            RedissonClient client = Redisson.create(config);

            cache = client.getLocalCachedMap("test-cache", LocalCachedMapOptions.<String, Value>defaults()
                    .storeMode(LocalCachedMapOptions.StoreMode.LOCALCACHE_REDIS)
                    .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.LOAD)
                    .syncStrategy(LocalCachedMapOptions.SyncStrategy.UPDATE));
            cache.preloadCache();
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Reisson version： 3.16.5
Redis: single sence
在使用redisson 过程中，正常使用redisson delay queue 时，会在运行过程中抛出

我确认redis 服务是正常的，因为另外一个redisson 延时队列并没有问题。服务重启后正常
导致这种问题的原因可能是什么？ 是因为连接突然不可用导致的吗？
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
I use redisson to subscribe message in my project, I found the pubsub connection will lost and message will be not received any more. No any exceptions can be found in log, so I tured log level to DEBUG on org.redisson. Then I found following logs, and I not sure is it normal or not:
on project start
2022/03/15 15:37:07.368 [ty-2-14] DEBUG ClientConnectionsEntry [-|-|-] - new pubsub connection created: RedisPubSubConnection@1163063656 [redisClient=[addr=redis://myredis-servrer:6379], channel=
[id: 0xdbb90202, L:/10.118.1.218:47226 - R:myredis-servrer/10.118.2.6:6379], currentCommand=null]
2022/03/15 15:37:07.373 [ty-2-10] INFO  MasterConnectionPool [-|-|-] - 5 connections initialized for myredis-servrer/10.118.2.6:6379
2022/03/15 15:37:07.376 [ty-2-14] INFO  MasterPubSubConnectionPool [-|-|-] - 1 connections initialized for myredis-servrer/10.118.2.6:6379
almost 4 hours later
2022/03/15 19:36:55.840 [ty-2-32] DEBUG ClientConnectionsEntry [-|-|-] - new pubsub connection created: RedisPubSubConnection@1656211046 [redisClient=[addr=redis://myredis-servrer:6379], channel=[id: 0xf3a494a2, L:/10.118.1.218:37412 - R:myredis-servrer/10.118.2.6:6379], currentCommand=CommandData [promise=RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@6c702440(incomplete)], command=(PING), params=[], codec=org.redisson.client.codec.StringCodec]]
and  13 seconds later
2022/03/15 19:37:09.041 [tty-2-8] DEBUG IdleConnectionWatcher [-|-|-] - Connection [id: 0xdbb90202, L:/10.118.1.218:47226 ! R:myredis-servrer/10.118.2.6:6379] has been closed due to idle timeout. Not used for 13167 ms
It seems the pubsub connection on port 47226 is replaced by an new pubsub connection on port 37412.
But CLIENT LIST with redis-cli show:
id=4824 addr=10.118.1.218:37412 laddr=10.118.2.6:6379 fd=19 name= age=12092 idle=22 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20496 events=r cmd=ping user=default redir=-1
flags is N not P.
This is my redisson.yaml:
singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password: null
clientName: null
address: "redis://myredis-server:6379"
subscriptionConnectionMinimumIdleSize: 1
subscriptionConnectionPoolSize: 50
subscriptionsPerConnection: 5
connectionMinimumIdleSize: 5
connectionPoolSize: 64
database: 0
dnsMonitoringInterval: 60000
pingConnectionInterval: 30000
keepAlive: true
threads: 16
nettyThreads: 32
codec: !<org.redisson.codec.FstCodec> {}
transportMode: "NIO"
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
version 3.16.1,see the exceptions:
org.redisson.client.RedisTimeoutException: Unable to acquire connection! RedissonPromise [promise=ImmediateEventExecutor$ImmediatePromise@4bc618ba(failure: java.util.concurrent.CancellationException)]Increase connection pool size. Node source: NodeSource [slot=null, addr=null, redisClient=null, redirect=null, entry=MasterSlaveEntry [masterEntry=[freeSubscribeConnectionsAmount=0, freeSubscribeConnectionsCounter=value:49:queue:0, freeConnectionsAmount=22, freeConnectionsCounter=value:-2144903244:queue:26923, freezeReason=null, client=[addr=redis://], nodeType=MASTER, firstFail=0]]], command: null, params: null after 0 retryattempts
at org.redisson.command.RedisExecutor$2.run(RedisExecutor.java:187)
at io.netty.util.HashedWheelTimer$HashedWheelTimeout.expire(HashedWheelTimer.java:672)
at io.netty.util.HashedWheelTimer$HashedWheelBucket.expireTimeouts(HashedWheelTimer.java:747)
at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:472)
at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
at java.lang.Thread.run(Thread.java:748)
Use Default configuration，Restart the service before resuming
It can be reproduced using the following code and configuration
@test
void tryLock() throws InterruptedException {
ExecutorService tw = Executors.newFixedThreadPool(500);
CountDownLatch latch2 = new CountDownLatch(1);
for (int i = 0; i < 1000; i++) {
tw.execute(()->{
try {
latch2.await();
} catch (InterruptedException e) {
e.printStackTrace();
}
manger.tryLock();
});
}
    latch2.countDown();
    Thread.sleep(30000);
}
 public void tryLock() {
      RLock lock = redisson.getLock("test::lock");
      try {
          if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {
              try {
                  Thread.sleep(2000);
                  log.info("lock over=======================");
              } finally {
                  lock.unlock();
              }
          }else {
              log.info("unLock over");
          }
      } catch (Exception e) {
          log.error("Try lock fail", e);
      }
  }

singleServerConfig:
idleConnectionTimeout: 10000
connectTimeout: 10000
timeout: 3000
retryAttempts: 3
retryInterval: 1500
password:
connectionMinimumIdleSize: 1
connectionPoolSize: 2
database: 1
address: "redis://"
How to solve
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

https://github.com/redisson/redisson/issues/4186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
the java program started with an error message :
java.io.IOException: java.lang.ClassNotFoundException: com.test.delay.queue.vo.ExpireOrder at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:148) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:383) at org.redisson.client.handler.CommandDecoder.decodeList(CommandDecoder.java:427) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:392) at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:198) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:137) at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:113) at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:510) at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722) at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.base/java.lang.Thread.run(Unknown Source) Caused by: java.lang.ClassNotFoundException: com.cheche365.partner.service.vo.ExpireOrder at java.base/java.net.URLClassLoader.findClass(Unknown Source) at java.base/java.lang.ClassLoader.loadClass(Unknown Source) at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) at java.base/java.lang.ClassLoader.loadClass(Unknown Source) at java.base/java.lang.Class.forName0(Native Method) at java.base/java.lang.Class.forName(Unknown Source) at org.jboss.marshalling.AbstractClassResolver.loadClass(AbstractClassResolver.java:129) at org.jboss.marshalling.AbstractClassResolver.resolveClass(AbstractClassResolver.java:110) at org.jboss.marshalling.river.RiverUnmarshaller.doReadClassDescriptor(RiverUnmarshaller.java:1048) at org.jboss.marshalling.river.RiverUnmarshaller.doReadNewObject(RiverUnmarshaller.java:1381) at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:298) at org.jboss.marshalling.river.RiverUnmarshaller.doReadObject(RiverUnmarshaller.java:231) at org.jboss.marshalling.AbstractObjectInput.readObject(AbstractObjectInput.java:41) at org.redisson.codec.MarshallingCodec.lambda$new$0(MarshallingCodec.java:146) ... 25 common frames omitted
this is my code :
`@Component
public class ThreadPoolTaskExecutorRunner implements ApplicationRunner {
private final ThreadPoolTaskExecutor threadPoolTaskExecutor;

public ThreadPoolTaskExecutorRunner(ThreadPoolTaskExecutor threadPoolTaskExecutor) {
    this.threadPoolTaskExecutor = threadPoolTaskExecutor;
}

@Override
public void run(ApplicationArguments args) throws Exception {
    try {
        log.info("ThreadPoolTaskExecutorRunner start");
        threadPoolTaskExecutor.execute(orderTaskFactory.createExpireOrderTask());
        log.info("ThreadPoolTaskExecutorRunner end");
    } catch (Exception e) {
        log.error("ThreadPoolTaskExecutorRunner fail, e : {}", ExceptionUtils.getStackTrace(e));
    }
}

}`
`
@DaTa
@builder
@AllArgsConstructor
@NoArgsConstructor
@slf4j
public class ExpireOrderTask implements Runnable{
private IDelayQueueService<ExpireOrder> iDelayQueueService;

@Override
public void run() {

    while (true){
        try {
            log.info("开始处理订单关闭任务");
            ExpireOrder needCloseExpireOrder = iDelayQueueService.take(ORDER_DELAY_QUEUE);
            log.info("开始处理订单关闭任务param : {}",JSONObject.toJSONString(needCloseExpireOrder));
        } catch (InterruptedException e) {
            log.error("关闭订单失败:{}", ExceptionUtils.getStackTrace(e));
        }
    }
}

}`
`@Service
public class DelayQueueServiceImpl implements IDelayQueueService {
private final RedissonClient redissonClient;

public DelayQueueServiceImpl(RedissonClient redissonClient) {
    this.redissonClient = redissonClient;
}

@Override
public void offerSeconds(T data, long time, String queueName) {
    offer(data, time, TimeUnit.SECONDS, queueName);
}

@Override
public void offer(T data, long time, TimeUnit timeUnit, String queueName) {
    findDelayQueue(queueName).offerAsync(data, time < 0 ? 0 : time, timeUnit);
}

@Override
public T take(String queueName) throws InterruptedException {
    RBlockingDeque<T> blockingQueue = findBlockingQueue(queueName);
    RDelayedQueue<T> delayQueue = findDelayQueue(blockingQueue);
    return blockingQueue.take();
}

@Override
public RBlockingDeque<T> findBlockingQueue(String queueName) {
    return redissonClient.getBlockingDeque(queueName);
}

@Override
public RDelayedQueue<T> findDelayQueue(String queueName) {
    return redissonClient.getDelayedQueue(findBlockingQueue(queueName));
}

@Override
public RDelayedQueue<T> findDelayQueue(RBlockingDeque<T> blockingQueue) {
    return redissonClient.getDelayedQueue(blockingQueue);
}

}`
I changed the package path of ExpireOrder.class , but I did not find the ExpireOrder task with the old path when I queried redis,now the task is blocking , i need help
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
